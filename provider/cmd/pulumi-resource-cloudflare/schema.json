{
    "name": "cloudflare",
    "description": "A Pulumi package for creating and managing Cloudflare cloud resources.",
    "keywords": [
        "pulumi",
        "cloudflare"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`cloudflare` Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare).",
    "repository": "https://github.com/pulumi/pulumi-cloudflare",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "cloudflare": "Cloudflare"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing Cloudflare cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-cloudflare` repo](https://github.com/cloudflare/terraform-provider-cloudflare/issues).",
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-cloudflare` repo](https://github.com/cloudflare/terraform-provider-cloudflare/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_BASE_PATH`\nenvironment variable.\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger). Alternatively, can be configured using\nthe `CLOUDFLARE_API_CLIENT_LOGGING` environment variable.\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_HOSTNAME`\nenvironment variable.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations. Alternatively, can be configured using the `CLOUDFLARE_API_KEY` environment variable. API\nkeys are [now considered legacy by\nCloudflare](https://developers.cloudflare.com/fundamentals/api/get-started/keys/#limitations), API tokens should be used\ninstead. Must provide only one of `api_key`, `api_token`, `api_user_service_key`.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations. Alternatively, can be configured using the `CLOUDFLARE_API_TOKEN` environment variable.\nMust provide only one of `api_key`, `api_token`, `api_user_service_key`.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints. Alternatively, can be configured using the\n`CLOUDFLARE_API_USER_SERVICE_KEY` environment variable. Must provide only one of `api_key`, `api_token`,\n`api_user_service_key`.\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address. Alternatively, can be configured using the `CLOUDFLARE_EMAIL` environment\nvariable. Required when using `api_key`. Conflicts with `api_token`.\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MAX_BACKOFF` environment variable.\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MIN_BACKOFF` environment variable.\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails. Alternatively, can be configured using the\n`CLOUDFLARE_RETRIES` environment variable.\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API. Alternatively, can be configured using the `CLOUDFLARE_RPS` environment\nvariable.\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            },
            "userAgentOperatorSuffix": {
                "type": "string"
            }
        }
    },
    "types": {
        "cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader": {
            "properties": {
                "allowAllHeaders": {
                    "type": "boolean",
                    "description": "Value to determine whether all HTTP headers are exposed.\n"
                },
                "allowAllMethods": {
                    "type": "boolean",
                    "description": "Value to determine whether all methods are exposed.\n"
                },
                "allowAllOrigins": {
                    "type": "boolean",
                    "description": "Value to determine whether all origins are permitted to make CORS requests.\n"
                },
                "allowCredentials": {
                    "type": "boolean",
                    "description": "Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.\n"
                },
                "allowedHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of HTTP headers to expose via CORS.\n"
                },
                "allowedMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of methods to expose via CORS.\n"
                },
                "allowedOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of origins permitted to make CORS requests.\n"
                },
                "maxAge": {
                    "type": "integer",
                    "description": "The maximum time a preflight request will be cached.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationFooterLink:AccessApplicationFooterLink": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the footer link.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the footer link.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationLandingPageDesign:AccessApplicationLandingPageDesign": {
            "properties": {
                "buttonColor": {
                    "type": "string",
                    "description": "The button color of the landing page.\n"
                },
                "buttonTextColor": {
                    "type": "string",
                    "description": "The button text color of the landing page.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "The URL of the image to be displayed in the landing page.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the landing page.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the landing page.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp": {
            "properties": {
                "accessTokenLifetime": {
                    "type": "string",
                    "description": "The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.\n"
                },
                "allowPkceWithoutClientSecret": {
                    "type": "boolean",
                    "description": "Allow PKCE flow without a client secret.\n"
                },
                "appLauncherUrl": {
                    "type": "string",
                    "description": "The URL where this applications tile redirects users.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "clientId": {
                    "type": "string",
                    "description": "The application client id.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The application client secret, only returned on initial apply.\n",
                    "secret": true
                },
                "consumerServiceUrl": {
                    "type": "string",
                    "description": "The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.\n"
                },
                "customAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationSaasAppCustomAttribute:AccessApplicationSaasAppCustomAttribute"
                    },
                    "description": "Custom attribute mapped from IDPs.\n"
                },
                "customClaims": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationSaasAppCustomClaim:AccessApplicationSaasAppCustomClaim"
                    },
                    "description": "Custom claim mapped from IDPs.\n"
                },
                "defaultRelayState": {
                    "type": "string",
                    "description": "The relay state used if not provided by the identity provider.\n"
                },
                "grantTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The OIDC flows supported by this application.\n"
                },
                "groupFilterRegex": {
                    "type": "string",
                    "description": "A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.\n"
                },
                "hybridAndImplicitOptions": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasAppHybridAndImplicitOptions:AccessApplicationSaasAppHybridAndImplicitOptions",
                    "description": "Hybrid and Implicit Flow options.\n"
                },
                "idpEntityId": {
                    "type": "string",
                    "description": "The unique identifier for the SaaS application.\n"
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "The format of the name identifier sent to the SaaS application.\n"
                },
                "nameIdTransformJsonata": {
                    "type": "string",
                    "description": "A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public certificate that will be used to verify identities.\n"
                },
                "redirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.\n"
                },
                "refreshTokenOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationSaasAppRefreshTokenOption:AccessApplicationSaasAppRefreshTokenOption"
                    },
                    "description": "Refresh token grant options.\n"
                },
                "samlAttributeTransformJsonata": {
                    "type": "string",
                    "description": "A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Define the user information shared with access.\n"
                },
                "spEntityId": {
                    "type": "string",
                    "description": "A globally unique name for an identity or service provider.\n"
                },
                "ssoEndpoint": {
                    "type": "string",
                    "description": "The endpoint where the SaaS application will send login requests.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clientId",
                        "clientSecret",
                        "grantTypes",
                        "idpEntityId",
                        "publicKey",
                        "scopes",
                        "ssoEndpoint"
                    ]
                }
            }
        },
        "cloudflare:index/AccessApplicationSaasAppCustomAttribute:AccessApplicationSaasAppCustomAttribute": {
            "properties": {
                "friendlyName": {
                    "type": "string",
                    "description": "A friendly name for the attribute as provided to the SaaS app.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided to the SaaS app.\n"
                },
                "nameFormat": {
                    "type": "string",
                    "description": "A globally unique name for an identity or service provider.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "True if the attribute must be always present.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasAppCustomAttributeSource:AccessApplicationSaasAppCustomAttributeSource"
                }
            },
            "type": "object",
            "required": [
                "source"
            ]
        },
        "cloudflare:index/AccessApplicationSaasAppCustomAttributeSource:AccessApplicationSaasAppCustomAttributeSource": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided by the IDP.\n"
                },
                "nameByIdp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping from IdP ID to claim name.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/AccessApplicationSaasAppCustomClaim:AccessApplicationSaasAppCustomClaim": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided to the SaaS app.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "True if the attribute must be always present.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "The scope of the claim.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasAppCustomClaimSource:AccessApplicationSaasAppCustomClaimSource"
                }
            },
            "type": "object",
            "required": [
                "source"
            ]
        },
        "cloudflare:index/AccessApplicationSaasAppCustomClaimSource:AccessApplicationSaasAppCustomClaimSource": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided by the IDP.\n"
                },
                "nameByIdp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping from IdP ID to claim name.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/AccessApplicationSaasAppHybridAndImplicitOptions:AccessApplicationSaasAppHybridAndImplicitOptions": {
            "properties": {
                "returnAccessTokenFromAuthorizationEndpoint": {
                    "type": "boolean",
                    "description": "If true, the authorization endpoint will return an access token.\n"
                },
                "returnIdTokenFromAuthorizationEndpoint": {
                    "type": "boolean",
                    "description": "If true, the authorization endpoint will return an id token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationSaasAppRefreshTokenOption:AccessApplicationSaasAppRefreshTokenOption": {
            "properties": {
                "lifetime": {
                    "type": "string",
                    "description": "How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationScimConfig:AccessApplicationScimConfig": {
            "properties": {
                "authentication": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationScimConfigAuthentication:AccessApplicationScimConfigAuthentication",
                    "description": "Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.\n"
                },
                "deactivateOnDelete": {
                    "type": "boolean",
                    "description": "If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether SCIM provisioning is turned on for this application.\n"
                },
                "idpUid": {
                    "type": "string",
                    "description": "The UID of the IdP to use as the source for SCIM resources to provision to this application.\n"
                },
                "mappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationScimConfigMapping:AccessApplicationScimConfigMapping"
                    },
                    "description": "A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.\n"
                },
                "remoteUri": {
                    "type": "string",
                    "description": "The base URI for the application's SCIM-compatible API.\n"
                }
            },
            "type": "object",
            "required": [
                "idpUid",
                "remoteUri"
            ]
        },
        "cloudflare:index/AccessApplicationScimConfigAuthentication:AccessApplicationScimConfigAuthentication": {
            "properties": {
                "authorizationUrl": {
                    "type": "string",
                    "description": "URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "The authentication scheme to use when making SCIM requests to this application.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "user": {
                    "type": "string",
                    "description": "User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.\n"
                }
            },
            "type": "object",
            "required": [
                "scheme"
            ]
        },
        "cloudflare:index/AccessApplicationScimConfigMapping:AccessApplicationScimConfigMapping": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether or not this mapping is enabled.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.\n"
                },
                "operations": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationScimConfigMappingOperations:AccessApplicationScimConfigMappingOperations",
                    "description": "Whether or not this mapping applies to creates, updates, or deletes.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Which SCIM resource type this mapping applies to.\n"
                },
                "transformJsonata": {
                    "type": "string",
                    "description": "A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.\n"
                }
            },
            "type": "object",
            "required": [
                "schema"
            ]
        },
        "cloudflare:index/AccessApplicationScimConfigMappingOperations:AccessApplicationScimConfigMappingOperations": {
            "properties": {
                "create": {
                    "type": "boolean",
                    "description": "Whether or not this mapping applies to create (POST) operations.\n"
                },
                "delete": {
                    "type": "boolean",
                    "description": "Whether or not this mapping applies to DELETE operations.\n"
                },
                "update": {
                    "type": "boolean",
                    "description": "Whether or not this mapping applies to update (PATCH/PUT) operations.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationTargetCriteria:AccessApplicationTargetCriteria": {
            "properties": {
                "port": {
                    "type": "integer",
                    "description": "The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The communication protocol your application secures.\n"
                },
                "targetAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationTargetCriteriaTargetAttribute:AccessApplicationTargetCriteriaTargetAttribute"
                    },
                    "description": "Contains a map of target attribute keys to target attribute values.\n"
                }
            },
            "type": "object",
            "required": [
                "port",
                "protocol",
                "targetAttributes"
            ]
        },
        "cloudflare:index/AccessApplicationTargetCriteriaTargetAttribute:AccessApplicationTargetCriteriaTargetAttribute": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The key of the attribute.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The values of the attribute.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "values"
            ]
        },
        "cloudflare:index/AccessGroupExclude:AccessGroupExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeAuthContext:AccessGroupExcludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeAzure:AccessGroupExcludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessGroupExcludeExternalEvaluation:AccessGroupExcludeExternalEvaluation",
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeGithub:AccessGroupExcludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeOkta:AccessGroupExcludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeSaml:AccessGroupExcludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeAuthContext:AccessGroupExcludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/AccessGroupExcludeAzure:AccessGroupExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeExternalEvaluation:AccessGroupExcludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeGithub:AccessGroupExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeOkta:AccessGroupExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeSaml:AccessGroupExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupInclude:AccessGroupInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeAuthContext:AccessGroupIncludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeAzure:AccessGroupIncludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessGroupIncludeExternalEvaluation:AccessGroupIncludeExternalEvaluation",
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeGithub:AccessGroupIncludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeOkta:AccessGroupIncludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeSaml:AccessGroupIncludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeAuthContext:AccessGroupIncludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/AccessGroupIncludeAzure:AccessGroupIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeExternalEvaluation:AccessGroupIncludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeGithub:AccessGroupIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeOkta:AccessGroupIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeSaml:AccessGroupIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequire:AccessGroupRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireAuthContext:AccessGroupRequireAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireAzure:AccessGroupRequireAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessGroupRequireExternalEvaluation:AccessGroupRequireExternalEvaluation",
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireGithub:AccessGroupRequireGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireGsuite:AccessGroupRequireGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireOkta:AccessGroupRequireOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireSaml:AccessGroupRequireSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireAuthContext:AccessGroupRequireAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/AccessGroupRequireAzure:AccessGroupRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireExternalEvaluation:AccessGroupRequireExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireGithub:AccessGroupRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireGsuite:AccessGroupRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireOkta:AccessGroupRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireSaml:AccessGroupRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig": {
            "properties": {
                "apiToken": {
                    "type": "string"
                },
                "appsDomain": {
                    "type": "string"
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "authUrl": {
                    "type": "string"
                },
                "authorizationServerId": {
                    "type": "string"
                },
                "centrifyAccount": {
                    "type": "string"
                },
                "centrifyAppId": {
                    "type": "string"
                },
                "certsUrl": {
                    "type": "string"
                },
                "claims": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "conditionalAccessEnabled": {
                    "type": "boolean"
                },
                "directoryId": {
                    "type": "string"
                },
                "emailAttributeName": {
                    "type": "string"
                },
                "emailClaimName": {
                    "type": "string"
                },
                "idpPublicCert": {
                    "type": "string"
                },
                "issuerUrl": {
                    "type": "string"
                },
                "oktaAccount": {
                    "type": "string"
                },
                "oneloginAccount": {
                    "type": "string"
                },
                "pingEnvId": {
                    "type": "string"
                },
                "pkceEnabled": {
                    "type": "boolean"
                },
                "redirectUrl": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "signRequest": {
                    "type": "boolean"
                },
                "ssoTargetUrl": {
                    "type": "string"
                },
                "supportGroups": {
                    "type": "boolean"
                },
                "tokenUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "attributes",
                        "claims",
                        "redirectUrl",
                        "scopes"
                    ]
                }
            }
        },
        "cloudflare:index/AccessIdentityProviderScimConfig:AccessIdentityProviderScimConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "groupMemberDeprovision": {
                    "type": "boolean"
                },
                "seatDeprovision": {
                    "type": "boolean"
                },
                "secret": {
                    "type": "string",
                    "secret": true
                },
                "userDeprovision": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "secret"
                    ]
                }
            }
        },
        "cloudflare:index/AccessMutualTlsHostnameSettingsSetting:AccessMutualTlsHostnameSettingsSetting": {
            "properties": {
                "chinaNetwork": {
                    "type": "boolean",
                    "description": "Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.\n"
                },
                "clientCertificateForwarding": {
                    "type": "boolean",
                    "description": "Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname that these settings apply to.\n"
                }
            },
            "type": "object",
            "required": [
                "hostname"
            ]
        },
        "cloudflare:index/AccessOrganizationCustomPage:AccessOrganizationCustomPage": {
            "properties": {
                "forbidden": {
                    "type": "string",
                    "description": "The id of the forbidden page.\n"
                },
                "identityDenied": {
                    "type": "string",
                    "description": "The id of the identity denied page.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "The background color on the login page.\n"
                },
                "footerText": {
                    "type": "string",
                    "description": "The text at the bottom of the login page.\n"
                },
                "headerText": {
                    "type": "string",
                    "description": "The text at the top of the login page.\n"
                },
                "logoPath": {
                    "type": "string",
                    "description": "The URL of the logo on the login page.\n"
                },
                "textColor": {
                    "type": "string",
                    "description": "The text color on the login page.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup": {
            "properties": {
                "approvalsNeeded": {
                    "type": "integer",
                    "description": "Number of approvals needed.\n"
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of emails to request approval from.\n"
                },
                "emailListUuid": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "approvalsNeeded"
            ]
        },
        "cloudflare:index/AccessPolicyConnectionRules:AccessPolicyConnectionRules": {
            "properties": {
                "ssh": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyConnectionRulesSsh:AccessPolicyConnectionRulesSsh",
                    "description": "The SSH-specific rules that define how users may connect to the targets secured by your application.\n"
                }
            },
            "type": "object",
            "required": [
                "ssh"
            ]
        },
        "cloudflare:index/AccessPolicyConnectionRulesSsh:AccessPolicyConnectionRulesSsh": {
            "properties": {
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Contains the Unix usernames that may be used when connecting over SSH.\n"
                }
            },
            "type": "object",
            "required": [
                "usernames"
            ]
        },
        "cloudflare:index/AccessPolicyExclude:AccessPolicyExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeAuthContext:AccessPolicyExcludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyExcludeExternalEvaluation:AccessPolicyExcludeExternalEvaluation",
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeAuthContext:AccessPolicyExcludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeExternalEvaluation:AccessPolicyExcludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyInclude:AccessPolicyInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeAuthContext:AccessPolicyIncludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyIncludeExternalEvaluation:AccessPolicyIncludeExternalEvaluation",
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeAuthContext:AccessPolicyIncludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeExternalEvaluation:AccessPolicyIncludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequire:AccessPolicyRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireAuthContext:AccessPolicyRequireAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireAzure:AccessPolicyRequireAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyRequireExternalEvaluation:AccessPolicyRequireExternalEvaluation",
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireGithub:AccessPolicyRequireGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireOkta:AccessPolicyRequireOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireSaml:AccessPolicyRequireSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireAuthContext:AccessPolicyRequireAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/AccessPolicyRequireAzure:AccessPolicyRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireExternalEvaluation:AccessPolicyRequireExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireGithub:AccessPolicyRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireOkta:AccessPolicyRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireSaml:AccessPolicyRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/AddressMapIp:AddressMapIp": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "An IPv4 or IPv6 address.\n"
                }
            },
            "type": "object",
            "required": [
                "ip"
            ]
        },
        "cloudflare:index/AddressMapMembership:AddressMapMembership": {
            "properties": {
                "canDelete": {
                    "type": "boolean",
                    "description": "Controls whether the membership can be deleted via the API or not.\n"
                },
                "identifier": {
                    "type": "string",
                    "description": "Identifier of the account or zone.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The type of the membership.\n"
                }
            },
            "type": "object",
            "required": [
                "identifier",
                "kind"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "canDelete",
                        "identifier",
                        "kind"
                    ]
                }
            }
        },
        "cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the characteristic.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of characteristic. Available values: `header`, `cookie`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenCondition:ApiTokenCondition": {
            "properties": {
                "requestIp": {
                    "$ref": "#/types/cloudflare:index/ApiTokenConditionRequestIp:ApiTokenConditionRequestIp",
                    "description": "Request IP related conditions.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenConditionRequestIp:ApiTokenConditionRequestIp": {
            "properties": {
                "ins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.\n"
                },
                "notIns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses or CIDR notation where the token should not be used from.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenPolicy:ApiTokenPolicy": {
            "properties": {
                "effect": {
                    "type": "string",
                    "description": "Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.\n"
                },
                "permissionGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.\n"
                },
                "resources": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Describes what operations against which resources are allowed or denied.\n"
                }
            },
            "type": "object",
            "required": [
                "permissionGroups",
                "resources"
            ]
        },
        "cloudflare:index/CertificatePackValidationError:CertificatePackValidationError": {
            "properties": {
                "message": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "message"
                    ]
                }
            }
        },
        "cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord": {
            "properties": {
                "cnameName": {
                    "type": "string"
                },
                "cnameTarget": {
                    "type": "string"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "httpBody": {
                    "type": "string"
                },
                "httpUrl": {
                    "type": "string"
                },
                "txtName": {
                    "type": "string"
                },
                "txtValue": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cnameName",
                        "cnameTarget",
                        "emails",
                        "httpBody",
                        "httpUrl",
                        "txtName",
                        "txtValue"
                    ]
                }
            }
        },
        "cloudflare:index/CloudConnectorRulesRule:CloudConnectorRulesRule": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Brief summary of the cloud connector rule and its intended use.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the headers rule is active.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "Criteria for an HTTP request to trigger the cloud connector rule. Uses the Firewall Rules expression language based on Wireshark display filters.\n"
                },
                "parameters": {
                    "$ref": "#/types/cloudflare:index/CloudConnectorRulesRuleParameters:CloudConnectorRulesRuleParameters",
                    "description": "Cloud Connector Rule Parameters\n"
                },
                "provider": {
                    "type": "string",
                    "description": "Type of provider. Available values: `aws_s3`, `cloudflare_r2`, `azure_storage`, `gcp_storage`\n"
                }
            },
            "type": "object",
            "required": [
                "expression",
                "provider"
            ]
        },
        "cloudflare:index/CloudConnectorRulesRuleParameters:CloudConnectorRulesRuleParameters": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Host parameter for cloud connector rule\n"
                }
            },
            "type": "object",
            "required": [
                "host"
            ]
        },
        "cloudflare:index/CustomHostnameSsl:CustomHostnameSsl": {
            "properties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.\n"
                },
                "certificateAuthority": {
                    "type": "string"
                },
                "customCertificate": {
                    "type": "string",
                    "description": "If a custom uploaded certificate is used.\n"
                },
                "customKey": {
                    "type": "string",
                    "description": "The key for a custom uploaded certificate.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.\n"
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslSetting:CustomHostnameSslSetting"
                    },
                    "description": "SSL/TLS settings for the certificate.\n"
                },
                "status": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.\n"
                },
                "validationErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslValidationError:CustomHostnameSslValidationError"
                    }
                },
                "validationRecords": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslValidationRecord:CustomHostnameSslValidationRecord"
                    }
                },
                "wildcard": {
                    "type": "boolean",
                    "description": "Indicates whether the certificate covers a wildcard.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certificateAuthority",
                        "settings",
                        "status",
                        "validationErrors",
                        "validationRecords"
                    ]
                }
            }
        },
        "cloudflare:index/CustomHostnameSslSetting:CustomHostnameSslSetting": {
            "properties": {
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of SSL/TLS ciphers to associate with this certificate.\n"
                },
                "earlyHints": {
                    "type": "string",
                    "description": "Whether early hints should be supported. Available values: `on`, `off`.\n"
                },
                "http2": {
                    "type": "string",
                    "description": "Whether HTTP2 should be supported. Available values: `on`, `off`.\n"
                },
                "minTlsVersion": {
                    "type": "string",
                    "description": "Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.\n"
                },
                "tls13": {
                    "type": "string",
                    "description": "Whether TLSv1.3 should be supported. Available values: `on`, `off`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/CustomHostnameSslValidationError:CustomHostnameSslValidationError": {
            "properties": {
                "message": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "message"
                    ]
                }
            }
        },
        "cloudflare:index/CustomHostnameSslValidationRecord:CustomHostnameSslValidationRecord": {
            "properties": {
                "cnameName": {
                    "type": "string"
                },
                "cnameTarget": {
                    "type": "string"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "httpBody": {
                    "type": "string"
                },
                "httpUrl": {
                    "type": "string"
                },
                "txtName": {
                    "type": "string"
                },
                "txtValue": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cnameName",
                        "cnameTarget",
                        "emails",
                        "httpBody",
                        "httpUrl",
                        "txtName",
                        "txtValue"
                    ]
                }
            }
        },
        "cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions": {
            "properties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Certificate certificate and the intermediate(s).\n"
                },
                "geoRestrictions": {
                    "type": "string",
                    "description": "Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Certificate's private key.\n",
                    "secret": true
                },
                "type": {
                    "type": "string",
                    "description": "Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "priority": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "cloudflare:index/DeviceDexTestData:DeviceDexTestData": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The type of Device Dex Test. Available values: `http`, `traceroute`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The http request method. Available values: `GET`.\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "kind"
            ]
        },
        "cloudflare:index/DeviceManagedNetworksConfig:DeviceManagedNetworksConfig": {
            "properties": {
                "sha256": {
                    "type": "string",
                    "description": "The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.\n"
                },
                "tlsSockaddr": {
                    "type": "string",
                    "description": "A network address of the form \"host:port\" that the WARP client will use to detect the presence of a TLS host.\n"
                }
            },
            "type": "object",
            "required": [
                "sha256",
                "tlsSockaddr"
            ]
        },
        "cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig": {
            "properties": {
                "accessClientId": {
                    "type": "string",
                    "description": "The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.\n",
                    "secret": true
                },
                "accessClientSecret": {
                    "type": "string",
                    "description": "The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.\n",
                    "secret": true
                },
                "apiUrl": {
                    "type": "string",
                    "description": "The third-party API's URL.\n"
                },
                "authUrl": {
                    "type": "string",
                    "description": "The third-party authorization API URL.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client identifier for authenticating API calls.\n"
                },
                "clientKey": {
                    "type": "string",
                    "description": "The client key for authenticating API calls.\n",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for authenticating API calls.\n",
                    "secret": true
                },
                "customerId": {
                    "type": "string",
                    "description": "The customer identifier for authenticating API calls.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput": {
            "properties": {
                "activeThreats": {
                    "type": "integer",
                    "description": "The number of active threats from SentinelOne.\n"
                },
                "certificateId": {
                    "type": "string",
                    "description": "The UUID of a Cloudflare managed certificate.\n"
                },
                "checkDisks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specific volume(s) to check for encryption.\n"
                },
                "checkPrivateKey": {
                    "type": "boolean",
                    "description": "Confirm the certificate was not imported from another device.\n"
                },
                "cn": {
                    "type": "string",
                    "description": "The common name for a certificate.\n"
                },
                "complianceStatus": {
                    "type": "string",
                    "description": "The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.\n"
                },
                "connectionId": {
                    "type": "string",
                    "description": "The workspace one or intune connection id.\n"
                },
                "countOperator": {
                    "type": "string",
                    "description": "The count comparison operator for kolide. Available values: `\u003e`, `\u003e=`, `\u003c`, `\u003c=`, `==`.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain that the client must join.\n"
                },
                "eidLastSeen": {
                    "type": "string",
                    "description": "The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if the firewall must be enabled.\n"
                },
                "exists": {
                    "type": "boolean",
                    "description": "Checks if the file should exist.\n"
                },
                "extendedKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The Teams List id. Required for `serial_number` and `unique_client_id` rule types.\n"
                },
                "infected": {
                    "type": "boolean",
                    "description": "True if SentinelOne device is infected.\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "True if SentinelOne device is active.\n"
                },
                "issueCount": {
                    "type": "string",
                    "description": "The number of issues for kolide.\n"
                },
                "lastSeen": {
                    "type": "string",
                    "description": "The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.\n"
                },
                "locations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInputLocation:DevicePostureRuleInputLocation"
                    },
                    "description": "List of operating system locations to check for a client certificate..\n"
                },
                "networkStatus": {
                    "type": "string",
                    "description": "The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The version comparison operator. Available values: `\u003e`, `\u003e=`, `\u003c`, `\u003c=`, `==`.\n"
                },
                "os": {
                    "type": "string",
                    "description": "OS signal score from Crowdstrike. Value must be between 1 and 100.\n"
                },
                "osDistroName": {
                    "type": "string",
                    "description": "The operating system excluding version information.\n"
                },
                "osDistroRevision": {
                    "type": "string",
                    "description": "The operating system version excluding OS name information or release name.\n"
                },
                "osVersionExtra": {
                    "type": "string",
                    "description": "Extra version value following the operating system semantic version.\n"
                },
                "overall": {
                    "type": "string",
                    "description": "Overall ZTA score from Crowdstrike. Value must be between 1 and 100.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to the file.\n"
                },
                "requireAll": {
                    "type": "boolean",
                    "description": "True if all drives must be encrypted.\n"
                },
                "riskLevel": {
                    "type": "string",
                    "description": "The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.\n"
                },
                "running": {
                    "type": "boolean",
                    "description": "Checks if the application should be running.\n"
                },
                "score": {
                    "type": "integer",
                    "description": "A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.\n"
                },
                "sensorConfig": {
                    "type": "string",
                    "description": "Sensor signal score from Crowdstrike. Value must be between 1 and 100.\n"
                },
                "sha256": {
                    "type": "string",
                    "description": "The sha256 hash of the file.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "The thumbprint of the file certificate.\n"
                },
                "totalScore": {
                    "type": "integer",
                    "description": "The total score from Tanium.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The operating system semantic version.\n"
                },
                "versionOperator": {
                    "type": "string",
                    "description": "The version comparison operator for Crowdstrike. Available values: `\u003e`, `\u003e=`, `\u003c`, `\u003c=`, `==`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "exists",
                        "infected",
                        "isActive",
                        "requireAll",
                        "running"
                    ]
                }
            }
        },
        "cloudflare:index/DevicePostureRuleInputLocation:DevicePostureRuleInputLocation": {
            "properties": {
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to check for client certificate rule.\n"
                },
                "trustStores": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of trust stores to check for client certificate rule. Available values: `system`, `user`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch": {
            "properties": {
                "platform": {
                    "type": "string",
                    "description": "The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/DlpProfileContextAwareness:DlpProfileContextAwareness": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                },
                "skip": {
                    "$ref": "#/types/cloudflare:index/DlpProfileContextAwarenessSkip:DlpProfileContextAwarenessSkip",
                    "description": "Content types to exclude from context analysis and return all matches.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "skip"
            ]
        },
        "cloudflare:index/DlpProfileContextAwarenessSkip:DlpProfileContextAwarenessSkip": {
            "properties": {
                "files": {
                    "type": "boolean",
                    "description": "Return all matches, regardless of context analysis result, if the data is a file.\n"
                }
            },
            "type": "object",
            "required": [
                "files"
            ]
        },
        "cloudflare:index/DlpProfileEntry:DlpProfileEntry": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the entry is active. Defaults to `false`.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique entry identifier.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the entry to deploy.\n"
                },
                "pattern": {
                    "$ref": "#/types/cloudflare:index/DlpProfileEntryPattern:DlpProfileEntryPattern"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "cloudflare:index/DlpProfileEntryPattern:DlpProfileEntryPattern": {
            "properties": {
                "regex": {
                    "type": "string",
                    "description": "The regex that defines the pattern.\n"
                },
                "validation": {
                    "type": "string",
                    "description": "The validation algorithm to apply with this pattern.\n"
                }
            },
            "type": "object",
            "required": [
                "regex"
            ]
        },
        "cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Type of supported action. Available values: `drop`, `forward`, `worker`.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list with items in the following form.\n"
                }
            },
            "type": "object",
            "required": [
                "type",
                "values"
            ]
        },
        "cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Type of matcher. Available values: `all`.\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Type of action. Available values: `forward`, `worker`, `drop`\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Value to match on. Required for `type` of `literal`.\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher": {
            "properties": {
                "field": {
                    "type": "string",
                    "description": "Field to match on. Required for `type` of `literal`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of matcher. Available values: `literal`, `all`\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value to match on. Required for `type` of `literal`.\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "cloudflare:index/FallbackDomainDomain:FallbackDomainDomain": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description of the fallback domain, displayed in the client UI.\n"
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses to handle domain resolution.\n"
                },
                "suffix": {
                    "type": "string",
                    "description": "The domain suffix to match when resolving locally.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/HealthcheckHeader:HealthcheckHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n"
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/HyperdriveConfigCaching:HyperdriveConfigCaching": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "Disable caching for this Hyperdrive configuration.\n"
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Configure the `max_age` value of this Hyperdrive configuration.\n"
                },
                "staleWhileRevalidate": {
                    "type": "integer",
                    "description": "Disable caching for this Hyperdrive configuration.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "disabled"
                    ]
                }
            }
        },
        "cloudflare:index/HyperdriveConfigOrigin:HyperdriveConfigOrigin": {
            "properties": {
                "accessClientId": {
                    "type": "string",
                    "description": "Client ID associated with the Cloudflare Access Service Token used to connect via Access.\n"
                },
                "accessClientSecret": {
                    "type": "string",
                    "description": "Client Secret associated with the Cloudflare Access Service Token used to connect via Access.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The name of your origin database.\n"
                },
                "host": {
                    "type": "string",
                    "description": "The host (hostname or IP) of your origin database.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the Hyperdrive configuration.\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "The port (default: 5432 for Postgres) of your origin database.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Specifies the URL scheme used to connect to your origin database.\n"
                },
                "user": {
                    "type": "string",
                    "description": "The user of your origin database.\n"
                }
            },
            "type": "object",
            "required": [
                "database",
                "host",
                "password",
                "scheme",
                "user"
            ]
        },
        "cloudflare:index/InfrastructureAccessTargetIp:InfrastructureAccessTargetIp": {
            "properties": {
                "ipv4": {
                    "$ref": "#/types/cloudflare:index/InfrastructureAccessTargetIpIpv4:InfrastructureAccessTargetIpIpv4",
                    "description": "The target's IPv4 address.\n"
                },
                "ipv6": {
                    "$ref": "#/types/cloudflare:index/InfrastructureAccessTargetIpIpv6:InfrastructureAccessTargetIpIpv6",
                    "description": "The target's IPv6 address.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/InfrastructureAccessTargetIpIpv4:InfrastructureAccessTargetIpIpv4": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ]
        },
        "cloudflare:index/InfrastructureAccessTargetIpIpv6:InfrastructureAccessTargetIpIpv6": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ]
        },
        "cloudflare:index/ListItem:ListItem": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "An optional comment for the item.\n"
                },
                "value": {
                    "$ref": "#/types/cloudflare:index/ListItemValue:ListItemValue"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ListItemHostname:ListItemHostname": {
            "properties": {
                "urlHostname": {
                    "type": "string",
                    "description": "The FQDN to match on.\n"
                }
            },
            "type": "object",
            "required": [
                "urlHostname"
            ]
        },
        "cloudflare:index/ListItemRedirect:ListItemRedirect": {
            "properties": {
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "Whether the redirect also matches subdomains of the source url.\n"
                },
                "preservePathSuffix": {
                    "type": "boolean",
                    "description": "Whether the redirect target url should keep the query string of the request's url.\n"
                },
                "preserveQueryString": {
                    "type": "boolean",
                    "description": "Whether the redirect target url should keep the query string of the request's url.\n"
                },
                "sourceUrl": {
                    "type": "string",
                    "description": "The source url of the redirect.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "The status code to be used when redirecting a request.\n"
                },
                "subpathMatching": {
                    "type": "boolean",
                    "description": "Whether the redirect also matches subpaths of the source url.\n"
                },
                "targetUrl": {
                    "type": "string",
                    "description": "The target url of the redirect.\n"
                }
            },
            "type": "object",
            "required": [
                "sourceUrl",
                "targetUrl"
            ]
        },
        "cloudflare:index/ListItemValue:ListItemValue": {
            "properties": {
                "asn": {
                    "type": "integer"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItemValueHostname:ListItemValueHostname"
                    }
                },
                "ip": {
                    "type": "string"
                },
                "redirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItemValueRedirect:ListItemValueRedirect"
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ListItemValueHostname:ListItemValueHostname": {
            "properties": {
                "urlHostname": {
                    "type": "string",
                    "description": "The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.\n"
                }
            },
            "type": "object",
            "required": [
                "urlHostname"
            ]
        },
        "cloudflare:index/ListItemValueRedirect:ListItemValueRedirect": {
            "properties": {
                "includeSubdomains": {
                    "type": "string",
                    "description": "Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.\n"
                },
                "preservePathSuffix": {
                    "type": "string",
                    "description": "Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.\n"
                },
                "preserveQueryString": {
                    "type": "string",
                    "description": "Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.\n"
                },
                "sourceUrl": {
                    "type": "string",
                    "description": "The source url of the redirect.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "The status code to be used when redirecting a request.\n"
                },
                "subpathMatching": {
                    "type": "string",
                    "description": "Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.\n"
                },
                "targetUrl": {
                    "type": "string",
                    "description": "The target url of the redirect.\n"
                }
            },
            "type": "object",
            "required": [
                "sourceUrl",
                "targetUrl"
            ]
        },
        "cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting": {
            "properties": {
                "failoverAcrossPools": {
                    "type": "boolean",
                    "description": "Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool": {
            "properties": {
                "country": {
                    "type": "string",
                    "description": "A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.\n"
                },
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given country.\n"
                }
            },
            "type": "object",
            "required": [
                "country",
                "poolIds"
            ]
        },
        "cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.\n"
                },
                "preferEcs": {
                    "type": "string",
                    "description": "Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy=\"proximity\"`, and `geo` will prefer ECS only when `steering_policy=\"geo\"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of values for the header.\n"
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding": {
            "properties": {
                "defaultPercent": {
                    "type": "number",
                    "description": "Percent of traffic to shed 0 - 100. Defaults to `0`.\n"
                },
                "defaultPolicy": {
                    "type": "string",
                    "description": "Method of shedding traffic. Available values: `\"\"`, `hash`, `random`. Defaults to `\"\"`.\n"
                },
                "sessionPercent": {
                    "type": "number",
                    "description": "Percent of session traffic to shed 0 - 100. Defaults to `0`.\n"
                },
                "sessionPolicy": {
                    "type": "string",
                    "description": "Method of shedding traffic. Available values: `\"\"`, `hash`. Defaults to `\"\"`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginHeader:LoadBalancerPoolOriginHeader"
                    },
                    "description": "HTTP request headers.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.\n"
                },
                "weight": {
                    "type": "number",
                    "description": "The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy=\"least_outstanding_requests\"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy=\"least_connections\"`, weight is used to scale the origin's open connections. Defaults to `1`.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "name"
            ]
        },
        "cloudflare:index/LoadBalancerPoolOriginHeader:LoadBalancerPoolOriginHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "HTTP Header name.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Values for the HTTP headers.\n"
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering": {
            "properties": {
                "policy": {
                    "type": "string",
                    "description": "Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `\"\"`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n"
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n"
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering": {
            "properties": {
                "defaultWeight": {
                    "type": "number",
                    "description": "The default weight for pools in the load balancer that are not specified in the `pool_weights` map.\n"
                },
                "poolWeights": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given region.\n"
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.\n"
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:index/LoadBalancerRule:LoadBalancerRule": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A disabled rule will not be executed.\n"
                },
                "fixedResponse": {
                    "$ref": "#/types/cloudflare:index/LoadBalancerRuleFixedResponse:LoadBalancerRuleFixedResponse",
                    "description": "Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human readable name for this rule.\n"
                },
                "overrides": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverride:LoadBalancerRuleOverride"
                    },
                    "description": "The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.\n"
                },
                "terminates": {
                    "type": "boolean",
                    "description": "Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "priority",
                        "terminates"
                    ]
                }
            }
        },
        "cloudflare:index/LoadBalancerRuleFixedResponse:LoadBalancerRuleFixedResponse": {
            "properties": {
                "contentType": {
                    "type": "string",
                    "description": "The value of the HTTP context-type header for this fixed response.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The value of the HTTP location header for this fixed response.\n"
                },
                "messageBody": {
                    "type": "string",
                    "description": "The text used as the html body for this fixed response.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "The HTTP status code used for this fixed response.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverride:LoadBalancerRuleOverride": {
            "properties": {
                "adaptiveRoutings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideAdaptiveRouting:LoadBalancerRuleOverrideAdaptiveRouting"
                    },
                    "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                },
                "countryPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideCountryPool:LoadBalancerRuleOverrideCountryPool"
                    },
                    "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                },
                "defaultPools": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                },
                "fallbackPool": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "locationStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideLocationStrategy:LoadBalancerRuleOverrideLocationStrategy"
                    },
                    "description": "Controls location-based steering for non-proxied requests.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverridePopPool:LoadBalancerRuleOverridePopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                },
                "randomSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideRandomSteering:LoadBalancerRuleOverrideRandomSteering"
                    },
                    "description": "Configures pool weights. When `steering_policy=\"random\"`, a random pool is selected with probability proportional to pool weights. When `steering_policy=\"least_outstanding_requests\"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy=\"least_connections\"`, pool weights are used to scale each pool's open connections.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideRegionPool:LoadBalancerRuleOverrideRegionPool"
                    },
                    "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Configure attributes for session affinity.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideSessionAffinityAttribute:LoadBalancerRuleOverrideSessionAffinityAttribute"
                    },
                    "description": "Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `\"\"` Defaults to `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "countryPools",
                        "popPools",
                        "regionPools"
                    ]
                }
            }
        },
        "cloudflare:index/LoadBalancerRuleOverrideAdaptiveRouting:LoadBalancerRuleOverrideAdaptiveRouting": {
            "properties": {
                "failoverAcrossPools": {
                    "type": "boolean",
                    "description": "Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverrideCountryPool:LoadBalancerRuleOverrideCountryPool": {
            "properties": {
                "country": {
                    "type": "string",
                    "description": "A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.\n"
                },
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given country.\n"
                }
            },
            "type": "object",
            "required": [
                "country",
                "poolIds"
            ]
        },
        "cloudflare:index/LoadBalancerRuleOverrideLocationStrategy:LoadBalancerRuleOverrideLocationStrategy": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.\n"
                },
                "preferEcs": {
                    "type": "string",
                    "description": "Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy=\"proximity\"`, and `geo` will prefer ECS only when `steering_policy=\"geo\"`. Available values: `always`, `never`, `proximity`, `geo`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverridePopPool:LoadBalancerRuleOverridePopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n"
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n"
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:index/LoadBalancerRuleOverrideRandomSteering:LoadBalancerRuleOverrideRandomSteering": {
            "properties": {
                "defaultWeight": {
                    "type": "number",
                    "description": "The default weight for pools in the load balancer that are not specified in the `pool_weights` map.\n"
                },
                "poolWeights": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverrideRegionPool:LoadBalancerRuleOverrideRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given region.\n"
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.\n"
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:index/LoadBalancerRuleOverrideSessionAffinityAttribute:LoadBalancerRuleOverrideSessionAffinityAttribute": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Configures the HTTP header names to use when header session affinity is enabled.\n"
                },
                "requireAllHeaders": {
                    "type": "boolean",
                    "description": "Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.\n"
                },
                "samesite": {
                    "type": "string",
                    "description": "Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure=\"Never\"`. Available values: `Auto`, `Lax`, `None`, `Strict`.\n"
                },
                "secure": {
                    "type": "string",
                    "description": "Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.\n"
                },
                "zeroDowntimeFailover": {
                    "type": "string",
                    "description": "Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerSessionAffinityAttribute:LoadBalancerSessionAffinityAttribute": {
            "properties": {
                "drainDuration": {
                    "type": "integer",
                    "description": "Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Configures the HTTP header names to use when header session affinity is enabled.\n"
                },
                "requireAllHeaders": {
                    "type": "boolean",
                    "description": "Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.\n"
                },
                "samesite": {
                    "type": "string",
                    "description": "Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure=\"Never\"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.\n"
                },
                "secure": {
                    "type": "string",
                    "description": "Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.\n"
                },
                "zeroDowntimeFailover": {
                    "type": "string",
                    "description": "Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/LogpushJobOutputOptions:LogpushJobOutputOptions": {
            "properties": {
                "batchPrefix": {
                    "type": "string",
                    "description": "String to be prepended before each batch.\n"
                },
                "batchSuffix": {
                    "type": "string",
                    "description": "String to be appended after each batch.\n"
                },
                "cve20214428": {
                    "type": "boolean",
                    "description": "Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.\n"
                },
                "fieldDelimiter": {
                    "type": "string",
                    "description": "String to join fields. This field be ignored when record_template is set. Defaults to `,`.\n"
                },
                "fieldNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of field names to be included in the Logpush output.\n"
                },
                "outputType": {
                    "type": "string",
                    "description": "Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.\n"
                },
                "recordDelimiter": {
                    "type": "string",
                    "description": "String to be inserted in-between the records as separator.\n"
                },
                "recordPrefix": {
                    "type": "string",
                    "description": "String to be prepended before each record. Defaults to `{`.\n"
                },
                "recordSuffix": {
                    "type": "string",
                    "description": "String to be appended after each record. Defaults to `}\n`.\n"
                },
                "recordTemplate": {
                    "type": "string",
                    "description": "String to use as template for each record instead of the default comma-separated list.\n"
                },
                "sampleRate": {
                    "type": "number",
                    "description": "Specifies the sampling rate. Defaults to `1`.\n"
                },
                "timestampFormat": {
                    "type": "string",
                    "description": "Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the headers rule is active.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique headers rule identifier.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "id"
            ]
        },
        "cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the headers rule is active.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique headers rule identifier.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Targeted actions for alert.\n"
                },
                "affectedComponents": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.\n"
                },
                "airportCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Filter on Points of Presence.\n"
                },
                "alertTriggerPreferences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Alert trigger preferences. Example: `slo`.\n"
                },
                "enableds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "State of the pool to alert on.\n"
                },
                "environments": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.\n"
                },
                "eventSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Source configuration to alert on for pool or origin.\n"
                },
                "eventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Stream event type to alert on.\n"
                },
                "events": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.\n"
                },
                "groupBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Alert grouping.\n"
                },
                "healthCheckIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Identifier health check. Required when using `filters.0.status`.\n"
                },
                "incidentImpacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.\n"
                },
                "inputIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Stream input id to alert on.\n"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A numerical limit. Example: `100`.\n"
                },
                "megabitsPerSeconds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Megabits per second threshold for dos alert.\n"
                },
                "newHealths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Health status to alert on for pool or origin.\n"
                },
                "newStatuses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tunnel health status to alert on.\n"
                },
                "packetsPerSeconds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Packets per second threshold for dos alert.\n"
                },
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Load balancer pool identifier.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.\n"
                },
                "projectIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Identifier of pages project.\n"
                },
                "protocols": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Protocol to alert on for dos.\n"
                },
                "requestsPerSeconds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Requests per second threshold for dos alert.\n"
                },
                "selectors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Selectors for alert. Valid options depend on the alert type.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "slos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A numerical limit. Example: `99.9`.\n"
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Status to alert on.\n"
                },
                "targetHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Target host to alert on for dos.\n"
                },
                "targetIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Target ip to alert on for dos in CIDR notation.\n"
                },
                "targetZoneNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Target domain to alert on.\n"
                },
                "tunnelIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tunnel IDs to alert on.\n"
                },
                "tunnelNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tunnel Names to alert on.\n"
                },
                "wheres": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Filter for alert.\n"
                },
                "zones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of zone identifiers.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/PageRuleActions:PageRuleActions": {
            "properties": {
                "alwaysUseHttps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n"
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "browserCacheTtl": {
                    "type": "string",
                    "description": "The Time To Live for the browser cache. `0` means 'Respect Existing Headers'\n"
                },
                "browserCheck": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "bypassCacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally bypass cache the page.\n"
                },
                "cacheByDeviceType": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "cacheDeceptionArmor": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "cacheKeyFields": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields",
                    "description": "Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.\n"
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Whether to set the cache level to `\"bypass\"`, `\"basic\"`, `\"simplified\"`, `\"aggressive\"`, or `\"cache_everything\"`.\n"
                },
                "cacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally cache the page.\n"
                },
                "cacheTtlByStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PageRuleActionsCacheTtlByStatus:PageRuleActionsCacheTtlByStatus"
                    },
                    "description": "Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.\n"
                },
                "disableApps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n"
                },
                "disablePerformance": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n"
                },
                "disableRailgun": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n"
                },
                "disableSecurity": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n"
                },
                "disableZaraz": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n"
                },
                "edgeCacheTtl": {
                    "type": "integer",
                    "description": "The Time To Live for the edge cache.\n"
                },
                "emailObfuscation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "explicitCacheControl": {
                    "type": "string",
                    "description": "Whether origin Cache-Control action is `\"on\"` or `\"off\"`.\n"
                },
                "forwardingUrl": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl",
                    "description": "The URL to forward to, and with what status. See below.\n"
                },
                "hostHeaderOverride": {
                    "type": "string",
                    "description": "Value of the Host header to send.\n"
                },
                "ipGeolocation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "minifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PageRuleActionsMinify:PageRuleActionsMinify"
                    },
                    "description": "The configuration for HTML, CSS and JS minification. See below for full list of options.\n"
                },
                "mirage": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "polish": {
                    "type": "string",
                    "description": "Whether this action is `\"off\"`, `\"lossless\"` or `\"lossy\"`.\n"
                },
                "resolveOverride": {
                    "type": "string",
                    "description": "Overridden origin server name.\n"
                },
                "respectStrongEtag": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "responseBuffering": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "rocketLoader": {
                    "type": "string",
                    "description": "Whether to set the rocket loader to `\"on\"`, `\"off\"`.\n"
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Whether to set the security level to `\"off\"`, `\"essentially_off\"`, `\"low\"`, `\"medium\"`, `\"high\"`, or `\"under_attack\"`.\n"
                },
                "serverSideExclude": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "ssl": {
                    "type": "string",
                    "description": "Whether to set the SSL mode to `\"off\"`, `\"flexible\"`, `\"full\"`, `\"strict\"`, or `\"origin_pull\"`.\n"
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                },
                "waf": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie",
                    "description": "Controls what cookies go into Cache Key:\n"
                },
                "header": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader",
                    "description": "Controls what HTTP headers go into Cache Key:\n"
                },
                "host": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost",
                    "description": "Controls which Host header goes into Cache Key:\n"
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString",
                    "description": "Controls which URL query string parameters go into the Cache Key.\n"
                },
                "user": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser",
                    "description": "Controls which end user-related features go into the Cache Key.\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "queryString",
                "user"
            ]
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified cookies, without including their actual values.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Use values of specified cookies in Cache Key.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "excludes",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "description": "`false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n"
                },
                "ignore": {
                    "type": "boolean",
                    "description": "`false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "excludes",
                        "ignore",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "description": "`true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.\n"
                },
                "geo": {
                    "type": "boolean",
                    "description": "`true` - includes the clients country, derived from the IP address; defaults to `false`.\n"
                },
                "lang": {
                    "type": "boolean",
                    "description": "`true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.\n\nExample:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Unrealistic example with all features used\nconst foobar = new cloudflare.PageRule(\"foobar\", {\n    zoneId: cloudflareZoneId,\n    target: `${cloudflareZone}/app/*`,\n    priority: 1,\n    actions: {\n        cacheKeyFields: {\n            cookie: {\n                checkPresences: [\"wordpress_test_cookie\"],\n            },\n            header: {\n                checkPresences: [\"header_present\"],\n                excludes: [\"origin\"],\n                includes: [\n                    \"api-key\",\n                    \"dnt\",\n                ],\n            },\n            host: {\n                resolved: true,\n            },\n            queryString: {\n                ignore: true,\n            },\n            user: {\n                deviceType: false,\n                geo: true,\n                lang: true,\n            },\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Unrealistic example with all features used\nfoobar = cloudflare.PageRule(\"foobar\",\n    zone_id=cloudflare_zone_id,\n    target=f\"{cloudflare_zone}/app/*\",\n    priority=1,\n    actions={\n        \"cache_key_fields\": {\n            \"cookie\": {\n                \"check_presences\": [\"wordpress_test_cookie\"],\n            },\n            \"header\": {\n                \"check_presences\": [\"header_present\"],\n                \"excludes\": [\"origin\"],\n                \"includes\": [\n                    \"api-key\",\n                    \"dnt\",\n                ],\n            },\n            \"host\": {\n                \"resolved\": True,\n            },\n            \"query_string\": {\n                \"ignore\": True,\n            },\n            \"user\": {\n                \"device_type\": False,\n                \"geo\": True,\n                \"lang\": True,\n            },\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Unrealistic example with all features used\n    var foobar = new Cloudflare.PageRule(\"foobar\", new()\n    {\n        ZoneId = cloudflareZoneId,\n        Target = $\"{cloudflareZone}/app/*\",\n        Priority = 1,\n        Actions = new Cloudflare.Inputs.PageRuleActionsArgs\n        {\n            CacheKeyFields = new Cloudflare.Inputs.PageRuleActionsCacheKeyFieldsArgs\n            {\n                Cookie = new Cloudflare.Inputs.PageRuleActionsCacheKeyFieldsCookieArgs\n                {\n                    CheckPresences = new[]\n                    {\n                        \"wordpress_test_cookie\",\n                    },\n                },\n                Header = new Cloudflare.Inputs.PageRuleActionsCacheKeyFieldsHeaderArgs\n                {\n                    CheckPresences = new[]\n                    {\n                        \"header_present\",\n                    },\n                    Excludes = new[]\n                    {\n                        \"origin\",\n                    },\n                    Includes = new[]\n                    {\n                        \"api-key\",\n                        \"dnt\",\n                    },\n                },\n                Host = new Cloudflare.Inputs.PageRuleActionsCacheKeyFieldsHostArgs\n                {\n                    Resolved = true,\n                },\n                QueryString = new Cloudflare.Inputs.PageRuleActionsCacheKeyFieldsQueryStringArgs\n                {\n                    Ignore = true,\n                },\n                User = new Cloudflare.Inputs.PageRuleActionsCacheKeyFieldsUserArgs\n                {\n                    DeviceType = false,\n                    Geo = true,\n                    Lang = true,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Unrealistic example with all features used\n\t\t_, err := cloudflare.NewPageRule(ctx, \"foobar\", \u0026cloudflare.PageRuleArgs{\n\t\t\tZoneId:   pulumi.Any(cloudflareZoneId),\n\t\t\tTarget:   pulumi.Sprintf(\"%v/app/*\", cloudflareZone),\n\t\t\tPriority: pulumi.Int(1),\n\t\t\tActions: \u0026cloudflare.PageRuleActionsArgs{\n\t\t\t\tCacheKeyFields: \u0026cloudflare.PageRuleActionsCacheKeyFieldsArgs{\n\t\t\t\t\tCookie: \u0026cloudflare.PageRuleActionsCacheKeyFieldsCookieArgs{\n\t\t\t\t\t\tCheckPresences: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"wordpress_test_cookie\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tHeader: \u0026cloudflare.PageRuleActionsCacheKeyFieldsHeaderArgs{\n\t\t\t\t\t\tCheckPresences: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"header_present\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tExcludes: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"origin\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIncludes: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"api-key\"),\n\t\t\t\t\t\t\tpulumi.String(\"dnt\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tHost: \u0026cloudflare.PageRuleActionsCacheKeyFieldsHostArgs{\n\t\t\t\t\t\tResolved: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tQueryString: \u0026cloudflare.PageRuleActionsCacheKeyFieldsQueryStringArgs{\n\t\t\t\t\t\tIgnore: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tUser: \u0026cloudflare.PageRuleActionsCacheKeyFieldsUserArgs{\n\t\t\t\t\t\tDeviceType: pulumi.Bool(false),\n\t\t\t\t\t\tGeo:        pulumi.Bool(true),\n\t\t\t\t\t\tLang:       pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.PageRule;\nimport com.pulumi.cloudflare.PageRuleArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsCacheKeyFieldsArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsCacheKeyFieldsCookieArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsCacheKeyFieldsHeaderArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsCacheKeyFieldsHostArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsCacheKeyFieldsQueryStringArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsCacheKeyFieldsUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Unrealistic example with all features used\n        var foobar = new PageRule(\"foobar\", PageRuleArgs.builder()\n            .zoneId(cloudflareZoneId)\n            .target(String.format(\"%s/app/*\", cloudflareZone))\n            .priority(1)\n            .actions(PageRuleActionsArgs.builder()\n                .cacheKeyFields(PageRuleActionsCacheKeyFieldsArgs.builder()\n                    .cookie(PageRuleActionsCacheKeyFieldsCookieArgs.builder()\n                        .checkPresences(\"wordpress_test_cookie\")\n                        .build())\n                    .header(PageRuleActionsCacheKeyFieldsHeaderArgs.builder()\n                        .checkPresences(\"header_present\")\n                        .excludes(\"origin\")\n                        .includes(                        \n                            \"api-key\",\n                            \"dnt\")\n                        .build())\n                    .host(PageRuleActionsCacheKeyFieldsHostArgs.builder()\n                        .resolved(true)\n                        .build())\n                    .queryString(PageRuleActionsCacheKeyFieldsQueryStringArgs.builder()\n                        .ignore(true)\n                        .build())\n                    .user(PageRuleActionsCacheKeyFieldsUserArgs.builder()\n                        .deviceType(false)\n                        .geo(true)\n                        .lang(true)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Unrealistic example with all features used\n  foobar:\n    type: cloudflare:PageRule\n    properties:\n      zoneId: ${cloudflareZoneId}\n      target: ${cloudflareZone}/app/*\n      priority: 1\n      actions:\n        cacheKeyFields:\n          cookie:\n            checkPresences:\n              - wordpress_test_cookie\n          header:\n            checkPresences:\n              - header_present\n            excludes:\n              - origin\n            includes:\n              - api-key\n              - dnt\n          host:\n            resolved: true\n          queryString:\n            ignore: true\n          user:\n            deviceType: false\n            geo: true\n            lang: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceType",
                        "geo",
                        "lang"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheTtlByStatus:PageRuleActionsCacheTtlByStatus": {
            "properties": {
                "codes": {
                    "type": "string",
                    "description": "A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Duration a resource lives in the Cloudflare cache.\n- positive number - cache for specified duration in seconds\n"
                }
            },
            "type": "object",
            "required": [
                "codes",
                "ttl"
            ]
        },
        "cloudflare:index/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "description": "The status code to use for the redirection.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to which the page rule should forward.\n"
                }
            },
            "type": "object",
            "required": [
                "statusCode",
                "url"
            ]
        },
        "cloudflare:index/PageRuleActionsMinify:PageRuleActionsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "Whether CSS should be minified. Valid values are `\"on\"` or `\"off\"`.\n"
                },
                "html": {
                    "type": "string",
                    "description": "Whether HTML should be minified. Valid values are `\"on\"` or `\"off\"`.\n"
                },
                "js": {
                    "type": "string",
                    "description": "Whether Javascript should be minified. Valid values are `\"on\"` or `\"off\"`.\n"
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig": {
            "properties": {
                "buildCaching": {
                    "type": "boolean",
                    "description": "Enable build caching for the project.\n"
                },
                "buildCommand": {
                    "type": "string",
                    "description": "Command used to build project.\n"
                },
                "destinationDir": {
                    "type": "string",
                    "description": "Output directory of the build.\n"
                },
                "rootDir": {
                    "type": "string",
                    "description": "Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.\n"
                },
                "webAnalyticsTag": {
                    "type": "string",
                    "description": "The classifying tag for analytics.\n"
                },
                "webAnalyticsToken": {
                    "type": "string",
                    "description": "The auth token for analytics.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs": {
            "properties": {
                "preview": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsPreview:PagesProjectDeploymentConfigsPreview",
                    "description": "Configuration for preview deploys.\n"
                },
                "production": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsProduction:PagesProjectDeploymentConfigsProduction",
                    "description": "Configuration for production deploys.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "preview",
                        "production"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectDeploymentConfigsPreview:PagesProjectDeploymentConfigsPreview": {
            "properties": {
                "alwaysUseLatestCompatibilityDate": {
                    "type": "boolean",
                    "description": "Use latest compatibility date for Pages Functions. Defaults to `false`.\n"
                },
                "compatibilityDate": {
                    "type": "string",
                    "description": "Compatibility date used for Pages Functions.\n"
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Compatibility flags used for Pages Functions.\n"
                },
                "d1Databases": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "D1 Databases used for Pages Functions. Defaults to `map[]`.\n"
                },
                "durableObjectNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Durable Object namespaces used for Pages Functions. Defaults to `map[]`.\n"
                },
                "environmentVariables": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Environment variables for Pages Functions. Defaults to `map[]`.\n"
                },
                "failOpen": {
                    "type": "boolean",
                    "description": "Fail open used for Pages Functions. Defaults to `false`.\n"
                },
                "kvNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "KV namespaces used for Pages Functions. Defaults to `map[]`.\n"
                },
                "placement": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsPreviewPlacement:PagesProjectDeploymentConfigsPreviewPlacement",
                    "description": "Configuration for placement in the Cloudflare Pages project.\n"
                },
                "r2Buckets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "R2 Buckets used for Pages Functions. Defaults to `map[]`.\n"
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Encrypted environment variables for Pages Functions. Defaults to `map[]`.\n",
                    "secret": true
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsPreviewServiceBinding:PagesProjectDeploymentConfigsPreviewServiceBinding"
                    },
                    "description": "Services used for Pages Functions.\n"
                },
                "usageModel": {
                    "type": "string",
                    "description": "Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "compatibilityDate",
                        "compatibilityFlags",
                        "placement"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectDeploymentConfigsPreviewPlacement:PagesProjectDeploymentConfigsPreviewPlacement": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Placement Mode for the Pages Function.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mode"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectDeploymentConfigsPreviewServiceBinding:PagesProjectDeploymentConfigsPreviewServiceBinding": {
            "properties": {
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment to bind to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "service": {
                    "type": "string",
                    "description": "The name of the Worker to bind to.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "service"
            ]
        },
        "cloudflare:index/PagesProjectDeploymentConfigsProduction:PagesProjectDeploymentConfigsProduction": {
            "properties": {
                "alwaysUseLatestCompatibilityDate": {
                    "type": "boolean",
                    "description": "Use latest compatibility date for Pages Functions. Defaults to `false`.\n"
                },
                "compatibilityDate": {
                    "type": "string",
                    "description": "Compatibility date used for Pages Functions.\n"
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Compatibility flags used for Pages Functions.\n"
                },
                "d1Databases": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "D1 Databases used for Pages Functions. Defaults to `map[]`.\n"
                },
                "durableObjectNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Durable Object namespaces used for Pages Functions. Defaults to `map[]`.\n"
                },
                "environmentVariables": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Environment variables for Pages Functions. Defaults to `map[]`.\n"
                },
                "failOpen": {
                    "type": "boolean",
                    "description": "Fail open used for Pages Functions. Defaults to `false`.\n"
                },
                "kvNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "KV namespaces used for Pages Functions. Defaults to `map[]`.\n"
                },
                "placement": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsProductionPlacement:PagesProjectDeploymentConfigsProductionPlacement",
                    "description": "Configuration for placement in the Cloudflare Pages project.\n"
                },
                "r2Buckets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "R2 Buckets used for Pages Functions. Defaults to `map[]`.\n"
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Encrypted environment variables for Pages Functions. Defaults to `map[]`.\n",
                    "secret": true
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsProductionServiceBinding:PagesProjectDeploymentConfigsProductionServiceBinding"
                    },
                    "description": "Services used for Pages Functions.\n"
                },
                "usageModel": {
                    "type": "string",
                    "description": "Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "compatibilityDate",
                        "compatibilityFlags",
                        "placement"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectDeploymentConfigsProductionPlacement:PagesProjectDeploymentConfigsProductionPlacement": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Placement Mode for the Pages Function.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mode"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectDeploymentConfigsProductionServiceBinding:PagesProjectDeploymentConfigsProductionServiceBinding": {
            "properties": {
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment to bind to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "service": {
                    "type": "string",
                    "description": "The name of the Worker to bind to.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "service"
            ]
        },
        "cloudflare:index/PagesProjectSource:PagesProjectSource": {
            "properties": {
                "config": {
                    "$ref": "#/types/cloudflare:index/PagesProjectSourceConfig:PagesProjectSourceConfig",
                    "description": "Configuration for the source of the Cloudflare Pages project.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Project host type.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/PagesProjectSourceConfig:PagesProjectSourceConfig": {
            "properties": {
                "deploymentsEnabled": {
                    "type": "boolean",
                    "description": "Toggle deployments on this repo. Defaults to `true`.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Project owner username. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "prCommentsEnabled": {
                    "type": "boolean",
                    "description": "Enable Pages to comment on Pull Requests. Defaults to `true`.\n"
                },
                "previewBranchExcludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Branches will be excluded from automatic deployment.\n"
                },
                "previewBranchIncludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Branches will be included for automatic deployment.\n"
                },
                "previewDeploymentSetting": {
                    "type": "string",
                    "description": "Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.\n"
                },
                "productionBranch": {
                    "type": "string",
                    "description": "Project production branch name.\n"
                },
                "productionDeploymentEnabled": {
                    "type": "boolean",
                    "description": "Enable production deployments. Defaults to `true`.\n"
                },
                "repoName": {
                    "type": "string",
                    "description": "Project repository name. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "productionBranch"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "previewBranchExcludes",
                        "previewBranchIncludes",
                        "productionBranch"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitAction:RateLimitAction": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                },
                "response": {
                    "$ref": "#/types/cloudflare:index/RateLimitActionResponse:RateLimitActionResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RateLimitActionResponse:RateLimitActionResponse": {
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The body to return, the content here should conform to the `content_type`.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.\n"
                }
            },
            "type": "object",
            "required": [
                "body",
                "contentType"
            ]
        },
        "cloudflare:index/RateLimitCorrelate:RateLimitCorrelate": {
            "properties": {
                "by": {
                    "type": "string",
                    "description": "If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RateLimitMatch:RateLimitMatch": {
            "properties": {
                "request": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatchRequest:RateLimitMatchRequest",
                    "description": "Matches HTTP requests (from the client to Cloudflare).\n"
                },
                "response": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatchResponse:RateLimitMatchResponse",
                    "description": "Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "request",
                        "response"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitMatchRequest:RateLimitMatchRequest": {
            "properties": {
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.\n"
                },
                "schemes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.\n"
                },
                "urlPattern": {
                    "type": "string",
                    "description": "The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "methods",
                        "schemes",
                        "urlPattern"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitMatchResponse:RateLimitMatchResponse": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "description": "List of HTTP headers maps to match the origin response on.\n"
                },
                "originTraffic": {
                    "type": "boolean",
                    "description": "Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.\n"
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "HTTP Status codes, can be one, many or indicate all by not providing this value.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "originTraffic",
                        "statuses"
                    ]
                }
            }
        },
        "cloudflare:index/RecordData:RecordData": {
            "properties": {
                "algorithm": {
                    "type": "integer"
                },
                "altitude": {
                    "type": "number"
                },
                "certificate": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "flags": {
                    "type": "string"
                },
                "keyTag": {
                    "type": "integer"
                },
                "latDegrees": {
                    "type": "integer"
                },
                "latDirection": {
                    "type": "string"
                },
                "latMinutes": {
                    "type": "integer"
                },
                "latSeconds": {
                    "type": "number"
                },
                "longDegrees": {
                    "type": "integer"
                },
                "longDirection": {
                    "type": "string"
                },
                "longMinutes": {
                    "type": "integer"
                },
                "longSeconds": {
                    "type": "number"
                },
                "matchingType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "precisionHorz": {
                    "type": "number"
                },
                "precisionVert": {
                    "type": "number"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "proto": {
                    "type": "string"
                },
                "protocol": {
                    "type": "integer"
                },
                "publicKey": {
                    "type": "string"
                },
                "regex": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                },
                "tag": {
                    "type": "string"
                },
                "target": {
                    "type": "string"
                },
                "type": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "value": {
                    "type": "string"
                },
                "weight": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RiskBehaviorBehavior:RiskBehaviorBehavior": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether this risk behavior type is enabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of this risk behavior type\n"
                },
                "riskLevel": {
                    "type": "string",
                    "description": "Risk level. Available values: `low`, `medium`, `high`\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "name",
                "riskLevel"
            ]
        },
        "cloudflare:index/RulesetRule:RulesetRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.\n"
                },
                "actionParameters": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParameters:RulesetRuleActionParameters",
                    "description": "List of parameters that configure the behavior of the ruleset rule action.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset rule and its intended use.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the rule is active.\n"
                },
                "exposedCredentialCheck": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleExposedCredentialCheck:RulesetRuleExposedCredentialCheck",
                    "description": "List of parameters that configure exposed credential checks.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique rule identifier.\n"
                },
                "lastUpdated": {
                    "type": "string",
                    "description": "The most recent update to this rule.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleLogging:RulesetRuleLogging",
                    "description": "List parameters to configure how the rule generates logs. Only valid for skip action.\n"
                },
                "ratelimit": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleRatelimit:RulesetRuleRatelimit",
                    "description": "List of parameters that configure HTTP rate limiting behaviour.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Rule reference.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset to deploy.\n"
                }
            },
            "type": "object",
            "required": [
                "expression"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "description",
                        "enabled",
                        "expression",
                        "id",
                        "lastUpdated",
                        "ref",
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParameters:RulesetRuleActionParameters": {
            "properties": {
                "additionalCacheablePorts": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Specifies uncommon ports to allow cacheable assets to be served from.\n"
                },
                "algorithms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersAlgorithm:RulesetRuleActionParametersAlgorithm"
                    },
                    "description": "Compression algorithms to use in order of preference.\n"
                },
                "automaticHttpsRewrites": {
                    "type": "boolean",
                    "description": "Turn on or off Cloudflare Automatic HTTPS rewrites.\n"
                },
                "autominifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersAutominify:RulesetRuleActionParametersAutominify"
                    },
                    "description": "Indicate which file extensions to minify automatically.\n"
                },
                "bic": {
                    "type": "boolean",
                    "description": "Inspect the visitor's browser for headers commonly associated with spammers and certain bots.\n"
                },
                "browserTtl": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersBrowserTtl:RulesetRuleActionParametersBrowserTtl",
                    "description": "List of browser TTL parameters to apply to the request.\n"
                },
                "cache": {
                    "type": "boolean",
                    "description": "Whether to cache if expression matches.\n"
                },
                "cacheKey": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKey:RulesetRuleActionParametersCacheKey",
                    "description": "List of cache key parameters to apply to the request.\n"
                },
                "cacheReserve": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheReserve:RulesetRuleActionParametersCacheReserve",
                    "description": "List of cache reserve parameters to apply to the request.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Content of the custom error response.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "Content-Type of the custom error response.\n"
                },
                "cookieFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cookie values to include as part of custom fields logging.\n"
                },
                "disableApps": {
                    "type": "boolean",
                    "description": "Turn off all active Cloudflare Apps.\n"
                },
                "disableRailgun": {
                    "type": "boolean",
                    "description": "Turn off railgun feature of the Cloudflare Speed app.\n"
                },
                "disableRum": {
                    "type": "boolean",
                    "description": "Turn off RUM feature.\n"
                },
                "disableZaraz": {
                    "type": "boolean",
                    "description": "Turn off zaraz feature.\n"
                },
                "edgeTtl": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersEdgeTtl:RulesetRuleActionParametersEdgeTtl",
                    "description": "List of edge TTL parameters to apply to the request.\n"
                },
                "emailObfuscation": {
                    "type": "boolean",
                    "description": "Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.\n"
                },
                "fonts": {
                    "type": "boolean",
                    "description": "Toggle fonts.\n"
                },
                "fromList": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersFromList:RulesetRuleActionParametersFromList",
                    "description": "Use a list to lookup information for the action.\n"
                },
                "fromValue": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersFromValue:RulesetRuleActionParametersFromValue",
                    "description": "Use a value to lookup information for the action.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersHeader:RulesetRuleActionParametersHeader"
                    },
                    "description": "List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Host Header that request origin receives.\n"
                },
                "hotlinkProtection": {
                    "type": "boolean",
                    "description": "Turn on or off the hotlink protection feature.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Identifier of the action parameter to modify.\n"
                },
                "increment": {
                    "type": "integer"
                },
                "matchedData": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersMatchedData:RulesetRuleActionParametersMatchedData",
                    "description": "List of properties to configure WAF payload logging.\n"
                },
                "mirage": {
                    "type": "boolean",
                    "description": "Turn on or off Cloudflare Mirage of the Cloudflare Speed app.\n"
                },
                "opportunisticEncryption": {
                    "type": "boolean",
                    "description": "Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.\n"
                },
                "origin": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOrigin:RulesetRuleActionParametersOrigin",
                    "description": "List of properties to change request origin.\n"
                },
                "originCacheControl": {
                    "type": "boolean",
                    "description": "Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.\n"
                },
                "originErrorPagePassthru": {
                    "type": "boolean",
                    "description": "Pass-through error page for origin.\n"
                },
                "overrides": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverrides:RulesetRuleActionParametersOverrides",
                    "description": "List of override configurations to apply to the ruleset.\n"
                },
                "phases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.\n"
                },
                "polish": {
                    "type": "string",
                    "description": "Apply options from the Polish feature of the Cloudflare Speed app.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.\n"
                },
                "readTimeout": {
                    "type": "integer",
                    "description": "Specifies a maximum timeout for reading content from an origin server.\n"
                },
                "requestFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of request headers to include as part of custom fields logging, in lowercase.\n"
                },
                "respectStrongEtags": {
                    "type": "boolean",
                    "description": "Respect strong ETags.\n"
                },
                "responseFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of response headers to include as part of custom fields logging, in lowercase.\n"
                },
                "responses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersResponse:RulesetRuleActionParametersResponse"
                    },
                    "description": "List of parameters that configure the response given to end users.\n"
                },
                "rocketLoader": {
                    "type": "boolean",
                    "description": "Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.\n"
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { \"efb7b8c949ac4650a09736fc376e9aee\" = \"5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760\" }`.\n"
                },
                "ruleset": {
                    "type": "string",
                    "description": "Which ruleset ID to target.\n"
                },
                "rulesets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed WAF rule IDs to target. Only valid when the `\"action\"` is set to skip.\n"
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Control options for the Security Level feature from the Security app.\n"
                },
                "serveStale": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersServeStale:RulesetRuleActionParametersServeStale",
                    "description": "List of serve stale parameters to apply to the request.\n"
                },
                "serverSideExcludes": {
                    "type": "boolean",
                    "description": "Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.\n"
                },
                "sni": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersSni:RulesetRuleActionParametersSni",
                    "description": "List of properties to manange Server Name Indication.\n"
                },
                "ssl": {
                    "type": "string",
                    "description": "Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "HTTP status code of the custom error response.\n"
                },
                "sxg": {
                    "type": "boolean",
                    "description": "Turn on or off the SXG feature.\n"
                },
                "uri": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUri:RulesetRuleActionParametersUri",
                    "description": "List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset to deploy.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParametersAlgorithm:RulesetRuleActionParametersAlgorithm": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the compression algorithm to use. Available values: `zstd`, `gzip`, `brotli`, `auto`, `default`, `none`\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersAutominify:RulesetRuleActionParametersAutominify": {
            "properties": {
                "css": {
                    "type": "boolean",
                    "description": "CSS minification.\n"
                },
                "html": {
                    "type": "boolean",
                    "description": "HTML minification.\n"
                },
                "js": {
                    "type": "boolean",
                    "description": "JS minification.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersBrowserTtl:RulesetRuleActionParametersBrowserTtl": {
            "properties": {
                "default": {
                    "type": "integer",
                    "description": "Default browser TTL. This value is required when override_origin is set\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKey:RulesetRuleActionParametersCacheKey": {
            "properties": {
                "cacheByDeviceType": {
                    "type": "boolean",
                    "description": "Cache by device type.\n"
                },
                "cacheDeceptionArmor": {
                    "type": "boolean",
                    "description": "Cache deception armor.\n"
                },
                "customKey": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKey:RulesetRuleActionParametersCacheKeyCustomKey",
                    "description": "Custom key parameters for the request.\n"
                },
                "ignoreQueryStringsOrder": {
                    "type": "boolean",
                    "description": "Ignore query strings order.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKey:RulesetRuleActionParametersCacheKeyCustomKey": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyCookie:RulesetRuleActionParametersCacheKeyCustomKeyCookie",
                    "description": "Cookie parameters for the custom key.\n"
                },
                "header": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHeader:RulesetRuleActionParametersCacheKeyCustomKeyHeader",
                    "description": "Header parameters for the custom key.\n"
                },
                "host": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHost:RulesetRuleActionParametersCacheKeyCustomKeyHost",
                    "description": "Host parameters for the custom key.\n"
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyQueryString:RulesetRuleActionParametersCacheKeyCustomKeyQueryString",
                    "description": "Query string parameters for the custom key.\n"
                },
                "user": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyUser:RulesetRuleActionParametersCacheKeyCustomKeyUser",
                    "description": "User parameters for the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyCookie:RulesetRuleActionParametersCacheKeyCustomKeyCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cookies to check for presence in the custom key.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cookies to include in the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHeader:RulesetRuleActionParametersCacheKeyCustomKeyHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to check for presence in the custom key.\n"
                },
                "contains": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Dictionary of headers mapping to lists of values to check for presence in the custom key.\n"
                },
                "excludeOrigin": {
                    "type": "boolean",
                    "description": "Exclude the origin header from the custom key.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to include in the custom key.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "excludeOrigin"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHost:RulesetRuleActionParametersCacheKeyCustomKeyHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "description": "Resolve hostname to IP address.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyQueryString:RulesetRuleActionParametersCacheKeyCustomKeyQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of query string parameters to exclude from the custom key.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of query string parameters to include in the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyUser:RulesetRuleActionParametersCacheKeyCustomKeyUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "description": "Add device type to the custom key.\n"
                },
                "geo": {
                    "type": "boolean",
                    "description": "Add geo data to the custom key.\n"
                },
                "lang": {
                    "type": "boolean",
                    "description": "Add language data to the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheReserve:RulesetRuleActionParametersCacheReserve": {
            "properties": {
                "eligible": {
                    "type": "boolean",
                    "description": "Determines whether Cloudflare will write the eligible resource to cache reserve.\n"
                },
                "minimumFileSize": {
                    "type": "integer",
                    "description": "The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and \"eligible\" is true, Cloudflare will use 0 bytes by default.\n"
                }
            },
            "type": "object",
            "required": [
                "eligible"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersEdgeTtl:RulesetRuleActionParametersEdgeTtl": {
            "properties": {
                "default": {
                    "type": "integer",
                    "description": "Default edge TTL.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`\n"
                },
                "statusCodeTtls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtl:RulesetRuleActionParametersEdgeTtlStatusCodeTtl"
                    },
                    "description": "Edge TTL for the status codes.\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtl:RulesetRuleActionParametersEdgeTtlStatusCodeTtl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "description": "Status code for which the edge TTL is applied.\n"
                },
                "statusCodeRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange:RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange"
                    },
                    "description": "Status code range for which the edge TTL is applied.\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Status code edge TTL value.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange:RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange": {
            "properties": {
                "from": {
                    "type": "integer",
                    "description": "From status code.\n"
                },
                "to": {
                    "type": "integer",
                    "description": "To status code.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersFromList:RulesetRuleActionParametersFromList": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Expression to use for the list lookup.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the list.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersFromValue:RulesetRuleActionParametersFromValue": {
            "properties": {
                "preserveQueryString": {
                    "type": "boolean",
                    "description": "Preserve query string for redirect URL.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "Status code for redirect.\n"
                },
                "targetUrl": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersFromValueTargetUrl:RulesetRuleActionParametersFromValueTargetUrl",
                    "description": "Target URL for redirect.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersFromValueTargetUrl:RulesetRuleActionParametersFromValueTargetUrl": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static value to provide as the HTTP request header value.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersHeader:RulesetRuleActionParametersHeader": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP request header to target.\n"
                },
                "operation": {
                    "type": "string",
                    "description": "Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static value to provide as the HTTP request header value.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersMatchedData:RulesetRuleActionParametersMatchedData": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOrigin:RulesetRuleActionParametersOrigin": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Origin Hostname where request is sent.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Origin Port where request is sent.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverrides:RulesetRuleActionParametersOverrides": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.\n"
                },
                "categories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverridesCategory:RulesetRuleActionParametersOverridesCategory"
                    },
                    "description": "List of tag-based overrides.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current ruleset-level override enables or disables the ruleset.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverridesRule:RulesetRuleActionParametersOverridesRule"
                    },
                    "description": "List of rule-based overrides.\n"
                },
                "sensitivityLevel": {
                    "type": "string",
                    "description": "Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverridesCategory:RulesetRuleActionParametersOverridesCategory": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.\n"
                },
                "category": {
                    "type": "string",
                    "description": "Tag name to apply the ruleset rule override to.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverridesRule:RulesetRuleActionParametersOverridesRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current rule-level override enables or disables the rule.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Rule ID to apply the override to.\n"
                },
                "scoreThreshold": {
                    "type": "integer",
                    "description": "Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.\n"
                },
                "sensitivityLevel": {
                    "type": "string",
                    "description": "Sensitivity level for a ruleset rule override.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersResponse:RulesetRuleActionParametersResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Body content to include in the response.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "HTTP content type to send in the response.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "HTTP status code to send in the response.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersServeStale:RulesetRuleActionParametersServeStale": {
            "properties": {
                "disableStaleWhileUpdating": {
                    "type": "boolean",
                    "description": "Disable stale while updating.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersSni:RulesetRuleActionParametersSni": {
            "properties": {
                "value": {
                    "type": "string",
                    "description": "Value to define for SNI.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUri:RulesetRuleActionParametersUri": {
            "properties": {
                "origin": {
                    "type": "boolean"
                },
                "path": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUriPath:RulesetRuleActionParametersUriPath",
                    "description": "URI path configuration when performing a URL rewrite.\n"
                },
                "query": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUriQuery:RulesetRuleActionParametersUriQuery",
                    "description": "Query string configuration when performing a URL rewrite.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUriPath:RulesetRuleActionParametersUriPath": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUriQuery:RulesetRuleActionParametersUriQuery": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleExposedCredentialCheck:RulesetRuleExposedCredentialCheck": {
            "properties": {
                "passwordExpression": {
                    "type": "string",
                    "description": "Firewall Rules expression language based on Wireshark display filters for where to check for the \"password\" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).\n"
                },
                "usernameExpression": {
                    "type": "string",
                    "description": "Firewall Rules expression language based on Wireshark display filters for where to check for the \"username\" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleLogging:RulesetRuleLogging": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Override the default logging behavior when a rule is matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleRatelimit:RulesetRuleRatelimit": {
            "properties": {
                "characteristics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of parameters that define how Cloudflare tracks the request rate for this rule.\n"
                },
                "countingExpression": {
                    "type": "string",
                    "description": "Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "mitigationTimeout": {
                    "type": "integer",
                    "description": "Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The period of time to consider (in seconds) when evaluating the request rate.\n"
                },
                "requestsPerPeriod": {
                    "type": "integer",
                    "description": "The number of requests over the period of time that will trigger the Rate Limiting rule.\n"
                },
                "requestsToOrigin": {
                    "type": "boolean",
                    "description": "Whether to include requests to origin within the Rate Limiting count.\n"
                },
                "scorePerPeriod": {
                    "type": "integer",
                    "description": "The maximum aggregate score over the period of time that will trigger Rate Limiting rule.\n"
                },
                "scoreResponseHeaderName": {
                    "type": "string",
                    "description": "Name of HTTP header in the response, set by the origin server, with the score for the current request.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "requestsToOrigin"
                    ]
                }
            }
        },
        "cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the DNS record associated with the application.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of DNS record associated with the application.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "cloudflare:index/SpectrumApplicationEdgeIps:SpectrumApplicationEdgeIps": {
            "properties": {
                "connectivity": {
                    "type": "string",
                    "description": "The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of edge IP configuration specified. Available values: `dynamic`, `static`.\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange": {
            "properties": {
                "end": {
                    "type": "integer",
                    "description": "Upper bound of the origin port range.\n"
                },
                "start": {
                    "type": "integer",
                    "description": "Lower bound of the origin port range.\n"
                }
            },
            "type": "object",
            "required": [
                "end",
                "start"
            ]
        },
        "cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address for the tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tunnel.\n"
                },
                "host": {
                    "type": "string",
                    "description": "The domain name for the tunnel.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus": {
            "properties": {
                "enabledDownloadPhase": {
                    "type": "boolean",
                    "description": "Scan on file download.\n"
                },
                "enabledUploadPhase": {
                    "type": "boolean",
                    "description": "Scan on file upload.\n"
                },
                "failClosed": {
                    "type": "boolean",
                    "description": "Block requests for files that cannot be scanned.\n"
                },
                "notificationSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirusNotificationSettings:TeamsAccountAntivirusNotificationSettings",
                    "description": "Set notifications for antivirus.\n"
                }
            },
            "type": "object",
            "required": [
                "enabledDownloadPhase",
                "enabledUploadPhase",
                "failClosed"
            ]
        },
        "cloudflare:index/TeamsAccountAntivirusNotificationSettings:TeamsAccountAntivirusNotificationSettings": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable notification settings.\n"
                },
                "message": {
                    "type": "string",
                    "description": "Notification content.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "Support URL to show in the notification.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "Hex code of block page background color.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of enablement.\n"
                },
                "footerText": {
                    "type": "string",
                    "description": "Block page footer text.\n"
                },
                "headerText": {
                    "type": "string",
                    "description": "Block page header text.\n"
                },
                "logoPath": {
                    "type": "string",
                    "description": "URL of block page logo.\n"
                },
                "mailtoAddress": {
                    "type": "string",
                    "description": "Admin email for users to contact.\n"
                },
                "mailtoSubject": {
                    "type": "string",
                    "description": "Subject line for emails created from block page.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of block page configuration.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountBodyScanning:TeamsAccountBodyScanning": {
            "properties": {
                "inspectionMode": {
                    "type": "string",
                    "description": "Body scanning inspection mode. Available values: `deep`, `shallow`.\n"
                }
            },
            "type": "object",
            "required": [
                "inspectionMode"
            ]
        },
        "cloudflare:index/TeamsAccountCertificate:TeamsAccountCertificate": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of certificate for TLS interception.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/TeamsAccountCustomCertificate:TeamsAccountCustomCertificate": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether TLS encryption should use a custom certificate.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of custom certificate.\n"
                },
                "updatedAt": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "id",
                        "updatedAt"
                    ]
                }
            }
        },
        "cloudflare:index/TeamsAccountExtendedEmailMatching:TeamsAccountExtendedEmailMatching": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "cloudflare:index/TeamsAccountFips:TeamsAccountFips": {
            "properties": {
                "tls": {
                    "type": "boolean",
                    "description": "Only allow FIPS-compliant TLS configuration.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountLogging:TeamsAccountLogging": {
            "properties": {
                "redactPii": {
                    "type": "boolean",
                    "description": "Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).\n"
                },
                "settingsByRuleType": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleType:TeamsAccountLoggingSettingsByRuleType",
                    "description": "Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.\n"
                }
            },
            "type": "object",
            "required": [
                "redactPii",
                "settingsByRuleType"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleType:TeamsAccountLoggingSettingsByRuleType": {
            "properties": {
                "dns": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeDns:TeamsAccountLoggingSettingsByRuleTypeDns",
                    "description": "Logging configuration for DNS requests.\n"
                },
                "http": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeHttp:TeamsAccountLoggingSettingsByRuleTypeHttp",
                    "description": "Logging configuration for HTTP requests.\n"
                },
                "l4": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeL4:TeamsAccountLoggingSettingsByRuleTypeL4",
                    "description": "Logging configuration for layer 4 requests.\n"
                }
            },
            "type": "object",
            "required": [
                "dns",
                "http",
                "l4"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeDns:TeamsAccountLoggingSettingsByRuleTypeDns": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "description": "Whether to log all activity.\n"
                },
                "logBlocks": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeHttp:TeamsAccountLoggingSettingsByRuleTypeHttp": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "description": "Whether to log all activity.\n"
                },
                "logBlocks": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeL4:TeamsAccountLoggingSettingsByRuleTypeL4": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "description": "Whether to log all activity.\n"
                },
                "logBlocks": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/TeamsAccountPayloadLog:TeamsAccountPayloadLog": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key used to encrypt matched payloads.\n"
                }
            },
            "type": "object",
            "required": [
                "publicKey"
            ]
        },
        "cloudflare:index/TeamsAccountProxy:TeamsAccountProxy": {
            "properties": {
                "disableForTime": {
                    "type": "integer",
                    "description": "Sets the time limit in seconds that a user can use an override code to bypass WARP.\n"
                },
                "rootCa": {
                    "type": "boolean",
                    "description": "Whether root ca is enabled account wide for ZT clients.\n"
                },
                "tcp": {
                    "type": "boolean",
                    "description": "Whether gateway proxy is enabled on gateway devices for TCP traffic.\n"
                },
                "udp": {
                    "type": "boolean",
                    "description": "Whether gateway proxy is enabled on gateway devices for UDP traffic.\n"
                },
                "virtualIp": {
                    "type": "boolean",
                    "description": "Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.\n"
                }
            },
            "type": "object",
            "required": [
                "disableForTime",
                "rootCa",
                "tcp",
                "udp",
                "virtualIp"
            ]
        },
        "cloudflare:index/TeamsAccountSshSessionLog:TeamsAccountSshSessionLog": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key used to encrypt ssh session.\n"
                }
            },
            "type": "object",
            "required": [
                "publicKey"
            ]
        },
        "cloudflare:index/TeamsListItemsWithDescription:TeamsListItemsWithDescription": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "description",
                "value"
            ]
        },
        "cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "network": {
                    "type": "string",
                    "description": "CIDR notation representation of the network IP.\n"
                }
            },
            "type": "object",
            "required": [
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "network"
                    ]
                }
            }
        },
        "cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings": {
            "properties": {
                "addHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Add custom headers to allowed requests in the form of key-value pairs.\n"
                },
                "allowChildBypass": {
                    "type": "boolean",
                    "description": "Allow parent MSP accounts to enable bypass their children's rules.\n"
                },
                "auditSsh": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsAuditSsh:TeamsRuleRuleSettingsAuditSsh",
                    "description": "Settings for auditing SSH usage.\n"
                },
                "bisoAdminControls": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsBisoAdminControls:TeamsRuleRuleSettingsBisoAdminControls",
                    "description": "Configure how browser isolation behaves.\n"
                },
                "blockPageEnabled": {
                    "type": "boolean",
                    "description": "Indicator of block page enablement.\n"
                },
                "blockPageReason": {
                    "type": "string",
                    "description": "The displayed reason for a user being blocked.\n"
                },
                "bypassParentRule": {
                    "type": "boolean",
                    "description": "Allow child MSP accounts to bypass their parent's rule.\n"
                },
                "checkSession": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsCheckSession:TeamsRuleRuleSettingsCheckSession",
                    "description": "Configure how session check behaves.\n"
                },
                "dnsResolvers": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsDnsResolvers:TeamsRuleRuleSettingsDnsResolvers",
                    "description": "Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.\n"
                },
                "egress": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsEgress:TeamsRuleRuleSettingsEgress",
                    "description": "Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.\n"
                },
                "ignoreCnameCategoryMatches": {
                    "type": "boolean",
                    "description": "Set to true, to ignore the category matches at CNAME domains in a response.\n"
                },
                "insecureDisableDnssecValidation": {
                    "type": "boolean",
                    "description": "Disable DNSSEC validation (must be Allow rule).\n"
                },
                "ipCategories": {
                    "type": "boolean",
                    "description": "Turns on IP category based filter on dns if the rule contains dns category checks.\n"
                },
                "l4override": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsL4override:TeamsRuleRuleSettingsL4override",
                    "description": "Settings to forward layer 4 traffic.\n"
                },
                "notificationSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsNotificationSettings:TeamsRuleRuleSettingsNotificationSettings",
                    "description": "Notification settings on a block rule.\n"
                },
                "overrideHost": {
                    "type": "string",
                    "description": "The host to override matching DNS queries with.\n"
                },
                "overrideIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IPs to override matching DNS queries with.\n"
                },
                "payloadLog": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsPayloadLog:TeamsRuleRuleSettingsPayloadLog",
                    "description": "Configure DLP Payload Logging settings for this rule.\n"
                },
                "resolveDnsThroughCloudflare": {
                    "type": "boolean",
                    "description": "Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.\n"
                },
                "untrustedCert": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsUntrustedCert:TeamsRuleRuleSettingsUntrustedCert",
                    "description": "Configure untrusted certificate settings for this rule.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsAuditSsh:TeamsRuleRuleSettingsAuditSsh": {
            "properties": {
                "commandLogging": {
                    "type": "boolean",
                    "description": "Log all SSH commands.\n"
                }
            },
            "type": "object",
            "required": [
                "commandLogging"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsBisoAdminControls:TeamsRuleRuleSettingsBisoAdminControls": {
            "properties": {
                "disableClipboardRedirection": {
                    "type": "boolean",
                    "description": "Disable clipboard redirection.\n"
                },
                "disableCopyPaste": {
                    "type": "boolean",
                    "description": "Disable copy-paste.\n"
                },
                "disableDownload": {
                    "type": "boolean",
                    "description": "Disable download.\n"
                },
                "disableKeyboard": {
                    "type": "boolean",
                    "description": "Disable keyboard usage.\n"
                },
                "disablePrinting": {
                    "type": "boolean",
                    "description": "Disable printing.\n"
                },
                "disableUpload": {
                    "type": "boolean",
                    "description": "Disable upload.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsCheckSession:TeamsRuleRuleSettingsCheckSession": {
            "properties": {
                "duration": {
                    "type": "string",
                    "description": "Configure how fresh the session needs to be to be considered valid.\n"
                },
                "enforce": {
                    "type": "boolean",
                    "description": "Enable session enforcement for this rule.\n"
                }
            },
            "type": "object",
            "required": [
                "duration",
                "enforce"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsDnsResolvers:TeamsRuleRuleSettingsDnsResolvers": {
            "properties": {
                "ipv4s": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsDnsResolversIpv4:TeamsRuleRuleSettingsDnsResolversIpv4"
                    },
                    "description": "IPv4 resolvers.\n"
                },
                "ipv6s": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsDnsResolversIpv6:TeamsRuleRuleSettingsDnsResolversIpv6"
                    },
                    "description": "IPv6 resolvers.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsDnsResolversIpv4:TeamsRuleRuleSettingsDnsResolversIpv4": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 address of the upstream resolver.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "A port number to use for the upstream resolver. Defaults to `53`.\n"
                },
                "routeThroughPrivateNetwork": {
                    "type": "boolean",
                    "description": "Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.\n"
                },
                "vnetId": {
                    "type": "string",
                    "description": "specify a virtual network for this resolver. Uses default virtual network id if omitted.\n"
                }
            },
            "type": "object",
            "required": [
                "ip"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsDnsResolversIpv6:TeamsRuleRuleSettingsDnsResolversIpv6": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 address of the upstream resolver.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "A port number to use for the upstream resolver. Defaults to `53`.\n"
                },
                "routeThroughPrivateNetwork": {
                    "type": "boolean",
                    "description": "Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.\n"
                },
                "vnetId": {
                    "type": "string",
                    "description": "specify a virtual network for this resolver. Uses default virtual network id if omitted.\n"
                }
            },
            "type": "object",
            "required": [
                "ip"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsEgress:TeamsRuleRuleSettingsEgress": {
            "properties": {
                "ipv4": {
                    "type": "string",
                    "description": "The IPv4 address to be used for egress.\n"
                },
                "ipv4Fallback": {
                    "type": "string",
                    "description": "The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.\n"
                },
                "ipv6": {
                    "type": "string",
                    "description": "The IPv6 range to be used for egress.\n"
                }
            },
            "type": "object",
            "required": [
                "ipv4",
                "ipv6"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsL4override:TeamsRuleRuleSettingsL4override": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Override IP to forward traffic to.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Override Port to forward traffic to.\n"
                }
            },
            "type": "object",
            "required": [
                "ip",
                "port"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsNotificationSettings:TeamsRuleRuleSettingsNotificationSettings": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable notification settings.\n"
                },
                "message": {
                    "type": "string",
                    "description": "Notification content.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "Support URL to show in the notification.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsPayloadLog:TeamsRuleRuleSettingsPayloadLog": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable DLP Payload Logging for this rule.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsUntrustedCert:TeamsRuleRuleSettingsUntrustedCert": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfig:TunnelConfigConfig": {
            "properties": {
                "ingressRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfigIngressRule:TunnelConfigConfigIngressRule"
                    },
                    "description": "Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = \"http_status:503\"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).\n"
                },
                "originRequest": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigOriginRequest:TunnelConfigConfigOriginRequest"
                },
                "warpRouting": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigWarpRouting:TunnelConfigConfigWarpRouting",
                    "description": "If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.\n"
                }
            },
            "type": "object",
            "required": [
                "ingressRules"
            ]
        },
        "cloudflare:index/TunnelConfigConfigIngressRule:TunnelConfigConfigIngressRule": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "description": "Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.\n"
                },
                "originRequest": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigIngressRuleOriginRequest:TunnelConfigConfigIngressRuleOriginRequest"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the incoming request. If the path matches, the request will be sent to the local service.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Name of the service to which the request will be sent.\n"
                }
            },
            "type": "object",
            "required": [
                "service"
            ]
        },
        "cloudflare:index/TunnelConfigConfigIngressRuleOriginRequest:TunnelConfigConfigIngressRuleOriginRequest": {
            "properties": {
                "access": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigIngressRuleOriginRequestAccess:TunnelConfigConfigIngressRuleOriginRequestAccess",
                    "description": "Access rules for the ingress service.\n"
                },
                "bastionMode": {
                    "type": "boolean",
                    "description": "Runs as jump host.\n"
                },
                "caPool": {
                    "type": "string",
                    "description": "Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `\"\"`.\n"
                },
                "connectTimeout": {
                    "type": "string",
                    "description": "Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.\n"
                },
                "disableChunkedEncoding": {
                    "type": "boolean",
                    "description": "Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.\n"
                },
                "http2Origin": {
                    "type": "boolean",
                    "description": "Enables HTTP/2 support for the origin connection. Defaults to `false`.\n"
                },
                "httpHostHeader": {
                    "type": "string",
                    "description": "Sets the HTTP Host header on requests sent to the local service. Defaults to `\"\"`.\n"
                },
                "ipRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfigIngressRuleOriginRequestIpRule:TunnelConfigConfigIngressRuleOriginRequestIpRule"
                    },
                    "description": "IP rules for the proxy service.\n"
                },
                "keepAliveConnections": {
                    "type": "integer",
                    "description": "Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.\n"
                },
                "keepAliveTimeout": {
                    "type": "string",
                    "description": "Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.\n"
                },
                "noHappyEyeballs": {
                    "type": "boolean",
                    "description": "Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.\n"
                },
                "noTlsVerify": {
                    "type": "boolean",
                    "description": "Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.\n"
                },
                "originServerName": {
                    "type": "string",
                    "description": "Hostname that cloudflared should expect from your origin server certificate. Defaults to `\"\"`.\n"
                },
                "proxyAddress": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.\n"
                },
                "proxyPort": {
                    "type": "integer",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.\n"
                },
                "proxyType": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `\"\"`, `socks`. Defaults to `\"\"`.\n"
                },
                "tcpKeepAlive": {
                    "type": "string",
                    "description": "The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.\n"
                },
                "tlsTimeout": {
                    "type": "string",
                    "description": "Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigIngressRuleOriginRequestAccess:TunnelConfigConfigIngressRuleOriginRequestAccess": {
            "properties": {
                "audTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Audience tags of the access rule.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the access rule is required.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Name of the team to which the access rule applies.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigIngressRuleOriginRequestIpRule:TunnelConfigConfigIngressRuleOriginRequestIpRule": {
            "properties": {
                "allow": {
                    "type": "boolean",
                    "description": "Whether to allow the IP prefix.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Ports to use within the IP rule.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "IP rule prefix.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigOriginRequest:TunnelConfigConfigOriginRequest": {
            "properties": {
                "access": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigOriginRequestAccess:TunnelConfigConfigOriginRequestAccess",
                    "description": "Access rules for the ingress service.\n"
                },
                "bastionMode": {
                    "type": "boolean",
                    "description": "Runs as jump host.\n"
                },
                "caPool": {
                    "type": "string",
                    "description": "Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `\"\"`.\n"
                },
                "connectTimeout": {
                    "type": "string",
                    "description": "Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.\n"
                },
                "disableChunkedEncoding": {
                    "type": "boolean",
                    "description": "Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.\n"
                },
                "http2Origin": {
                    "type": "boolean",
                    "description": "Enables HTTP/2 support for the origin connection. Defaults to `false`.\n"
                },
                "httpHostHeader": {
                    "type": "string",
                    "description": "Sets the HTTP Host header on requests sent to the local service. Defaults to `\"\"`.\n"
                },
                "ipRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfigOriginRequestIpRule:TunnelConfigConfigOriginRequestIpRule"
                    },
                    "description": "IP rules for the proxy service.\n"
                },
                "keepAliveConnections": {
                    "type": "integer",
                    "description": "Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.\n"
                },
                "keepAliveTimeout": {
                    "type": "string",
                    "description": "Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.\n"
                },
                "noHappyEyeballs": {
                    "type": "boolean",
                    "description": "Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.\n"
                },
                "noTlsVerify": {
                    "type": "boolean",
                    "description": "Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.\n"
                },
                "originServerName": {
                    "type": "string",
                    "description": "Hostname that cloudflared should expect from your origin server certificate. Defaults to `\"\"`.\n"
                },
                "proxyAddress": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.\n"
                },
                "proxyPort": {
                    "type": "integer",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.\n"
                },
                "proxyType": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `\"\"`, `socks`. Defaults to `\"\"`.\n"
                },
                "tcpKeepAlive": {
                    "type": "string",
                    "description": "The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.\n"
                },
                "tlsTimeout": {
                    "type": "string",
                    "description": "Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigOriginRequestAccess:TunnelConfigConfigOriginRequestAccess": {
            "properties": {
                "audTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Audience tags of the access rule.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the access rule is required.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Name of the team to which the access rule applies.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigOriginRequestIpRule:TunnelConfigConfigOriginRequestIpRule": {
            "properties": {
                "allow": {
                    "type": "boolean",
                    "description": "Whether to allow the IP prefix.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Ports to use within the IP rule.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "IP rule prefix.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigWarpRouting:TunnelConfigConfigWarpRouting": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether WARP routing is enabled.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.\n"
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/WaitingRoomAdditionalRoute:WaitingRoomAdditionalRoute": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "The additional host name for which the waiting room to be applied on (no wildcards).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the additional host to enable the waiting room on. Defaults to `/`.\n"
                }
            },
            "type": "object",
            "required": [
                "host"
            ]
        },
        "cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the waiting room rule and its intended use.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique rule identifier.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the waiting room rule.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "expression"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "expression",
                        "id",
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding": {
            "properties": {
                "dataset": {
                    "type": "string",
                    "description": "The name of the Analytics Engine dataset to write to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "dataset",
                "name"
            ]
        },
        "cloudflare:index/WorkerScriptD1DatabaseBinding:WorkerScriptD1DatabaseBinding": {
            "properties": {
                "databaseId": {
                    "type": "string",
                    "description": "Database ID of D1 database to use.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "databaseId",
                "name"
            ]
        },
        "cloudflare:index/WorkerScriptHyperdriveConfigBinding:WorkerScriptHyperdriveConfigBinding": {
            "properties": {
                "binding": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Hyperdrive config to use.\n"
                }
            },
            "type": "object",
            "required": [
                "binding",
                "id"
            ]
        },
        "cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "ID of the KV namespace you want to use.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "namespaceId"
            ]
        },
        "cloudflare:index/WorkerScriptPlacement:WorkerScriptPlacement": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The placement mode for the Worker. Available values: `smart`.\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "text": {
                    "type": "string",
                    "description": "The plain text you want to store.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkerScriptQueueBinding:WorkerScriptQueueBinding": {
            "properties": {
                "binding": {
                    "type": "string",
                    "description": "The name of the global variable for the binding in your Worker code.\n"
                },
                "queue": {
                    "type": "string",
                    "description": "Name of the queue you want to use.\n"
                }
            },
            "type": "object",
            "required": [
                "binding",
                "queue"
            ]
        },
        "cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding": {
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "The name of the Bucket to bind to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "bucketName",
                "name"
            ]
        },
        "cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "text": {
                    "type": "string",
                    "description": "The secret text you want to store.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding": {
            "properties": {
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment to bind to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "service": {
                    "type": "string",
                    "description": "The name of the Worker to bind to.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "service"
            ]
        },
        "cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding": {
            "properties": {
                "module": {
                    "type": "string",
                    "description": "The base64 encoded wasm module you want to store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "module",
                "name"
            ]
        },
        "cloudflare:index/WorkersScriptAnalyticsEngineBinding:WorkersScriptAnalyticsEngineBinding": {
            "properties": {
                "dataset": {
                    "type": "string",
                    "description": "The name of the Analytics Engine dataset to write to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "dataset",
                "name"
            ]
        },
        "cloudflare:index/WorkersScriptD1DatabaseBinding:WorkersScriptD1DatabaseBinding": {
            "properties": {
                "databaseId": {
                    "type": "string",
                    "description": "Database ID of D1 database to use.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "databaseId",
                "name"
            ]
        },
        "cloudflare:index/WorkersScriptHyperdriveConfigBinding:WorkersScriptHyperdriveConfigBinding": {
            "properties": {
                "binding": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Hyperdrive config to use.\n"
                }
            },
            "type": "object",
            "required": [
                "binding",
                "id"
            ]
        },
        "cloudflare:index/WorkersScriptKvNamespaceBinding:WorkersScriptKvNamespaceBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "ID of the KV namespace you want to use.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "namespaceId"
            ]
        },
        "cloudflare:index/WorkersScriptPlacement:WorkersScriptPlacement": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The placement mode for the Worker. Available values: `smart`.\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/WorkersScriptPlainTextBinding:WorkersScriptPlainTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "text": {
                    "type": "string",
                    "description": "The plain text you want to store.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkersScriptQueueBinding:WorkersScriptQueueBinding": {
            "properties": {
                "binding": {
                    "type": "string",
                    "description": "The name of the global variable for the binding in your Worker code.\n"
                },
                "queue": {
                    "type": "string",
                    "description": "Name of the queue you want to use.\n"
                }
            },
            "type": "object",
            "required": [
                "binding",
                "queue"
            ]
        },
        "cloudflare:index/WorkersScriptR2BucketBinding:WorkersScriptR2BucketBinding": {
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "The name of the Bucket to bind to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "bucketName",
                "name"
            ]
        },
        "cloudflare:index/WorkersScriptSecretTextBinding:WorkersScriptSecretTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "text": {
                    "type": "string",
                    "description": "The secret text you want to store.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkersScriptServiceBinding:WorkersScriptServiceBinding": {
            "properties": {
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment to bind to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "service": {
                    "type": "string",
                    "description": "The name of the Worker to bind to.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "service"
            ]
        },
        "cloudflare:index/WorkersScriptWebassemblyBinding:WorkersScriptWebassemblyBinding": {
            "properties": {
                "module": {
                    "type": "string",
                    "description": "The base64 encoded wasm module you want to store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                }
            },
            "type": "object",
            "required": [
                "module",
                "name"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationCorsHeader:ZeroTrustAccessApplicationCorsHeader": {
            "properties": {
                "allowAllHeaders": {
                    "type": "boolean",
                    "description": "Value to determine whether all HTTP headers are exposed.\n"
                },
                "allowAllMethods": {
                    "type": "boolean",
                    "description": "Value to determine whether all methods are exposed.\n"
                },
                "allowAllOrigins": {
                    "type": "boolean",
                    "description": "Value to determine whether all origins are permitted to make CORS requests.\n"
                },
                "allowCredentials": {
                    "type": "boolean",
                    "description": "Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.\n"
                },
                "allowedHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of HTTP headers to expose via CORS.\n"
                },
                "allowedMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of methods to expose via CORS.\n"
                },
                "allowedOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of origins permitted to make CORS requests.\n"
                },
                "maxAge": {
                    "type": "integer",
                    "description": "The maximum time a preflight request will be cached.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessApplicationFooterLink:ZeroTrustAccessApplicationFooterLink": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the footer link.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the footer link.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessApplicationLandingPageDesign:ZeroTrustAccessApplicationLandingPageDesign": {
            "properties": {
                "buttonColor": {
                    "type": "string",
                    "description": "The button color of the landing page.\n"
                },
                "buttonTextColor": {
                    "type": "string",
                    "description": "The button text color of the landing page.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "The URL of the image to be displayed in the landing page.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the landing page.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the landing page.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasApp:ZeroTrustAccessApplicationSaasApp": {
            "properties": {
                "accessTokenLifetime": {
                    "type": "string",
                    "description": "The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.\n"
                },
                "allowPkceWithoutClientSecret": {
                    "type": "boolean",
                    "description": "Allow PKCE flow without a client secret.\n"
                },
                "appLauncherUrl": {
                    "type": "string",
                    "description": "The URL where this applications tile redirects users.\n"
                },
                "authType": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "clientId": {
                    "type": "string",
                    "description": "The application client id.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The application client secret, only returned on initial apply.\n",
                    "secret": true
                },
                "consumerServiceUrl": {
                    "type": "string",
                    "description": "The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.\n"
                },
                "customAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomAttribute:ZeroTrustAccessApplicationSaasAppCustomAttribute"
                    },
                    "description": "Custom attribute mapped from IDPs.\n"
                },
                "customClaims": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomClaim:ZeroTrustAccessApplicationSaasAppCustomClaim"
                    },
                    "description": "Custom claim mapped from IDPs.\n"
                },
                "defaultRelayState": {
                    "type": "string",
                    "description": "The relay state used if not provided by the identity provider.\n"
                },
                "grantTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The OIDC flows supported by this application.\n"
                },
                "groupFilterRegex": {
                    "type": "string",
                    "description": "A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.\n"
                },
                "hybridAndImplicitOptions": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions:ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions",
                    "description": "Hybrid and Implicit Flow options.\n"
                },
                "idpEntityId": {
                    "type": "string",
                    "description": "The unique identifier for the SaaS application.\n"
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "The format of the name identifier sent to the SaaS application.\n"
                },
                "nameIdTransformJsonata": {
                    "type": "string",
                    "description": "A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public certificate that will be used to verify identities.\n"
                },
                "redirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.\n"
                },
                "refreshTokenOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasAppRefreshTokenOption:ZeroTrustAccessApplicationSaasAppRefreshTokenOption"
                    },
                    "description": "Refresh token grant options.\n"
                },
                "samlAttributeTransformJsonata": {
                    "type": "string",
                    "description": "A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Define the user information shared with access.\n"
                },
                "spEntityId": {
                    "type": "string",
                    "description": "A globally unique name for an identity or service provider.\n"
                },
                "ssoEndpoint": {
                    "type": "string",
                    "description": "The endpoint where the SaaS application will send login requests.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clientId",
                        "clientSecret",
                        "grantTypes",
                        "idpEntityId",
                        "publicKey",
                        "scopes",
                        "ssoEndpoint"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomAttribute:ZeroTrustAccessApplicationSaasAppCustomAttribute": {
            "properties": {
                "friendlyName": {
                    "type": "string",
                    "description": "A friendly name for the attribute as provided to the SaaS app.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided to the SaaS app.\n"
                },
                "nameFormat": {
                    "type": "string",
                    "description": "A globally unique name for an identity or service provider.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "True if the attribute must be always present.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomAttributeSource:ZeroTrustAccessApplicationSaasAppCustomAttributeSource"
                }
            },
            "type": "object",
            "required": [
                "source"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomAttributeSource:ZeroTrustAccessApplicationSaasAppCustomAttributeSource": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided by the IDP.\n"
                },
                "nameByIdp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping from IdP ID to claim name.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomClaim:ZeroTrustAccessApplicationSaasAppCustomClaim": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided to the SaaS app.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "True if the attribute must be always present.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "The scope of the claim.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomClaimSource:ZeroTrustAccessApplicationSaasAppCustomClaimSource"
                }
            },
            "type": "object",
            "required": [
                "source"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasAppCustomClaimSource:ZeroTrustAccessApplicationSaasAppCustomClaimSource": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the attribute as provided by the IDP.\n"
                },
                "nameByIdp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping from IdP ID to claim name.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions:ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions": {
            "properties": {
                "returnAccessTokenFromAuthorizationEndpoint": {
                    "type": "boolean",
                    "description": "If true, the authorization endpoint will return an access token.\n"
                },
                "returnIdTokenFromAuthorizationEndpoint": {
                    "type": "boolean",
                    "description": "If true, the authorization endpoint will return an id token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessApplicationSaasAppRefreshTokenOption:ZeroTrustAccessApplicationSaasAppRefreshTokenOption": {
            "properties": {
                "lifetime": {
                    "type": "string",
                    "description": "How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessApplicationScimConfig:ZeroTrustAccessApplicationScimConfig": {
            "properties": {
                "authentication": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationScimConfigAuthentication:ZeroTrustAccessApplicationScimConfigAuthentication",
                    "description": "Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.\n"
                },
                "deactivateOnDelete": {
                    "type": "boolean",
                    "description": "If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether SCIM provisioning is turned on for this application.\n"
                },
                "idpUid": {
                    "type": "string",
                    "description": "The UID of the IdP to use as the source for SCIM resources to provision to this application.\n"
                },
                "mappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationScimConfigMapping:ZeroTrustAccessApplicationScimConfigMapping"
                    },
                    "description": "A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.\n"
                },
                "remoteUri": {
                    "type": "string",
                    "description": "The base URI for the application's SCIM-compatible API.\n"
                }
            },
            "type": "object",
            "required": [
                "idpUid",
                "remoteUri"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationScimConfigAuthentication:ZeroTrustAccessApplicationScimConfigAuthentication": {
            "properties": {
                "authorizationUrl": {
                    "type": "string",
                    "description": "URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "The authentication scheme to use when making SCIM requests to this application.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.\n"
                },
                "user": {
                    "type": "string",
                    "description": "User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.\n"
                }
            },
            "type": "object",
            "required": [
                "scheme"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationScimConfigMapping:ZeroTrustAccessApplicationScimConfigMapping": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether or not this mapping is enabled.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.\n"
                },
                "operations": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationScimConfigMappingOperations:ZeroTrustAccessApplicationScimConfigMappingOperations",
                    "description": "Whether or not this mapping applies to creates, updates, or deletes.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Which SCIM resource type this mapping applies to.\n"
                },
                "transformJsonata": {
                    "type": "string",
                    "description": "A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.\n"
                }
            },
            "type": "object",
            "required": [
                "schema"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationScimConfigMappingOperations:ZeroTrustAccessApplicationScimConfigMappingOperations": {
            "properties": {
                "create": {
                    "type": "boolean",
                    "description": "Whether or not this mapping applies to create (POST) operations.\n"
                },
                "delete": {
                    "type": "boolean",
                    "description": "Whether or not this mapping applies to DELETE operations.\n"
                },
                "update": {
                    "type": "boolean",
                    "description": "Whether or not this mapping applies to update (PATCH/PUT) operations.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessApplicationTargetCriteria:ZeroTrustAccessApplicationTargetCriteria": {
            "properties": {
                "port": {
                    "type": "integer",
                    "description": "The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The communication protocol your application secures.\n"
                },
                "targetAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationTargetCriteriaTargetAttribute:ZeroTrustAccessApplicationTargetCriteriaTargetAttribute"
                    },
                    "description": "Contains a map of target attribute keys to target attribute values.\n"
                }
            },
            "type": "object",
            "required": [
                "port",
                "protocol",
                "targetAttributes"
            ]
        },
        "cloudflare:index/ZeroTrustAccessApplicationTargetCriteriaTargetAttribute:ZeroTrustAccessApplicationTargetCriteriaTargetAttribute": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The key of the attribute.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The values of the attribute.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "values"
            ]
        },
        "cloudflare:index/ZeroTrustAccessGroupExclude:ZeroTrustAccessGroupExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeAuthContext:ZeroTrustAccessGroupExcludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeAzure:ZeroTrustAccessGroupExcludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeExternalEvaluation:ZeroTrustAccessGroupExcludeExternalEvaluation"
                    },
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeGithub:ZeroTrustAccessGroupExcludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeGsuite:ZeroTrustAccessGroupExcludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeOkta:ZeroTrustAccessGroupExcludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExcludeSaml:ZeroTrustAccessGroupExcludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeAuthContext:ZeroTrustAccessGroupExcludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeAzure:ZeroTrustAccessGroupExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeExternalEvaluation:ZeroTrustAccessGroupExcludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeGithub:ZeroTrustAccessGroupExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeGsuite:ZeroTrustAccessGroupExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeOkta:ZeroTrustAccessGroupExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupExcludeSaml:ZeroTrustAccessGroupExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupInclude:ZeroTrustAccessGroupInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeAuthContext:ZeroTrustAccessGroupIncludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeAzure:ZeroTrustAccessGroupIncludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeExternalEvaluation:ZeroTrustAccessGroupIncludeExternalEvaluation"
                    },
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeGithub:ZeroTrustAccessGroupIncludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeGsuite:ZeroTrustAccessGroupIncludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeOkta:ZeroTrustAccessGroupIncludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupIncludeSaml:ZeroTrustAccessGroupIncludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeAuthContext:ZeroTrustAccessGroupIncludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeAzure:ZeroTrustAccessGroupIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeExternalEvaluation:ZeroTrustAccessGroupIncludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeGithub:ZeroTrustAccessGroupIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeGsuite:ZeroTrustAccessGroupIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeOkta:ZeroTrustAccessGroupIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupIncludeSaml:ZeroTrustAccessGroupIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequire:ZeroTrustAccessGroupRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireAuthContext:ZeroTrustAccessGroupRequireAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireAzure:ZeroTrustAccessGroupRequireAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireExternalEvaluation:ZeroTrustAccessGroupRequireExternalEvaluation"
                    },
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireGithub:ZeroTrustAccessGroupRequireGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireGsuite:ZeroTrustAccessGroupRequireGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireOkta:ZeroTrustAccessGroupRequireOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequireSaml:ZeroTrustAccessGroupRequireSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireAuthContext:ZeroTrustAccessGroupRequireAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireAzure:ZeroTrustAccessGroupRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireExternalEvaluation:ZeroTrustAccessGroupRequireExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireGithub:ZeroTrustAccessGroupRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireGsuite:ZeroTrustAccessGroupRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireOkta:ZeroTrustAccessGroupRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessGroupRequireSaml:ZeroTrustAccessGroupRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessIdentityProviderConfig:ZeroTrustAccessIdentityProviderConfig": {
            "properties": {
                "apiToken": {
                    "type": "string"
                },
                "appsDomain": {
                    "type": "string"
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "authUrl": {
                    "type": "string"
                },
                "authorizationServerId": {
                    "type": "string"
                },
                "centrifyAccount": {
                    "type": "string"
                },
                "centrifyAppId": {
                    "type": "string"
                },
                "certsUrl": {
                    "type": "string"
                },
                "claims": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "conditionalAccessEnabled": {
                    "type": "boolean"
                },
                "directoryId": {
                    "type": "string"
                },
                "emailAttributeName": {
                    "type": "string"
                },
                "emailClaimName": {
                    "type": "string"
                },
                "idpPublicCert": {
                    "type": "string"
                },
                "issuerUrl": {
                    "type": "string"
                },
                "oktaAccount": {
                    "type": "string"
                },
                "oneloginAccount": {
                    "type": "string"
                },
                "pingEnvId": {
                    "type": "string"
                },
                "pkceEnabled": {
                    "type": "boolean"
                },
                "redirectUrl": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "signRequest": {
                    "type": "boolean"
                },
                "ssoTargetUrl": {
                    "type": "string"
                },
                "supportGroups": {
                    "type": "boolean"
                },
                "tokenUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "attributes",
                        "claims",
                        "redirectUrl",
                        "scopes"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustAccessIdentityProviderScimConfig:ZeroTrustAccessIdentityProviderScimConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "groupMemberDeprovision": {
                    "type": "boolean"
                },
                "seatDeprovision": {
                    "type": "boolean"
                },
                "secret": {
                    "type": "string",
                    "secret": true
                },
                "userDeprovision": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "secret"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustAccessMtlsHostnameSettingsSetting:ZeroTrustAccessMtlsHostnameSettingsSetting": {
            "properties": {
                "chinaNetwork": {
                    "type": "boolean",
                    "description": "Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.\n"
                },
                "clientCertificateForwarding": {
                    "type": "boolean",
                    "description": "Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname that these settings apply to.\n"
                }
            },
            "type": "object",
            "required": [
                "hostname"
            ]
        },
        "cloudflare:index/ZeroTrustAccessOrganizationCustomPage:ZeroTrustAccessOrganizationCustomPage": {
            "properties": {
                "forbidden": {
                    "type": "string",
                    "description": "The id of the forbidden page.\n"
                },
                "identityDenied": {
                    "type": "string",
                    "description": "The id of the identity denied page.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessOrganizationLoginDesign:ZeroTrustAccessOrganizationLoginDesign": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "The background color on the login page.\n"
                },
                "footerText": {
                    "type": "string",
                    "description": "The text at the bottom of the login page.\n"
                },
                "headerText": {
                    "type": "string",
                    "description": "The text at the top of the login page.\n"
                },
                "logoPath": {
                    "type": "string",
                    "description": "The URL of the logo on the login page.\n"
                },
                "textColor": {
                    "type": "string",
                    "description": "The text color on the login page.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyApprovalGroup:ZeroTrustAccessPolicyApprovalGroup": {
            "properties": {
                "approvalsNeeded": {
                    "type": "integer",
                    "description": "Number of approvals needed.\n"
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of emails to request approval from.\n"
                },
                "emailListUuid": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "approvalsNeeded"
            ]
        },
        "cloudflare:index/ZeroTrustAccessPolicyConnectionRules:ZeroTrustAccessPolicyConnectionRules": {
            "properties": {
                "ssh": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyConnectionRulesSsh:ZeroTrustAccessPolicyConnectionRulesSsh",
                    "description": "The SSH-specific rules that define how users may connect to the targets secured by your application.\n"
                }
            },
            "type": "object",
            "required": [
                "ssh"
            ]
        },
        "cloudflare:index/ZeroTrustAccessPolicyConnectionRulesSsh:ZeroTrustAccessPolicyConnectionRulesSsh": {
            "properties": {
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Contains the Unix usernames that may be used when connecting over SSH.\n"
                }
            },
            "type": "object",
            "required": [
                "usernames"
            ]
        },
        "cloudflare:index/ZeroTrustAccessPolicyExclude:ZeroTrustAccessPolicyExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeAuthContext:ZeroTrustAccessPolicyExcludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeAzure:ZeroTrustAccessPolicyExcludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeExternalEvaluation:ZeroTrustAccessPolicyExcludeExternalEvaluation"
                    },
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeGithub:ZeroTrustAccessPolicyExcludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeGsuite:ZeroTrustAccessPolicyExcludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeOkta:ZeroTrustAccessPolicyExcludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExcludeSaml:ZeroTrustAccessPolicyExcludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeAuthContext:ZeroTrustAccessPolicyExcludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeAzure:ZeroTrustAccessPolicyExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeExternalEvaluation:ZeroTrustAccessPolicyExcludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeGithub:ZeroTrustAccessPolicyExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeGsuite:ZeroTrustAccessPolicyExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeOkta:ZeroTrustAccessPolicyExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyExcludeSaml:ZeroTrustAccessPolicyExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyInclude:ZeroTrustAccessPolicyInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeAuthContext:ZeroTrustAccessPolicyIncludeAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeAzure:ZeroTrustAccessPolicyIncludeAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeExternalEvaluation:ZeroTrustAccessPolicyIncludeExternalEvaluation"
                    },
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeGithub:ZeroTrustAccessPolicyIncludeGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeGsuite:ZeroTrustAccessPolicyIncludeGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeOkta:ZeroTrustAccessPolicyIncludeOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyIncludeSaml:ZeroTrustAccessPolicyIncludeSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeAuthContext:ZeroTrustAccessPolicyIncludeAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeAzure:ZeroTrustAccessPolicyIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeExternalEvaluation:ZeroTrustAccessPolicyIncludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeGithub:ZeroTrustAccessPolicyIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeGsuite:ZeroTrustAccessPolicyIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeOkta:ZeroTrustAccessPolicyIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyIncludeSaml:ZeroTrustAccessPolicyIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequire:ZeroTrustAccessPolicyRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "description": "Matches any valid Access service token.\n"
                },
                "authContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireAuthContext:ZeroTrustAccessPolicyRequireAuthContext"
                    }
                },
                "authMethod": {
                    "type": "string",
                    "description": "The type of authentication method. Refer to https://datatracker.ietf.org/doc/html/rfc8176#section-2 for possible types.\n"
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireAzure:ZeroTrustAccessPolicyRequireAzure"
                    },
                    "description": "Matches an Azure group. Requires an Azure identity provider.\n"
                },
                "certificate": {
                    "type": "boolean",
                    "description": "Matches any valid client certificate.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Matches a valid client certificate common name.\n"
                },
                "commonNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.\n"
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a device posture integration.\n"
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email domain to match.\n"
                },
                "emailLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created email list.\n"
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the user.\n"
                },
                "everyone": {
                    "type": "boolean",
                    "description": "Matches everyone.\n"
                },
                "externalEvaluations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireExternalEvaluation:ZeroTrustAccessPolicyRequireExternalEvaluation"
                    },
                    "description": "Create Allow or Block policies which evaluate the user based on custom criteria. https://developers.cloudflare.com/cloudflare-one/policies/access/external-evaluation/.\n"
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Matches a specific country.\n"
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireGithub:ZeroTrustAccessPolicyRequireGithub"
                    },
                    "description": "Matches a Github organization. Requires a Github identity provider.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created Access group.\n"
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireGsuite:ZeroTrustAccessPolicyRequireGsuite"
                    },
                    "description": "Matches a group in Google Workspace. Requires a Google Workspace identity provider.\n"
                },
                "ipLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a previously created IP list.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IPv4 or IPv6 CIDR block.\n"
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of a configured identity provider.\n"
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireOkta:ZeroTrustAccessPolicyRequireOkta"
                    },
                    "description": "Matches an Okta group. Requires an Okta identity provider.\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequireSaml:ZeroTrustAccessPolicyRequireSaml"
                    },
                    "description": "Matches a SAML group. Requires a SAML identity provider.\n"
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of an Access service token.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireAuthContext:ZeroTrustAccessPolicyRequireAuthContext": {
            "properties": {
                "acId": {
                    "type": "string",
                    "description": "The ACID of the Authentication Context.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the Authentication Context.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                }
            },
            "type": "object",
            "required": [
                "acId",
                "id",
                "identityProviderId"
            ]
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireAzure:ZeroTrustAccessPolicyRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of the Azure identity provider.\n"
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of the Azure group or user.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireExternalEvaluation:ZeroTrustAccessPolicyRequireExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "description": "The API endpoint containing your business logic.\n"
                },
                "keysUrl": {
                    "type": "string",
                    "description": "The API endpoint containing the key that Access uses to verify that the response came from your API.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireGithub:ZeroTrustAccessPolicyRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Github identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The teams that should be matched.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireGsuite:ZeroTrustAccessPolicyRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The email of the Google Workspace group.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Google Workspace identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireOkta:ZeroTrustAccessPolicyRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your Okta identity provider.\n"
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The name of the Okta Group.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustAccessPolicyRequireSaml:ZeroTrustAccessPolicyRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The SAML attribute value to look for.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "The ID of your SAML identity provider.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustDeviceManagedNetworksConfig:ZeroTrustDeviceManagedNetworksConfig": {
            "properties": {
                "sha256": {
                    "type": "string",
                    "description": "The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.\n"
                },
                "tlsSockaddr": {
                    "type": "string",
                    "description": "A network address of the form \"host:port\" that the WARP client will use to detect the presence of a TLS host.\n"
                }
            },
            "type": "object",
            "required": [
                "sha256",
                "tlsSockaddr"
            ]
        },
        "cloudflare:index/ZeroTrustDevicePostureIntegrationConfig:ZeroTrustDevicePostureIntegrationConfig": {
            "properties": {
                "accessClientId": {
                    "type": "string",
                    "description": "The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.\n",
                    "secret": true
                },
                "accessClientSecret": {
                    "type": "string",
                    "description": "The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.\n",
                    "secret": true
                },
                "apiUrl": {
                    "type": "string",
                    "description": "The third-party API's URL.\n"
                },
                "authUrl": {
                    "type": "string",
                    "description": "The third-party authorization API URL.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client identifier for authenticating API calls.\n"
                },
                "clientKey": {
                    "type": "string",
                    "description": "The client key for authenticating API calls.\n",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for authenticating API calls.\n",
                    "secret": true
                },
                "customerId": {
                    "type": "string",
                    "description": "The customer identifier for authenticating API calls.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustDevicePostureRuleInput:ZeroTrustDevicePostureRuleInput": {
            "properties": {
                "activeThreats": {
                    "type": "integer",
                    "description": "The number of active threats from SentinelOne.\n"
                },
                "certificateId": {
                    "type": "string",
                    "description": "The UUID of a Cloudflare managed certificate.\n"
                },
                "checkDisks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specific volume(s) to check for encryption.\n"
                },
                "checkPrivateKey": {
                    "type": "boolean",
                    "description": "Confirm the certificate was not imported from another device.\n"
                },
                "cn": {
                    "type": "string",
                    "description": "The common name for a certificate.\n"
                },
                "complianceStatus": {
                    "type": "string",
                    "description": "The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.\n"
                },
                "connectionId": {
                    "type": "string",
                    "description": "The workspace one or intune connection id.\n"
                },
                "countOperator": {
                    "type": "string",
                    "description": "The count comparison operator for kolide. Available values: `\u003e`, `\u003e=`, `\u003c`, `\u003c=`, `==`.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain that the client must join.\n"
                },
                "eidLastSeen": {
                    "type": "string",
                    "description": "The time a device last seen in Tanium. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if the firewall must be enabled.\n"
                },
                "exists": {
                    "type": "boolean",
                    "description": "Checks if the file should exist.\n"
                },
                "extendedKeyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The Teams List id. Required for `serial_number` and `unique_client_id` rule types.\n"
                },
                "infected": {
                    "type": "boolean",
                    "description": "True if SentinelOne device is infected.\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "True if SentinelOne device is active.\n"
                },
                "issueCount": {
                    "type": "string",
                    "description": "The number of issues for kolide.\n"
                },
                "lastSeen": {
                    "type": "string",
                    "description": "The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.\n"
                },
                "locations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleInputLocation:ZeroTrustDevicePostureRuleInputLocation"
                    },
                    "description": "List of operating system locations to check for a client certificate..\n"
                },
                "networkStatus": {
                    "type": "string",
                    "description": "The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "The current operational state of a SentinelOne Agent. Available values: `na`, `partially_disabled`, `auto_fully_disabled`, `fully_disabled`, `auto_partially_disabled`, `disabled_error`, `db_corruption`.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The version comparison operator. Available values: `\u003e`, `\u003e=`, `\u003c`, `\u003c=`, `==`.\n"
                },
                "os": {
                    "type": "string",
                    "description": "OS signal score from Crowdstrike. Value must be between 1 and 100.\n"
                },
                "osDistroName": {
                    "type": "string",
                    "description": "The operating system excluding version information.\n"
                },
                "osDistroRevision": {
                    "type": "string",
                    "description": "The operating system version excluding OS name information or release name.\n"
                },
                "osVersionExtra": {
                    "type": "string",
                    "description": "Extra version value following the operating system semantic version.\n"
                },
                "overall": {
                    "type": "string",
                    "description": "Overall ZTA score from Crowdstrike. Value must be between 1 and 100.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to the file.\n"
                },
                "requireAll": {
                    "type": "boolean",
                    "description": "True if all drives must be encrypted.\n"
                },
                "riskLevel": {
                    "type": "string",
                    "description": "The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.\n"
                },
                "running": {
                    "type": "boolean",
                    "description": "Checks if the application should be running.\n"
                },
                "score": {
                    "type": "integer",
                    "description": "A value between 0-100 assigned to devices set by the 3rd party posture provider for custom device posture integrations.\n"
                },
                "sensorConfig": {
                    "type": "string",
                    "description": "Sensor signal score from Crowdstrike. Value must be between 1 and 100.\n"
                },
                "sha256": {
                    "type": "string",
                    "description": "The sha256 hash of the file.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The hosts current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "The thumbprint of the file certificate.\n"
                },
                "totalScore": {
                    "type": "integer",
                    "description": "The total score from Tanium.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The operating system semantic version.\n"
                },
                "versionOperator": {
                    "type": "string",
                    "description": "The version comparison operator for Crowdstrike. Available values: `\u003e`, `\u003e=`, `\u003c`, `\u003c=`, `==`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "exists",
                        "infected",
                        "isActive",
                        "requireAll",
                        "running"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustDevicePostureRuleInputLocation:ZeroTrustDevicePostureRuleInputLocation": {
            "properties": {
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of paths to check for client certificate rule.\n"
                },
                "trustStores": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of trust stores to check for client certificate rule. Available values: `system`, `user`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustDevicePostureRuleMatch:ZeroTrustDevicePostureRuleMatch": {
            "properties": {
                "platform": {
                    "type": "string",
                    "description": "The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustDexTestData:ZeroTrustDexTestData": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The type of Device Dex Test. Available values: `http`, `traceroute`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The http request method. Available values: `GET`.\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "kind"
            ]
        },
        "cloudflare:index/ZeroTrustDlpProfileContextAwareness:ZeroTrustDlpProfileContextAwareness": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                },
                "skip": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileContextAwarenessSkip:ZeroTrustDlpProfileContextAwarenessSkip",
                    "description": "Content types to exclude from context analysis and return all matches.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "skip"
            ]
        },
        "cloudflare:index/ZeroTrustDlpProfileContextAwarenessSkip:ZeroTrustDlpProfileContextAwarenessSkip": {
            "properties": {
                "files": {
                    "type": "boolean",
                    "description": "Return all matches, regardless of context analysis result, if the data is a file.\n"
                }
            },
            "type": "object",
            "required": [
                "files"
            ]
        },
        "cloudflare:index/ZeroTrustDlpProfileEntry:ZeroTrustDlpProfileEntry": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the entry is active. Defaults to `false`.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique entry identifier.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the entry to deploy.\n"
                },
                "pattern": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileEntryPattern:ZeroTrustDlpProfileEntryPattern"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustDlpProfileEntryPattern:ZeroTrustDlpProfileEntryPattern": {
            "properties": {
                "regex": {
                    "type": "string",
                    "description": "The regex that defines the pattern.\n"
                },
                "validation": {
                    "type": "string",
                    "description": "The validation algorithm to apply with this pattern.\n"
                }
            },
            "type": "object",
            "required": [
                "regex"
            ]
        },
        "cloudflare:index/ZeroTrustDnsLocationNetwork:ZeroTrustDnsLocationNetwork": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "network": {
                    "type": "string",
                    "description": "CIDR notation representation of the network IP.\n"
                }
            },
            "type": "object",
            "required": [
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "network"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettings:ZeroTrustGatewayPolicyRuleSettings": {
            "properties": {
                "addHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Add custom headers to allowed requests in the form of key-value pairs.\n"
                },
                "allowChildBypass": {
                    "type": "boolean",
                    "description": "Allow parent MSP accounts to enable bypass their children's rules.\n"
                },
                "auditSsh": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsAuditSsh:ZeroTrustGatewayPolicyRuleSettingsAuditSsh",
                    "description": "Settings for auditing SSH usage.\n"
                },
                "bisoAdminControls": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls:ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls",
                    "description": "Configure how browser isolation behaves.\n"
                },
                "blockPageEnabled": {
                    "type": "boolean",
                    "description": "Indicator of block page enablement.\n"
                },
                "blockPageReason": {
                    "type": "string",
                    "description": "The displayed reason for a user being blocked.\n"
                },
                "bypassParentRule": {
                    "type": "boolean",
                    "description": "Allow child MSP accounts to bypass their parent's rule.\n"
                },
                "checkSession": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsCheckSession:ZeroTrustGatewayPolicyRuleSettingsCheckSession",
                    "description": "Configure how session check behaves.\n"
                },
                "dnsResolvers": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsDnsResolvers:ZeroTrustGatewayPolicyRuleSettingsDnsResolvers",
                    "description": "Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.\n"
                },
                "egress": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsEgress:ZeroTrustGatewayPolicyRuleSettingsEgress",
                    "description": "Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.\n"
                },
                "ignoreCnameCategoryMatches": {
                    "type": "boolean",
                    "description": "Set to true, to ignore the category matches at CNAME domains in a response.\n"
                },
                "insecureDisableDnssecValidation": {
                    "type": "boolean",
                    "description": "Disable DNSSEC validation (must be Allow rule).\n"
                },
                "ipCategories": {
                    "type": "boolean",
                    "description": "Turns on IP category based filter on dns if the rule contains dns category checks.\n"
                },
                "l4override": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsL4override:ZeroTrustGatewayPolicyRuleSettingsL4override",
                    "description": "Settings to forward layer 4 traffic.\n"
                },
                "notificationSettings": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsNotificationSettings:ZeroTrustGatewayPolicyRuleSettingsNotificationSettings",
                    "description": "Notification settings on a block rule.\n"
                },
                "overrideHost": {
                    "type": "string",
                    "description": "The host to override matching DNS queries with.\n"
                },
                "overrideIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IPs to override matching DNS queries with.\n"
                },
                "payloadLog": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsPayloadLog:ZeroTrustGatewayPolicyRuleSettingsPayloadLog",
                    "description": "Configure DLP Payload Logging settings for this rule.\n"
                },
                "resolveDnsThroughCloudflare": {
                    "type": "boolean",
                    "description": "Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.\n"
                },
                "untrustedCert": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsUntrustedCert:ZeroTrustGatewayPolicyRuleSettingsUntrustedCert",
                    "description": "Configure untrusted certificate settings for this rule.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsAuditSsh:ZeroTrustGatewayPolicyRuleSettingsAuditSsh": {
            "properties": {
                "commandLogging": {
                    "type": "boolean",
                    "description": "Log all SSH commands.\n"
                }
            },
            "type": "object",
            "required": [
                "commandLogging"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls:ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls": {
            "properties": {
                "disableClipboardRedirection": {
                    "type": "boolean",
                    "description": "Disable clipboard redirection.\n"
                },
                "disableCopyPaste": {
                    "type": "boolean",
                    "description": "Disable copy-paste.\n"
                },
                "disableDownload": {
                    "type": "boolean",
                    "description": "Disable download.\n"
                },
                "disableKeyboard": {
                    "type": "boolean",
                    "description": "Disable keyboard usage.\n"
                },
                "disablePrinting": {
                    "type": "boolean",
                    "description": "Disable printing.\n"
                },
                "disableUpload": {
                    "type": "boolean",
                    "description": "Disable upload.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsCheckSession:ZeroTrustGatewayPolicyRuleSettingsCheckSession": {
            "properties": {
                "duration": {
                    "type": "string",
                    "description": "Configure how fresh the session needs to be to be considered valid.\n"
                },
                "enforce": {
                    "type": "boolean",
                    "description": "Enable session enforcement for this rule.\n"
                }
            },
            "type": "object",
            "required": [
                "duration",
                "enforce"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsDnsResolvers:ZeroTrustGatewayPolicyRuleSettingsDnsResolvers": {
            "properties": {
                "ipv4s": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4:ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4"
                    },
                    "description": "IPv4 resolvers.\n"
                },
                "ipv6s": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6:ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6"
                    },
                    "description": "IPv6 resolvers.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4:ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 address of the upstream resolver.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "A port number to use for the upstream resolver. Defaults to `53`.\n"
                },
                "routeThroughPrivateNetwork": {
                    "type": "boolean",
                    "description": "Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.\n"
                },
                "vnetId": {
                    "type": "string",
                    "description": "specify a virtual network for this resolver. Uses default virtual network id if omitted.\n"
                }
            },
            "type": "object",
            "required": [
                "ip"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6:ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 address of the upstream resolver.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "A port number to use for the upstream resolver. Defaults to `53`.\n"
                },
                "routeThroughPrivateNetwork": {
                    "type": "boolean",
                    "description": "Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.\n"
                },
                "vnetId": {
                    "type": "string",
                    "description": "specify a virtual network for this resolver. Uses default virtual network id if omitted.\n"
                }
            },
            "type": "object",
            "required": [
                "ip"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsEgress:ZeroTrustGatewayPolicyRuleSettingsEgress": {
            "properties": {
                "ipv4": {
                    "type": "string",
                    "description": "The IPv4 address to be used for egress.\n"
                },
                "ipv4Fallback": {
                    "type": "string",
                    "description": "The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.\n"
                },
                "ipv6": {
                    "type": "string",
                    "description": "The IPv6 range to be used for egress.\n"
                }
            },
            "type": "object",
            "required": [
                "ipv4",
                "ipv6"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsL4override:ZeroTrustGatewayPolicyRuleSettingsL4override": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Override IP to forward traffic to.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Override Port to forward traffic to.\n"
                }
            },
            "type": "object",
            "required": [
                "ip",
                "port"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsNotificationSettings:ZeroTrustGatewayPolicyRuleSettingsNotificationSettings": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable notification settings.\n"
                },
                "message": {
                    "type": "string",
                    "description": "Notification content.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "Support URL to show in the notification.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsPayloadLog:ZeroTrustGatewayPolicyRuleSettingsPayloadLog": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable DLP Payload Logging for this rule.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "cloudflare:index/ZeroTrustGatewayPolicyRuleSettingsUntrustedCert:ZeroTrustGatewayPolicyRuleSettingsUntrustedCert": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewaySettingsAntivirus:ZeroTrustGatewaySettingsAntivirus": {
            "properties": {
                "enabledDownloadPhase": {
                    "type": "boolean",
                    "description": "Scan on file download.\n"
                },
                "enabledUploadPhase": {
                    "type": "boolean",
                    "description": "Scan on file upload.\n"
                },
                "failClosed": {
                    "type": "boolean",
                    "description": "Block requests for files that cannot be scanned.\n"
                },
                "notificationSettings": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsAntivirusNotificationSettings:ZeroTrustGatewaySettingsAntivirusNotificationSettings",
                    "description": "Set notifications for antivirus.\n"
                }
            },
            "type": "object",
            "required": [
                "enabledDownloadPhase",
                "enabledUploadPhase",
                "failClosed"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsAntivirusNotificationSettings:ZeroTrustGatewaySettingsAntivirusNotificationSettings": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable notification settings.\n"
                },
                "message": {
                    "type": "string",
                    "description": "Notification content.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "Support URL to show in the notification.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewaySettingsBlockPage:ZeroTrustGatewaySettingsBlockPage": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "Hex code of block page background color.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of enablement.\n"
                },
                "footerText": {
                    "type": "string",
                    "description": "Block page footer text.\n"
                },
                "headerText": {
                    "type": "string",
                    "description": "Block page header text.\n"
                },
                "logoPath": {
                    "type": "string",
                    "description": "URL of block page logo.\n"
                },
                "mailtoAddress": {
                    "type": "string",
                    "description": "Admin email for users to contact.\n"
                },
                "mailtoSubject": {
                    "type": "string",
                    "description": "Subject line for emails created from block page.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of block page configuration.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewaySettingsBodyScanning:ZeroTrustGatewaySettingsBodyScanning": {
            "properties": {
                "inspectionMode": {
                    "type": "string",
                    "description": "Body scanning inspection mode. Available values: `deep`, `shallow`.\n"
                }
            },
            "type": "object",
            "required": [
                "inspectionMode"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsCertificate:ZeroTrustGatewaySettingsCertificate": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of certificate for TLS interception.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsCustomCertificate:ZeroTrustGatewaySettingsCustomCertificate": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether TLS encryption should use a custom certificate.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of custom certificate.\n"
                },
                "updatedAt": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "id",
                        "updatedAt"
                    ]
                }
            }
        },
        "cloudflare:index/ZeroTrustGatewaySettingsExtendedEmailMatching:ZeroTrustGatewaySettingsExtendedEmailMatching": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsFips:ZeroTrustGatewaySettingsFips": {
            "properties": {
                "tls": {
                    "type": "boolean",
                    "description": "Only allow FIPS-compliant TLS configuration.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustGatewaySettingsLogging:ZeroTrustGatewaySettingsLogging": {
            "properties": {
                "redactPii": {
                    "type": "boolean",
                    "description": "Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).\n"
                },
                "settingsByRuleType": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleType:ZeroTrustGatewaySettingsLoggingSettingsByRuleType",
                    "description": "Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.\n"
                }
            },
            "type": "object",
            "required": [
                "redactPii",
                "settingsByRuleType"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleType:ZeroTrustGatewaySettingsLoggingSettingsByRuleType": {
            "properties": {
                "dns": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns:ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns",
                    "description": "Logging configuration for DNS requests.\n"
                },
                "http": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp:ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp",
                    "description": "Logging configuration for HTTP requests.\n"
                },
                "l4": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4:ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4",
                    "description": "Logging configuration for layer 4 requests.\n"
                }
            },
            "type": "object",
            "required": [
                "dns",
                "http",
                "l4"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns:ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "description": "Whether to log all activity.\n"
                },
                "logBlocks": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp:ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "description": "Whether to log all activity.\n"
                },
                "logBlocks": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4:ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "description": "Whether to log all activity.\n"
                },
                "logBlocks": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsPayloadLog:ZeroTrustGatewaySettingsPayloadLog": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key used to encrypt matched payloads.\n"
                }
            },
            "type": "object",
            "required": [
                "publicKey"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsProxy:ZeroTrustGatewaySettingsProxy": {
            "properties": {
                "disableForTime": {
                    "type": "integer",
                    "description": "Sets the time limit in seconds that a user can use an override code to bypass WARP.\n"
                },
                "rootCa": {
                    "type": "boolean",
                    "description": "Whether root ca is enabled account wide for ZT clients.\n"
                },
                "tcp": {
                    "type": "boolean",
                    "description": "Whether gateway proxy is enabled on gateway devices for TCP traffic.\n"
                },
                "udp": {
                    "type": "boolean",
                    "description": "Whether gateway proxy is enabled on gateway devices for UDP traffic.\n"
                },
                "virtualIp": {
                    "type": "boolean",
                    "description": "Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.\n"
                }
            },
            "type": "object",
            "required": [
                "disableForTime",
                "rootCa",
                "tcp",
                "udp",
                "virtualIp"
            ]
        },
        "cloudflare:index/ZeroTrustGatewaySettingsSshSessionLog:ZeroTrustGatewaySettingsSshSessionLog": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key used to encrypt ssh session.\n"
                }
            },
            "type": "object",
            "required": [
                "publicKey"
            ]
        },
        "cloudflare:index/ZeroTrustInfrastructureAccessTargetIp:ZeroTrustInfrastructureAccessTargetIp": {
            "properties": {
                "ipv4": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustInfrastructureAccessTargetIpIpv4:ZeroTrustInfrastructureAccessTargetIpIpv4",
                    "description": "The target's IPv4 address.\n"
                },
                "ipv6": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustInfrastructureAccessTargetIpIpv6:ZeroTrustInfrastructureAccessTargetIpIpv6",
                    "description": "The target's IPv6 address.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustInfrastructureAccessTargetIpIpv4:ZeroTrustInfrastructureAccessTargetIpIpv4": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ]
        },
        "cloudflare:index/ZeroTrustInfrastructureAccessTargetIpIpv6:ZeroTrustInfrastructureAccessTargetIpIpv6": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ]
        },
        "cloudflare:index/ZeroTrustListItemsWithDescription:ZeroTrustListItemsWithDescription": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "description",
                "value"
            ]
        },
        "cloudflare:index/ZeroTrustLocalFallbackDomainDomain:ZeroTrustLocalFallbackDomainDomain": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description of the fallback domain, displayed in the client UI.\n"
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses to handle domain resolution.\n"
                },
                "suffix": {
                    "type": "string",
                    "description": "The domain suffix to match when resolving locally.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustRiskBehaviorBehavior:ZeroTrustRiskBehaviorBehavior": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether this risk behavior type is enabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of this risk behavior type\n"
                },
                "riskLevel": {
                    "type": "string",
                    "description": "Risk level. Available values: `low`, `medium`, `high`\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "name",
                "riskLevel"
            ]
        },
        "cloudflare:index/ZeroTrustSplitTunnelTunnel:ZeroTrustSplitTunnelTunnel": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address for the tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tunnel.\n"
                },
                "host": {
                    "type": "string",
                    "description": "The domain name for the tunnel.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfig:ZeroTrustTunnelCloudflaredConfigConfig": {
            "properties": {
                "ingressRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRule:ZeroTrustTunnelCloudflaredConfigConfigIngressRule"
                    },
                    "description": "Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = \"http_status:503\"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).\n"
                },
                "originRequest": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigOriginRequest:ZeroTrustTunnelCloudflaredConfigConfigOriginRequest"
                },
                "warpRouting": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigWarpRouting:ZeroTrustTunnelCloudflaredConfigConfigWarpRouting",
                    "description": "If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.\n"
                }
            },
            "type": "object",
            "required": [
                "ingressRules"
            ]
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRule:ZeroTrustTunnelCloudflaredConfigConfigIngressRule": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "description": "Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.\n"
                },
                "originRequest": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest:ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the incoming request. If the path matches, the request will be sent to the local service.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Name of the service to which the request will be sent.\n"
                }
            },
            "type": "object",
            "required": [
                "service"
            ]
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest:ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest": {
            "properties": {
                "access": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess:ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess",
                    "description": "Access rules for the ingress service.\n"
                },
                "bastionMode": {
                    "type": "boolean",
                    "description": "Runs as jump host.\n"
                },
                "caPool": {
                    "type": "string",
                    "description": "Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `\"\"`.\n"
                },
                "connectTimeout": {
                    "type": "string",
                    "description": "Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.\n"
                },
                "disableChunkedEncoding": {
                    "type": "boolean",
                    "description": "Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.\n"
                },
                "http2Origin": {
                    "type": "boolean",
                    "description": "Enables HTTP/2 support for the origin connection. Defaults to `false`.\n"
                },
                "httpHostHeader": {
                    "type": "string",
                    "description": "Sets the HTTP Host header on requests sent to the local service. Defaults to `\"\"`.\n"
                },
                "ipRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule:ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule"
                    },
                    "description": "IP rules for the proxy service.\n"
                },
                "keepAliveConnections": {
                    "type": "integer",
                    "description": "Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.\n"
                },
                "keepAliveTimeout": {
                    "type": "string",
                    "description": "Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.\n"
                },
                "noHappyEyeballs": {
                    "type": "boolean",
                    "description": "Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.\n"
                },
                "noTlsVerify": {
                    "type": "boolean",
                    "description": "Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.\n"
                },
                "originServerName": {
                    "type": "string",
                    "description": "Hostname that cloudflared should expect from your origin server certificate. Defaults to `\"\"`.\n"
                },
                "proxyAddress": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.\n"
                },
                "proxyPort": {
                    "type": "integer",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.\n"
                },
                "proxyType": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `\"\"`, `socks`. Defaults to `\"\"`.\n"
                },
                "tcpKeepAlive": {
                    "type": "string",
                    "description": "The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.\n"
                },
                "tlsTimeout": {
                    "type": "string",
                    "description": "Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess:ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess": {
            "properties": {
                "audTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Audience tags of the access rule.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the access rule is required.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Name of the team to which the access rule applies.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule:ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule": {
            "properties": {
                "allow": {
                    "type": "boolean",
                    "description": "Whether to allow the IP prefix.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Ports to use within the IP rule.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "IP rule prefix.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigOriginRequest:ZeroTrustTunnelCloudflaredConfigConfigOriginRequest": {
            "properties": {
                "access": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess:ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess",
                    "description": "Access rules for the ingress service.\n"
                },
                "bastionMode": {
                    "type": "boolean",
                    "description": "Runs as jump host.\n"
                },
                "caPool": {
                    "type": "string",
                    "description": "Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `\"\"`.\n"
                },
                "connectTimeout": {
                    "type": "string",
                    "description": "Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.\n"
                },
                "disableChunkedEncoding": {
                    "type": "boolean",
                    "description": "Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.\n"
                },
                "http2Origin": {
                    "type": "boolean",
                    "description": "Enables HTTP/2 support for the origin connection. Defaults to `false`.\n"
                },
                "httpHostHeader": {
                    "type": "string",
                    "description": "Sets the HTTP Host header on requests sent to the local service. Defaults to `\"\"`.\n"
                },
                "ipRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule:ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule"
                    },
                    "description": "IP rules for the proxy service.\n"
                },
                "keepAliveConnections": {
                    "type": "integer",
                    "description": "Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.\n"
                },
                "keepAliveTimeout": {
                    "type": "string",
                    "description": "Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.\n"
                },
                "noHappyEyeballs": {
                    "type": "boolean",
                    "description": "Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.\n"
                },
                "noTlsVerify": {
                    "type": "boolean",
                    "description": "Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.\n"
                },
                "originServerName": {
                    "type": "string",
                    "description": "Hostname that cloudflared should expect from your origin server certificate. Defaults to `\"\"`.\n"
                },
                "proxyAddress": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.\n"
                },
                "proxyPort": {
                    "type": "integer",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.\n"
                },
                "proxyType": {
                    "type": "string",
                    "description": "cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `\"\"`, `socks`. Defaults to `\"\"`.\n"
                },
                "tcpKeepAlive": {
                    "type": "string",
                    "description": "The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.\n"
                },
                "tlsTimeout": {
                    "type": "string",
                    "description": "Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess:ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess": {
            "properties": {
                "audTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Audience tags of the access rule.\n"
                },
                "required": {
                    "type": "boolean",
                    "description": "Whether the access rule is required.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Name of the team to which the access rule applies.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule:ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule": {
            "properties": {
                "allow": {
                    "type": "boolean",
                    "description": "Whether to allow the IP prefix.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Ports to use within the IP rule.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "IP rule prefix.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfigWarpRouting:ZeroTrustTunnelCloudflaredConfigConfigWarpRouting": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether WARP routing is enabled.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Available values: `ip`, `ip_range`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.\n"
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting": {
            "properties": {
                "alwaysOnline": {
                    "type": "string"
                },
                "alwaysUseHttps": {
                    "type": "string"
                },
                "automaticHttpsRewrites": {
                    "type": "string"
                },
                "binaryAst": {
                    "type": "string"
                },
                "brotli": {
                    "type": "string"
                },
                "browserCacheTtl": {
                    "type": "integer"
                },
                "browserCheck": {
                    "type": "string"
                },
                "cacheLevel": {
                    "type": "string"
                },
                "challengeTtl": {
                    "type": "integer"
                },
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "cnameFlattening": {
                    "type": "string"
                },
                "developmentMode": {
                    "type": "string"
                },
                "earlyHints": {
                    "type": "string"
                },
                "emailObfuscation": {
                    "type": "string"
                },
                "filterLogsToCloudflare": {
                    "type": "string"
                },
                "fonts": {
                    "type": "string"
                },
                "h2Prioritization": {
                    "type": "string"
                },
                "hotlinkProtection": {
                    "type": "string"
                },
                "http2": {
                    "type": "string"
                },
                "http3": {
                    "type": "string"
                },
                "imageResizing": {
                    "type": "string"
                },
                "ipGeolocation": {
                    "type": "string"
                },
                "ipv6": {
                    "type": "string"
                },
                "logToCloudflare": {
                    "type": "string"
                },
                "maxUpload": {
                    "type": "integer"
                },
                "minTlsVersion": {
                    "type": "string"
                },
                "minify": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingMinify:ZoneSettingsOverrideInitialSettingMinify"
                },
                "mirage": {
                    "type": "string"
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingMobileRedirect:ZoneSettingsOverrideInitialSettingMobileRedirect",
                    "deprecationMessage": "Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects."
                },
                "nel": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingNel:ZoneSettingsOverrideInitialSettingNel"
                },
                "opportunisticEncryption": {
                    "type": "string"
                },
                "opportunisticOnion": {
                    "type": "string"
                },
                "orangeToOrange": {
                    "type": "string"
                },
                "originErrorPagePassThru": {
                    "type": "string"
                },
                "originMaxHttpVersion": {
                    "type": "string"
                },
                "polish": {
                    "type": "string"
                },
                "prefetchPreload": {
                    "type": "string"
                },
                "privacyPass": {
                    "type": "string"
                },
                "proxyReadTimeout": {
                    "type": "string"
                },
                "pseudoIpv4": {
                    "type": "string"
                },
                "replaceInsecureJs": {
                    "type": "string"
                },
                "responseBuffering": {
                    "type": "string"
                },
                "rocketLoader": {
                    "type": "string"
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingSecurityHeader:ZoneSettingsOverrideInitialSettingSecurityHeader"
                },
                "securityLevel": {
                    "type": "string"
                },
                "serverSideExclude": {
                    "type": "string"
                },
                "sortQueryStringForCache": {
                    "type": "string"
                },
                "speedBrain": {
                    "type": "string"
                },
                "ssl": {
                    "type": "string"
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead."
                },
                "tls13": {
                    "type": "string"
                },
                "tlsClientAuth": {
                    "type": "string"
                },
                "trueClientIpHeader": {
                    "type": "string"
                },
                "universalSsl": {
                    "type": "string"
                },
                "visitorIp": {
                    "type": "string"
                },
                "waf": {
                    "type": "string"
                },
                "webp": {
                    "type": "string"
                },
                "websockets": {
                    "type": "string"
                },
                "zeroRtt": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "binaryAst",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "ciphers",
                        "cnameFlattening",
                        "developmentMode",
                        "earlyHints",
                        "emailObfuscation",
                        "filterLogsToCloudflare",
                        "fonts",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "logToCloudflare",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "nel",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "orangeToOrange",
                        "originErrorPagePassThru",
                        "originMaxHttpVersion",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "proxyReadTimeout",
                        "pseudoIpv4",
                        "replaceInsecureJs",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "speedBrain",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "visitorIp",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingMinify:ZoneSettingsOverrideInitialSettingMinify": {
            "properties": {
                "css": {
                    "type": "string"
                },
                "html": {
                    "type": "string"
                },
                "js": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingMobileRedirect:ZoneSettingsOverrideInitialSettingMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "stripUri": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingNel:ZoneSettingsOverrideInitialSettingNel": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingSecurityHeader:ZoneSettingsOverrideInitialSettingSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "includeSubdomains": {
                    "type": "boolean"
                },
                "maxAge": {
                    "type": "integer"
                },
                "nosniff": {
                    "type": "boolean"
                },
                "preload": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings": {
            "properties": {
                "alwaysOnline": {
                    "type": "string"
                },
                "alwaysUseHttps": {
                    "type": "string"
                },
                "automaticHttpsRewrites": {
                    "type": "string"
                },
                "binaryAst": {
                    "type": "string"
                },
                "brotli": {
                    "type": "string"
                },
                "browserCacheTtl": {
                    "type": "integer"
                },
                "browserCheck": {
                    "type": "string"
                },
                "cacheLevel": {
                    "type": "string"
                },
                "challengeTtl": {
                    "type": "integer"
                },
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "cnameFlattening": {
                    "type": "string"
                },
                "developmentMode": {
                    "type": "string"
                },
                "earlyHints": {
                    "type": "string"
                },
                "emailObfuscation": {
                    "type": "string"
                },
                "filterLogsToCloudflare": {
                    "type": "string"
                },
                "fonts": {
                    "type": "string"
                },
                "h2Prioritization": {
                    "type": "string"
                },
                "hotlinkProtection": {
                    "type": "string"
                },
                "http2": {
                    "type": "string"
                },
                "http3": {
                    "type": "string"
                },
                "imageResizing": {
                    "type": "string"
                },
                "ipGeolocation": {
                    "type": "string"
                },
                "ipv6": {
                    "type": "string"
                },
                "logToCloudflare": {
                    "type": "string"
                },
                "maxUpload": {
                    "type": "integer"
                },
                "minTlsVersion": {
                    "type": "string"
                },
                "minify": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify"
                },
                "mirage": {
                    "type": "string"
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect",
                    "deprecationMessage": "Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects."
                },
                "nel": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsNel:ZoneSettingsOverrideSettingsNel"
                },
                "opportunisticEncryption": {
                    "type": "string"
                },
                "opportunisticOnion": {
                    "type": "string"
                },
                "orangeToOrange": {
                    "type": "string"
                },
                "originErrorPagePassThru": {
                    "type": "string"
                },
                "originMaxHttpVersion": {
                    "type": "string"
                },
                "polish": {
                    "type": "string"
                },
                "prefetchPreload": {
                    "type": "string"
                },
                "privacyPass": {
                    "type": "string"
                },
                "proxyReadTimeout": {
                    "type": "string"
                },
                "pseudoIpv4": {
                    "type": "string"
                },
                "replaceInsecureJs": {
                    "type": "string"
                },
                "responseBuffering": {
                    "type": "string"
                },
                "rocketLoader": {
                    "type": "string"
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader"
                },
                "securityLevel": {
                    "type": "string"
                },
                "serverSideExclude": {
                    "type": "string"
                },
                "sortQueryStringForCache": {
                    "type": "string"
                },
                "speedBrain": {
                    "type": "string"
                },
                "ssl": {
                    "type": "string"
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead."
                },
                "tls13": {
                    "type": "string"
                },
                "tlsClientAuth": {
                    "type": "string"
                },
                "trueClientIpHeader": {
                    "type": "string"
                },
                "universalSsl": {
                    "type": "string"
                },
                "visitorIp": {
                    "type": "string"
                },
                "waf": {
                    "type": "string"
                },
                "webp": {
                    "type": "string"
                },
                "websockets": {
                    "type": "string"
                },
                "zeroRtt": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "binaryAst",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "ciphers",
                        "cnameFlattening",
                        "developmentMode",
                        "earlyHints",
                        "emailObfuscation",
                        "filterLogsToCloudflare",
                        "fonts",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "logToCloudflare",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "nel",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "orangeToOrange",
                        "originErrorPagePassThru",
                        "originMaxHttpVersion",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "proxyReadTimeout",
                        "pseudoIpv4",
                        "replaceInsecureJs",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "speedBrain",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "visitorIp",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify": {
            "properties": {
                "css": {
                    "type": "string"
                },
                "html": {
                    "type": "string"
                },
                "js": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "stripUri": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsNel:ZoneSettingsOverrideSettingsNel": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "includeSubdomains": {
                    "type": "boolean"
                },
                "maxAge": {
                    "type": "integer"
                },
                "nosniff": {
                    "type": "boolean"
                },
                "preload": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:index/getAccountRolesRole:getAccountRolesRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of role's permissions.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Role identifier tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Role Name.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getAccountsAccount:getAccountsAccount": {
            "properties": {
                "enforceTwofactor": {
                    "type": "boolean",
                    "description": "Whether 2FA is enforced on the account.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Account ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Account name.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Account subscription type.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getDevicePostureRulesRule:getDevicePostureRulesRule": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the Device Posture Rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getDevicesDevice:getDevicesDevice": {
            "properties": {
                "created": {
                    "type": "string",
                    "description": "When the device was created.\n"
                },
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the device has been deleted.\n"
                },
                "deviceType": {
                    "type": "string",
                    "description": "The type of the device.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Device ID.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IPv4 or IPv6 address.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The device's public key.\n"
                },
                "lastSeen": {
                    "type": "string",
                    "description": "When the device was last seen.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The device's MAC address.\n"
                },
                "manufacturer": {
                    "type": "string",
                    "description": "The device manufacturer's name.\n"
                },
                "model": {
                    "type": "string",
                    "description": "The device model name.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The device name.\n"
                },
                "osDistroName": {
                    "type": "string",
                    "description": "The Linux distribution name.\n"
                },
                "osDistroRevision": {
                    "type": "string",
                    "description": "The Linux distribution revision.\n"
                },
                "osVersion": {
                    "type": "string",
                    "description": "The operating system version.\n"
                },
                "osVersionExtra": {
                    "type": "string",
                    "description": "Extra version value following the operating system version.\n"
                },
                "revokedAt": {
                    "type": "string",
                    "description": "When the device was revoked.\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "The device's serial number.\n"
                },
                "updated": {
                    "type": "string",
                    "description": "When the device was updated.\n"
                },
                "userEmail": {
                    "type": "string",
                    "description": "User's email.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "User's ID.\n"
                },
                "userName": {
                    "type": "string",
                    "description": "User's Name.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The WARP client version.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getDlpDatasetsDataset:getDlpDatasetsDataset": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "secret": {
                    "type": "boolean"
                },
                "status": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "description",
                "id",
                "name",
                "secret",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getGatewayAppTypesAppType:getGatewayAppTypesAppType": {
            "properties": {
                "applicationTypeId": {
                    "type": "integer",
                    "description": "The identifier for the application type of this app.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A short summary of the app type.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The identifier for this app type. There is only one app type per ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the app type.\n"
                }
            },
            "type": "object",
            "required": [
                "applicationTypeId",
                "description",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getGatewayCategoriesCategory:getGatewayCategoriesCategory": {
            "properties": {
                "beta": {
                    "type": "boolean",
                    "description": "True if the category is in beta and subject to change.\n"
                },
                "class": {
                    "type": "string",
                    "description": "Which account types are allowed to create policies based on this category.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A short summary of domains in the category.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The identifier for this category. There is only one category per ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                },
                "subcategories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getGatewayCategoriesCategorySubcategory:getGatewayCategoriesCategorySubcategory"
                    },
                    "description": "A list of subcategories.\n"
                }
            },
            "type": "object",
            "required": [
                "beta",
                "class",
                "description",
                "id",
                "name",
                "subcategories"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getGatewayCategoriesCategorySubcategory:getGatewayCategoriesCategorySubcategory": {
            "properties": {
                "beta": {
                    "type": "boolean",
                    "description": "True if the subcategory is in beta and subject to change.\n"
                },
                "class": {
                    "type": "string",
                    "description": "Which account types are allowed to create policies based on this subcategory.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A short summary of domains in the subcategory.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The identifier for this subcategory. There is only one subcategory per ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the subcategory.\n"
                }
            },
            "type": "object",
            "required": [
                "beta",
                "class",
                "description",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getInfrastructureAccessTargetsTarget:getInfrastructureAccessTargetsTarget": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The date and time at which the target was created.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A non-unique field that refers to a target.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The identifier of this resource. This is target's unique identifier.\n"
                },
                "ip": {
                    "$ref": "#/types/cloudflare:index/getInfrastructureAccessTargetsTargetIp:getInfrastructureAccessTargetsTargetIp",
                    "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                },
                "modifiedAt": {
                    "type": "string",
                    "description": "The date and time at which the target was last modified.\n"
                }
            },
            "type": "object",
            "required": [
                "accountId",
                "createdAt",
                "hostname",
                "id",
                "ip",
                "modifiedAt"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getInfrastructureAccessTargetsTargetIp:getInfrastructureAccessTargetsTargetIp": {
            "properties": {
                "ipv4": {
                    "$ref": "#/types/cloudflare:index/getInfrastructureAccessTargetsTargetIpIpv4:getInfrastructureAccessTargetsTargetIpIpv4",
                    "description": "The target's IPv4 address.\n"
                },
                "ipv6": {
                    "$ref": "#/types/cloudflare:index/getInfrastructureAccessTargetsTargetIpIpv6:getInfrastructureAccessTargetsTargetIpIpv6",
                    "description": "The target's IPv6 address.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getInfrastructureAccessTargetsTargetIpIpv4:getInfrastructureAccessTargetsTargetIpIpv4": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getInfrastructureAccessTargetsTargetIpIpv6:getInfrastructureAccessTargetsTargetIpIpv6": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getListsList:getListsList": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "List description.\n"
                },
                "id": {
                    "type": "string",
                    "description": "List identifier.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "List kind.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The list name to target for the resource.\n"
                },
                "numitems": {
                    "type": "integer",
                    "description": "Number of items in list.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getLoadBalancerPoolsFilter:getLoadBalancerPoolsFilter": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the Load Balancer pool to lookup.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getLoadBalancerPoolsPool:getLoadBalancerPoolsPool": {
            "properties": {
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief description of the Load Balancer Pool intention.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID for this load balancer pool.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Latitude this pool is physically located at; used for proximity steering.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPoolLoadShedding:getLoadBalancerPoolsPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Longitude this pool is physically located at; used for proximity steering.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "Minimum number of origins that must be healthy for this pool to serve traffic.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Short name (tag) for the pool.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "Email address to send health status notifications to. Multiple emails are set as a comma delimited list.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPoolOrigin:getLoadBalancerPoolsPoolOrigin"
                    },
                    "description": "The list of origins within this pool.\n"
                }
            },
            "type": "object",
            "required": [
                "checkRegions",
                "createdOn",
                "description",
                "enabled",
                "id",
                "latitude",
                "loadSheddings",
                "longitude",
                "minimumOrigins",
                "modifiedOn",
                "monitor",
                "name",
                "notificationEmail",
                "origins"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getLoadBalancerPoolsPoolLoadShedding:getLoadBalancerPoolsPoolLoadShedding": {
            "properties": {
                "defaultPercent": {
                    "type": "number",
                    "description": "Percent of traffic to shed 0 - 100.\n"
                },
                "defaultPolicy": {
                    "type": "string",
                    "description": "Method of shedding traffic. Available values: `\"\"`, `hash`, `random`\n"
                },
                "sessionPercent": {
                    "type": "number",
                    "description": "Percent of session traffic to shed 0 - 100.\n"
                },
                "sessionPolicy": {
                    "type": "string",
                    "description": "Method of shedding traffic. Available values: `\"\"`, `hash`\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getLoadBalancerPoolsPoolOrigin:getLoadBalancerPoolsPoolOrigin": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPoolOriginHeader:getLoadBalancerPoolsPoolOriginHeader"
                    },
                    "description": "HTTP request headers.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.\n"
                },
                "weight": {
                    "type": "number",
                    "description": "The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy=\"least_outstanding_requests\"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy=\"least_connections\"`, weight is used to scale the origin's open connections.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "name"
            ]
        },
        "cloudflare:index/getLoadBalancerPoolsPoolOriginHeader:getLoadBalancerPoolsPoolOriginHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "HTTP Header name.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Values for the HTTP headers.\n"
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/getRulesetsFilter:getRulesetsFilter": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of the Ruleset to target.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset to filter on.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRuleset:getRulesetsRuleset": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset and its intended use.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the ruleset.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset. Available values: `custom`, `managed`, `root`, `zone`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset executes. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRule:getRulesetsRulesetRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "kind",
                "name",
                "phase",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRule:getRulesetsRulesetRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`\n"
                },
                "actionParameters": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParameters:getRulesetsRulesetRuleActionParameters",
                    "description": "List of parameters that configure the behavior of the ruleset rule action.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset rule and its intended use.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the rule is active.\n"
                },
                "exposedCredentialCheck": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleExposedCredentialCheck:getRulesetsRulesetRuleExposedCredentialCheck",
                    "description": "List of parameters that configure exposed credential checks.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique rule identifier.\n"
                },
                "lastUpdated": {
                    "type": "string",
                    "description": "The most recent update to this rule.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleLogging:getRulesetsRulesetRuleLogging",
                    "description": "List parameters to configure how the rule generates logs.\n"
                },
                "ratelimit": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleRatelimit:getRulesetsRulesetRuleRatelimit",
                    "description": "List of parameters that configure HTTP rate limiting behaviour.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Rule reference.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset to deploy.\n"
                }
            },
            "type": "object",
            "required": [
                "expression",
                "id",
                "ref",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParameters:getRulesetsRulesetRuleActionParameters": {
            "properties": {
                "additionalCacheablePorts": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Allows for the ability to support caching on non-standard ports.\n"
                },
                "automaticHttpsRewrites": {
                    "type": "boolean",
                    "description": "Turn on or off Cloudflare Automatic HTTPS rewrites.\n"
                },
                "autominifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersAutominify:getRulesetsRulesetRuleActionParametersAutominify"
                    },
                    "description": "Indicate which file extensions to minify automatically.\n"
                },
                "bic": {
                    "type": "boolean",
                    "description": "Inspect the visitor's browser for headers commonly associated with spammers and certain bots.\n"
                },
                "browserTtl": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersBrowserTtl:getRulesetsRulesetRuleActionParametersBrowserTtl",
                    "description": "List of browser TTL parameters to apply to the request.\n"
                },
                "cache": {
                    "type": "boolean",
                    "description": "Whether to cache if expression matches.\n"
                },
                "cacheKey": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKey:getRulesetsRulesetRuleActionParametersCacheKey",
                    "description": "List of cache key parameters to apply to the request.\n"
                },
                "cacheReserve": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheReserve:getRulesetsRulesetRuleActionParametersCacheReserve",
                    "description": "List of cache reserve parameters to apply to the request.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Content of the custom error response\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "Content-Type of the custom error response\n"
                },
                "cookieFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cookie values to include as part of custom fields logging.\n"
                },
                "disableApps": {
                    "type": "boolean",
                    "description": "Turn off all active Cloudflare Apps.\n"
                },
                "disableRailgun": {
                    "type": "boolean",
                    "description": "Turn off railgun feature of the Cloudflare Speed app.\n"
                },
                "disableZaraz": {
                    "type": "boolean",
                    "description": "Turn off zaraz feature.\n"
                },
                "edgeTtl": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersEdgeTtl:getRulesetsRulesetRuleActionParametersEdgeTtl",
                    "description": "List of edge TTL parameters to apply to the request.\n"
                },
                "emailObfuscation": {
                    "type": "boolean",
                    "description": "Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.\n"
                },
                "fromList": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersFromList:getRulesetsRulesetRuleActionParametersFromList",
                    "description": "Use a list to lookup information for the action.\n"
                },
                "fromValue": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersFromValue:getRulesetsRulesetRuleActionParametersFromValue",
                    "description": "Use a value to lookup information for the action.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersHeader:getRulesetsRulesetRuleActionParametersHeader"
                    },
                    "description": "List of HTTP header modifications to perform in the ruleset rule.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Host Header that request origin receives.\n"
                },
                "hotlinkProtection": {
                    "type": "boolean",
                    "description": "Turn on or off the hotlink protection feature.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Identifier of the action parameter to modify.\n"
                },
                "increment": {
                    "type": "integer"
                },
                "matchedData": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersMatchedData:getRulesetsRulesetRuleActionParametersMatchedData",
                    "description": "List of properties to configure WAF payload logging.\n"
                },
                "mirage": {
                    "type": "boolean",
                    "description": "Turn on or off Cloudflare Mirage of the Cloudflare Speed app.\n"
                },
                "opportunisticEncryption": {
                    "type": "boolean",
                    "description": "Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.\n"
                },
                "origin": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersOrigin:getRulesetsRulesetRuleActionParametersOrigin",
                    "description": "List of properties to change request origin.\n"
                },
                "originCacheControl": {
                    "type": "boolean",
                    "description": "Sets a more compliant mode for parsing Cache Control headers\n"
                },
                "originErrorPagePassthru": {
                    "type": "boolean",
                    "description": "Pass-through error page for origin.\n"
                },
                "overrides": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersOverrides:getRulesetsRulesetRuleActionParametersOverrides",
                    "description": "List of override configurations to apply to the ruleset.\n"
                },
                "phases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`\n"
                },
                "polish": {
                    "type": "string",
                    "description": "Apply options from the Polish feature of the Cloudflare Speed app.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`\n"
                },
                "readTimeout": {
                    "type": "integer",
                    "description": "Sets the timeout value for reading content from an origin server.\n"
                },
                "requestFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of request headers to include as part of custom fields logging, in lowercase.\n"
                },
                "respectStrongEtags": {
                    "type": "boolean",
                    "description": "Respect strong ETags.\n"
                },
                "responseFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of response headers to include as part of custom fields logging, in lowercase.\n"
                },
                "responses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersResponse:getRulesetsRulesetRuleActionParametersResponse"
                    },
                    "description": "List of parameters that configure the response given to end users\n"
                },
                "rocketLoader": {
                    "type": "boolean",
                    "description": "Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.\n"
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { \"efb7b8c949ac4650a09736fc376e9aee\" = \"5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760\" }`\n"
                },
                "ruleset": {
                    "type": "string",
                    "description": "Which ruleset ID to target.\n"
                },
                "rulesets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed WAF rule IDs to target. Only valid when the `\"action\"` is set to skip\n"
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Control options for the Security Level feature from the Security app.\n"
                },
                "serveStale": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersServeStale:getRulesetsRulesetRuleActionParametersServeStale",
                    "description": "List of serve stale parameters to apply to the request.\n"
                },
                "serverSideExcludes": {
                    "type": "boolean",
                    "description": "Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.\n"
                },
                "sni": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersSni:getRulesetsRulesetRuleActionParametersSni",
                    "description": "List of properties to manange Server Name Indication.\n"
                },
                "ssl": {
                    "type": "string",
                    "description": "Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "HTTP status code of the custom error response\n"
                },
                "sxg": {
                    "type": "boolean",
                    "description": "Turn on or off the SXG feature.\n"
                },
                "uri": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersUri:getRulesetsRulesetRuleActionParametersUri",
                    "description": "List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset to deploy.\n"
                }
            },
            "type": "object",
            "required": [
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersAutominify:getRulesetsRulesetRuleActionParametersAutominify": {
            "properties": {
                "css": {
                    "type": "boolean",
                    "description": "SSL minification.\n"
                },
                "html": {
                    "type": "boolean",
                    "description": "HTML minification.\n"
                },
                "js": {
                    "type": "boolean",
                    "description": "JS minification.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersBrowserTtl:getRulesetsRulesetRuleActionParametersBrowserTtl": {
            "properties": {
                "default": {
                    "type": "integer",
                    "description": "Default browser TTL.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the browser TTL.\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKey:getRulesetsRulesetRuleActionParametersCacheKey": {
            "properties": {
                "cacheByDeviceType": {
                    "type": "boolean",
                    "description": "Cache by device type. Conflicts with \"custom_key.user.device_type\".\n"
                },
                "cacheDeceptionArmor": {
                    "type": "boolean",
                    "description": "Cache deception armor.\n"
                },
                "customKey": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKey:getRulesetsRulesetRuleActionParametersCacheKeyCustomKey",
                    "description": "Custom key parameters for the request.\n"
                },
                "ignoreQueryStringsOrder": {
                    "type": "boolean",
                    "description": "Ignore query strings order.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKey:getRulesetsRulesetRuleActionParametersCacheKeyCustomKey": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie",
                    "description": "Cookie parameters for the custom key.\n"
                },
                "header": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader",
                    "description": "Header parameters for the custom key.\n"
                },
                "host": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost",
                    "description": "Host parameters for the custom key.\n"
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString",
                    "description": "Query string parameters for the custom key.\n"
                },
                "user": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser",
                    "description": "User parameters for the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cookies to check for presence in the custom key.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cookies to include in the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to check for presence in the custom key.\n"
                },
                "contains": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Dictionary of headers mapping to lists of values to check for presence in the custom key.\n"
                },
                "excludeOrigin": {
                    "type": "boolean",
                    "description": "Exclude the origin header from the custom key.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of headers to include in the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "description": "Resolve hostname to IP address.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of query string parameters to exclude from the custom key. Conflicts with \"include\".\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of query string parameters to include in the custom key. Conflicts with \"exclude\".\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser:getRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "description": "Add device type to the custom key. Conflicts with \"cache_key.cache_by_device_type\".\n"
                },
                "geo": {
                    "type": "boolean",
                    "description": "Add geo data to the custom key.\n"
                },
                "lang": {
                    "type": "boolean",
                    "description": "Add language data to the custom key.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersCacheReserve:getRulesetsRulesetRuleActionParametersCacheReserve": {
            "properties": {
                "eligible": {
                    "type": "boolean",
                    "description": "Determines whether Cloudflare will write the eligible resource to cache reserve.\n"
                },
                "minimumFileSize": {
                    "type": "integer",
                    "description": "The minimum file size, in bytes, eligible for storage in cache reserve. If omitted and \"eligible\" is true, Cloudflare will use 0 bytes by default.\n"
                }
            },
            "type": "object",
            "required": [
                "eligible"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersEdgeTtl:getRulesetsRulesetRuleActionParametersEdgeTtl": {
            "properties": {
                "default": {
                    "type": "integer",
                    "description": "Default edge TTL\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the edge TTL.\n"
                },
                "statusCodeTtls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl:getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl"
                    },
                    "description": "Edge TTL for the status codes.\n"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl:getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "description": "Status code for which the edge TTL is applied. Conflicts with \"status_code_range\".\n"
                },
                "statusCodeRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange:getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange"
                    },
                    "description": "Status code range for which the edge TTL is applied. Conflicts with \"status_code\".\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Status code edge TTL value.\n"
                }
            },
            "type": "object",
            "required": [
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange:getRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange": {
            "properties": {
                "from": {
                    "type": "integer",
                    "description": "From status code.\n"
                },
                "to": {
                    "type": "integer",
                    "description": "To status code.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersFromList:getRulesetsRulesetRuleActionParametersFromList": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Expression to use for the list lookup.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the list.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersFromValue:getRulesetsRulesetRuleActionParametersFromValue": {
            "properties": {
                "preserveQueryString": {
                    "type": "boolean",
                    "description": "Preserve query string for redirect URL.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "Status code for redirect.\n"
                },
                "targetUrl": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersFromValueTargetUrl:getRulesetsRulesetRuleActionParametersFromValueTargetUrl",
                    "description": "Target URL for redirect.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersFromValueTargetUrl:getRulesetsRulesetRuleActionParametersFromValueTargetUrl": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `\"value\"`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static value to provide as the HTTP request header value. Conflicts with `\"expression\"`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersHeader:getRulesetsRulesetRuleActionParametersHeader": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `\"value\"`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP request header to target.\n"
                },
                "operation": {
                    "type": "string",
                    "description": "Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static value to provide as the HTTP request header value. Conflicts with `\"expression\"`.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersMatchedData:getRulesetsRulesetRuleActionParametersMatchedData": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure)\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersOrigin:getRulesetsRulesetRuleActionParametersOrigin": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Origin Hostname where request is sent.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Origin Port where request is sent.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersOverrides:getRulesetsRulesetRuleActionParametersOverrides": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`\n"
                },
                "categories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersOverridesCategory:getRulesetsRulesetRuleActionParametersOverridesCategory"
                    },
                    "description": "List of tag-based overrides.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current ruleset-level override enables or disables the ruleset.\n",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration."
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersOverridesRule:getRulesetsRulesetRuleActionParametersOverridesRule"
                    },
                    "description": "List of rule-based overrides.\n"
                },
                "sensitivityLevel": {
                    "type": "string",
                    "description": "Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`\n"
                },
                "status": {
                    "type": "string",
                    "description": "Defines if the current ruleset-level override enables or disables the ruleset. Available values: `enabled`, `disabled`\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersOverridesCategory:getRulesetsRulesetRuleActionParametersOverridesCategory": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`\n"
                },
                "category": {
                    "type": "string",
                    "description": "Tag name to apply the ruleset rule override to.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.\n",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration."
                },
                "status": {
                    "type": "string",
                    "description": "Defines if the current tag-level override enables or disables the ruleset rules with the specified tag. Available values: `enabled`, `disabled`\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersOverridesRule:getRulesetsRulesetRuleActionParametersOverridesRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current rule-level override enables or disables the rule.\n",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration."
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "scoreThreshold": {
                    "type": "integer",
                    "description": "Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.\n"
                },
                "sensitivityLevel": {
                    "type": "string",
                    "description": "Sensitivity level for a ruleset rule override.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Defines if the current rule-level override enables or disables the rule. Available values: `enabled`, `disabled`\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersResponse:getRulesetsRulesetRuleActionParametersResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Body content to include in the response.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "HTTP content type to send in the response.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "HTTP status code to send in the response.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersServeStale:getRulesetsRulesetRuleActionParametersServeStale": {
            "properties": {
                "disableStaleWhileUpdating": {
                    "type": "boolean",
                    "description": "Disable stale while updating.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersSni:getRulesetsRulesetRuleActionParametersSni": {
            "properties": {
                "value": {
                    "type": "string",
                    "description": "Value to define for SNI.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersUri:getRulesetsRulesetRuleActionParametersUri": {
            "properties": {
                "origin": {
                    "type": "boolean"
                },
                "path": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersUriPath:getRulesetsRulesetRuleActionParametersUriPath",
                    "description": "URI path configuration when performing a URL rewrite.\n"
                },
                "query": {
                    "$ref": "#/types/cloudflare:index/getRulesetsRulesetRuleActionParametersUriQuery:getRulesetsRulesetRuleActionParametersUriQuery",
                    "description": "Query string configuration when performing a URL rewrite.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersUriPath:getRulesetsRulesetRuleActionParametersUriPath": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleActionParametersUriQuery:getRulesetsRulesetRuleActionParametersUriQuery": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions\n"
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleExposedCredentialCheck:getRulesetsRulesetRuleExposedCredentialCheck": {
            "properties": {
                "passwordExpression": {
                    "type": "string",
                    "description": "Firewall Rules expression language based on Wireshark display filters for where to check for the \"password\" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).\n"
                },
                "usernameExpression": {
                    "type": "string",
                    "description": "Firewall Rules expression language based on Wireshark display filters for where to check for the \"username\" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleLogging:getRulesetsRulesetRuleLogging": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Override the default logging behavior when a rule is matched.\n",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration."
                },
                "status": {
                    "type": "string",
                    "description": "Override the default logging behavior when a rule is matched. Available values: `enabled`, `disabled`\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getRulesetsRulesetRuleRatelimit:getRulesetsRulesetRuleRatelimit": {
            "properties": {
                "characteristics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of parameters that define how Cloudflare tracks the request rate for this rule.\n"
                },
                "countingExpression": {
                    "type": "string",
                    "description": "Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n"
                },
                "mitigationTimeout": {
                    "type": "integer",
                    "description": "Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The period of time to consider (in seconds) when evaluating the request rate.\n"
                },
                "requestsPerPeriod": {
                    "type": "integer",
                    "description": "The number of requests over the period of time that will trigger the Rate Limiting rule.\n"
                },
                "requestsToOrigin": {
                    "type": "boolean",
                    "description": "Whether to include requests to origin within the Rate Limiting count.\n"
                },
                "scorePerPeriod": {
                    "type": "integer",
                    "description": "The maximum aggregate score over the period of time that will trigger Rate Limiting rule.\n"
                },
                "scoreResponseHeaderName": {
                    "type": "string",
                    "description": "Name of HTTP header in the response, set by the origin server, with the score for the current request.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZeroTrustInfrastructureAccessTargetsTarget:getZeroTrustInfrastructureAccessTargetsTarget": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The date and time at which the target was created.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A non-unique field that refers to a target.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The identifier of this resource. This is target's unique identifier.\n"
                },
                "ip": {
                    "$ref": "#/types/cloudflare:index/getZeroTrustInfrastructureAccessTargetsTargetIp:getZeroTrustInfrastructureAccessTargetsTargetIp",
                    "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                },
                "modifiedAt": {
                    "type": "string",
                    "description": "The date and time at which the target was last modified.\n"
                }
            },
            "type": "object",
            "required": [
                "accountId",
                "createdAt",
                "hostname",
                "id",
                "ip",
                "modifiedAt"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getZeroTrustInfrastructureAccessTargetsTargetIp:getZeroTrustInfrastructureAccessTargetsTargetIp": {
            "properties": {
                "ipv4": {
                    "$ref": "#/types/cloudflare:index/getZeroTrustInfrastructureAccessTargetsTargetIpIpv4:getZeroTrustInfrastructureAccessTargetsTargetIpIpv4",
                    "description": "The target's IPv4 address.\n"
                },
                "ipv6": {
                    "$ref": "#/types/cloudflare:index/getZeroTrustInfrastructureAccessTargetsTargetIpIpv6:getZeroTrustInfrastructureAccessTargetsTargetIpIpv6",
                    "description": "The target's IPv6 address.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZeroTrustInfrastructureAccessTargetsTargetIpIpv4:getZeroTrustInfrastructureAccessTargetsTargetIpIpv4": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getZeroTrustInfrastructureAccessTargetsTargetIpIpv6:getZeroTrustInfrastructureAccessTargetsTargetIpIpv6": {
            "properties": {
                "ipAddr": {
                    "type": "string",
                    "description": "The IP address of the target.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The private virtual network identifier for the target.\n"
                }
            },
            "type": "object",
            "required": [
                "ipAddr",
                "virtualNetworkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getZonesFilter:getZonesFilter": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "lookupType": {
                    "type": "string",
                    "description": "The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.\n"
                },
                "match": {
                    "type": "string",
                    "description": "A RE2 compatible regular expression to filter the\tresults. This is performed client side whereas the `name` and `lookup_type`\tare performed on the Cloudflare server side.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A string value to search for.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Paused status of the zone to lookup. Defaults to `false`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone to lookup.\n"
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZonesZone:getZonesZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The zone ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Zone name.\n"
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the cloudflare package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_BASE_PATH`\nenvironment variable.\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger). Alternatively, can be configured using\nthe `CLOUDFLARE_API_CLIENT_LOGGING` environment variable.\n"
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_HOSTNAME`\nenvironment variable.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations. Alternatively, can be configured using the `CLOUDFLARE_API_KEY` environment variable. API\nkeys are [now considered legacy by\nCloudflare](https://developers.cloudflare.com/fundamentals/api/get-started/keys/#limitations), API tokens should be used\ninstead. Must provide only one of `api_key`, `api_token`, `api_user_service_key`.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations. Alternatively, can be configured using the `CLOUDFLARE_API_TOKEN` environment variable.\nMust provide only one of `api_key`, `api_token`, `api_user_service_key`.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints. Alternatively, can be configured using the\n`CLOUDFLARE_API_USER_SERVICE_KEY` environment variable. Must provide only one of `api_key`, `api_token`,\n`api_user_service_key`.\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address. Alternatively, can be configured using the `CLOUDFLARE_EMAIL` environment\nvariable. Required when using `api_key`. Conflicts with `api_token`.\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MAX_BACKOFF` environment variable.\n"
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MIN_BACKOFF` environment variable.\n"
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails. Alternatively, can be configured using the\n`CLOUDFLARE_RETRIES` environment variable.\n"
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API. Alternatively, can be configured using the `CLOUDFLARE_RPS` environment\nvariable.\n"
            },
            "userAgentOperatorSuffix": {
                "type": "string"
            }
        },
        "inputProperties": {
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_BASE_PATH`\nenvironment variable.\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger). Alternatively, can be configured using\nthe `CLOUDFLARE_API_CLIENT_LOGGING` environment variable.\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_HOSTNAME`\nenvironment variable.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations. Alternatively, can be configured using the `CLOUDFLARE_API_KEY` environment variable. API\nkeys are [now considered legacy by\nCloudflare](https://developers.cloudflare.com/fundamentals/api/get-started/keys/#limitations), API tokens should be used\ninstead. Must provide only one of `api_key`, `api_token`, `api_user_service_key`.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations. Alternatively, can be configured using the `CLOUDFLARE_API_TOKEN` environment variable.\nMust provide only one of `api_key`, `api_token`, `api_user_service_key`.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints. Alternatively, can be configured using the\n`CLOUDFLARE_API_USER_SERVICE_KEY` environment variable. Must provide only one of `api_key`, `api_token`,\n`api_user_service_key`.\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address. Alternatively, can be configured using the `CLOUDFLARE_EMAIL` environment\nvariable. Required when using `api_key`. Conflicts with `api_token`.\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MAX_BACKOFF` environment variable.\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MIN_BACKOFF` environment variable.\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails. Alternatively, can be configured using the\n`CLOUDFLARE_RETRIES` environment variable.\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API. Alternatively, can be configured using the `CLOUDFLARE_RPS` environment\nvariable.\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            },
            "userAgentOperatorSuffix": {
                "type": "string"
            }
        }
    },
    "resources": {
        "cloudflare:index/accessApplication:AccessApplication": {
            "description": "Provides a Cloudflare Access Application resource. Access\nApplications are used to restrict access to a whole application using an\nauthorisation gateway managed by Cloudflare.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/accessApplication:AccessApplication example \u003caccount_id\u003e/\u003capplication_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherLogoUrl": {
                    "type": "string",
                    "description": "The logo URL of the app launcher.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the application.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                },
                "bgColor": {
                    "type": "string",
                    "description": "The background color of the app launcher.\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via identity based rules.\n"
                },
                "customNonIdentityDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via non identity rules.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The custom pages selected for the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "footerLinks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationFooterLink:AccessApplicationFooterLink"
                    },
                    "description": "The footer links of the app launcher.\n"
                },
                "headerBgColor": {
                    "type": "string",
                    "description": "The background color of the header bar in the app launcher.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean",
                    "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                },
                "landingPageDesign": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationLandingPageDesign:AccessApplicationLandingPageDesign",
                    "description": "The landing page design of the app launcher.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "optionsPreflightBypass": {
                    "type": "boolean",
                    "description": "Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.\n"
                },
                "saasApp": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp",
                    "description": "SaaS configuration for the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string",
                    "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                },
                "scimConfig": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationScimConfig:AccessApplicationScimConfig",
                    "description": "Configuration for provisioning to this application via SCIM. This is currently in closed beta.\n"
                },
                "selfHostedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.\n"
                },
                "serviceAuth401Redirect": {
                    "type": "boolean",
                    "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                },
                "skipAppLauncherLoginPage": {
                    "type": "boolean",
                    "description": "Option to skip the App Launcher landing page. Defaults to `false`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean",
                    "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The itags associated with the application.\n"
                },
                "targetCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationTargetCriteria:AccessApplicationTargetCriteria"
                    },
                    "description": "The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "aud",
                "domain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherLogoUrl": {
                    "type": "string",
                    "description": "The logo URL of the app launcher.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                },
                "bgColor": {
                    "type": "string",
                    "description": "The background color of the app launcher.\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via identity based rules.\n"
                },
                "customNonIdentityDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via non identity rules.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The custom pages selected for the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "footerLinks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationFooterLink:AccessApplicationFooterLink"
                    },
                    "description": "The footer links of the app launcher.\n"
                },
                "headerBgColor": {
                    "type": "string",
                    "description": "The background color of the header bar in the app launcher.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean",
                    "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                },
                "landingPageDesign": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationLandingPageDesign:AccessApplicationLandingPageDesign",
                    "description": "The landing page design of the app launcher.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "optionsPreflightBypass": {
                    "type": "boolean",
                    "description": "Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.\n"
                },
                "saasApp": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp",
                    "description": "SaaS configuration for the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string",
                    "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                },
                "scimConfig": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationScimConfig:AccessApplicationScimConfig",
                    "description": "Configuration for provisioning to this application via SCIM. This is currently in closed beta.\n"
                },
                "selfHostedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.\n"
                },
                "serviceAuth401Redirect": {
                    "type": "boolean",
                    "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                },
                "skipAppLauncherLoginPage": {
                    "type": "boolean",
                    "description": "Option to skip the App Launcher landing page. Defaults to `false`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean",
                    "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The itags associated with the application.\n"
                },
                "targetCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationTargetCriteria:AccessApplicationTargetCriteria"
                    },
                    "description": "The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessApplication resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "allowAuthenticateViaWarp": {
                        "type": "boolean",
                        "description": "When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.\n"
                    },
                    "allowedIdps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identity providers selected for the application.\n"
                    },
                    "appLauncherLogoUrl": {
                        "type": "string",
                        "description": "The logo URL of the app launcher.\n"
                    },
                    "appLauncherVisible": {
                        "type": "boolean",
                        "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the application.\n"
                    },
                    "autoRedirectToIdentity": {
                        "type": "boolean",
                        "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                    },
                    "bgColor": {
                        "type": "string",
                        "description": "The background color of the app launcher.\n"
                    },
                    "corsHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                        },
                        "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                    },
                    "customDenyMessage": {
                        "type": "string",
                        "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                    },
                    "customDenyUrl": {
                        "type": "string",
                        "description": "Option that redirects to a custom URL when a user is denied access to the application via identity based rules.\n"
                    },
                    "customNonIdentityDenyUrl": {
                        "type": "string",
                        "description": "Option that redirects to a custom URL when a user is denied access to the application via non identity rules.\n"
                    },
                    "customPages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The custom pages selected for the application.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.\n"
                    },
                    "enableBindingCookie": {
                        "type": "boolean",
                        "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                    },
                    "footerLinks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessApplicationFooterLink:AccessApplicationFooterLink"
                        },
                        "description": "The footer links of the app launcher.\n"
                    },
                    "headerBgColor": {
                        "type": "string",
                        "description": "The background color of the header bar in the app launcher.\n"
                    },
                    "httpOnlyCookieAttribute": {
                        "type": "boolean",
                        "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                    },
                    "landingPageDesign": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationLandingPageDesign:AccessApplicationLandingPageDesign",
                        "description": "The landing page design of the app launcher.\n"
                    },
                    "logoUrl": {
                        "type": "string",
                        "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "optionsPreflightBypass": {
                        "type": "boolean",
                        "description": "Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.\n"
                    },
                    "saasApp": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp",
                        "description": "SaaS configuration for the Access Application.\n"
                    },
                    "sameSiteCookieAttribute": {
                        "type": "string",
                        "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                    },
                    "scimConfig": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationScimConfig:AccessApplicationScimConfig",
                        "description": "Configuration for provisioning to this application via SCIM. This is currently in closed beta.\n"
                    },
                    "selfHostedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.\n"
                    },
                    "serviceAuth401Redirect": {
                        "type": "boolean",
                        "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                    },
                    "skipAppLauncherLoginPage": {
                        "type": "boolean",
                        "description": "Option to skip the App Launcher landing page. Defaults to `false`.\n"
                    },
                    "skipInterstitial": {
                        "type": "boolean",
                        "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The itags associated with the application.\n"
                    },
                    "targetCriterias": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessApplicationTargetCriteria:AccessApplicationTargetCriteria"
                        },
                        "description": "The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessCaCertificate:AccessCaCertificate": {
            "description": "Cloudflare Access can replace traditional SSH key models with\nshort-lived certificates issued to your users based on the token\ngenerated by their Access login.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// account level\nconst example = new cloudflare.AccessCaCertificate(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    applicationId: \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n});\n// zone level\nconst anotherExample = new cloudflare.AccessCaCertificate(\"another_example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    applicationId: \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# account level\nexample = cloudflare.AccessCaCertificate(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    application_id=\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n# zone level\nanother_example = cloudflare.AccessCaCertificate(\"another_example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    application_id=\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // account level\n    var example = new Cloudflare.AccessCaCertificate(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ApplicationId = \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n    });\n\n    // zone level\n    var anotherExample = new Cloudflare.AccessCaCertificate(\"another_example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        ApplicationId = \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// account level\n\t\t_, err := cloudflare.NewAccessCaCertificate(ctx, \"example\", \u0026cloudflare.AccessCaCertificateArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tApplicationId: pulumi.String(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// zone level\n\t\t_, err = cloudflare.NewAccessCaCertificate(ctx, \"another_example\", \u0026cloudflare.AccessCaCertificateArgs{\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tApplicationId: pulumi.String(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessCaCertificate;\nimport com.pulumi.cloudflare.AccessCaCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // account level\n        var example = new AccessCaCertificate(\"example\", AccessCaCertificateArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .applicationId(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n            .build());\n\n        // zone level\n        var anotherExample = new AccessCaCertificate(\"anotherExample\", AccessCaCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .applicationId(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # account level\n  example:\n    type: cloudflare:AccessCaCertificate\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      applicationId: 6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\n  # zone level\n  anotherExample:\n    type: cloudflare:AccessCaCertificate\n    name: another_example\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      applicationId: fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAccount level CA certificate import.\n\n```sh\n$ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/\u003caccount_id\u003e/\u003capplication_id\u003e\n```\n\nZone level CA certificate import.\n\n```sh\n$ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/\u003czone_id\u003e/\u003capplication_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the CA certificate.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Cryptographic public key of the generated CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "applicationId",
                "aud",
                "publicKey",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "applicationId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessCaCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The Access Application ID to associate with the CA certificate.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the CA certificate.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Cryptographic public key of the generated CA certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessCustomPage:AccessCustomPage": {
            "description": "Provides a resource to customize the pages your end users will see\nwhen trying to reach applications behind Cloudflare Access.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.AccessCustomPage(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"example\",\n    type: \"forbidden\",\n    customHtml: \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.AccessCustomPage(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"example\",\n    type=\"forbidden\",\n    custom_html=\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.AccessCustomPage(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"example\",\n        Type = \"forbidden\",\n        CustomHtml = \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessCustomPage(ctx, \"example\", \u0026cloudflare.AccessCustomPageArgs{\n\t\t\tZoneId:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:       pulumi.String(\"example\"),\n\t\t\tType:       pulumi.String(\"forbidden\"),\n\t\t\tCustomHtml: pulumi.String(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessCustomPage;\nimport com.pulumi.cloudflare.AccessCustomPageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AccessCustomPage(\"example\", AccessCustomPageArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"example\")\n            .type(\"forbidden\")\n            .customHtml(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:AccessCustomPage\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: example\n      type: forbidden\n      customHtml: \u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps to display on the custom page.\n"
                },
                "customHtml": {
                    "type": "string",
                    "description": "Custom HTML to display on the custom page.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Custom Page configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps to display on the custom page.\n"
                },
                "customHtml": {
                    "type": "string",
                    "description": "Custom HTML to display on the custom page.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Custom Page configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessCustomPage resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "appCount": {
                        "type": "integer",
                        "description": "Number of apps to display on the custom page.\n"
                    },
                    "customHtml": {
                        "type": "string",
                        "description": "Custom HTML to display on the custom page.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Custom Page configuration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessGroup:AccessGroup": {
            "description": "Provides a Cloudflare Access Group resource. Access Groups are used\nin conjunction with Access Policies to restrict access to a\nparticular resource based on group membership.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/accessGroup:AccessGroup example \u003caccount_id\u003e/\u003cgroup_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                    }
                },
                "name": {
                    "type": "string"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "includes",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                    }
                },
                "name": {
                    "type": "string"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessGroup resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                        }
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                        }
                    },
                    "name": {
                        "type": "string"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                        }
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessIdentityProvider:AccessIdentityProvider": {
            "description": "Provides a Cloudflare Access Identity Provider resource. Identity\nProviders are used as an authentication or authorisation source\nwithin Access.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// one time pin\nconst pinLogin = new cloudflare.AccessIdentityProvider(\"pin_login\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"PIN login\",\n    type: \"onetimepin\",\n});\n// oauth\nconst githubOauth = new cloudflare.AccessIdentityProvider(\"github_oauth\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"GitHub OAuth\",\n    type: \"github\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n    }],\n});\n// saml\nconst jumpcloudSaml = new cloudflare.AccessIdentityProvider(\"jumpcloud_saml\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"JumpCloud SAML\",\n    type: \"saml\",\n    configs: [{\n        issuerUrl: \"jumpcloud\",\n        ssoTargetUrl: \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n        attributes: [\n            \"email\",\n            \"username\",\n        ],\n        signRequest: false,\n        idpPublicCert: `MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o`,\n    }],\n});\n// okta\nconst okta = new cloudflare.AccessIdentityProvider(\"okta\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Okta\",\n    type: \"okta\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n        apiToken: \"okta_api_token\",\n        oktaAccount: \"https://example.com\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# one time pin\npin_login = cloudflare.AccessIdentityProvider(\"pin_login\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"PIN login\",\n    type=\"onetimepin\")\n# oauth\ngithub_oauth = cloudflare.AccessIdentityProvider(\"github_oauth\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"GitHub OAuth\",\n    type=\"github\",\n    configs=[{\n        \"client_id\": \"example\",\n        \"client_secret\": \"secret_key\",\n    }])\n# saml\njumpcloud_saml = cloudflare.AccessIdentityProvider(\"jumpcloud_saml\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"JumpCloud SAML\",\n    type=\"saml\",\n    configs=[{\n        \"issuer_url\": \"jumpcloud\",\n        \"sso_target_url\": \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n        \"attributes\": [\n            \"email\",\n            \"username\",\n        ],\n        \"sign_request\": False,\n        \"idp_public_cert\": \"\"\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\"\"\",\n    }])\n# okta\nokta = cloudflare.AccessIdentityProvider(\"okta\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Okta\",\n    type=\"okta\",\n    configs=[{\n        \"client_id\": \"example\",\n        \"client_secret\": \"secret_key\",\n        \"api_token\": \"okta_api_token\",\n        \"okta_account\": \"https://example.com\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // one time pin\n    var pinLogin = new Cloudflare.AccessIdentityProvider(\"pin_login\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"PIN login\",\n        Type = \"onetimepin\",\n    });\n\n    // oauth\n    var githubOauth = new Cloudflare.AccessIdentityProvider(\"github_oauth\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"GitHub OAuth\",\n        Type = \"github\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n            {\n                ClientId = \"example\",\n                ClientSecret = \"secret_key\",\n            },\n        },\n    });\n\n    // saml\n    var jumpcloudSaml = new Cloudflare.AccessIdentityProvider(\"jumpcloud_saml\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"JumpCloud SAML\",\n        Type = \"saml\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n            {\n                IssuerUrl = \"jumpcloud\",\n                SsoTargetUrl = \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n                Attributes = new[]\n                {\n                    \"email\",\n                    \"username\",\n                },\n                SignRequest = false,\n                IdpPublicCert = @\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\",\n            },\n        },\n    });\n\n    // okta\n    var okta = new Cloudflare.AccessIdentityProvider(\"okta\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Okta\",\n        Type = \"okta\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n            {\n                ClientId = \"example\",\n                ClientSecret = \"secret_key\",\n                ApiToken = \"okta_api_token\",\n                OktaAccount = \"https://example.com\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// one time pin\n\t\t_, err := cloudflare.NewAccessIdentityProvider(ctx, \"pin_login\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"PIN login\"),\n\t\t\tType:      pulumi.String(\"onetimepin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// oauth\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"github_oauth\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"GitHub OAuth\"),\n\t\t\tType:      pulumi.String(\"github\"),\n\t\t\tConfigs: cloudflare.AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.AccessIdentityProviderConfigArgs{\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// saml\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"jumpcloud_saml\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"JumpCloud SAML\"),\n\t\t\tType:      pulumi.String(\"saml\"),\n\t\t\tConfigs: cloudflare.AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.AccessIdentityProviderConfigArgs{\n\t\t\t\t\tIssuerUrl:    pulumi.String(\"jumpcloud\"),\n\t\t\t\t\tSsoTargetUrl: pulumi.String(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\"),\n\t\t\t\t\tAttributes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"email\"),\n\t\t\t\t\t\tpulumi.String(\"username\"),\n\t\t\t\t\t},\n\t\t\t\t\tSignRequest:   pulumi.Bool(false),\n\t\t\t\t\tIdpPublicCert: pulumi.String(\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// okta\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"okta\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"Okta\"),\n\t\t\tType:      pulumi.String(\"okta\"),\n\t\t\tConfigs: cloudflare.AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.AccessIdentityProviderConfigArgs{\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t\tApiToken:     pulumi.String(\"okta_api_token\"),\n\t\t\t\t\tOktaAccount:  pulumi.String(\"https://example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessIdentityProvider;\nimport com.pulumi.cloudflare.AccessIdentityProviderArgs;\nimport com.pulumi.cloudflare.inputs.AccessIdentityProviderConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // one time pin\n        var pinLogin = new AccessIdentityProvider(\"pinLogin\", AccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"PIN login\")\n            .type(\"onetimepin\")\n            .build());\n\n        // oauth\n        var githubOauth = new AccessIdentityProvider(\"githubOauth\", AccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"GitHub OAuth\")\n            .type(\"github\")\n            .configs(AccessIdentityProviderConfigArgs.builder()\n                .clientId(\"example\")\n                .clientSecret(\"secret_key\")\n                .build())\n            .build());\n\n        // saml\n        var jumpcloudSaml = new AccessIdentityProvider(\"jumpcloudSaml\", AccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"JumpCloud SAML\")\n            .type(\"saml\")\n            .configs(AccessIdentityProviderConfigArgs.builder()\n                .issuerUrl(\"jumpcloud\")\n                .ssoTargetUrl(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\")\n                .attributes(                \n                    \"email\",\n                    \"username\")\n                .signRequest(false)\n                .idpPublicCert(\"\"\"\nMIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o                \"\"\")\n                .build())\n            .build());\n\n        // okta\n        var okta = new AccessIdentityProvider(\"okta\", AccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Okta\")\n            .type(\"okta\")\n            .configs(AccessIdentityProviderConfigArgs.builder()\n                .clientId(\"example\")\n                .clientSecret(\"secret_key\")\n                .apiToken(\"okta_api_token\")\n                .oktaAccount(\"https://example.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # one time pin\n  pinLogin:\n    type: cloudflare:AccessIdentityProvider\n    name: pin_login\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: PIN login\n      type: onetimepin\n  # oauth\n  githubOauth:\n    type: cloudflare:AccessIdentityProvider\n    name: github_oauth\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: GitHub OAuth\n      type: github\n      configs:\n        - clientId: example\n          clientSecret: secret_key\n  # saml\n  jumpcloudSaml:\n    type: cloudflare:AccessIdentityProvider\n    name: jumpcloud_saml\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: JumpCloud SAML\n      type: saml\n      configs:\n        - issuerUrl: jumpcloud\n          ssoTargetUrl: https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\n          attributes:\n            - email\n            - username\n          signRequest: false\n          idpPublicCert: |-\n            MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\n            uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n  # okta\n  okta:\n    type: cloudflare:AccessIdentityProvider\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Okta\n      type: okta\n      configs:\n        - clientId: example\n          clientSecret: secret_key\n          apiToken: okta_api_token\n          oktaAccount: https://example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/accessIdentityProvider:AccessIdentityProvider example \u003caccount_id\u003e/\u003cidentity_provider_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "scimConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderScimConfig:AccessIdentityProviderScimConfig"
                    },
                    "description": "Configuration for SCIM settings for a given IDP.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "configs",
                "name",
                "scimConfigs",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "scimConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderScimConfig:AccessIdentityProviderScimConfig"
                    },
                    "description": "Configuration for SCIM settings for a given IDP.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessIdentityProvider resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                        },
                        "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Identity Provider configuration.\n"
                    },
                    "scimConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessIdentityProviderScimConfig:AccessIdentityProviderScimConfig"
                        },
                        "description": "Configuration for SCIM settings for a given IDP.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessKeysConfiguration:AccessKeysConfiguration": {
            "description": "Access Keys Configuration defines the rotation policy for the keys\nthat access will use to sign data.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "keyRotationIntervalDays": {
                    "type": "integer",
                    "description": "Number of days to trigger a rotation of the keys.\n"
                }
            },
            "required": [
                "accountId",
                "keyRotationIntervalDays"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "keyRotationIntervalDays": {
                    "type": "integer",
                    "description": "Number of days to trigger a rotation of the keys.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessKeysConfiguration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "keyRotationIntervalDays": {
                        "type": "integer",
                        "description": "Number of days to trigger a rotation of the keys.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate": {
            "description": "Provides a Cloudflare Access Mutual TLS Certificate resource.\nMutual TLS authentication ensures that the traffic is secure and\ntrusted in both directions between a client and server and can be\n used with Access to only allows requests from devices with a\n corresponding client certificate.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myCert = new cloudflare.AccessMutualTlsCertificate(\"my_cert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"My Root Cert\",\n    certificate: caPem,\n    associatedHostnames: [\"staging.example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_cert = cloudflare.AccessMutualTlsCertificate(\"my_cert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"My Root Cert\",\n    certificate=ca_pem,\n    associated_hostnames=[\"staging.example.com\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCert = new Cloudflare.AccessMutualTlsCertificate(\"my_cert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"My Root Cert\",\n        Certificate = caPem,\n        AssociatedHostnames = new[]\n        {\n            \"staging.example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessMutualTlsCertificate(ctx, \"my_cert\", \u0026cloudflare.AccessMutualTlsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:        pulumi.String(\"My Root Cert\"),\n\t\t\tCertificate: pulumi.Any(caPem),\n\t\t\tAssociatedHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"staging.example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessMutualTlsCertificate;\nimport com.pulumi.cloudflare.AccessMutualTlsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCert = new AccessMutualTlsCertificate(\"myCert\", AccessMutualTlsCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"My Root Cert\")\n            .certificate(caPem)\n            .associatedHostnames(\"staging.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCert:\n    type: cloudflare:AccessMutualTlsCertificate\n    name: my_cert\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: My Root Cert\n      certificate: ${caPem}\n      associatedHostnames:\n        - staging.example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAccount level import.\n\n```sh\n$ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example account/\u003caccount_id\u003e/\u003cmutual_tls_certificate_id\u003e\n```\n\nZone level import.\n\n```sh\n$ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example zone/\u003czone_id\u003e/\u003cmutual_tls_certificate_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "fingerprint": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "fingerprint",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessMutualTlsCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "associatedHostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames that will be prompted for this certificate.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The Root CA for your certificates.\n"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings": {
            "description": "Provides a Cloudflare Access Mutual TLS Certificate Settings resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.AccessMutualTlsHostnameSettings(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    settings: [{\n        hostname: \"example.com\",\n        clientCertificateForwarding: true,\n        chinaNetwork: false,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.AccessMutualTlsHostnameSettings(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    settings=[{\n        \"hostname\": \"example.com\",\n        \"client_certificate_forwarding\": True,\n        \"china_network\": False,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.AccessMutualTlsHostnameSettings(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Settings = new[]\n        {\n            new Cloudflare.Inputs.AccessMutualTlsHostnameSettingsSettingArgs\n            {\n                Hostname = \"example.com\",\n                ClientCertificateForwarding = true,\n                ChinaNetwork = false,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessMutualTlsHostnameSettings(ctx, \"example\", \u0026cloudflare.AccessMutualTlsHostnameSettingsArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tSettings: cloudflare.AccessMutualTlsHostnameSettingsSettingArray{\n\t\t\t\t\u0026cloudflare.AccessMutualTlsHostnameSettingsSettingArgs{\n\t\t\t\t\tHostname:                    pulumi.String(\"example.com\"),\n\t\t\t\t\tClientCertificateForwarding: pulumi.Bool(true),\n\t\t\t\t\tChinaNetwork:                pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessMutualTlsHostnameSettings;\nimport com.pulumi.cloudflare.AccessMutualTlsHostnameSettingsArgs;\nimport com.pulumi.cloudflare.inputs.AccessMutualTlsHostnameSettingsSettingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AccessMutualTlsHostnameSettings(\"example\", AccessMutualTlsHostnameSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .settings(AccessMutualTlsHostnameSettingsSettingArgs.builder()\n                .hostname(\"example.com\")\n                .clientCertificateForwarding(true)\n                .chinaNetwork(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:AccessMutualTlsHostnameSettings\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      settings:\n        - hostname: example.com\n          clientCertificateForwarding: true\n          chinaNetwork: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAccount level mTLS hostname settings import.\n\n```sh\n$ pulumi import cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings example account/\u003caccount_id\u003e\n```\n\nZone level mTLS hostname settings import.\n\n```sh\n$ pulumi import cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings example zone/\u003czone_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessMutualTlsHostnameSettingsSetting:AccessMutualTlsHostnameSettingsSetting"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessMutualTlsHostnameSettingsSetting:AccessMutualTlsHostnameSettingsSetting"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessMutualTlsHostnameSettings resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "settings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessMutualTlsHostnameSettingsSetting:AccessMutualTlsHostnameSettingsSetting"
                        }
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessOrganization:AccessOrganization": {
            "description": "A Zero Trust organization defines the user login experience.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.AccessOrganization(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example.cloudflareaccess.com\",\n    authDomain: \"example.cloudflareaccess.com\",\n    isUiReadOnly: false,\n    userSeatExpirationInactiveTime: \"720h\",\n    autoRedirectToIdentity: false,\n    loginDesigns: [{\n        backgroundColor: \"#ffffff\",\n        textColor: \"#000000\",\n        logoPath: \"https://example.com/logo.png\",\n        headerText: \"My header text\",\n        footerText: \"My footer text\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.AccessOrganization(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example.cloudflareaccess.com\",\n    auth_domain=\"example.cloudflareaccess.com\",\n    is_ui_read_only=False,\n    user_seat_expiration_inactive_time=\"720h\",\n    auto_redirect_to_identity=False,\n    login_designs=[{\n        \"background_color\": \"#ffffff\",\n        \"text_color\": \"#000000\",\n        \"logo_path\": \"https://example.com/logo.png\",\n        \"header_text\": \"My header text\",\n        \"footer_text\": \"My footer text\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.AccessOrganization(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example.cloudflareaccess.com\",\n        AuthDomain = \"example.cloudflareaccess.com\",\n        IsUiReadOnly = false,\n        UserSeatExpirationInactiveTime = \"720h\",\n        AutoRedirectToIdentity = false,\n        LoginDesigns = new[]\n        {\n            new Cloudflare.Inputs.AccessOrganizationLoginDesignArgs\n            {\n                BackgroundColor = \"#ffffff\",\n                TextColor = \"#000000\",\n                LogoPath = \"https://example.com/logo.png\",\n                HeaderText = \"My header text\",\n                FooterText = \"My footer text\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessOrganization(ctx, \"example\", \u0026cloudflare.AccessOrganizationArgs{\n\t\t\tAccountId:                      pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:                           pulumi.String(\"example.cloudflareaccess.com\"),\n\t\t\tAuthDomain:                     pulumi.String(\"example.cloudflareaccess.com\"),\n\t\t\tIsUiReadOnly:                   pulumi.Bool(false),\n\t\t\tUserSeatExpirationInactiveTime: pulumi.String(\"720h\"),\n\t\t\tAutoRedirectToIdentity:         pulumi.Bool(false),\n\t\t\tLoginDesigns: cloudflare.AccessOrganizationLoginDesignArray{\n\t\t\t\t\u0026cloudflare.AccessOrganizationLoginDesignArgs{\n\t\t\t\t\tBackgroundColor: pulumi.String(\"#ffffff\"),\n\t\t\t\t\tTextColor:       pulumi.String(\"#000000\"),\n\t\t\t\t\tLogoPath:        pulumi.String(\"https://example.com/logo.png\"),\n\t\t\t\t\tHeaderText:      pulumi.String(\"My header text\"),\n\t\t\t\t\tFooterText:      pulumi.String(\"My footer text\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessOrganization;\nimport com.pulumi.cloudflare.AccessOrganizationArgs;\nimport com.pulumi.cloudflare.inputs.AccessOrganizationLoginDesignArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AccessOrganization(\"example\", AccessOrganizationArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example.cloudflareaccess.com\")\n            .authDomain(\"example.cloudflareaccess.com\")\n            .isUiReadOnly(false)\n            .userSeatExpirationInactiveTime(\"720h\")\n            .autoRedirectToIdentity(false)\n            .loginDesigns(AccessOrganizationLoginDesignArgs.builder()\n                .backgroundColor(\"#ffffff\")\n                .textColor(\"#000000\")\n                .logoPath(\"https://example.com/logo.png\")\n                .headerText(\"My header text\")\n                .footerText(\"My footer text\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:AccessOrganization\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example.cloudflareaccess.com\n      authDomain: example.cloudflareaccess.com\n      isUiReadOnly: false\n      userSeatExpirationInactiveTime: 720h\n      autoRedirectToIdentity: false\n      loginDesigns:\n        - backgroundColor: '#ffffff'\n          textColor: '#000000'\n          logoPath: https://example.com/logo.png\n          headerText: My header text\n          footerText: My footer text\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/accessOrganization:AccessOrganization example \u003caccount_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.\n"
                },
                "authDomain": {
                    "type": "string",
                    "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "When set to true, users skip the identity provider selection step during login.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessOrganizationCustomPage:AccessOrganizationCustomPage"
                    },
                    "description": "Custom pages for your Zero Trust organization.\n"
                },
                "isUiReadOnly": {
                    "type": "boolean",
                    "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                },
                "loginDesigns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your Zero Trust organization.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "uiReadOnlyToggleReason": {
                    "type": "string",
                    "description": "A description of the reason why the UI read only field is being toggled.\n"
                },
                "userSeatExpirationInactiveTime": {
                    "type": "string",
                    "description": "The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.\n"
                },
                "warpAuthSessionDuration": {
                    "type": "string",
                    "description": "The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "authDomain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.\n"
                },
                "authDomain": {
                    "type": "string",
                    "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "When set to true, users skip the identity provider selection step during login.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessOrganizationCustomPage:AccessOrganizationCustomPage"
                    },
                    "description": "Custom pages for your Zero Trust organization.\n"
                },
                "isUiReadOnly": {
                    "type": "boolean",
                    "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                },
                "loginDesigns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your Zero Trust organization.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "uiReadOnlyToggleReason": {
                    "type": "string",
                    "description": "A description of the reason why the UI read only field is being toggled.\n"
                },
                "userSeatExpirationInactiveTime": {
                    "type": "string",
                    "description": "The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.\n"
                },
                "warpAuthSessionDuration": {
                    "type": "string",
                    "description": "The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "authDomain",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessOrganization resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "allowAuthenticateViaWarp": {
                        "type": "boolean",
                        "description": "When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.\n"
                    },
                    "authDomain": {
                        "type": "string",
                        "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                    },
                    "autoRedirectToIdentity": {
                        "type": "boolean",
                        "description": "When set to true, users skip the identity provider selection step during login.\n"
                    },
                    "customPages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessOrganizationCustomPage:AccessOrganizationCustomPage"
                        },
                        "description": "Custom pages for your Zero Trust organization.\n"
                    },
                    "isUiReadOnly": {
                        "type": "boolean",
                        "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                    },
                    "loginDesigns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of your Zero Trust organization.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                    },
                    "uiReadOnlyToggleReason": {
                        "type": "string",
                        "description": "A description of the reason why the UI read only field is being toggled.\n"
                    },
                    "userSeatExpirationInactiveTime": {
                        "type": "string",
                        "description": "The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.\n"
                    },
                    "warpAuthSessionDuration": {
                        "type": "string",
                        "description": "The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessPolicy:AccessPolicy": {
            "description": "Provides a Cloudflare Access Policy resource. Access Policies are\nused in conjunction with Access Applications to restrict access to\na particular resource.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in most cases using either is fine.\n   However, if you're using a scoped access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\" zone needs to use the `zone_id` argument.\n   If 'application_id' is omitted, the policy created can be reused by multiple access applications.\n   Any cloudflare.AccessApplication resource can reference reusable policies through its `policies` argument.\n   To destroy a reusable policy and remove it from all applications' policies lists on the same apply, preemptively set the\n   lifecycle option `create_before_destroy` to true on the 'cloudflare_access_policy' resource.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/accessPolicy:AccessPolicy example account/\u003caccount_id\u003e/\u003capplication_id\u003e/\u003cpolicy_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                    }
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "connectionRules": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyConnectionRules:AccessPolicyConnectionRules",
                    "description": "The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "isolationRequired": {
                    "type": "boolean",
                    "description": "Require this application to be served in an isolated browser for users matching this policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Required when using `application_id`.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "decision",
                "includes",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                    }
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "connectionRules": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyConnectionRules:AccessPolicyConnectionRules",
                    "description": "The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "isolationRequired": {
                    "type": "boolean",
                    "description": "Require this application to be served in an isolated browser for users matching this policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Required when using `application_id`.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "decision",
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "approvalGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                        }
                    },
                    "approvalRequired": {
                        "type": "boolean"
                    },
                    "connectionRules": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyConnectionRules:AccessPolicyConnectionRules",
                        "description": "The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                    },
                    "decision": {
                        "type": "string",
                        "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                        },
                        "description": "A series of access conditions, see Access Groups.\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                        },
                        "description": "A series of access conditions, see Access Groups.\n"
                    },
                    "isolationRequired": {
                        "type": "boolean",
                        "description": "Require this application to be served in an isolated browser for users matching this policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Policy.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The unique precedence for policies on a single application. Required when using `application_id`.\n"
                    },
                    "purposeJustificationPrompt": {
                        "type": "string",
                        "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                    },
                    "purposeJustificationRequired": {
                        "type": "boolean",
                        "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                        },
                        "description": "A series of access conditions, see Access Groups.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessRule:AccessRule": {
            "description": "Provides a Cloudflare IP Firewall Access Rule resource. Access\ncontrol can be applied on basis of IP addresses, IP ranges, AS\nnumbers or countries.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Challenge requests coming from known Tor exit nodes.\nconst torExitNodes = new cloudflare.AccessRule(\"tor_exit_nodes\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes: \"Requests coming from known Tor exit nodes\",\n    mode: \"challenge\",\n    configuration: {\n        target: \"country\",\n        value: \"T1\",\n    },\n});\n// Allowlist requests coming from Antarctica, but only for single zone.\nconst antarctica = new cloudflare.AccessRule(\"antarctica\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes: \"Requests coming from Antarctica\",\n    mode: \"whitelist\",\n    configuration: {\n        target: \"country\",\n        value: \"AQ\",\n    },\n});\nconst config = new pulumi.Config();\nconst myOffice = config.getObject\u003cArray\u003cstring\u003e\u003e(\"myOffice\") || [\n    \"192.0.2.0/24\",\n    \"198.51.100.0/24\",\n    \"2001:db8::/56\",\n];\nconst officeNetwork: cloudflare.AccessRule[] = [];\nfor (const range = {value: 0}; range.value \u003c myOffice.length; range.value++) {\n    officeNetwork.push(new cloudflare.AccessRule(`office_network-${range.value}`, {\n        accountId: \"f037e56e89293a057740de681ac9abbe\",\n        notes: \"Requests coming from office network\",\n        mode: \"whitelist\",\n        configuration: {\n            target: \"ip_range\",\n            value: myOffice[range.value],\n        },\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Challenge requests coming from known Tor exit nodes.\ntor_exit_nodes = cloudflare.AccessRule(\"tor_exit_nodes\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes=\"Requests coming from known Tor exit nodes\",\n    mode=\"challenge\",\n    configuration={\n        \"target\": \"country\",\n        \"value\": \"T1\",\n    })\n# Allowlist requests coming from Antarctica, but only for single zone.\nantarctica = cloudflare.AccessRule(\"antarctica\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes=\"Requests coming from Antarctica\",\n    mode=\"whitelist\",\n    configuration={\n        \"target\": \"country\",\n        \"value\": \"AQ\",\n    })\nconfig = pulumi.Config()\nmy_office = config.get_object(\"myOffice\")\nif my_office is None:\n    my_office = [\n        \"192.0.2.0/24\",\n        \"198.51.100.0/24\",\n        \"2001:db8::/56\",\n    ]\noffice_network = []\nfor range in [{\"value\": i} for i in range(0, len(my_office))]:\n    office_network.append(cloudflare.AccessRule(f\"office_network-{range['value']}\",\n        account_id=\"f037e56e89293a057740de681ac9abbe\",\n        notes=\"Requests coming from office network\",\n        mode=\"whitelist\",\n        configuration={\n            \"target\": \"ip_range\",\n            \"value\": my_office[range[\"value\"]],\n        }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Challenge requests coming from known Tor exit nodes.\n    var torExitNodes = new Cloudflare.AccessRule(\"tor_exit_nodes\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Notes = \"Requests coming from known Tor exit nodes\",\n        Mode = \"challenge\",\n        Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs\n        {\n            Target = \"country\",\n            Value = \"T1\",\n        },\n    });\n\n    // Allowlist requests coming from Antarctica, but only for single zone.\n    var antarctica = new Cloudflare.AccessRule(\"antarctica\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Notes = \"Requests coming from Antarctica\",\n        Mode = \"whitelist\",\n        Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs\n        {\n            Target = \"country\",\n            Value = \"AQ\",\n        },\n    });\n\n    var config = new Config();\n    var myOffice = config.GetObject\u003cstring[]\u003e(\"myOffice\") ?? new[]\n    {\n        \"192.0.2.0/24\",\n        \"198.51.100.0/24\",\n        \"2001:db8::/56\",\n    };\n    var officeNetwork = new List\u003cCloudflare.AccessRule\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c myOffice.Length; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        officeNetwork.Add(new Cloudflare.AccessRule($\"office_network-{range.Value}\", new()\n        {\n            AccountId = \"f037e56e89293a057740de681ac9abbe\",\n            Notes = \"Requests coming from office network\",\n            Mode = \"whitelist\",\n            Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs\n            {\n                Target = \"ip_range\",\n                Value = myOffice[range.Value],\n            },\n        }));\n    }\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessRule;\nimport com.pulumi.cloudflare.AccessRuleArgs;\nimport com.pulumi.cloudflare.inputs.AccessRuleConfigurationArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        // Challenge requests coming from known Tor exit nodes.\n        var torExitNodes = new AccessRule(\"torExitNodes\", AccessRuleArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .notes(\"Requests coming from known Tor exit nodes\")\n            .mode(\"challenge\")\n            .configuration(AccessRuleConfigurationArgs.builder()\n                .target(\"country\")\n                .value(\"T1\")\n                .build())\n            .build());\n\n        // Allowlist requests coming from Antarctica, but only for single zone.\n        var antarctica = new AccessRule(\"antarctica\", AccessRuleArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .notes(\"Requests coming from Antarctica\")\n            .mode(\"whitelist\")\n            .configuration(AccessRuleConfigurationArgs.builder()\n                .target(\"country\")\n                .value(\"AQ\")\n                .build())\n            .build());\n\n        final var myOffice = config.get(\"myOffice\").orElse(        \n            \"192.0.2.0/24\",\n            \"198.51.100.0/24\",\n            \"2001:db8::/56\");\n        for (var i = 0; i \u003c myOffice.length(); i++) {\n            new AccessRule(\"officeNetwork-\" + i, AccessRuleArgs.builder()\n                .accountId(\"f037e56e89293a057740de681ac9abbe\")\n                .notes(\"Requests coming from office network\")\n                .mode(\"whitelist\")\n                .configuration(AccessRuleConfigurationArgs.builder()\n                    .target(\"ip_range\")\n                    .value(myOffice[range.value()])\n                    .build())\n                .build());\n\n        \n}\n    }\n}\n```\n```yaml\nconfiguration:\n  # Allowlist office's network IP ranges on all account zones (or other lists of\n  # resources).\n  myOffice:\n    type: list(string)\n    default:\n      - 192.0.2.0/24\n      - 198.51.100.0/24\n      - 2001:db8::/56\nresources:\n  # Challenge requests coming from known Tor exit nodes.\n  torExitNodes:\n    type: cloudflare:AccessRule\n    name: tor_exit_nodes\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      notes: Requests coming from known Tor exit nodes\n      mode: challenge\n      configuration:\n        target: country\n        value: T1\n  # Allowlist requests coming from Antarctica, but only for single zone.\n  antarctica:\n    type: cloudflare:AccessRule\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      notes: Requests coming from Antarctica\n      mode: whitelist\n      configuration:\n        target: country\n        value: AQ\n  officeNetwork:\n    type: cloudflare:AccessRule\n    name: office_network\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      notes: Requests coming from office network\n      mode: whitelist\n      configuration:\n        target: ip_range\n        value:\n          fn::select:\n            - ${range.value}\n            - ${myOffice}\n    options: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUser level access rule import.\n\n```sh\n$ pulumi import cloudflare:index/accessRule:AccessRule default user/\u003cuser_id\u003e/\u003crule_id\u003e\n```\n\nZone level access rule import.\n\n```sh\n$ pulumi import cloudflare:index/accessRule:AccessRule default zone/\u003czone_id\u003e/\u003crule_id\u003e\n```\n\nAccount level access rule import.\n\n```sh\n$ pulumi import cloudflare:index/accessRule:AccessRule default account/\u003caccount_id\u003e/\u003crule_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "configuration": {
                    "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "configuration",
                "mode",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configuration": {
                    "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configuration",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "configuration": {
                        "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                        "description": "Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "mode": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.\n"
                    },
                    "notes": {
                        "type": "string",
                        "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessServiceToken:AccessServiceToken": {
            "description": "Access Service Tokens are used for service-to-service communication\nwhen an application is behind Cloudflare Access.\n\n## Import\n\nIf you are importing an Access Service Token you will not have the\n\nclient_secret available in the state for use. The client_secret is only\n\navailable once, at creation. In most cases, it is better to just create a new\n\nresource should you need to reference it in other resources.\n\n```sh\n$ pulumi import cloudflare:index/accessServiceToken:AccessServiceToken example \u003caccount_id\u003e/\u003cservice_token_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                },
                "duration": {
                    "type": "string",
                    "description": "Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Date when the token expires.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "clientId",
                "clientSecret",
                "duration",
                "expiresAt",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "duration": {
                    "type": "string",
                    "description": "Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessServiceToken resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "duration": {
                        "type": "string",
                        "description": "Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Date when the token expires.\n"
                    },
                    "minDaysForRenewal": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the token's intent.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessTag:AccessTag": {
            "description": "Provides a resource to customize the pages your end users will see\nwhen trying to reach applications behind Cloudflare Access.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps associated with the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Tag.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "appCount",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps associated with the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Tag.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessTag resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "appCount": {
                        "type": "integer",
                        "description": "Number of apps associated with the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Tag.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/account:Account": {
            "description": "Provides a Cloudflare Account resource. Account is the basic resource for\nworking with Cloudflare zones, teams and users.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Account(\"example\", {\n    name: \"some-enterprise-account\",\n    type: \"enterprise\",\n    enforceTwofactor: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Account(\"example\",\n    name=\"some-enterprise-account\",\n    type=\"enterprise\",\n    enforce_twofactor=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Account(\"example\", new()\n    {\n        Name = \"some-enterprise-account\",\n        Type = \"enterprise\",\n        EnforceTwofactor = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccount(ctx, \"example\", \u0026cloudflare.AccountArgs{\n\t\t\tName:             pulumi.String(\"some-enterprise-account\"),\n\t\t\tType:             pulumi.String(\"enterprise\"),\n\t\t\tEnforceTwofactor: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Account;\nimport com.pulumi.cloudflare.AccountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Account(\"example\", AccountArgs.builder()\n            .name(\"some-enterprise-account\")\n            .type(\"enterprise\")\n            .enforceTwofactor(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Account\n    properties:\n      name: some-enterprise-account\n      type: enterprise\n      enforceTwofactor: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/account:Account example \u003caccount_id\u003e\n```\n\n",
            "properties": {
                "enforceTwofactor": {
                    "type": "boolean",
                    "description": "Whether 2FA is enforced on the account. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the account that is displayed in the Cloudflare dashboard.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "enforceTwofactor": {
                    "type": "boolean",
                    "description": "Whether 2FA is enforced on the account. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the account that is displayed in the Cloudflare dashboard.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Account resources.\n",
                "properties": {
                    "enforceTwofactor": {
                        "type": "boolean",
                        "description": "Whether 2FA is enforced on the account. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the account that is displayed in the Cloudflare dashboard.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accountMember:AccountMember": {
            "description": "Provides a resource which manages Cloudflare account members.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.AccountMember(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    emailAddress: \"user@example.com\",\n    roleIds: [\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.AccountMember(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    email_address=\"user@example.com\",\n    role_ids=[\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.AccountMember(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        EmailAddress = \"user@example.com\",\n        RoleIds = new[]\n        {\n            \"68b329da9893e34099c7d8ad5cb9c940\",\n            \"d784fa8b6d98d27699781bd9a7cf19f0\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccountMember(ctx, \"example\", \u0026cloudflare.AccountMemberArgs{\n\t\t\tAccountId:    pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tEmailAddress: pulumi.String(\"user@example.com\"),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"68b329da9893e34099c7d8ad5cb9c940\"),\n\t\t\t\tpulumi.String(\"d784fa8b6d98d27699781bd9a7cf19f0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccountMember;\nimport com.pulumi.cloudflare.AccountMemberArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AccountMember(\"example\", AccountMemberArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .emailAddress(\"user@example.com\")\n            .roleIds(            \n                \"68b329da9893e34099c7d8ad5cb9c940\",\n                \"d784fa8b6d98d27699781bd9a7cf19f0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:AccountMember\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      emailAddress: user@example.com\n      roleIds:\n        - 68b329da9893e34099c7d8ad5cb9c940\n        - d784fa8b6d98d27699781bd9a7cf19f0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/accountMember:AccountMember example \u003caccount_id\u003e/\u003cmember_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to create the account member in.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of account role IDs that you want to assign to a member.\n"
                },
                "status": {
                    "type": "string",
                    "description": "A member's status in the account. Available values: `accepted`, `pending`.\n"
                }
            },
            "required": [
                "accountId",
                "emailAddress",
                "roleIds",
                "status"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to create the account member in.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of account role IDs that you want to assign to a member.\n"
                },
                "status": {
                    "type": "string",
                    "description": "A member's status in the account. Available values: `accepted`, `pending`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "emailAddress",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountMember resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "Account ID to create the account member in.\n"
                    },
                    "emailAddress": {
                        "type": "string",
                        "description": "The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of account role IDs that you want to assign to a member.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "A member's status in the account. Available values: `accepted`, `pending`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/addressMap:AddressMap": {
            "description": "Provides the ability to manage IP addresses that can be used by DNS records when\nthey are proxied through Cloudflare.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.AddressMap(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    description: \"My address map\",\n    defaultSni: \"*.example.com\",\n    enabled: true,\n    ips: [\n        {\n            ip: \"192.0.2.1\",\n        },\n        {\n            ip: \"203.0.113.1\",\n        },\n    ],\n    memberships: [\n        {\n            identifier: \"92f17202ed8bd63d69a66b86a49a8f6b\",\n            kind: \"account\",\n        },\n        {\n            identifier: \"023e105f4ecef8ad9ca31a8372d0c353\",\n            kind: \"zone\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.AddressMap(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    description=\"My address map\",\n    default_sni=\"*.example.com\",\n    enabled=True,\n    ips=[\n        {\n            \"ip\": \"192.0.2.1\",\n        },\n        {\n            \"ip\": \"203.0.113.1\",\n        },\n    ],\n    memberships=[\n        {\n            \"identifier\": \"92f17202ed8bd63d69a66b86a49a8f6b\",\n            \"kind\": \"account\",\n        },\n        {\n            \"identifier\": \"023e105f4ecef8ad9ca31a8372d0c353\",\n            \"kind\": \"zone\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.AddressMap(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Description = \"My address map\",\n        DefaultSni = \"*.example.com\",\n        Enabled = true,\n        Ips = new[]\n        {\n            new Cloudflare.Inputs.AddressMapIpArgs\n            {\n                Ip = \"192.0.2.1\",\n            },\n            new Cloudflare.Inputs.AddressMapIpArgs\n            {\n                Ip = \"203.0.113.1\",\n            },\n        },\n        Memberships = new[]\n        {\n            new Cloudflare.Inputs.AddressMapMembershipArgs\n            {\n                Identifier = \"92f17202ed8bd63d69a66b86a49a8f6b\",\n                Kind = \"account\",\n            },\n            new Cloudflare.Inputs.AddressMapMembershipArgs\n            {\n                Identifier = \"023e105f4ecef8ad9ca31a8372d0c353\",\n                Kind = \"zone\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAddressMap(ctx, \"example\", \u0026cloudflare.AddressMapArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tDescription: pulumi.String(\"My address map\"),\n\t\t\tDefaultSni:  pulumi.String(\"*.example.com\"),\n\t\t\tEnabled:     pulumi.Bool(true),\n\t\t\tIps: cloudflare.AddressMapIpArray{\n\t\t\t\t\u0026cloudflare.AddressMapIpArgs{\n\t\t\t\t\tIp: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.AddressMapIpArgs{\n\t\t\t\t\tIp: pulumi.String(\"203.0.113.1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMemberships: cloudflare.AddressMapMembershipArray{\n\t\t\t\t\u0026cloudflare.AddressMapMembershipArgs{\n\t\t\t\t\tIdentifier: pulumi.String(\"92f17202ed8bd63d69a66b86a49a8f6b\"),\n\t\t\t\t\tKind:       pulumi.String(\"account\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.AddressMapMembershipArgs{\n\t\t\t\t\tIdentifier: pulumi.String(\"023e105f4ecef8ad9ca31a8372d0c353\"),\n\t\t\t\t\tKind:       pulumi.String(\"zone\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AddressMap;\nimport com.pulumi.cloudflare.AddressMapArgs;\nimport com.pulumi.cloudflare.inputs.AddressMapIpArgs;\nimport com.pulumi.cloudflare.inputs.AddressMapMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AddressMap(\"example\", AddressMapArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .description(\"My address map\")\n            .defaultSni(\"*.example.com\")\n            .enabled(true)\n            .ips(            \n                AddressMapIpArgs.builder()\n                    .ip(\"192.0.2.1\")\n                    .build(),\n                AddressMapIpArgs.builder()\n                    .ip(\"203.0.113.1\")\n                    .build())\n            .memberships(            \n                AddressMapMembershipArgs.builder()\n                    .identifier(\"92f17202ed8bd63d69a66b86a49a8f6b\")\n                    .kind(\"account\")\n                    .build(),\n                AddressMapMembershipArgs.builder()\n                    .identifier(\"023e105f4ecef8ad9ca31a8372d0c353\")\n                    .kind(\"zone\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:AddressMap\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      description: My address map\n      defaultSni: '*.example.com'\n      enabled: true\n      ips:\n        - ip: 192.0.2.1\n        - ip: 203.0.113.1\n      memberships:\n        - identifier: 92f17202ed8bd63d69a66b86a49a8f6b\n          kind: account\n        - identifier: 023e105f4ecef8ad9ca31a8372d0c353\n          kind: zone\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/addressMap:AddressMap example \u003caccount_id\u003e/\u003caddress_map_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "canDelete": {
                    "type": "boolean",
                    "description": "If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.\n"
                },
                "canModifyIps": {
                    "type": "boolean",
                    "description": "If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.\n"
                },
                "defaultSni": {
                    "type": "string",
                    "description": "If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the address map.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the Address Map is enabled or not.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AddressMapIp:AddressMapIp"
                    },
                    "description": "The set of IPs on the Address Map.\n"
                },
                "memberships": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AddressMapMembership:AddressMapMembership"
                    },
                    "description": "Zones and Accounts which will be assigned IPs on this Address Map.\n"
                }
            },
            "required": [
                "accountId",
                "canDelete",
                "canModifyIps",
                "enabled"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "defaultSni": {
                    "type": "string",
                    "description": "If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the address map.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the Address Map is enabled or not.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AddressMapIp:AddressMapIp"
                    },
                    "description": "The set of IPs on the Address Map.\n"
                },
                "memberships": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AddressMapMembership:AddressMapMembership"
                    },
                    "description": "Zones and Accounts which will be assigned IPs on this Address Map.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AddressMap resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "canDelete": {
                        "type": "boolean",
                        "description": "If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.\n"
                    },
                    "canModifyIps": {
                        "type": "boolean",
                        "description": "If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.\n"
                    },
                    "defaultSni": {
                        "type": "string",
                        "description": "If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the address map.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the Address Map is enabled or not.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AddressMapIp:AddressMapIp"
                        },
                        "description": "The set of IPs on the Address Map.\n"
                    },
                    "memberships": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AddressMapMembership:AddressMapMembership"
                        },
                        "description": "Zones and Accounts which will be assigned IPs on this Address Map.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiShield:ApiShield": {
            "description": "Provides a resource to manage API Shield configurations.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ApiShield(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    authIdCharacteristics: [{\n        name: \"my-example-header\",\n        type: \"header\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ApiShield(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    auth_id_characteristics=[{\n        \"name\": \"my-example-header\",\n        \"type\": \"header\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ApiShield(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        AuthIdCharacteristics = new[]\n        {\n            new Cloudflare.Inputs.ApiShieldAuthIdCharacteristicArgs\n            {\n                Name = \"my-example-header\",\n                Type = \"header\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewApiShield(ctx, \"example\", \u0026cloudflare.ApiShieldArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tAuthIdCharacteristics: cloudflare.ApiShieldAuthIdCharacteristicArray{\n\t\t\t\t\u0026cloudflare.ApiShieldAuthIdCharacteristicArgs{\n\t\t\t\t\tName: pulumi.String(\"my-example-header\"),\n\t\t\t\t\tType: pulumi.String(\"header\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ApiShield;\nimport com.pulumi.cloudflare.ApiShieldArgs;\nimport com.pulumi.cloudflare.inputs.ApiShieldAuthIdCharacteristicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ApiShield(\"example\", ApiShieldArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .authIdCharacteristics(ApiShieldAuthIdCharacteristicArgs.builder()\n                .name(\"my-example-header\")\n                .type(\"header\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ApiShield\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      authIdCharacteristics:\n        - name: my-example-header\n          type: header\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "authIdCharacteristics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic"
                    },
                    "description": "Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "authIdCharacteristics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic"
                    },
                    "description": "Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiShield resources.\n",
                "properties": {
                    "authIdCharacteristics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic"
                        },
                        "description": "Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiShieldOperation:ApiShieldOperation": {
            "description": "Provides a resource to manage an operation in API Shield Endpoint Management.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ApiShieldOperation(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    method: \"GET\",\n    host: \"api.example.com\",\n    endpoint: \"/path\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ApiShieldOperation(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    method=\"GET\",\n    host=\"api.example.com\",\n    endpoint=\"/path\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ApiShieldOperation(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Method = \"GET\",\n        Host = \"api.example.com\",\n        Endpoint = \"/path\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewApiShieldOperation(ctx, \"example\", \u0026cloudflare.ApiShieldOperationArgs{\n\t\t\tZoneId:   pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tMethod:   pulumi.String(\"GET\"),\n\t\t\tHost:     pulumi.String(\"api.example.com\"),\n\t\t\tEndpoint: pulumi.String(\"/path\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ApiShieldOperation;\nimport com.pulumi.cloudflare.ApiShieldOperationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ApiShieldOperation(\"example\", ApiShieldOperationArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .method(\"GET\")\n            .host(\"api.example.com\")\n            .endpoint(\"/path\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ApiShieldOperation\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      method: GET\n      host: api.example.com\n      endpoint: /path\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "endpoint": {
                    "type": "string",
                    "description": "The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**\n"
                },
                "host": {
                    "type": "string",
                    "description": "RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "method": {
                    "type": "string",
                    "description": "The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "endpoint",
                "host",
                "method",
                "zoneId"
            ],
            "inputProperties": {
                "endpoint": {
                    "type": "string",
                    "description": "The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "host": {
                    "type": "string",
                    "description": "RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "method": {
                    "type": "string",
                    "description": "The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpoint",
                "host",
                "method",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiShieldOperation resources.\n",
                "properties": {
                    "endpoint": {
                        "type": "string",
                        "description": "The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "host": {
                        "type": "string",
                        "description": "RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "method": {
                        "type": "string",
                        "description": "The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiShieldOperationSchemaValidationSettings:ApiShieldOperationSchemaValidationSettings": {
            "description": "Provides a resource to manage operation-level settings in API Shield Schema Validation 2.0.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ApiShieldOperation(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    method: \"GET\",\n    host: \"api.example.com\",\n    endpoint: \"/path\",\n});\nconst exampleApiShieldOperationSchemaValidationSettings = new cloudflare.ApiShieldOperationSchemaValidationSettings(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    operationId: example.id,\n    mitigationAction: \"block\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ApiShieldOperation(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    method=\"GET\",\n    host=\"api.example.com\",\n    endpoint=\"/path\")\nexample_api_shield_operation_schema_validation_settings = cloudflare.ApiShieldOperationSchemaValidationSettings(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    operation_id=example.id,\n    mitigation_action=\"block\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ApiShieldOperation(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Method = \"GET\",\n        Host = \"api.example.com\",\n        Endpoint = \"/path\",\n    });\n\n    var exampleApiShieldOperationSchemaValidationSettings = new Cloudflare.ApiShieldOperationSchemaValidationSettings(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        OperationId = example.Id,\n        MitigationAction = \"block\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.NewApiShieldOperation(ctx, \"example\", \u0026cloudflare.ApiShieldOperationArgs{\n\t\t\tZoneId:   pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tMethod:   pulumi.String(\"GET\"),\n\t\t\tHost:     pulumi.String(\"api.example.com\"),\n\t\t\tEndpoint: pulumi.String(\"/path\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewApiShieldOperationSchemaValidationSettings(ctx, \"example\", \u0026cloudflare.ApiShieldOperationSchemaValidationSettingsArgs{\n\t\t\tZoneId:           pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tOperationId:      example.ID(),\n\t\t\tMitigationAction: pulumi.String(\"block\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ApiShieldOperation;\nimport com.pulumi.cloudflare.ApiShieldOperationArgs;\nimport com.pulumi.cloudflare.ApiShieldOperationSchemaValidationSettings;\nimport com.pulumi.cloudflare.ApiShieldOperationSchemaValidationSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ApiShieldOperation(\"example\", ApiShieldOperationArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .method(\"GET\")\n            .host(\"api.example.com\")\n            .endpoint(\"/path\")\n            .build());\n\n        var exampleApiShieldOperationSchemaValidationSettings = new ApiShieldOperationSchemaValidationSettings(\"exampleApiShieldOperationSchemaValidationSettings\", ApiShieldOperationSchemaValidationSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .operationId(example.id())\n            .mitigationAction(\"block\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ApiShieldOperation\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      method: GET\n      host: api.example.com\n      endpoint: /path\n  exampleApiShieldOperationSchemaValidationSettings:\n    type: cloudflare:ApiShieldOperationSchemaValidationSettings\n    name: example\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      operationId: ${example.id}\n      mitigationAction: block\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "mitigationAction": {
                    "type": "string",
                    "description": "The mitigation action to apply to this operation.\n"
                },
                "operationId": {
                    "type": "string",
                    "description": "Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "operationId",
                "zoneId"
            ],
            "inputProperties": {
                "mitigationAction": {
                    "type": "string",
                    "description": "The mitigation action to apply to this operation.\n"
                },
                "operationId": {
                    "type": "string",
                    "description": "Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "operationId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiShieldOperationSchemaValidationSettings resources.\n",
                "properties": {
                    "mitigationAction": {
                        "type": "string",
                        "description": "The mitigation action to apply to this operation.\n"
                    },
                    "operationId": {
                        "type": "string",
                        "description": "Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiShieldSchema:ApiShieldSchema": {
            "description": "Provides a resource to manage a schema in API Shield Schema Validation 2.0.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst petstoreSchema = new cloudflare.ApiShieldSchema(\"petstore_schema\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"myschema\",\n    kind: \"openapi_v3\",\n    validationEnabled: true,\n    source: std.file({\n        input: \"./schemas/petstore.json\",\n    }).then(invoke =\u003e invoke.result),\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\npetstore_schema = cloudflare.ApiShieldSchema(\"petstore_schema\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"myschema\",\n    kind=\"openapi_v3\",\n    validation_enabled=True,\n    source=std.file(input=\"./schemas/petstore.json\").result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var petstoreSchema = new Cloudflare.ApiShieldSchema(\"petstore_schema\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"myschema\",\n        Kind = \"openapi_v3\",\n        ValidationEnabled = true,\n        Source = Std.File.Invoke(new()\n        {\n            Input = \"./schemas/petstore.json\",\n        }).Apply(invoke =\u003e invoke.Result),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"./schemas/petstore.json\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewApiShieldSchema(ctx, \"petstore_schema\", \u0026cloudflare.ApiShieldSchemaArgs{\n\t\t\tZoneId:            pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:              pulumi.String(\"myschema\"),\n\t\t\tKind:              pulumi.String(\"openapi_v3\"),\n\t\t\tValidationEnabled: pulumi.Bool(true),\n\t\t\tSource:            pulumi.String(invokeFile.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ApiShieldSchema;\nimport com.pulumi.cloudflare.ApiShieldSchemaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var petstoreSchema = new ApiShieldSchema(\"petstoreSchema\", ApiShieldSchemaArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"myschema\")\n            .kind(\"openapi_v3\")\n            .validationEnabled(true)\n            .source(StdFunctions.file(FileArgs.builder()\n                .input(\"./schemas/petstore.json\")\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  petstoreSchema:\n    type: cloudflare:ApiShieldSchema\n    name: petstore_schema\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: myschema\n      kind: openapi_v3\n      validationEnabled: true # optional, default false\n      source:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: ./schemas/petstore.json\n          Return: result\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": "Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the schema. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "source": {
                    "type": "string",
                    "description": "Schema file bytes. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "validationEnabled": {
                    "type": "boolean",
                    "description": "Flag whether schema is enabled for validation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "name",
                "source",
                "zoneId"
            ],
            "inputProperties": {
                "kind": {
                    "type": "string",
                    "description": "Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the schema. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "description": "Schema file bytes. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "validationEnabled": {
                    "type": "boolean",
                    "description": "Flag whether schema is enabled for validation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "source",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiShieldSchema resources.\n",
                "properties": {
                    "kind": {
                        "type": "string",
                        "description": "Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the schema. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "source": {
                        "type": "string",
                        "description": "Schema file bytes. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "validationEnabled": {
                        "type": "boolean",
                        "description": "Flag whether schema is enabled for validation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiShieldSchemaValidationSettings:ApiShieldSchemaValidationSettings": {
            "description": "Provides a resource to manage settings in API Shield Schema Validation 2.0.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ApiShieldSchemaValidationSettings(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    validationDefaultMitigationAction: \"log\",\n    validationOverrideMitigationAction: \"none\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ApiShieldSchemaValidationSettings(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    validation_default_mitigation_action=\"log\",\n    validation_override_mitigation_action=\"none\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ApiShieldSchemaValidationSettings(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        ValidationDefaultMitigationAction = \"log\",\n        ValidationOverrideMitigationAction = \"none\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewApiShieldSchemaValidationSettings(ctx, \"example\", \u0026cloudflare.ApiShieldSchemaValidationSettingsArgs{\n\t\t\tZoneId:                             pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tValidationDefaultMitigationAction:  pulumi.String(\"log\"),\n\t\t\tValidationOverrideMitigationAction: pulumi.String(\"none\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ApiShieldSchemaValidationSettings;\nimport com.pulumi.cloudflare.ApiShieldSchemaValidationSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ApiShieldSchemaValidationSettings(\"example\", ApiShieldSchemaValidationSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .validationDefaultMitigationAction(\"log\")\n            .validationOverrideMitigationAction(\"none\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ApiShieldSchemaValidationSettings\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      validationDefaultMitigationAction: log\n      validationOverrideMitigationAction: none\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "validationDefaultMitigationAction": {
                    "type": "string",
                    "description": "The default mitigation action used when there is no mitigation action defined on the operation.\n"
                },
                "validationOverrideMitigationAction": {
                    "type": "string",
                    "description": "When set, this overrides both zone level and operation level mitigation actions.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "validationDefaultMitigationAction",
                "zoneId"
            ],
            "inputProperties": {
                "validationDefaultMitigationAction": {
                    "type": "string",
                    "description": "The default mitigation action used when there is no mitigation action defined on the operation.\n"
                },
                "validationOverrideMitigationAction": {
                    "type": "string",
                    "description": "When set, this overrides both zone level and operation level mitigation actions.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "validationDefaultMitigationAction",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiShieldSchemaValidationSettings resources.\n",
                "properties": {
                    "validationDefaultMitigationAction": {
                        "type": "string",
                        "description": "The default mitigation action used when there is no mitigation action defined on the operation.\n"
                    },
                    "validationOverrideMitigationAction": {
                        "type": "string",
                        "description": "When set, this overrides both zone level and operation level mitigation actions.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiToken:ApiToken": {
            "description": "Provides a resource which manages Cloudflare API tokens.\n\nRead more about permission groups and their applicable scopes in the\n[developer documentation](https://developers.cloudflare.com/api/tokens/create/permissions).\n\n",
            "properties": {
                "condition": {
                    "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                    "description": "Conditions under which the token should be considered valid.\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The expiration time on or after which the token MUST NOT be accepted for processing.\n"
                },
                "issuedOn": {
                    "type": "string",
                    "description": "Timestamp of when the token was issued.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Timestamp of when the token was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the API Token.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time before which the token MUST NOT be accepted for processing.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                    },
                    "description": "Permissions policy. Multiple policy blocks can be defined.\n"
                },
                "status": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the API Token.\n",
                    "secret": true
                }
            },
            "required": [
                "issuedOn",
                "modifiedOn",
                "name",
                "policies",
                "status",
                "value"
            ],
            "inputProperties": {
                "condition": {
                    "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                    "description": "Conditions under which the token should be considered valid.\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The expiration time on or after which the token MUST NOT be accepted for processing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the API Token.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time before which the token MUST NOT be accepted for processing.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                    },
                    "description": "Permissions policy. Multiple policy blocks can be defined.\n"
                }
            },
            "requiredInputs": [
                "name",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiToken resources.\n",
                "properties": {
                    "condition": {
                        "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                        "description": "Conditions under which the token should be considered valid.\n"
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "The expiration time on or after which the token MUST NOT be accepted for processing.\n"
                    },
                    "issuedOn": {
                        "type": "string",
                        "description": "Timestamp of when the token was issued.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Timestamp of when the token was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the API Token.\n"
                    },
                    "notBefore": {
                        "type": "string",
                        "description": "The time before which the token MUST NOT be accepted for processing.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                        },
                        "description": "Permissions policy. Multiple policy blocks can be defined.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the API Token.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/argo:Argo": {
            "description": "Cloudflare Argo controls the routing to your origin and tiered\ncaching options to speed up your website browsing experience.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Argo(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    tieredCaching: \"on\",\n    smartRouting: \"on\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Argo(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    tiered_caching=\"on\",\n    smart_routing=\"on\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Argo(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        TieredCaching = \"on\",\n        SmartRouting = \"on\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewArgo(ctx, \"example\", \u0026cloudflare.ArgoArgs{\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tTieredCaching: pulumi.String(\"on\"),\n\t\t\tSmartRouting:  pulumi.String(\"on\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Argo;\nimport com.pulumi.cloudflare.ArgoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Argo(\"example\", ArgoArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .tieredCaching(\"on\")\n            .smartRouting(\"on\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Argo\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      tieredCaching: on\n      smartRouting: on\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/argo:Argo example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Available values: `on`, `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Available values: `on`, `off`.\n",
                    "deprecationMessage": "tiered_caching has been deprecated in favour of using `cloudflare.TieredCache` resource instead."
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Available values: `on`, `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Available values: `on`, `off`.\n",
                    "deprecationMessage": "tiered_caching has been deprecated in favour of using `cloudflare.TieredCache` resource instead."
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Argo resources.\n",
                "properties": {
                    "smartRouting": {
                        "type": "string",
                        "description": "Whether smart routing is enabled. Available values: `on`, `off`.\n"
                    },
                    "tieredCaching": {
                        "type": "string",
                        "description": "Whether tiered caching is enabled. Available values: `on`, `off`.\n",
                        "deprecationMessage": "tiered_caching has been deprecated in favour of using `cloudflare.TieredCache` resource instead."
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls": {
            "description": "Provides a Cloudflare Authenticated Origin Pulls resource. A `cloudflare.AuthenticatedOriginPulls`\nresource is required to use Per-Zone or Per-Hostname Authenticated\nOrigin Pulls.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Authenticated Origin Pulls\nconst myAop = new cloudflare.AuthenticatedOriginPulls(\"my_aop\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n});\n// Per-Zone Authenticated Origin Pulls\nconst myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-zone\",\n});\nconst myPerZoneAop = new cloudflare.AuthenticatedOriginPulls(\"my_per_zone_aop\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    authenticatedOriginPullsCertificate: myPerZoneAopCert.id,\n    enabled: true,\n});\n// Per-Hostname Authenticated Origin Pulls\nconst myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-hostname\",\n});\nconst myPerHostnameAop = new cloudflare.AuthenticatedOriginPulls(\"my_per_hostname_aop\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    authenticatedOriginPullsCertificate: myPerHostnameAopCert.id,\n    hostname: \"aop.example.com\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Authenticated Origin Pulls\nmy_aop = cloudflare.AuthenticatedOriginPulls(\"my_aop\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True)\n# Per-Zone Authenticated Origin Pulls\nmy_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-zone\")\nmy_per_zone_aop = cloudflare.AuthenticatedOriginPulls(\"my_per_zone_aop\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    authenticated_origin_pulls_certificate=my_per_zone_aop_cert.id,\n    enabled=True)\n# Per-Hostname Authenticated Origin Pulls\nmy_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-hostname\")\nmy_per_hostname_aop = cloudflare.AuthenticatedOriginPulls(\"my_per_hostname_aop\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    authenticated_origin_pulls_certificate=my_per_hostname_aop_cert.id,\n    hostname=\"aop.example.com\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Authenticated Origin Pulls\n    var myAop = new Cloudflare.AuthenticatedOriginPulls(\"my_aop\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n    });\n\n    // Per-Zone Authenticated Origin Pulls\n    var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-zone\",\n    });\n\n    var myPerZoneAop = new Cloudflare.AuthenticatedOriginPulls(\"my_per_zone_aop\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        AuthenticatedOriginPullsCertificate = myPerZoneAopCert.Id,\n        Enabled = true,\n    });\n\n    // Per-Hostname Authenticated Origin Pulls\n    var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-hostname\",\n    });\n\n    var myPerHostnameAop = new Cloudflare.AuthenticatedOriginPulls(\"my_per_hostname_aop\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        AuthenticatedOriginPullsCertificate = myPerHostnameAopCert.Id,\n        Hostname = \"aop.example.com\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Authenticated Origin Pulls\n\t\t_, err := cloudflare.NewAuthenticatedOriginPulls(ctx, \"my_aop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Per-Zone Authenticated Origin Pulls\n\t\tmyPerZoneAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"my_per_zone_aop_cert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-zone\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, \"my_per_zone_aop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:                              pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tAuthenticatedOriginPullsCertificate: myPerZoneAopCert.ID(),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Per-Hostname Authenticated Origin Pulls\n\t\tmyPerHostnameAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"my_per_hostname_aop_cert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-hostname\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, \"my_per_hostname_aop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:                              pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tAuthenticatedOriginPullsCertificate: myPerHostnameAopCert.ID(),\n\t\t\tHostname:                            pulumi.String(\"aop.example.com\"),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AuthenticatedOriginPulls;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsArgs;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificate;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Authenticated Origin Pulls\n        var myAop = new AuthenticatedOriginPulls(\"myAop\", AuthenticatedOriginPullsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(true)\n            .build());\n\n        // Per-Zone Authenticated Origin Pulls\n        var myPerZoneAopCert = new AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-zone\")\n            .build());\n\n        var myPerZoneAop = new AuthenticatedOriginPulls(\"myPerZoneAop\", AuthenticatedOriginPullsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .authenticatedOriginPullsCertificate(myPerZoneAopCert.id())\n            .enabled(true)\n            .build());\n\n        // Per-Hostname Authenticated Origin Pulls\n        var myPerHostnameAopCert = new AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-hostname\")\n            .build());\n\n        var myPerHostnameAop = new AuthenticatedOriginPulls(\"myPerHostnameAop\", AuthenticatedOriginPullsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .authenticatedOriginPullsCertificate(myPerHostnameAopCert.id())\n            .hostname(\"aop.example.com\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Authenticated Origin Pulls\n  myAop:\n    type: cloudflare:AuthenticatedOriginPulls\n    name: my_aop\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: true\n  # Per-Zone Authenticated Origin Pulls\n  myPerZoneAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    name: my_per_zone_aop_cert\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-zone\n  myPerZoneAop:\n    type: cloudflare:AuthenticatedOriginPulls\n    name: my_per_zone_aop\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      authenticatedOriginPullsCertificate: ${myPerZoneAopCert.id}\n      enabled: true\n  # Per-Hostname Authenticated Origin Pulls\n  myPerHostnameAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    name: my_per_hostname_aop_cert\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-hostname\n  myPerHostnameAop:\n    type: cloudflare:AuthenticatedOriginPulls\n    name: my_per_hostname_aop\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      authenticatedOriginPullsCertificate: ${myPerHostnameAopCert.id}\n      hostname: aop.example.com\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nglobal\n\n```sh\n$ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example \u003czone_id\u003e\n```\n\nper zone\n\n```sh\n$ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example \u003czone_id\u003e/\u003ccertificate_id\u003e\n```\n\nper hostname\n\n```sh\n$ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example \u003czone_id\u003e/\u003ccertificate_id\u003e/\u003chostname\u003e\n```\n\n",
            "properties": {
                "authenticatedOriginPullsCertificate": {
                    "type": "string",
                    "description": "The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "authenticatedOriginPullsCertificate": {
                    "type": "string",
                    "description": "The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthenticatedOriginPulls resources.\n",
                "properties": {
                    "authenticatedOriginPullsCertificate": {
                        "type": "string",
                        "description": "The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate": {
            "description": "Provides a Cloudflare Authenticated Origin Pulls certificate\nresource. An uploaded client certificate is required to use Per-Zone\n or Per-Hostname Authenticated Origin Pulls.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Per-Zone Authenticated Origin Pulls certificate\nconst myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-zone\",\n});\n// Per-Hostname Authenticated Origin Pulls certificate\nconst myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-hostname\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Per-Zone Authenticated Origin Pulls certificate\nmy_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-zone\")\n# Per-Hostname Authenticated Origin Pulls certificate\nmy_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-hostname\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Per-Zone Authenticated Origin Pulls certificate\n    var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-zone\",\n    });\n\n    // Per-Hostname Authenticated Origin Pulls certificate\n    var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-hostname\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Per-Zone Authenticated Origin Pulls certificate\n\t\t_, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"my_per_zone_aop_cert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-zone\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Per-Hostname Authenticated Origin Pulls certificate\n\t\t_, err = cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"my_per_hostname_aop_cert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-hostname\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificate;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Per-Zone Authenticated Origin Pulls certificate\n        var myPerZoneAopCert = new AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-zone\")\n            .build());\n\n        // Per-Hostname Authenticated Origin Pulls certificate\n        var myPerHostnameAopCert = new AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-hostname\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Per-Zone Authenticated Origin Pulls certificate\n  myPerZoneAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    name: my_per_zone_aop_cert\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-zone\n  # Per-Hostname Authenticated Origin Pulls certificate\n  myPerHostnameAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    name: my_per_hostname_aop_cert\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-hostname\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate example \u003czone_id\u003e/\u003ccertificate_type\u003e/\u003ccertificate_id\u003e\n```\n\n",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The public client certificate. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                },
                "serialNumber": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "signature": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "status": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "type": {
                    "type": "string",
                    "description": "The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "uploadedOn": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "certificate",
                "expiresOn",
                "issuer",
                "privateKey",
                "serialNumber",
                "signature",
                "status",
                "type",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "The public client certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthenticatedOriginPullsCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The public client certificate. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "issuer": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "uploadedOn": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/botManagement:BotManagement": {
            "description": "Provides a resource to configure Bot Management.\n\nSpecifically, this resource can be used to manage:\n\n- **Bot Fight Mode**\n- **Super Bot Fight Mode**\n- **Bot Management for Enterprise**\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.BotManagement(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enableJs: true,\n    sbfmDefinitelyAutomated: \"block\",\n    sbfmLikelyAutomated: \"managed_challenge\",\n    sbfmVerifiedBots: \"allow\",\n    sbfmStaticResourceProtection: false,\n    optimizeWordpress: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.BotManagement(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enable_js=True,\n    sbfm_definitely_automated=\"block\",\n    sbfm_likely_automated=\"managed_challenge\",\n    sbfm_verified_bots=\"allow\",\n    sbfm_static_resource_protection=False,\n    optimize_wordpress=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.BotManagement(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        EnableJs = true,\n        SbfmDefinitelyAutomated = \"block\",\n        SbfmLikelyAutomated = \"managed_challenge\",\n        SbfmVerifiedBots = \"allow\",\n        SbfmStaticResourceProtection = false,\n        OptimizeWordpress = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewBotManagement(ctx, \"example\", \u0026cloudflare.BotManagementArgs{\n\t\t\tZoneId:                       pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnableJs:                     pulumi.Bool(true),\n\t\t\tSbfmDefinitelyAutomated:      pulumi.String(\"block\"),\n\t\t\tSbfmLikelyAutomated:          pulumi.String(\"managed_challenge\"),\n\t\t\tSbfmVerifiedBots:             pulumi.String(\"allow\"),\n\t\t\tSbfmStaticResourceProtection: pulumi.Bool(false),\n\t\t\tOptimizeWordpress:            pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.BotManagement;\nimport com.pulumi.cloudflare.BotManagementArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new BotManagement(\"example\", BotManagementArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enableJs(true)\n            .sbfmDefinitelyAutomated(\"block\")\n            .sbfmLikelyAutomated(\"managed_challenge\")\n            .sbfmVerifiedBots(\"allow\")\n            .sbfmStaticResourceProtection(false)\n            .optimizeWordpress(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:BotManagement\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enableJs: true\n      sbfmDefinitelyAutomated: block\n      sbfmLikelyAutomated: managed_challenge\n      sbfmVerifiedBots: allow\n      sbfmStaticResourceProtection: false\n      optimizeWordpress: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/botManagement:BotManagement example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "aiBotsProtection": {
                    "type": "string",
                    "description": "Enable rule to block AI Scrapers and Crawlers.\n"
                },
                "autoUpdateModel": {
                    "type": "boolean",
                    "description": "Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).\n"
                },
                "enableJs": {
                    "type": "boolean",
                    "description": "Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).\n"
                },
                "fightMode": {
                    "type": "boolean",
                    "description": "Whether to enable Bot Fight Mode.\n"
                },
                "optimizeWordpress": {
                    "type": "boolean",
                    "description": "Whether to optimize Super Bot Fight Mode protections for Wordpress.\n"
                },
                "sbfmDefinitelyAutomated": {
                    "type": "string",
                    "description": "Super Bot Fight Mode (SBFM) action to take on definitely automated requests.\n"
                },
                "sbfmLikelyAutomated": {
                    "type": "string",
                    "description": "Super Bot Fight Mode (SBFM) action to take on likely automated requests.\n"
                },
                "sbfmStaticResourceProtection": {
                    "type": "boolean",
                    "description": "Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.\n"
                },
                "sbfmVerifiedBots": {
                    "type": "string",
                    "description": "Super Bot Fight Mode (SBFM) action to take on verified bots requests.\n"
                },
                "suppressSessionScore": {
                    "type": "boolean",
                    "description": "Whether to disable tracking the highest bot score for a session in the Bot Management cookie.\n"
                },
                "usingLatestModel": {
                    "type": "boolean",
                    "description": "A read-only field that indicates whether the zone currently is running the latest ML model.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "aiBotsProtection",
                "usingLatestModel",
                "zoneId"
            ],
            "inputProperties": {
                "aiBotsProtection": {
                    "type": "string",
                    "description": "Enable rule to block AI Scrapers and Crawlers.\n"
                },
                "autoUpdateModel": {
                    "type": "boolean",
                    "description": "Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).\n"
                },
                "enableJs": {
                    "type": "boolean",
                    "description": "Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).\n"
                },
                "fightMode": {
                    "type": "boolean",
                    "description": "Whether to enable Bot Fight Mode.\n"
                },
                "optimizeWordpress": {
                    "type": "boolean",
                    "description": "Whether to optimize Super Bot Fight Mode protections for Wordpress.\n"
                },
                "sbfmDefinitelyAutomated": {
                    "type": "string",
                    "description": "Super Bot Fight Mode (SBFM) action to take on definitely automated requests.\n"
                },
                "sbfmLikelyAutomated": {
                    "type": "string",
                    "description": "Super Bot Fight Mode (SBFM) action to take on likely automated requests.\n"
                },
                "sbfmStaticResourceProtection": {
                    "type": "boolean",
                    "description": "Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.\n"
                },
                "sbfmVerifiedBots": {
                    "type": "string",
                    "description": "Super Bot Fight Mode (SBFM) action to take on verified bots requests.\n"
                },
                "suppressSessionScore": {
                    "type": "boolean",
                    "description": "Whether to disable tracking the highest bot score for a session in the Bot Management cookie.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BotManagement resources.\n",
                "properties": {
                    "aiBotsProtection": {
                        "type": "string",
                        "description": "Enable rule to block AI Scrapers and Crawlers.\n"
                    },
                    "autoUpdateModel": {
                        "type": "boolean",
                        "description": "Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).\n"
                    },
                    "enableJs": {
                        "type": "boolean",
                        "description": "Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).\n"
                    },
                    "fightMode": {
                        "type": "boolean",
                        "description": "Whether to enable Bot Fight Mode.\n"
                    },
                    "optimizeWordpress": {
                        "type": "boolean",
                        "description": "Whether to optimize Super Bot Fight Mode protections for Wordpress.\n"
                    },
                    "sbfmDefinitelyAutomated": {
                        "type": "string",
                        "description": "Super Bot Fight Mode (SBFM) action to take on definitely automated requests.\n"
                    },
                    "sbfmLikelyAutomated": {
                        "type": "string",
                        "description": "Super Bot Fight Mode (SBFM) action to take on likely automated requests.\n"
                    },
                    "sbfmStaticResourceProtection": {
                        "type": "boolean",
                        "description": "Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.\n"
                    },
                    "sbfmVerifiedBots": {
                        "type": "string",
                        "description": "Super Bot Fight Mode (SBFM) action to take on verified bots requests.\n"
                    },
                    "suppressSessionScore": {
                        "type": "boolean",
                        "description": "Whether to disable tracking the highest bot score for a session in the Bot Management cookie.\n"
                    },
                    "usingLatestModel": {
                        "type": "boolean",
                        "description": "A read-only field that indicates whether the zone currently is running the latest ML model.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/byoIpPrefix:ByoIpPrefix": {
            "description": "Provides the ability to manage Bring-Your-Own-IP prefixes (BYOIP)\nwhich are used with or without Magic Transit.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ByoIpPrefix(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    prefixId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Example IP Prefix\",\n    advertisement: \"on\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ByoIpPrefix(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    prefix_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Example IP Prefix\",\n    advertisement=\"on\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ByoIpPrefix(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        PrefixId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Description = \"Example IP Prefix\",\n        Advertisement = \"on\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewByoIpPrefix(ctx, \"example\", \u0026cloudflare.ByoIpPrefixArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tPrefixId:      pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription:   pulumi.String(\"Example IP Prefix\"),\n\t\t\tAdvertisement: pulumi.String(\"on\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ByoIpPrefix;\nimport com.pulumi.cloudflare.ByoIpPrefixArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ByoIpPrefix(\"example\", ByoIpPrefixArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .prefixId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .description(\"Example IP Prefix\")\n            .advertisement(\"on\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ByoIpPrefix\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      prefixId: d41d8cd98f00b204e9800998ecf8427e\n      description: Example IP Prefix\n      advertisement: on\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/byoIpPrefix:ByoIpPrefix example \u003caccount_id\u003e/\u003cprefix_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the BYO IP prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "advertisement",
                "description",
                "prefixId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the BYO IP prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "prefixId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ByoIpPrefix resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "advertisement": {
                        "type": "string",
                        "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the BYO IP prefix.\n"
                    },
                    "prefixId": {
                        "type": "string",
                        "description": "The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/certificatePack:CertificatePack": {
            "description": "## Example Usage\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/certificatePack:CertificatePack example \u003czone_id\u003e/\u003ccertificate_pack_id\u003e\n```\n\nWhile supported, importing isn't recommended and it is advised to replace the\n\ncertificate entirely instead.\n\n",
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`, `ssl_com`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "cloudflareBranding": {
                    "type": "boolean",
                    "description": "Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "type": {
                    "type": "string",
                    "description": "Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "validationErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationError:CertificatePackValidationError"
                    }
                },
                "validationMethod": {
                    "type": "string",
                    "description": "Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "validationRecords": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord"
                    }
                },
                "validityDays": {
                    "type": "integer",
                    "description": "How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "waitForActiveStatus": {
                    "type": "boolean",
                    "description": "Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "certificateAuthority",
                "hosts",
                "type",
                "validationErrors",
                "validationMethod",
                "validationRecords",
                "validityDays",
                "zoneId"
            ],
            "inputProperties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`, `ssl_com`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "cloudflareBranding": {
                    "type": "boolean",
                    "description": "Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "validationErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationError:CertificatePackValidationError"
                    }
                },
                "validationMethod": {
                    "type": "string",
                    "description": "Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "validationRecords": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord"
                    }
                },
                "validityDays": {
                    "type": "integer",
                    "description": "How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "waitForActiveStatus": {
                    "type": "boolean",
                    "description": "Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "certificateAuthority",
                "hosts",
                "type",
                "validationMethod",
                "validityDays",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertificatePack resources.\n",
                "properties": {
                    "certificateAuthority": {
                        "type": "string",
                        "description": "Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`, `ssl_com`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudflareBranding": {
                        "type": "boolean",
                        "description": "Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "validationErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CertificatePackValidationError:CertificatePackValidationError"
                        }
                    },
                    "validationMethod": {
                        "type": "string",
                        "description": "Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "validationRecords": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord"
                        }
                    },
                    "validityDays": {
                        "type": "integer",
                        "description": "How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "waitForActiveStatus": {
                        "type": "boolean",
                        "description": "Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/cloudConnectorRules:CloudConnectorRules": {
            "description": "The Cloud Connector Rules resource allows you to create and manage cloud connector rules for a zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudConnectorRules;\nimport com.pulumi.cloudflare.CloudConnectorRulesArgs;\nimport com.pulumi.cloudflare.inputs.CloudConnectorRulesRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudConnectorRules(\"example\", CloudConnectorRulesArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .rules(CloudConnectorRulesRuleArgs.builder()\n                .description(\"connect aws bucket\")\n                .enabled(true)\n                .expression(\"http.uri\")\n                .provider(\"aws_s3\")\n                .parameters(CloudConnectorRulesRuleParametersArgs.builder()\n                    .host(\"mystorage.s3.ams.amazonaws.com\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:CloudConnectorRules\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      rules:\n        - description: connect aws bucket\n          enabled: true\n          expression: http.uri\n          provider: aws_s3\n          parameters:\n            - host: mystorage.s3.ams.amazonaws.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CloudConnectorRulesRule:CloudConnectorRulesRule"
                    },
                    "description": "List of Cloud Connector Rules\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CloudConnectorRulesRule:CloudConnectorRulesRule"
                    },
                    "description": "List of Cloud Connector Rules\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudConnectorRules resources.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CloudConnectorRulesRule:CloudConnectorRulesRule"
                        },
                        "description": "List of Cloud Connector Rules\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customHostname:CustomHostname": {
            "description": "Provides a Cloudflare custom hostname (also known as SSL for SaaS) resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.CustomHostname(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname: \"hostname.example.com\",\n    ssls: [{\n        method: \"txt\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.CustomHostname(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname=\"hostname.example.com\",\n    ssls=[{\n        \"method\": \"txt\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.CustomHostname(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Hostname = \"hostname.example.com\",\n        Ssls = new[]\n        {\n            new Cloudflare.Inputs.CustomHostnameSslArgs\n            {\n                Method = \"txt\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomHostname(ctx, \"example\", \u0026cloudflare.CustomHostnameArgs{\n\t\t\tZoneId:   pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tHostname: pulumi.String(\"hostname.example.com\"),\n\t\t\tSsls: cloudflare.CustomHostnameSslArray{\n\t\t\t\t\u0026cloudflare.CustomHostnameSslArgs{\n\t\t\t\t\tMethod: pulumi.String(\"txt\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomHostname;\nimport com.pulumi.cloudflare.CustomHostnameArgs;\nimport com.pulumi.cloudflare.inputs.CustomHostnameSslArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CustomHostname(\"example\", CustomHostnameArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .hostname(\"hostname.example.com\")\n            .ssls(CustomHostnameSslArgs.builder()\n                .method(\"txt\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:CustomHostname\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      hostname: hostname.example.com\n      ssls:\n        - method: txt\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/customHostname:CustomHostname example 1d5fdc9e88c8a8c4518b068cd94331fe/0d89c70d-ad9f-4843-b99f-6cc0252067e9\n```\n\n",
            "properties": {
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.\n"
                },
                "customOriginServer": {
                    "type": "string",
                    "description": "The custom origin server used for certificates.\n"
                },
                "customOriginSni": {
                    "type": "string",
                    "description": "The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ownershipVerification": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ownershipVerificationHttp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ssls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                    },
                    "description": "SSL properties used when creating the custom hostname.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the certificate.\n"
                },
                "waitForSslPendingValidation": {
                    "type": "boolean",
                    "description": "Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "hostname",
                "ownershipVerification",
                "ownershipVerificationHttp",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.\n"
                },
                "customOriginServer": {
                    "type": "string",
                    "description": "The custom origin server used for certificates.\n"
                },
                "customOriginSni": {
                    "type": "string",
                    "description": "The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "ssls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                    },
                    "description": "SSL properties used when creating the custom hostname.\n"
                },
                "waitForSslPendingValidation": {
                    "type": "boolean",
                    "description": "Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostname",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomHostname resources.\n",
                "properties": {
                    "customMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.\n"
                    },
                    "customOriginServer": {
                        "type": "string",
                        "description": "The custom origin server used for certificates.\n"
                    },
                    "customOriginSni": {
                        "type": "string",
                        "description": "The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ownershipVerification": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "ownershipVerificationHttp": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "ssls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                        },
                        "description": "SSL properties used when creating the custom hostname.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the certificate.\n"
                    },
                    "waitForSslPendingValidation": {
                        "type": "boolean",
                        "description": "Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin": {
            "description": "Provides a Cloudflare custom hostname fallback origin resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.CustomHostnameFallbackOrigin(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    origin: \"fallback.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.CustomHostnameFallbackOrigin(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    origin=\"fallback.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.CustomHostnameFallbackOrigin(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Origin = \"fallback.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomHostnameFallbackOrigin(ctx, \"example\", \u0026cloudflare.CustomHostnameFallbackOriginArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tOrigin: pulumi.String(\"fallback.example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomHostnameFallbackOrigin;\nimport com.pulumi.cloudflare.CustomHostnameFallbackOriginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CustomHostnameFallbackOrigin(\"example\", CustomHostnameFallbackOriginArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .origin(\"fallback.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:CustomHostnameFallbackOrigin\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      origin: fallback.example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin example \u003czone_id\u003e/\u003cfallback_hostname\u003e\n```\n\n",
            "properties": {
                "origin": {
                    "type": "string",
                    "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the fallback origin's activation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "origin",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "origin": {
                    "type": "string",
                    "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "origin",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomHostnameFallbackOrigin resources.\n",
                "properties": {
                    "origin": {
                        "type": "string",
                        "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the fallback origin's activation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customPages:CustomPages": {
            "description": "Provides a resource which manages Cloudflare custom error pages.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.CustomPages(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    type: \"basic_challenge\",\n    url: \"https://example.com/challenge.html\",\n    state: \"customized\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.CustomPages(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    type=\"basic_challenge\",\n    url=\"https://example.com/challenge.html\",\n    state=\"customized\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.CustomPages(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Type = \"basic_challenge\",\n        Url = \"https://example.com/challenge.html\",\n        State = \"customized\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomPages(ctx, \"example\", \u0026cloudflare.CustomPagesArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tType:   pulumi.String(\"basic_challenge\"),\n\t\t\tUrl:    pulumi.String(\"https://example.com/challenge.html\"),\n\t\t\tState:  pulumi.String(\"customized\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomPages;\nimport com.pulumi.cloudflare.CustomPagesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CustomPages(\"example\", CustomPagesArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .type(\"basic_challenge\")\n            .url(\"https://example.com/challenge.html\")\n            .state(\"customized\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:CustomPages\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      type: basic_challenge\n      url: https://example.com/challenge.html\n      state: customized\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/customPages:CustomPages example \u003cresource_level\u003e/\u003cresource_id\u003e/\u003ccustom_page_type\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Managed state of the custom page. Available values: `default`, `customized`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "type",
                "url"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Managed state of the custom page. Available values: `default`, `customized`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "type",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomPages resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Managed state of the custom page. Available values: `default`, `customized`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "URL of where the custom page source is located.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customSsl:CustomSsl": {
            "description": "Provides a Cloudflare custom SSL resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.CustomSsl(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    customSslOptions: {\n        certificate: \"-----INSERT CERTIFICATE-----\",\n        privateKey: \"-----INSERT PRIVATE KEY-----\",\n        bundleMethod: \"ubiquitous\",\n        geoRestrictions: \"us\",\n        type: \"legacy_custom\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.CustomSsl(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    custom_ssl_options={\n        \"certificate\": \"-----INSERT CERTIFICATE-----\",\n        \"private_key\": \"-----INSERT PRIVATE KEY-----\",\n        \"bundle_method\": \"ubiquitous\",\n        \"geo_restrictions\": \"us\",\n        \"type\": \"legacy_custom\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.CustomSsl(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        CustomSslOptions = new Cloudflare.Inputs.CustomSslCustomSslOptionsArgs\n        {\n            Certificate = \"-----INSERT CERTIFICATE-----\",\n            PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n            BundleMethod = \"ubiquitous\",\n            GeoRestrictions = \"us\",\n            Type = \"legacy_custom\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomSsl(ctx, \"example\", \u0026cloudflare.CustomSslArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tCustomSslOptions: \u0026cloudflare.CustomSslCustomSslOptionsArgs{\n\t\t\t\tCertificate:     pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\t\tPrivateKey:      pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\t\tBundleMethod:    pulumi.String(\"ubiquitous\"),\n\t\t\t\tGeoRestrictions: pulumi.String(\"us\"),\n\t\t\t\tType:            pulumi.String(\"legacy_custom\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomSsl;\nimport com.pulumi.cloudflare.CustomSslArgs;\nimport com.pulumi.cloudflare.inputs.CustomSslCustomSslOptionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CustomSsl(\"example\", CustomSslArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .customSslOptions(CustomSslCustomSslOptionsArgs.builder()\n                .certificate(\"-----INSERT CERTIFICATE-----\")\n                .privateKey(\"-----INSERT PRIVATE KEY-----\")\n                .bundleMethod(\"ubiquitous\")\n                .geoRestrictions(\"us\")\n                .type(\"legacy_custom\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:CustomSsl\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      customSslOptions:\n        certificate: '-----INSERT CERTIFICATE-----'\n        privateKey: '-----INSERT PRIVATE KEY-----'\n        bundleMethod: ubiquitous\n        geoRestrictions: us\n        type: legacy_custom\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/customSsl:CustomSsl example \u003czone_id\u003e/\u003ccertificate_id\u003e\n```\n\n",
            "properties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "expiresOn": {
                    "type": "string"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "issuer": {
                    "type": "string"
                },
                "modifiedOn": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "signature": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "expiresOn",
                "hosts",
                "issuer",
                "modifiedOn",
                "priority",
                "signature",
                "status",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomSsl resources.\n",
                "properties": {
                    "customSslOptions": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                        "description": "The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "customSslPriorities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                        }
                    },
                    "expiresOn": {
                        "type": "string"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "modifiedOn": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    },
                    "uploadedOn": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/d1Database:D1Database": {
            "description": "The [D1 Database](https://developers.cloudflare.com/d1/) resource allows you to manage Cloudflare D1 databases.\n\n!\u003e When a D1 Database is replaced all the data is lost. Please ensure you have a\n   backup of your data before replacing a D1 Database.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.D1Database(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"terraform-database\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.D1Database(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"terraform-database\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.D1Database(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"terraform-database\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewD1Database(ctx, \"example\", \u0026cloudflare.D1DatabaseArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"terraform-database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.D1Database;\nimport com.pulumi.cloudflare.D1DatabaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new D1Database(\"example\", D1DatabaseArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"terraform-database\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:D1Database\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: terraform-database\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/d1Database:D1Database example \u003caccount id\u003e/\u003cdatabase id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the D1 Database.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The backend version of the database.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "version"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the D1 Database.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering D1Database resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the D1 Database.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The backend version of the database.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/deviceDexTest:DeviceDexTest": {
            "description": "Provides a Cloudflare Device Dex Test resource. Device Dex Tests allow for building location-aware device settings policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.DeviceDexTest(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"GET homepage\",\n    description: \"Send a HTTP GET request to the home endpoint every half hour.\",\n    interval: \"0h30m0s\",\n    enabled: true,\n    data: {\n        host: \"https://example.com/home\",\n        kind: \"http\",\n        method: \"GET\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.DeviceDexTest(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"GET homepage\",\n    description=\"Send a HTTP GET request to the home endpoint every half hour.\",\n    interval=\"0h30m0s\",\n    enabled=True,\n    data={\n        \"host\": \"https://example.com/home\",\n        \"kind\": \"http\",\n        \"method\": \"GET\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.DeviceDexTest(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"GET homepage\",\n        Description = \"Send a HTTP GET request to the home endpoint every half hour.\",\n        Interval = \"0h30m0s\",\n        Enabled = true,\n        Data = new Cloudflare.Inputs.DeviceDexTestDataArgs\n        {\n            Host = \"https://example.com/home\",\n            Kind = \"http\",\n            Method = \"GET\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDeviceDexTest(ctx, \"example\", \u0026cloudflare.DeviceDexTestArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"GET homepage\"),\n\t\t\tDescription: pulumi.String(\"Send a HTTP GET request to the home endpoint every half hour.\"),\n\t\t\tInterval:    pulumi.String(\"0h30m0s\"),\n\t\t\tEnabled:     pulumi.Bool(true),\n\t\t\tData: \u0026cloudflare.DeviceDexTestDataArgs{\n\t\t\t\tHost:   pulumi.String(\"https://example.com/home\"),\n\t\t\t\tKind:   pulumi.String(\"http\"),\n\t\t\t\tMethod: pulumi.String(\"GET\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DeviceDexTest;\nimport com.pulumi.cloudflare.DeviceDexTestArgs;\nimport com.pulumi.cloudflare.inputs.DeviceDexTestDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DeviceDexTest(\"example\", DeviceDexTestArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"GET homepage\")\n            .description(\"Send a HTTP GET request to the home endpoint every half hour.\")\n            .interval(\"0h30m0s\")\n            .enabled(true)\n            .data(DeviceDexTestDataArgs.builder()\n                .host(\"https://example.com/home\")\n                .kind(\"http\")\n                .method(\"GET\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:DeviceDexTest\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: GET homepage\n      description: Send a HTTP GET request to the home endpoint every half hour.\n      interval: 0h30m0s\n      enabled: true\n      data:\n        host: https://example.com/home\n        kind: http\n        method: GET\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/deviceDexTest:DeviceDexTest example \u003caccount_id\u003e/\u003cdevice_dex_test_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp of when the Dex Test was created.\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/DeviceDexTestData:DeviceDexTestData",
                    "description": "The configuration object which contains the details for the WARP client to conduct the test.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Additional details about the test.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines whether or not the test is active.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "How often the test will run.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Dex Test. Must be unique.\n"
                },
                "updated": {
                    "type": "string",
                    "description": "Timestamp of when the Dex Test was last updated.\n"
                }
            },
            "required": [
                "accountId",
                "created",
                "data",
                "description",
                "enabled",
                "interval",
                "name",
                "updated"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/DeviceDexTestData:DeviceDexTestData",
                    "description": "The configuration object which contains the details for the WARP client to conduct the test.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Additional details about the test.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines whether or not the test is active.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "How often the test will run.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Dex Test. Must be unique.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "data",
                "description",
                "enabled",
                "interval",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeviceDexTest resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "created": {
                        "type": "string",
                        "description": "Timestamp of when the Dex Test was created.\n"
                    },
                    "data": {
                        "$ref": "#/types/cloudflare:index/DeviceDexTestData:DeviceDexTestData",
                        "description": "The configuration object which contains the details for the WARP client to conduct the test.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Additional details about the test.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines whether or not the test is active.\n"
                    },
                    "interval": {
                        "type": "string",
                        "description": "How often the test will run.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Device Dex Test. Must be unique.\n"
                    },
                    "updated": {
                        "type": "string",
                        "description": "Timestamp of when the Dex Test was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/deviceManagedNetworks:DeviceManagedNetworks": {
            "description": "Provides a Cloudflare Device Managed Network resource. Device managed networks allow for building location-aware device settings policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst managedNetworks = new cloudflare.DeviceManagedNetworks(\"managed_networks\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"managed-network-1\",\n    type: \"tls\",\n    config: {\n        tlsSockaddr: \"foobar:1234\",\n        sha256: \"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmanaged_networks = cloudflare.DeviceManagedNetworks(\"managed_networks\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"managed-network-1\",\n    type=\"tls\",\n    config={\n        \"tls_sockaddr\": \"foobar:1234\",\n        \"sha256\": \"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var managedNetworks = new Cloudflare.DeviceManagedNetworks(\"managed_networks\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"managed-network-1\",\n        Type = \"tls\",\n        Config = new Cloudflare.Inputs.DeviceManagedNetworksConfigArgs\n        {\n            TlsSockaddr = \"foobar:1234\",\n            Sha256 = \"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDeviceManagedNetworks(ctx, \"managed_networks\", \u0026cloudflare.DeviceManagedNetworksArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"managed-network-1\"),\n\t\t\tType:      pulumi.String(\"tls\"),\n\t\t\tConfig: \u0026cloudflare.DeviceManagedNetworksConfigArgs{\n\t\t\t\tTlsSockaddr: pulumi.String(\"foobar:1234\"),\n\t\t\t\tSha256:      pulumi.String(\"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DeviceManagedNetworks;\nimport com.pulumi.cloudflare.DeviceManagedNetworksArgs;\nimport com.pulumi.cloudflare.inputs.DeviceManagedNetworksConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var managedNetworks = new DeviceManagedNetworks(\"managedNetworks\", DeviceManagedNetworksArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"managed-network-1\")\n            .type(\"tls\")\n            .config(DeviceManagedNetworksConfigArgs.builder()\n                .tlsSockaddr(\"foobar:1234\")\n                .sha256(\"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  managedNetworks:\n    type: cloudflare:DeviceManagedNetworks\n    name: managed_networks\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: managed-network-1\n      type: tls\n      config:\n        tlsSockaddr: foobar:1234\n        sha256: b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/deviceManagedNetworks:DeviceManagedNetworks example \u003caccount_id\u003e/\u003cdevice_managed_networks_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/DeviceManagedNetworksConfig:DeviceManagedNetworksConfig",
                    "description": "The configuration containing information for the WARP client to detect the managed network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Managed Network. Must be unique.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of Device Managed Network. Available values: `tls`.\n"
                }
            },
            "required": [
                "accountId",
                "config",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/DeviceManagedNetworksConfig:DeviceManagedNetworksConfig",
                    "description": "The configuration containing information for the WARP client to detect the managed network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Managed Network. Must be unique.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of Device Managed Network. Available values: `tls`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "config",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeviceManagedNetworks resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "config": {
                        "$ref": "#/types/cloudflare:index/DeviceManagedNetworksConfig:DeviceManagedNetworksConfig",
                        "description": "The configuration containing information for the WARP client to detect the managed network.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Device Managed Network. Must be unique.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of Device Managed Network. Available values: `tls`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates": {
            "description": "Provides a Cloudflare device policy certificates resource. Device\npolicy certificate resources enable client device certificate\ngeneration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.DevicePolicyCertificates(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.DevicePolicyCertificates(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.DevicePolicyCertificates(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePolicyCertificates(ctx, \"example\", \u0026cloudflare.DevicePolicyCertificatesArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DevicePolicyCertificates;\nimport com.pulumi.cloudflare.DevicePolicyCertificatesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DevicePolicyCertificates(\"example\", DevicePolicyCertificatesArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:DevicePolicyCertificates\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if certificate generation is enabled.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if certificate generation is enabled.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePolicyCertificates resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "`true` if certificate generation is enabled.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePostureIntegration:DevicePostureIntegration": {
            "description": "Provides a Cloudflare Device Posture Integration resource. Device\nposture integrations configure third-party data providers for device\nposture rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.DevicePostureIntegration(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Device posture integration\",\n    type: \"workspace_one\",\n    interval: \"24h\",\n    configs: [{\n        apiUrl: \"https://example.com/api\",\n        authUrl: \"https://example.com/connect/token\",\n        clientId: \"client-id\",\n        clientSecret: \"client-secret\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.DevicePostureIntegration(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Device posture integration\",\n    type=\"workspace_one\",\n    interval=\"24h\",\n    configs=[{\n        \"api_url\": \"https://example.com/api\",\n        \"auth_url\": \"https://example.com/connect/token\",\n        \"client_id\": \"client-id\",\n        \"client_secret\": \"client-secret\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.DevicePostureIntegration(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Device posture integration\",\n        Type = \"workspace_one\",\n        Interval = \"24h\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.DevicePostureIntegrationConfigArgs\n            {\n                ApiUrl = \"https://example.com/api\",\n                AuthUrl = \"https://example.com/connect/token\",\n                ClientId = \"client-id\",\n                ClientSecret = \"client-secret\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePostureIntegration(ctx, \"example\", \u0026cloudflare.DevicePostureIntegrationArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"Device posture integration\"),\n\t\t\tType:      pulumi.String(\"workspace_one\"),\n\t\t\tInterval:  pulumi.String(\"24h\"),\n\t\t\tConfigs: cloudflare.DevicePostureIntegrationConfigArray{\n\t\t\t\t\u0026cloudflare.DevicePostureIntegrationConfigArgs{\n\t\t\t\t\tApiUrl:       pulumi.String(\"https://example.com/api\"),\n\t\t\t\t\tAuthUrl:      pulumi.String(\"https://example.com/connect/token\"),\n\t\t\t\t\tClientId:     pulumi.String(\"client-id\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"client-secret\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DevicePostureIntegration;\nimport com.pulumi.cloudflare.DevicePostureIntegrationArgs;\nimport com.pulumi.cloudflare.inputs.DevicePostureIntegrationConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DevicePostureIntegration(\"example\", DevicePostureIntegrationArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Device posture integration\")\n            .type(\"workspace_one\")\n            .interval(\"24h\")\n            .configs(DevicePostureIntegrationConfigArgs.builder()\n                .apiUrl(\"https://example.com/api\")\n                .authUrl(\"https://example.com/connect/token\")\n                .clientId(\"client-id\")\n                .clientSecret(\"client-secret\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:DevicePostureIntegration\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Device posture integration\n      type: workspace_one\n      interval: 24h\n      configs:\n        - apiUrl: https://example.com/api\n          authUrl: https://example.com/connect/token\n          clientId: client-id\n          clientSecret: client-secret\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/devicePostureIntegration:DevicePostureIntegration example \u003caccount_id\u003e/\u003cdevice_posture_integration_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig"
                    },
                    "description": "The device posture integration's connection authorization parameters.\n"
                },
                "identifier": {
                    "type": "string"
                },
                "interval": {
                    "type": "string",
                    "description": "Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture integration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig"
                    },
                    "description": "The device posture integration's connection authorization parameters.\n"
                },
                "identifier": {
                    "type": "string"
                },
                "interval": {
                    "type": "string",
                    "description": "Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture integration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePostureIntegration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig"
                        },
                        "description": "The device posture integration's connection authorization parameters.\n"
                    },
                    "identifier": {
                        "type": "string"
                    },
                    "interval": {
                        "type": "string",
                        "description": "Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture integration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePostureRule:DevicePostureRule": {
            "description": "Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst eaxmple = new cloudflare.DevicePostureRule(\"eaxmple\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Corporate devices posture rule\",\n    type: \"os_version\",\n    description: \"Device posture rule for corporate devices.\",\n    schedule: \"24h\",\n    expiration: \"24h\",\n    matches: [{\n        platform: \"linux\",\n    }],\n    inputs: [{\n        id: corporateDevices.id,\n        version: \"1.0.0\",\n        operator: \"\u003c\",\n        osDistroName: \"ubuntu\",\n        osDistroRevision: \"1.0.0\",\n        osVersionExtra: \"(a)\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\neaxmple = cloudflare.DevicePostureRule(\"eaxmple\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Corporate devices posture rule\",\n    type=\"os_version\",\n    description=\"Device posture rule for corporate devices.\",\n    schedule=\"24h\",\n    expiration=\"24h\",\n    matches=[{\n        \"platform\": \"linux\",\n    }],\n    inputs=[{\n        \"id\": corporate_devices[\"id\"],\n        \"version\": \"1.0.0\",\n        \"operator\": \"\u003c\",\n        \"os_distro_name\": \"ubuntu\",\n        \"os_distro_revision\": \"1.0.0\",\n        \"os_version_extra\": \"(a)\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var eaxmple = new Cloudflare.DevicePostureRule(\"eaxmple\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Corporate devices posture rule\",\n        Type = \"os_version\",\n        Description = \"Device posture rule for corporate devices.\",\n        Schedule = \"24h\",\n        Expiration = \"24h\",\n        Matches = new[]\n        {\n            new Cloudflare.Inputs.DevicePostureRuleMatchArgs\n            {\n                Platform = \"linux\",\n            },\n        },\n        Inputs = new[]\n        {\n            new Cloudflare.Inputs.DevicePostureRuleInputArgs\n            {\n                Id = corporateDevices.Id,\n                Version = \"1.0.0\",\n                Operator = \"\u003c\",\n                OsDistroName = \"ubuntu\",\n                OsDistroRevision = \"1.0.0\",\n                OsVersionExtra = \"(a)\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePostureRule(ctx, \"eaxmple\", \u0026cloudflare.DevicePostureRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"Corporate devices posture rule\"),\n\t\t\tType:        pulumi.String(\"os_version\"),\n\t\t\tDescription: pulumi.String(\"Device posture rule for corporate devices.\"),\n\t\t\tSchedule:    pulumi.String(\"24h\"),\n\t\t\tExpiration:  pulumi.String(\"24h\"),\n\t\t\tMatches: cloudflare.DevicePostureRuleMatchArray{\n\t\t\t\t\u0026cloudflare.DevicePostureRuleMatchArgs{\n\t\t\t\t\tPlatform: pulumi.String(\"linux\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tInputs: cloudflare.DevicePostureRuleInputTypeArray{\n\t\t\t\t\u0026cloudflare.DevicePostureRuleInputTypeArgs{\n\t\t\t\t\tId:               pulumi.Any(corporateDevices.Id),\n\t\t\t\t\tVersion:          pulumi.String(\"1.0.0\"),\n\t\t\t\t\tOperator:         pulumi.String(\"\u003c\"),\n\t\t\t\t\tOsDistroName:     pulumi.String(\"ubuntu\"),\n\t\t\t\t\tOsDistroRevision: pulumi.String(\"1.0.0\"),\n\t\t\t\t\tOsVersionExtra:   pulumi.String(\"(a)\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DevicePostureRule;\nimport com.pulumi.cloudflare.DevicePostureRuleArgs;\nimport com.pulumi.cloudflare.inputs.DevicePostureRuleMatchArgs;\nimport com.pulumi.cloudflare.inputs.DevicePostureRuleInputArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var eaxmple = new DevicePostureRule(\"eaxmple\", DevicePostureRuleArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Corporate devices posture rule\")\n            .type(\"os_version\")\n            .description(\"Device posture rule for corporate devices.\")\n            .schedule(\"24h\")\n            .expiration(\"24h\")\n            .matches(DevicePostureRuleMatchArgs.builder()\n                .platform(\"linux\")\n                .build())\n            .inputs(DevicePostureRuleInputArgs.builder()\n                .id(corporateDevices.id())\n                .version(\"1.0.0\")\n                .operator(\"\u003c\")\n                .osDistroName(\"ubuntu\")\n                .osDistroRevision(\"1.0.0\")\n                .osVersionExtra(\"(a)\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  eaxmple:\n    type: cloudflare:DevicePostureRule\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Corporate devices posture rule\n      type: os_version\n      description: Device posture rule for corporate devices.\n      schedule: 24h\n      expiration: 24h\n      matches:\n        - platform: linux\n      inputs:\n        - id: ${corporateDevices.id}\n          version: 1.0.0\n          operator: \u003c\n          osDistroName: ubuntu\n          osDistroRevision: 1.0.0\n          osVersionExtra: (a)\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/devicePostureRule:DevicePostureRule example \u003caccount_id\u003e/\u003cdevice_posture_rule_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                    },
                    "description": "Required for all rule types except `warp`, `gateway`, and `tanium`.\n"
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                }
            },
            "required": [
                "accountId",
                "inputs",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                    },
                    "description": "Required for all rule types except `warp`, `gateway`, and `tanium`.\n"
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePostureRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string",
                        "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                    },
                    "inputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                        },
                        "description": "Required for all rule types except `warp`, `gateway`, and `tanium`.\n"
                    },
                    "matches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                        },
                        "description": "The conditions that the client must match to run the rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture rule.\n"
                    },
                    "schedule": {
                        "type": "string",
                        "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy": {
            "description": "Provides a Cloudflare Device Settings Policy resource. Device policies configure settings applied to WARP devices.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst developerWarpPolicy = new cloudflare.DeviceSettingsPolicy(\"developer_warp_policy\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Developers WARP settings policy\",\n    description: \"Developers WARP settings policy description\",\n    precedence: 10,\n    match: \"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n    \"default\": false,\n    enabled: true,\n    allowModeSwitch: true,\n    allowUpdates: true,\n    allowedToLeave: true,\n    autoConnect: 0,\n    captivePortal: 5,\n    disableAutoFallback: true,\n    supportUrl: \"https://cloudflare.com\",\n    switchLocked: true,\n    serviceModeV2Mode: \"warp\",\n    serviceModeV2Port: 3000,\n    excludeOfficeIps: false,\n    tunnelProtocol: \"wireguard\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ndeveloper_warp_policy = cloudflare.DeviceSettingsPolicy(\"developer_warp_policy\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Developers WARP settings policy\",\n    description=\"Developers WARP settings policy description\",\n    precedence=10,\n    match=\"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n    default=False,\n    enabled=True,\n    allow_mode_switch=True,\n    allow_updates=True,\n    allowed_to_leave=True,\n    auto_connect=0,\n    captive_portal=5,\n    disable_auto_fallback=True,\n    support_url=\"https://cloudflare.com\",\n    switch_locked=True,\n    service_mode_v2_mode=\"warp\",\n    service_mode_v2_port=3000,\n    exclude_office_ips=False,\n    tunnel_protocol=\"wireguard\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var developerWarpPolicy = new Cloudflare.DeviceSettingsPolicy(\"developer_warp_policy\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Developers WARP settings policy\",\n        Description = \"Developers WARP settings policy description\",\n        Precedence = 10,\n        Match = \"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n        Default = false,\n        Enabled = true,\n        AllowModeSwitch = true,\n        AllowUpdates = true,\n        AllowedToLeave = true,\n        AutoConnect = 0,\n        CaptivePortal = 5,\n        DisableAutoFallback = true,\n        SupportUrl = \"https://cloudflare.com\",\n        SwitchLocked = true,\n        ServiceModeV2Mode = \"warp\",\n        ServiceModeV2Port = 3000,\n        ExcludeOfficeIps = false,\n        TunnelProtocol = \"wireguard\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDeviceSettingsPolicy(ctx, \"developer_warp_policy\", \u0026cloudflare.DeviceSettingsPolicyArgs{\n\t\t\tAccountId:           pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:                pulumi.String(\"Developers WARP settings policy\"),\n\t\t\tDescription:         pulumi.String(\"Developers WARP settings policy description\"),\n\t\t\tPrecedence:          pulumi.Int(10),\n\t\t\tMatch:               pulumi.String(\"any(identity.groups.name[*] in {\\\"Developers\\\"})\"),\n\t\t\tDefault:             pulumi.Bool(false),\n\t\t\tEnabled:             pulumi.Bool(true),\n\t\t\tAllowModeSwitch:     pulumi.Bool(true),\n\t\t\tAllowUpdates:        pulumi.Bool(true),\n\t\t\tAllowedToLeave:      pulumi.Bool(true),\n\t\t\tAutoConnect:         pulumi.Int(0),\n\t\t\tCaptivePortal:       pulumi.Int(5),\n\t\t\tDisableAutoFallback: pulumi.Bool(true),\n\t\t\tSupportUrl:          pulumi.String(\"https://cloudflare.com\"),\n\t\t\tSwitchLocked:        pulumi.Bool(true),\n\t\t\tServiceModeV2Mode:   pulumi.String(\"warp\"),\n\t\t\tServiceModeV2Port:   pulumi.Int(3000),\n\t\t\tExcludeOfficeIps:    pulumi.Bool(false),\n\t\t\tTunnelProtocol:      pulumi.String(\"wireguard\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DeviceSettingsPolicy;\nimport com.pulumi.cloudflare.DeviceSettingsPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var developerWarpPolicy = new DeviceSettingsPolicy(\"developerWarpPolicy\", DeviceSettingsPolicyArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Developers WARP settings policy\")\n            .description(\"Developers WARP settings policy description\")\n            .precedence(10)\n            .match(\"any(identity.groups.name[*] in {\\\"Developers\\\"})\")\n            .default_(false)\n            .enabled(true)\n            .allowModeSwitch(true)\n            .allowUpdates(true)\n            .allowedToLeave(true)\n            .autoConnect(0)\n            .captivePortal(5)\n            .disableAutoFallback(true)\n            .supportUrl(\"https://cloudflare.com\")\n            .switchLocked(true)\n            .serviceModeV2Mode(\"warp\")\n            .serviceModeV2Port(3000)\n            .excludeOfficeIps(false)\n            .tunnelProtocol(\"wireguard\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  developerWarpPolicy:\n    type: cloudflare:DeviceSettingsPolicy\n    name: developer_warp_policy\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Developers WARP settings policy\n      description: Developers WARP settings policy description\n      precedence: 10\n      match: any(identity.groups.name[*] in {\"Developers\"})\n      default: false\n      enabled: true\n      allowModeSwitch: true\n      allowUpdates: true\n      allowedToLeave: true\n      autoConnect: 0\n      captivePortal: 5\n      disableAutoFallback: true\n      supportUrl: https://cloudflare.com\n      switchLocked: true\n      serviceModeV2Mode: warp\n      serviceModeV2Port: 3000\n      excludeOfficeIps: false\n      tunnelProtocol: wireguard\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nFor default device settings policies you must use \"default\" as the policy ID.\n\n```sh\n$ pulumi import cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy example \u003caccount_id\u003e/\u003cdevice_policy_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowModeSwitch": {
                    "type": "boolean",
                    "description": "Whether to allow mode switch for this policy.\n"
                },
                "allowUpdates": {
                    "type": "boolean",
                    "description": "Whether to allow updates under this policy.\n"
                },
                "allowedToLeave": {
                    "type": "boolean",
                    "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                },
                "autoConnect": {
                    "type": "integer",
                    "description": "The amount of time in seconds to reconnect after having been disabled.\n"
                },
                "captivePortal": {
                    "type": "integer",
                    "description": "The captive portal value for this policy. Defaults to `180`.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Whether the policy refers to the default account policy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of Policy.\n"
                },
                "disableAutoFallback": {
                    "type": "boolean",
                    "description": "Whether to disable auto fallback for this policy.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                },
                "excludeOfficeIps": {
                    "type": "boolean",
                    "description": "Whether to add Microsoft IPs to split tunnel exclusions.\n"
                },
                "match": {
                    "type": "string",
                    "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                },
                "serviceModeV2Mode": {
                    "type": "string",
                    "description": "The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.\n"
                },
                "serviceModeV2Port": {
                    "type": "integer",
                    "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "The support URL that will be opened when sending feedback.\n"
                },
                "switchLocked": {
                    "type": "boolean",
                    "description": "Enablement of the ZT client switch lock.\n"
                },
                "tunnelProtocol": {
                    "type": "string",
                    "description": "Determines which tunnel protocol to use. Available values: `\"\"`, `wireguard`, `masque`. Defaults to `wireguard`.\n"
                }
            },
            "required": [
                "accountId",
                "description",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowModeSwitch": {
                    "type": "boolean",
                    "description": "Whether to allow mode switch for this policy.\n"
                },
                "allowUpdates": {
                    "type": "boolean",
                    "description": "Whether to allow updates under this policy.\n"
                },
                "allowedToLeave": {
                    "type": "boolean",
                    "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                },
                "autoConnect": {
                    "type": "integer",
                    "description": "The amount of time in seconds to reconnect after having been disabled.\n"
                },
                "captivePortal": {
                    "type": "integer",
                    "description": "The captive portal value for this policy. Defaults to `180`.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Whether the policy refers to the default account policy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of Policy.\n"
                },
                "disableAutoFallback": {
                    "type": "boolean",
                    "description": "Whether to disable auto fallback for this policy.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                },
                "excludeOfficeIps": {
                    "type": "boolean",
                    "description": "Whether to add Microsoft IPs to split tunnel exclusions.\n"
                },
                "match": {
                    "type": "string",
                    "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                },
                "serviceModeV2Mode": {
                    "type": "string",
                    "description": "The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.\n"
                },
                "serviceModeV2Port": {
                    "type": "integer",
                    "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "The support URL that will be opened when sending feedback.\n"
                },
                "switchLocked": {
                    "type": "boolean",
                    "description": "Enablement of the ZT client switch lock.\n"
                },
                "tunnelProtocol": {
                    "type": "string",
                    "description": "Determines which tunnel protocol to use. Available values: `\"\"`, `wireguard`, `masque`. Defaults to `wireguard`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "description",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeviceSettingsPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "allowModeSwitch": {
                        "type": "boolean",
                        "description": "Whether to allow mode switch for this policy.\n"
                    },
                    "allowUpdates": {
                        "type": "boolean",
                        "description": "Whether to allow updates under this policy.\n"
                    },
                    "allowedToLeave": {
                        "type": "boolean",
                        "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                    },
                    "autoConnect": {
                        "type": "integer",
                        "description": "The amount of time in seconds to reconnect after having been disabled.\n"
                    },
                    "captivePortal": {
                        "type": "integer",
                        "description": "The captive portal value for this policy. Defaults to `180`.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Whether the policy refers to the default account policy.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of Policy.\n"
                    },
                    "disableAutoFallback": {
                        "type": "boolean",
                        "description": "Whether to disable auto fallback for this policy.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                    },
                    "excludeOfficeIps": {
                        "type": "boolean",
                        "description": "Whether to add Microsoft IPs to split tunnel exclusions.\n"
                    },
                    "match": {
                        "type": "string",
                        "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the policy.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                    },
                    "serviceModeV2Mode": {
                        "type": "string",
                        "description": "The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.\n"
                    },
                    "serviceModeV2Port": {
                        "type": "integer",
                        "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                    },
                    "supportUrl": {
                        "type": "string",
                        "description": "The support URL that will be opened when sending feedback.\n"
                    },
                    "switchLocked": {
                        "type": "boolean",
                        "description": "Enablement of the ZT client switch lock.\n"
                    },
                    "tunnelProtocol": {
                        "type": "string",
                        "description": "Determines which tunnel protocol to use. Available values: `\"\"`, `wireguard`, `masque`. Defaults to `wireguard`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/dlpProfile:DlpProfile": {
            "description": "Provides a Cloudflare DLP Profile resource. Data Loss Prevention profiles\nare a set of entries that can be matched in HTTP bodies or files.\nThey are referenced in Zero Trust Gateway rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Predefined profile must be imported, cannot be created\nconst creds = new cloudflare.DlpProfile(\"creds\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Credentials and Secrets\",\n    type: \"predefined\",\n    allowedMatchCount: 3,\n    entries: [\n        {\n            enabled: true,\n            name: \"Amazon AWS Access Key ID\",\n            id: \"d8fcfc9c-773c-405e-8426-21ecbb67ba93\",\n        },\n        {\n            enabled: false,\n            id: \"2c0e33e1-71da-40c8-aad3-32e674ad3d96\",\n            name: \"Amazon AWS Secret Access Key\",\n        },\n        {\n            enabled: true,\n            id: \"4e92c006-3802-4dff-bbe1-8e1513b1c92a\",\n            name: \"Microsoft Azure Client Secret\",\n        },\n        {\n            enabled: false,\n            id: \"5c713294-2375-4904-abcf-e4a15be4d592\",\n            name: \"SSH Private Key\",\n        },\n        {\n            enabled: true,\n            id: \"6c6579e4-d832-42d5-905c-8e53340930f2\",\n            name: \"Google GCP API Key\",\n        },\n    ],\n});\n// Custom profile\nconst exampleCustom = new cloudflare.DlpProfile(\"example_custom\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Example Custom Profile\",\n    description: \"A profile with example entries\",\n    type: \"custom\",\n    allowedMatchCount: 0,\n    entries: [\n        {\n            name: \"Matches visa credit cards\",\n            enabled: true,\n            pattern: {\n                regex: \"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\",\n                validation: \"luhn\",\n            },\n        },\n        {\n            name: \"Matches diners club card\",\n            enabled: true,\n            pattern: {\n                regex: \"(?:0[0-5]|[68][0-9])[0-9]{11}\",\n                validation: \"luhn\",\n            },\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Predefined profile must be imported, cannot be created\ncreds = cloudflare.DlpProfile(\"creds\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Credentials and Secrets\",\n    type=\"predefined\",\n    allowed_match_count=3,\n    entries=[\n        {\n            \"enabled\": True,\n            \"name\": \"Amazon AWS Access Key ID\",\n            \"id\": \"d8fcfc9c-773c-405e-8426-21ecbb67ba93\",\n        },\n        {\n            \"enabled\": False,\n            \"id\": \"2c0e33e1-71da-40c8-aad3-32e674ad3d96\",\n            \"name\": \"Amazon AWS Secret Access Key\",\n        },\n        {\n            \"enabled\": True,\n            \"id\": \"4e92c006-3802-4dff-bbe1-8e1513b1c92a\",\n            \"name\": \"Microsoft Azure Client Secret\",\n        },\n        {\n            \"enabled\": False,\n            \"id\": \"5c713294-2375-4904-abcf-e4a15be4d592\",\n            \"name\": \"SSH Private Key\",\n        },\n        {\n            \"enabled\": True,\n            \"id\": \"6c6579e4-d832-42d5-905c-8e53340930f2\",\n            \"name\": \"Google GCP API Key\",\n        },\n    ])\n# Custom profile\nexample_custom = cloudflare.DlpProfile(\"example_custom\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Example Custom Profile\",\n    description=\"A profile with example entries\",\n    type=\"custom\",\n    allowed_match_count=0,\n    entries=[\n        {\n            \"name\": \"Matches visa credit cards\",\n            \"enabled\": True,\n            \"pattern\": {\n                \"regex\": \"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\",\n                \"validation\": \"luhn\",\n            },\n        },\n        {\n            \"name\": \"Matches diners club card\",\n            \"enabled\": True,\n            \"pattern\": {\n                \"regex\": \"(?:0[0-5]|[68][0-9])[0-9]{11}\",\n                \"validation\": \"luhn\",\n            },\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Predefined profile must be imported, cannot be created\n    var creds = new Cloudflare.DlpProfile(\"creds\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Credentials and Secrets\",\n        Type = \"predefined\",\n        AllowedMatchCount = 3,\n        Entries = new[]\n        {\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Enabled = true,\n                Name = \"Amazon AWS Access Key ID\",\n                Id = \"d8fcfc9c-773c-405e-8426-21ecbb67ba93\",\n            },\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Enabled = false,\n                Id = \"2c0e33e1-71da-40c8-aad3-32e674ad3d96\",\n                Name = \"Amazon AWS Secret Access Key\",\n            },\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Enabled = true,\n                Id = \"4e92c006-3802-4dff-bbe1-8e1513b1c92a\",\n                Name = \"Microsoft Azure Client Secret\",\n            },\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Enabled = false,\n                Id = \"5c713294-2375-4904-abcf-e4a15be4d592\",\n                Name = \"SSH Private Key\",\n            },\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Enabled = true,\n                Id = \"6c6579e4-d832-42d5-905c-8e53340930f2\",\n                Name = \"Google GCP API Key\",\n            },\n        },\n    });\n\n    // Custom profile\n    var exampleCustom = new Cloudflare.DlpProfile(\"example_custom\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Example Custom Profile\",\n        Description = \"A profile with example entries\",\n        Type = \"custom\",\n        AllowedMatchCount = 0,\n        Entries = new[]\n        {\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Name = \"Matches visa credit cards\",\n                Enabled = true,\n                Pattern = new Cloudflare.Inputs.DlpProfileEntryPatternArgs\n                {\n                    Regex = \"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\",\n                    Validation = \"luhn\",\n                },\n            },\n            new Cloudflare.Inputs.DlpProfileEntryArgs\n            {\n                Name = \"Matches diners club card\",\n                Enabled = true,\n                Pattern = new Cloudflare.Inputs.DlpProfileEntryPatternArgs\n                {\n                    Regex = \"(?:0[0-5]|[68][0-9])[0-9]{11}\",\n                    Validation = \"luhn\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Predefined profile must be imported, cannot be created\n\t\t_, err := cloudflare.NewDlpProfile(ctx, \"creds\", \u0026cloudflare.DlpProfileArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:              pulumi.String(\"Credentials and Secrets\"),\n\t\t\tType:              pulumi.String(\"predefined\"),\n\t\t\tAllowedMatchCount: pulumi.Int(3),\n\t\t\tEntries: cloudflare.DlpProfileEntryArray{\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tName:    pulumi.String(\"Amazon AWS Access Key ID\"),\n\t\t\t\t\tId:      pulumi.String(\"d8fcfc9c-773c-405e-8426-21ecbb67ba93\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tId:      pulumi.String(\"2c0e33e1-71da-40c8-aad3-32e674ad3d96\"),\n\t\t\t\t\tName:    pulumi.String(\"Amazon AWS Secret Access Key\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tId:      pulumi.String(\"4e92c006-3802-4dff-bbe1-8e1513b1c92a\"),\n\t\t\t\t\tName:    pulumi.String(\"Microsoft Azure Client Secret\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tId:      pulumi.String(\"5c713294-2375-4904-abcf-e4a15be4d592\"),\n\t\t\t\t\tName:    pulumi.String(\"SSH Private Key\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tId:      pulumi.String(\"6c6579e4-d832-42d5-905c-8e53340930f2\"),\n\t\t\t\t\tName:    pulumi.String(\"Google GCP API Key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Custom profile\n\t\t_, err = cloudflare.NewDlpProfile(ctx, \"example_custom\", \u0026cloudflare.DlpProfileArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:              pulumi.String(\"Example Custom Profile\"),\n\t\t\tDescription:       pulumi.String(\"A profile with example entries\"),\n\t\t\tType:              pulumi.String(\"custom\"),\n\t\t\tAllowedMatchCount: pulumi.Int(0),\n\t\t\tEntries: cloudflare.DlpProfileEntryArray{\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tName:    pulumi.String(\"Matches visa credit cards\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tPattern: \u0026cloudflare.DlpProfileEntryPatternArgs{\n\t\t\t\t\t\tRegex:      pulumi.String(\"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\"),\n\t\t\t\t\t\tValidation: pulumi.String(\"luhn\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.DlpProfileEntryArgs{\n\t\t\t\t\tName:    pulumi.String(\"Matches diners club card\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tPattern: \u0026cloudflare.DlpProfileEntryPatternArgs{\n\t\t\t\t\t\tRegex:      pulumi.String(\"(?:0[0-5]|[68][0-9])[0-9]{11}\"),\n\t\t\t\t\t\tValidation: pulumi.String(\"luhn\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DlpProfile;\nimport com.pulumi.cloudflare.DlpProfileArgs;\nimport com.pulumi.cloudflare.inputs.DlpProfileEntryArgs;\nimport com.pulumi.cloudflare.inputs.DlpProfileEntryPatternArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Predefined profile must be imported, cannot be created\n        var creds = new DlpProfile(\"creds\", DlpProfileArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Credentials and Secrets\")\n            .type(\"predefined\")\n            .allowedMatchCount(3)\n            .entries(            \n                DlpProfileEntryArgs.builder()\n                    .enabled(true)\n                    .name(\"Amazon AWS Access Key ID\")\n                    .id(\"d8fcfc9c-773c-405e-8426-21ecbb67ba93\")\n                    .build(),\n                DlpProfileEntryArgs.builder()\n                    .enabled(false)\n                    .id(\"2c0e33e1-71da-40c8-aad3-32e674ad3d96\")\n                    .name(\"Amazon AWS Secret Access Key\")\n                    .build(),\n                DlpProfileEntryArgs.builder()\n                    .enabled(true)\n                    .id(\"4e92c006-3802-4dff-bbe1-8e1513b1c92a\")\n                    .name(\"Microsoft Azure Client Secret\")\n                    .build(),\n                DlpProfileEntryArgs.builder()\n                    .enabled(false)\n                    .id(\"5c713294-2375-4904-abcf-e4a15be4d592\")\n                    .name(\"SSH Private Key\")\n                    .build(),\n                DlpProfileEntryArgs.builder()\n                    .enabled(true)\n                    .id(\"6c6579e4-d832-42d5-905c-8e53340930f2\")\n                    .name(\"Google GCP API Key\")\n                    .build())\n            .build());\n\n        // Custom profile\n        var exampleCustom = new DlpProfile(\"exampleCustom\", DlpProfileArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Example Custom Profile\")\n            .description(\"A profile with example entries\")\n            .type(\"custom\")\n            .allowedMatchCount(0)\n            .entries(            \n                DlpProfileEntryArgs.builder()\n                    .name(\"Matches visa credit cards\")\n                    .enabled(true)\n                    .pattern(DlpProfileEntryPatternArgs.builder()\n                        .regex(\"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\")\n                        .validation(\"luhn\")\n                        .build())\n                    .build(),\n                DlpProfileEntryArgs.builder()\n                    .name(\"Matches diners club card\")\n                    .enabled(true)\n                    .pattern(DlpProfileEntryPatternArgs.builder()\n                        .regex(\"(?:0[0-5]|[68][0-9])[0-9]{11}\")\n                        .validation(\"luhn\")\n                        .build())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Predefined profile must be imported, cannot be created\n  creds:\n    type: cloudflare:DlpProfile\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Credentials and Secrets\n      type: predefined\n      allowedMatchCount: 3\n      entries:\n        - enabled: true\n          name: Amazon AWS Access Key ID\n          id: d8fcfc9c-773c-405e-8426-21ecbb67ba93\n        - enabled: false\n          id: 2c0e33e1-71da-40c8-aad3-32e674ad3d96\n          name: Amazon AWS Secret Access Key\n        - enabled: true\n          id: 4e92c006-3802-4dff-bbe1-8e1513b1c92a\n          name: Microsoft Azure Client Secret\n        - enabled: false\n          id: 5c713294-2375-4904-abcf-e4a15be4d592\n          name: SSH Private Key\n        - enabled: true\n          id: 6c6579e4-d832-42d5-905c-8e53340930f2\n          name: Google GCP API Key\n  # Custom profile\n  exampleCustom:\n    type: cloudflare:DlpProfile\n    name: example_custom\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Example Custom Profile\n      description: A profile with example entries\n      type: custom\n      allowedMatchCount: 0\n      entries:\n        - name: Matches visa credit cards\n          enabled: true\n          pattern:\n            regex: 4\\d{3}([-\\. ])?\\d{4}([-\\. ])?\\d{4}([-\\. ])?\\d{4}\n            validation: luhn\n        - name: Matches diners club card\n          enabled: true\n          pattern:\n            regex: (?:0[0-5]|[68][0-9])[0-9]{11}\n            validation: luhn\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/dlpProfile:DlpProfile example \u003caccount_id\u003e/\u003cdlp_profile_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "allowedMatchCount": {
                    "type": "integer",
                    "description": "Related DLP policies will trigger when the match count exceeds the number set.\n"
                },
                "contextAwareness": {
                    "$ref": "#/types/cloudflare:index/DlpProfileContextAwareness:DlpProfileContextAwareness",
                    "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the profile and its intended use.\n"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DlpProfileEntry:DlpProfileEntry"
                    },
                    "description": "List of entries to apply to the profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ocrEnabled": {
                    "type": "boolean",
                    "description": "If true, scan images via OCR to determine if any text present matches filters.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "allowedMatchCount",
                "contextAwareness",
                "entries",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "allowedMatchCount": {
                    "type": "integer",
                    "description": "Related DLP policies will trigger when the match count exceeds the number set.\n"
                },
                "contextAwareness": {
                    "$ref": "#/types/cloudflare:index/DlpProfileContextAwareness:DlpProfileContextAwareness",
                    "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the profile and its intended use.\n"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DlpProfileEntry:DlpProfileEntry"
                    },
                    "description": "List of entries to apply to the profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "ocrEnabled": {
                    "type": "boolean",
                    "description": "If true, scan images via OCR to determine if any text present matches filters.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "allowedMatchCount",
                "entries",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DlpProfile resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "allowedMatchCount": {
                        "type": "integer",
                        "description": "Related DLP policies will trigger when the match count exceeds the number set.\n"
                    },
                    "contextAwareness": {
                        "$ref": "#/types/cloudflare:index/DlpProfileContextAwareness:DlpProfileContextAwareness",
                        "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Brief summary of the profile and its intended use.\n"
                    },
                    "entries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DlpProfileEntry:DlpProfileEntry"
                        },
                        "description": "List of entries to apply to the profile.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ocrEnabled": {
                        "type": "boolean",
                        "description": "If true, scan images via OCR to determine if any text present matches filters.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingAddress:EmailRoutingAddress": {
            "description": "The [Email Routing Address](https://developers.cloudflare.com/email-routing/setup/email-routing-addresses/#destination-addresses) resource allows you to manage Cloudflare Email Routing Destination Addresses.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.EmailRoutingAddress(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    email: \"user@example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.EmailRoutingAddress(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    email=\"user@example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.EmailRoutingAddress(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Email = \"user@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingAddress(ctx, \"example\", \u0026cloudflare.EmailRoutingAddressArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tEmail:     pulumi.String(\"user@example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingAddress;\nimport com.pulumi.cloudflare.EmailRoutingAddressArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new EmailRoutingAddress(\"example\", EmailRoutingAddressArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .email(\"user@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:EmailRoutingAddress\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      email: user@example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/emailRoutingAddress:EmailRoutingAddress example \u003caccount_id\u003e/\u003cemail_routing_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "created": {
                    "type": "string",
                    "description": "The date and time the destination address has been created.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The contact email address of the user.\n"
                },
                "modified": {
                    "type": "string",
                    "description": "The date and time the destination address has been modified.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Destination address identifier.\n"
                },
                "verified": {
                    "type": "string",
                    "description": "The date and time the destination address has been verified. Null means not verified yet.\n"
                }
            },
            "required": [
                "accountId",
                "created",
                "email",
                "modified",
                "tag",
                "verified"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The contact email address of the user.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "email"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingAddress resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "The date and time the destination address has been created.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The contact email address of the user.\n"
                    },
                    "modified": {
                        "type": "string",
                        "description": "The date and time the destination address has been modified.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Destination address identifier.\n"
                    },
                    "verified": {
                        "type": "string",
                        "description": "The date and time the destination address has been verified. Null means not verified yet.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingCatchAll:EmailRoutingCatchAll": {
            "description": "Provides a resource for managing Email Routing Addresses catch all behaviour.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.EmailRoutingCatchAll(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"example catch all\",\n    enabled: true,\n    matchers: [{\n        type: \"all\",\n    }],\n    actions: [{\n        type: \"forward\",\n        values: [\"destinationaddress@example.net\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.EmailRoutingCatchAll(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"example catch all\",\n    enabled=True,\n    matchers=[{\n        \"type\": \"all\",\n    }],\n    actions=[{\n        \"type\": \"forward\",\n        \"values\": [\"destinationaddress@example.net\"],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.EmailRoutingCatchAll(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"example catch all\",\n        Enabled = true,\n        Matchers = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingCatchAllMatcherArgs\n            {\n                Type = \"all\",\n            },\n        },\n        Actions = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingCatchAllActionArgs\n            {\n                Type = \"forward\",\n                Values = new[]\n                {\n                    \"destinationaddress@example.net\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingCatchAll(ctx, \"example\", \u0026cloudflare.EmailRoutingCatchAllArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:    pulumi.String(\"example catch all\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tMatchers: cloudflare.EmailRoutingCatchAllMatcherArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingCatchAllMatcherArgs{\n\t\t\t\t\tType: pulumi.String(\"all\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tActions: cloudflare.EmailRoutingCatchAllActionArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingCatchAllActionArgs{\n\t\t\t\t\tType: pulumi.String(\"forward\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"destinationaddress@example.net\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingCatchAll;\nimport com.pulumi.cloudflare.EmailRoutingCatchAllArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingCatchAllMatcherArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingCatchAllActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new EmailRoutingCatchAll(\"example\", EmailRoutingCatchAllArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"example catch all\")\n            .enabled(true)\n            .matchers(EmailRoutingCatchAllMatcherArgs.builder()\n                .type(\"all\")\n                .build())\n            .actions(EmailRoutingCatchAllActionArgs.builder()\n                .type(\"forward\")\n                .values(\"destinationaddress@example.net\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:EmailRoutingCatchAll\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: example catch all\n      enabled: true\n      matchers:\n        - type: all\n      actions:\n        - type: forward\n          values:\n            - destinationaddress@example.net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction"
                    },
                    "description": "List actions patterns.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Routing rule status.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Routing rule identifier.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "actions",
                "matchers",
                "name",
                "tag",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction"
                    },
                    "description": "List actions patterns.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Routing rule status.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "actions",
                "matchers",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingCatchAll resources.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction"
                        },
                        "description": "List actions patterns.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Routing rule status.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher"
                        },
                        "description": "Matching patterns to forward to your actions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Routing rule name.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Routing rule identifier.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingRule:EmailRoutingRule": {
            "description": "The [Email Routing Rule](https://developers.cloudflare.com/email-routing/setup/email-routing-addresses/#email-rule-actions) resource allows you to create and manage email routing rules for a zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst main = new cloudflare.EmailRoutingRule(\"main\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"terraform rule\",\n    enabled: true,\n    matchers: [{\n        type: \"literal\",\n        field: \"to\",\n        value: \"test@example.com\",\n    }],\n    actions: [{\n        type: \"forward\",\n        values: [\"destinationaddress@example.net\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmain = cloudflare.EmailRoutingRule(\"main\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"terraform rule\",\n    enabled=True,\n    matchers=[{\n        \"type\": \"literal\",\n        \"field\": \"to\",\n        \"value\": \"test@example.com\",\n    }],\n    actions=[{\n        \"type\": \"forward\",\n        \"values\": [\"destinationaddress@example.net\"],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new Cloudflare.EmailRoutingRule(\"main\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"terraform rule\",\n        Enabled = true,\n        Matchers = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingRuleMatcherArgs\n            {\n                Type = \"literal\",\n                Field = \"to\",\n                Value = \"test@example.com\",\n            },\n        },\n        Actions = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingRuleActionArgs\n            {\n                Type = \"forward\",\n                Values = new[]\n                {\n                    \"destinationaddress@example.net\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingRule(ctx, \"main\", \u0026cloudflare.EmailRoutingRuleArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:    pulumi.String(\"terraform rule\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tMatchers: cloudflare.EmailRoutingRuleMatcherArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingRuleMatcherArgs{\n\t\t\t\t\tType:  pulumi.String(\"literal\"),\n\t\t\t\t\tField: pulumi.String(\"to\"),\n\t\t\t\t\tValue: pulumi.String(\"test@example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tActions: cloudflare.EmailRoutingRuleActionArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingRuleActionArgs{\n\t\t\t\t\tType: pulumi.String(\"forward\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"destinationaddress@example.net\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingRule;\nimport com.pulumi.cloudflare.EmailRoutingRuleArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingRuleMatcherArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingRuleActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new EmailRoutingRule(\"main\", EmailRoutingRuleArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"terraform rule\")\n            .enabled(true)\n            .matchers(EmailRoutingRuleMatcherArgs.builder()\n                .type(\"literal\")\n                .field(\"to\")\n                .value(\"test@example.com\")\n                .build())\n            .actions(EmailRoutingRuleActionArgs.builder()\n                .type(\"forward\")\n                .values(\"destinationaddress@example.net\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: cloudflare:EmailRoutingRule\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: terraform rule\n      enabled: true\n      matchers:\n        - type: literal\n          field: to\n          value: test@example.com\n      actions:\n        - type: forward\n          values:\n            - destinationaddress@example.net\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/emailRoutingRule:EmailRoutingRule example \u003czone_id\u003e/\u003cemail_routing_rule_id\u003e\n```\n\n",
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction"
                    },
                    "description": "Actions to take when a match is found.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the email routing rule is enabled.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the email routing rule.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "The tag of the email routing rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "name",
                "priority",
                "tag",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction"
                    },
                    "description": "Actions to take when a match is found.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the email routing rule is enabled.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the email routing rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingRule resources.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction"
                        },
                        "description": "Actions to take when a match is found.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the email routing rule is enabled.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher"
                        },
                        "description": "Matching patterns to forward to your actions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Routing rule name.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the email routing rule.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "The tag of the email routing rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingSettings:EmailRoutingSettings": {
            "description": "Provides a resource for managing Email Routing settings.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myZone = new cloudflare.EmailRoutingSettings(\"my_zone\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_zone = cloudflare.EmailRoutingSettings(\"my_zone\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myZone = new Cloudflare.EmailRoutingSettings(\"my_zone\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingSettings(ctx, \"my_zone\", \u0026cloudflare.EmailRoutingSettingsArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingSettings;\nimport com.pulumi.cloudflare.EmailRoutingSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myZone = new EmailRoutingSettings(\"myZone\", EmailRoutingSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(\"true\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myZone:\n    type: cloudflare:EmailRoutingSettings\n    name: my_zone\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: 'true'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "created": {
                    "type": "string",
                    "description": "The date and time the settings have been created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "modified": {
                    "type": "string",
                    "description": "The date and time the settings have been modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Domain of your zone.\n"
                },
                "skipWizard": {
                    "type": "boolean",
                    "description": "Flag to check if the user skipped the configuration wizard.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Show the state of your account, and the type or configuration error.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Email Routing settings identifier.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "created",
                "enabled",
                "modified",
                "name",
                "skipWizard",
                "status",
                "tag",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "skipWizard": {
                    "type": "boolean",
                    "description": "Flag to check if the user skipped the configuration wizard.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingSettings resources.\n",
                "properties": {
                    "created": {
                        "type": "string",
                        "description": "The date and time the settings have been created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "modified": {
                        "type": "string",
                        "description": "The date and time the settings have been modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Domain of your zone.\n"
                    },
                    "skipWizard": {
                        "type": "boolean",
                        "description": "Flag to check if the user skipped the configuration wizard.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Show the state of your account, and the type or configuration error.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Email Routing settings identifier.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/fallbackDomain:FallbackDomain": {
            "description": "Provides a Cloudflare Fallback Domain resource. Fallback domains are\nused to ignore DNS requests to a given list of domains. These DNS\nrequests will be passed back to other DNS servers configured on\nexisting network interfaces on the device.\n\n## Import\n\nFallback Domains for default device policies must use \"default\" as the policy ID.\n\n```sh\n$ pulumi import cloudflare:index/fallbackDomain:FallbackDomain example \u003caccount_id\u003e/\u003cpolicy_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/FallbackDomainDomain:FallbackDomainDomain"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this fallback domain policy.\n"
                }
            },
            "required": [
                "accountId",
                "domains"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/FallbackDomainDomain:FallbackDomainDomain"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this fallback domain policy.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "domains"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FallbackDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "domains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/FallbackDomainDomain:FallbackDomainDomain"
                        }
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The settings policy for which to configure this fallback domain policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/filter:Filter": {
            "description": "Filter expressions that can be referenced across multiple features,\ne.g. Firewall Rules. See [what is a filter](https://developers.cloudflare.com/firewall/api/cf-filters/what-is-a-filter/)\nfor more details and available fields and operators.\n\n\u003e `cloudflare.Filter` is in a deprecation phase until January 15th, 2025.\n  During this time period, this resource is still fully\n  supported but you are strongly advised to move to the\n  `cloudflare.Ruleset` resource. Full details can be found in the\n  developer documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpress = new cloudflare.Filter(\"wordpress\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress = cloudflare.Filter(\"wordpress\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var wordpress = new Cloudflare.Filter(\"wordpress\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Description = \"Wordpress break-in attempts that are outside of the office\",\n        Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewFilter(ctx, \"wordpress\", \u0026cloudflare.FilterArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tDescription: pulumi.String(\"Wordpress break-in attempts that are outside of the office\"),\n\t\t\tExpression:  pulumi.String(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Filter;\nimport com.pulumi.cloudflare.FilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var wordpress = new Filter(\"wordpress\", FilterArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .description(\"Wordpress break-in attempts that are outside of the office\")\n            .expression(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  wordpress:\n    type: cloudflare:Filter\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      description: Wordpress break-in attempts that are outside of the office\n      expression: (http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/filter:Filter example \u003czone_id\u003e/\u003cfilter_id\u003e\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "expression",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "expression",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Filter resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the purpose of the filter.\n"
                    },
                    "expression": {
                        "type": "string",
                        "description": "The filter expression to be used.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter is currently paused.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "Short reference tag to quickly select related rules.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/firewallRule:FirewallRule": {
            "description": "Define Firewall rules using filter expressions for more control over\nhow traffic is matched to the rule. A filter expression permits\nselecting traffic by multiple criteria allowing greater freedom in\nrule creation.\n\nFilter expressions needs to be created first before using Firewall\nRule.\n\n\u003e `cloudflare.FirewallRule` is in a deprecation phase until January 15th, 2025.\n  During this time period, this resource is still\n  fully supported but you are strongly advised  to move to the\n  `cloudflare.Ruleset` resource. Full details can be found in the\n  developer documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpress = new cloudflare.Filter(\"wordpress\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n});\nconst wordpressFirewallRule = new cloudflare.FirewallRule(\"wordpress\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    description: \"Block wordpress break-in attempts\",\n    filterId: wordpress.id,\n    action: \"block\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress = cloudflare.Filter(\"wordpress\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\nwordpress_firewall_rule = cloudflare.FirewallRule(\"wordpress\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    description=\"Block wordpress break-in attempts\",\n    filter_id=wordpress.id,\n    action=\"block\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var wordpress = new Cloudflare.Filter(\"wordpress\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Description = \"Wordpress break-in attempts that are outside of the office\",\n        Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    });\n\n    var wordpressFirewallRule = new Cloudflare.FirewallRule(\"wordpress\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Description = \"Block wordpress break-in attempts\",\n        FilterId = wordpress.Id,\n        Action = \"block\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\twordpress, err := cloudflare.NewFilter(ctx, \"wordpress\", \u0026cloudflare.FilterArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tDescription: pulumi.String(\"Wordpress break-in attempts that are outside of the office\"),\n\t\t\tExpression:  pulumi.String(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewFirewallRule(ctx, \"wordpress\", \u0026cloudflare.FirewallRuleArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tDescription: pulumi.String(\"Block wordpress break-in attempts\"),\n\t\t\tFilterId:    wordpress.ID(),\n\t\t\tAction:      pulumi.String(\"block\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Filter;\nimport com.pulumi.cloudflare.FilterArgs;\nimport com.pulumi.cloudflare.FirewallRule;\nimport com.pulumi.cloudflare.FirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var wordpress = new Filter(\"wordpress\", FilterArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .description(\"Wordpress break-in attempts that are outside of the office\")\n            .expression(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\n            .build());\n\n        var wordpressFirewallRule = new FirewallRule(\"wordpressFirewallRule\", FirewallRuleArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .description(\"Block wordpress break-in attempts\")\n            .filterId(wordpress.id())\n            .action(\"block\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  wordpress:\n    type: cloudflare:Filter\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      description: Wordpress break-in attempts that are outside of the office\n      expression: (http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1\n  wordpressFirewallRule:\n    type: cloudflare:FirewallRule\n    name: wordpress\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      description: Block wordpress break-in attempts\n      filterId: ${wordpress.id}\n      action: block\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/firewallRule:FirewallRule example \u003czone_id\u003e/\u003cfirewall_rule_id\u003e\n```\n\n",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string",
                    "description": "The identifier of the Filter to use for determining if the Firewall Rule should be triggered.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "action",
                "filterId",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string",
                    "description": "The identifier of the Filter to use for determining if the Firewall Rule should be triggered.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "filterId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallRule resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the rule to help identify it.\n"
                    },
                    "filterId": {
                        "type": "string",
                        "description": "The identifier of the Filter to use for determining if the Firewall Rule should be triggered.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter based firewall rule is currently paused.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                    },
                    "products": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/greTunnel:GreTunnel": {
            "description": "Provides a resource, that manages GRE tunnels for Magic Transit.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.GreTunnel(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"GRE_1\",\n    customerGreEndpoint: \"203.0.113.1\",\n    cloudflareGreEndpoint: \"203.0.113.2\",\n    interfaceAddress: \"192.0.2.0/31\",\n    description: \"Tunnel for ISP X\",\n    ttl: 64,\n    mtu: 1476,\n    healthCheckEnabled: true,\n    healthCheckTarget: \"203.0.113.1\",\n    healthCheckType: \"reply\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.GreTunnel(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"GRE_1\",\n    customer_gre_endpoint=\"203.0.113.1\",\n    cloudflare_gre_endpoint=\"203.0.113.2\",\n    interface_address=\"192.0.2.0/31\",\n    description=\"Tunnel for ISP X\",\n    ttl=64,\n    mtu=1476,\n    health_check_enabled=True,\n    health_check_target=\"203.0.113.1\",\n    health_check_type=\"reply\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.GreTunnel(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"GRE_1\",\n        CustomerGreEndpoint = \"203.0.113.1\",\n        CloudflareGreEndpoint = \"203.0.113.2\",\n        InterfaceAddress = \"192.0.2.0/31\",\n        Description = \"Tunnel for ISP X\",\n        Ttl = 64,\n        Mtu = 1476,\n        HealthCheckEnabled = true,\n        HealthCheckTarget = \"203.0.113.1\",\n        HealthCheckType = \"reply\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewGreTunnel(ctx, \"example\", \u0026cloudflare.GreTunnelArgs{\n\t\t\tAccountId:             pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:                  pulumi.String(\"GRE_1\"),\n\t\t\tCustomerGreEndpoint:   pulumi.String(\"203.0.113.1\"),\n\t\t\tCloudflareGreEndpoint: pulumi.String(\"203.0.113.2\"),\n\t\t\tInterfaceAddress:      pulumi.String(\"192.0.2.0/31\"),\n\t\t\tDescription:           pulumi.String(\"Tunnel for ISP X\"),\n\t\t\tTtl:                   pulumi.Int(64),\n\t\t\tMtu:                   pulumi.Int(1476),\n\t\t\tHealthCheckEnabled:    pulumi.Bool(true),\n\t\t\tHealthCheckTarget:     pulumi.String(\"203.0.113.1\"),\n\t\t\tHealthCheckType:       pulumi.String(\"reply\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.GreTunnel;\nimport com.pulumi.cloudflare.GreTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new GreTunnel(\"example\", GreTunnelArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"GRE_1\")\n            .customerGreEndpoint(\"203.0.113.1\")\n            .cloudflareGreEndpoint(\"203.0.113.2\")\n            .interfaceAddress(\"192.0.2.0/31\")\n            .description(\"Tunnel for ISP X\")\n            .ttl(64)\n            .mtu(1476)\n            .healthCheckEnabled(true)\n            .healthCheckTarget(\"203.0.113.1\")\n            .healthCheckType(\"reply\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:GreTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: GRE_1\n      customerGreEndpoint: 203.0.113.1\n      cloudflareGreEndpoint: 203.0.113.2\n      interfaceAddress: 192.0.2.0/31\n      description: Tunnel for ISP X\n      ttl: 64\n      mtu: 1476\n      healthCheckEnabled: true\n      healthCheckTarget: 203.0.113.1\n      healthCheckType: reply\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/greTunnel:GreTunnel example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "cloudflareGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                },
                "customerGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the GRE tunnel intent.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the GRE tunnel.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time To Live (TTL) in number of hops of the GRE tunnel.\n"
                }
            },
            "required": [
                "cloudflareGreEndpoint",
                "customerGreEndpoint",
                "healthCheckEnabled",
                "healthCheckTarget",
                "healthCheckType",
                "interfaceAddress",
                "mtu",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "cloudflareGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                },
                "customerGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the GRE tunnel intent.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the GRE tunnel.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time To Live (TTL) in number of hops of the GRE tunnel.\n"
                }
            },
            "requiredInputs": [
                "cloudflareGreEndpoint",
                "customerGreEndpoint",
                "interfaceAddress",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GreTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudflareGreEndpoint": {
                        "type": "string",
                        "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                    },
                    "customerGreEndpoint": {
                        "type": "string",
                        "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the GRE tunnel intent.\n"
                    },
                    "healthCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies if ICMP tunnel health checks are enabled.\n"
                    },
                    "healthCheckTarget": {
                        "type": "string",
                        "description": "The IP address of the customer endpoint that will receive tunnel health checks.\n"
                    },
                    "healthCheckType": {
                        "type": "string",
                        "description": "Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.\n"
                    },
                    "interfaceAddress": {
                        "type": "string",
                        "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the GRE tunnel.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Time To Live (TTL) in number of hops of the GRE tunnel.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/healthcheck:Healthcheck": {
            "description": "Standalone Health Checks provide a way to monitor origin servers\nwithout needing a Cloudflare Load Balancer.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// HTTPS Healthcheck\nconst httpHealthCheck = new cloudflare.Healthcheck(\"http_health_check\", {\n    zoneId: cloudflareZoneId,\n    name: \"http-health-check\",\n    description: \"example http health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    type: \"HTTPS\",\n    port: 443,\n    method: \"GET\",\n    path: \"/health\",\n    expectedBody: \"alive\",\n    expectedCodes: [\n        \"2xx\",\n        \"301\",\n    ],\n    followRedirects: true,\n    allowInsecure: false,\n    headers: [{\n        header: \"Host\",\n        values: [\"example.com\"],\n    }],\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n// TCP Healthcheck\nconst tcpHealthCheck = new cloudflare.Healthcheck(\"tcp_health_check\", {\n    zoneId: cloudflareZoneId,\n    name: \"tcp-health-check\",\n    description: \"example tcp health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    type: \"TCP\",\n    port: 22,\n    method: \"connection_established\",\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# HTTPS Healthcheck\nhttp_health_check = cloudflare.Healthcheck(\"http_health_check\",\n    zone_id=cloudflare_zone_id,\n    name=\"http-health-check\",\n    description=\"example http health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    type=\"HTTPS\",\n    port=443,\n    method=\"GET\",\n    path=\"/health\",\n    expected_body=\"alive\",\n    expected_codes=[\n        \"2xx\",\n        \"301\",\n    ],\n    follow_redirects=True,\n    allow_insecure=False,\n    headers=[{\n        \"header\": \"Host\",\n        \"values\": [\"example.com\"],\n    }],\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n# TCP Healthcheck\ntcp_health_check = cloudflare.Healthcheck(\"tcp_health_check\",\n    zone_id=cloudflare_zone_id,\n    name=\"tcp-health-check\",\n    description=\"example tcp health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    type=\"TCP\",\n    port=22,\n    method=\"connection_established\",\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // HTTPS Healthcheck\n    var httpHealthCheck = new Cloudflare.Healthcheck(\"http_health_check\", new()\n    {\n        ZoneId = cloudflareZoneId,\n        Name = \"http-health-check\",\n        Description = \"example http health check\",\n        Address = \"example.com\",\n        Suspended = false,\n        CheckRegions = new[]\n        {\n            \"WEU\",\n            \"EEU\",\n        },\n        Type = \"HTTPS\",\n        Port = 443,\n        Method = \"GET\",\n        Path = \"/health\",\n        ExpectedBody = \"alive\",\n        ExpectedCodes = new[]\n        {\n            \"2xx\",\n            \"301\",\n        },\n        FollowRedirects = true,\n        AllowInsecure = false,\n        Headers = new[]\n        {\n            new Cloudflare.Inputs.HealthcheckHeaderArgs\n            {\n                Header = \"Host\",\n                Values = new[]\n                {\n                    \"example.com\",\n                },\n            },\n        },\n        Timeout = 10,\n        Retries = 2,\n        Interval = 60,\n        ConsecutiveFails = 3,\n        ConsecutiveSuccesses = 2,\n    });\n\n    // TCP Healthcheck\n    var tcpHealthCheck = new Cloudflare.Healthcheck(\"tcp_health_check\", new()\n    {\n        ZoneId = cloudflareZoneId,\n        Name = \"tcp-health-check\",\n        Description = \"example tcp health check\",\n        Address = \"example.com\",\n        Suspended = false,\n        CheckRegions = new[]\n        {\n            \"WEU\",\n            \"EEU\",\n        },\n        Type = \"TCP\",\n        Port = 22,\n        Method = \"connection_established\",\n        Timeout = 10,\n        Retries = 2,\n        Interval = 60,\n        ConsecutiveFails = 3,\n        ConsecutiveSuccesses = 2,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// HTTPS Healthcheck\n\t\t_, err := cloudflare.NewHealthcheck(ctx, \"http_health_check\", \u0026cloudflare.HealthcheckArgs{\n\t\t\tZoneId:      pulumi.Any(cloudflareZoneId),\n\t\t\tName:        pulumi.String(\"http-health-check\"),\n\t\t\tDescription: pulumi.String(\"example http health check\"),\n\t\t\tAddress:     pulumi.String(\"example.com\"),\n\t\t\tSuspended:   pulumi.Bool(false),\n\t\t\tCheckRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WEU\"),\n\t\t\t\tpulumi.String(\"EEU\"),\n\t\t\t},\n\t\t\tType:         pulumi.String(\"HTTPS\"),\n\t\t\tPort:         pulumi.Int(443),\n\t\t\tMethod:       pulumi.String(\"GET\"),\n\t\t\tPath:         pulumi.String(\"/health\"),\n\t\t\tExpectedBody: pulumi.String(\"alive\"),\n\t\t\tExpectedCodes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"2xx\"),\n\t\t\t\tpulumi.String(\"301\"),\n\t\t\t},\n\t\t\tFollowRedirects: pulumi.Bool(true),\n\t\t\tAllowInsecure:   pulumi.Bool(false),\n\t\t\tHeaders: cloudflare.HealthcheckHeaderArray{\n\t\t\t\t\u0026cloudflare.HealthcheckHeaderArgs{\n\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTimeout:              pulumi.Int(10),\n\t\t\tRetries:              pulumi.Int(2),\n\t\t\tInterval:             pulumi.Int(60),\n\t\t\tConsecutiveFails:     pulumi.Int(3),\n\t\t\tConsecutiveSuccesses: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// TCP Healthcheck\n\t\t_, err = cloudflare.NewHealthcheck(ctx, \"tcp_health_check\", \u0026cloudflare.HealthcheckArgs{\n\t\t\tZoneId:      pulumi.Any(cloudflareZoneId),\n\t\t\tName:        pulumi.String(\"tcp-health-check\"),\n\t\t\tDescription: pulumi.String(\"example tcp health check\"),\n\t\t\tAddress:     pulumi.String(\"example.com\"),\n\t\t\tSuspended:   pulumi.Bool(false),\n\t\t\tCheckRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WEU\"),\n\t\t\t\tpulumi.String(\"EEU\"),\n\t\t\t},\n\t\t\tType:                 pulumi.String(\"TCP\"),\n\t\t\tPort:                 pulumi.Int(22),\n\t\t\tMethod:               pulumi.String(\"connection_established\"),\n\t\t\tTimeout:              pulumi.Int(10),\n\t\t\tRetries:              pulumi.Int(2),\n\t\t\tInterval:             pulumi.Int(60),\n\t\t\tConsecutiveFails:     pulumi.Int(3),\n\t\t\tConsecutiveSuccesses: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Healthcheck;\nimport com.pulumi.cloudflare.HealthcheckArgs;\nimport com.pulumi.cloudflare.inputs.HealthcheckHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // HTTPS Healthcheck\n        var httpHealthCheck = new Healthcheck(\"httpHealthCheck\", HealthcheckArgs.builder()\n            .zoneId(cloudflareZoneId)\n            .name(\"http-health-check\")\n            .description(\"example http health check\")\n            .address(\"example.com\")\n            .suspended(false)\n            .checkRegions(            \n                \"WEU\",\n                \"EEU\")\n            .type(\"HTTPS\")\n            .port(443)\n            .method(\"GET\")\n            .path(\"/health\")\n            .expectedBody(\"alive\")\n            .expectedCodes(            \n                \"2xx\",\n                \"301\")\n            .followRedirects(true)\n            .allowInsecure(false)\n            .headers(HealthcheckHeaderArgs.builder()\n                .header(\"Host\")\n                .values(\"example.com\")\n                .build())\n            .timeout(10)\n            .retries(2)\n            .interval(60)\n            .consecutiveFails(3)\n            .consecutiveSuccesses(2)\n            .build());\n\n        // TCP Healthcheck\n        var tcpHealthCheck = new Healthcheck(\"tcpHealthCheck\", HealthcheckArgs.builder()\n            .zoneId(cloudflareZoneId)\n            .name(\"tcp-health-check\")\n            .description(\"example tcp health check\")\n            .address(\"example.com\")\n            .suspended(false)\n            .checkRegions(            \n                \"WEU\",\n                \"EEU\")\n            .type(\"TCP\")\n            .port(22)\n            .method(\"connection_established\")\n            .timeout(10)\n            .retries(2)\n            .interval(60)\n            .consecutiveFails(3)\n            .consecutiveSuccesses(2)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # HTTPS Healthcheck\n  httpHealthCheck:\n    type: cloudflare:Healthcheck\n    name: http_health_check\n    properties:\n      zoneId: ${cloudflareZoneId}\n      name: http-health-check\n      description: example http health check\n      address: example.com\n      suspended: false\n      checkRegions:\n        - WEU\n        - EEU\n      type: HTTPS\n      port: 443\n      method: GET\n      path: /health\n      expectedBody: alive\n      expectedCodes:\n        - 2xx\n        - '301'\n      followRedirects: true\n      allowInsecure: false\n      headers:\n        - header: Host\n          values:\n            - example.com\n      timeout: 10\n      retries: 2\n      interval: 60\n      consecutiveFails: 3\n      consecutiveSuccesses: 2\n  # TCP Healthcheck\n  tcpHealthCheck:\n    type: cloudflare:Healthcheck\n    name: tcp_health_check\n    properties:\n      zoneId: ${cloudflareZoneId}\n      name: tcp-health-check\n      description: example tcp health check\n      address: example.com\n      suspended: false\n      checkRegions:\n        - WEU\n        - EEU\n      type: TCP\n      port: 22\n      method: connection_established\n      timeout: 10\n      retries: 2\n      interval: 60\n      consecutiveFails: 3\n      consecutiveSuccesses: 2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUse the Zone ID and Healthcheck ID to import.\n\n```sh\n$ pulumi import cloudflare:index/healthcheck:Healthcheck example \u003czone_id\u003e/\u003chealthcheck_id\u003e\n```\n\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Defaults to `false`.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Last modified time.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Defaults to `/`.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check. Defaults to `80`.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Defaults to `false`.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "address",
                "checkRegions",
                "createdOn",
                "method",
                "modifiedOn",
                "name",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Defaults to `false`.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Defaults to `/`.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check. Defaults to `80`.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Defaults to `false`.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "address",
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Healthcheck resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The hostname or IP address of the origin server to run health checks on.\n"
                    },
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.\n"
                    },
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                    },
                    "consecutiveFails": {
                        "type": "integer",
                        "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.\n"
                    },
                    "consecutiveSuccesses": {
                        "type": "integer",
                        "description": "The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-readable description of the health check.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.\n"
                    },
                    "expectedCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if the origin returns a 3xx status code. Defaults to `false`.\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                        },
                        "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Last modified time.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. Defaults to `/`.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port number to connect to for the health check. Defaults to `80`.\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, no health checks are sent to the origin. Defaults to `false`.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/hostnameTlsSetting:HostnameTlsSetting": {
            "description": "Provides a Cloudflare per-hostname TLS setting resource. Used to set TLS settings for hostnames under the specified zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.HostnameTlsSetting(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname: \"sub.example.com\",\n    setting: \"min_tls_version\",\n    value: \"1.2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.HostnameTlsSetting(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname=\"sub.example.com\",\n    setting=\"min_tls_version\",\n    value=\"1.2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.HostnameTlsSetting(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Hostname = \"sub.example.com\",\n        Setting = \"min_tls_version\",\n        Value = \"1.2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewHostnameTlsSetting(ctx, \"example\", \u0026cloudflare.HostnameTlsSettingArgs{\n\t\t\tZoneId:   pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tHostname: pulumi.String(\"sub.example.com\"),\n\t\t\tSetting:  pulumi.String(\"min_tls_version\"),\n\t\t\tValue:    pulumi.String(\"1.2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.HostnameTlsSetting;\nimport com.pulumi.cloudflare.HostnameTlsSettingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new HostnameTlsSetting(\"example\", HostnameTlsSettingArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .hostname(\"sub.example.com\")\n            .setting(\"min_tls_version\")\n            .value(\"1.2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:HostnameTlsSetting\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      hostname: sub.example.com\n      setting: min_tls_version\n      value: '1.2'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/hostnameTlsSetting:HostnameTlsSetting example \u003czone_id\u003e/\u003chostname\u003e/\u003csetting_name\u003e\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "setting": {
                    "type": "string",
                    "description": "TLS setting name. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "updatedAt": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "TLS setting value.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "createdAt",
                "hostname",
                "setting",
                "updatedAt",
                "value",
                "zoneId"
            ],
            "inputProperties": {
                "hostname": {
                    "type": "string",
                    "description": "Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "setting": {
                    "type": "string",
                    "description": "TLS setting name. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "TLS setting value.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostname",
                "setting",
                "value",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostnameTlsSetting resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "setting": {
                        "type": "string",
                        "description": "TLS setting name. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "updatedAt": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string",
                        "description": "TLS setting value.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/hostnameTlsSettingCiphers:HostnameTlsSettingCiphers": {
            "description": "Provides a Cloudflare per-hostname TLS setting resource, specifically for ciphers suites. Used to set ciphers suites for hostnames under the specified zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.HostnameTlsSettingCiphers(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname: \"sub.example.com\",\n    values: [\"ECDHE-RSA-AES128-GCM-SHA256\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.HostnameTlsSettingCiphers(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname=\"sub.example.com\",\n    values=[\"ECDHE-RSA-AES128-GCM-SHA256\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.HostnameTlsSettingCiphers(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Hostname = \"sub.example.com\",\n        Values = new[]\n        {\n            \"ECDHE-RSA-AES128-GCM-SHA256\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewHostnameTlsSettingCiphers(ctx, \"example\", \u0026cloudflare.HostnameTlsSettingCiphersArgs{\n\t\t\tZoneId:   pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tHostname: pulumi.String(\"sub.example.com\"),\n\t\t\tValues: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ECDHE-RSA-AES128-GCM-SHA256\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.HostnameTlsSettingCiphers;\nimport com.pulumi.cloudflare.HostnameTlsSettingCiphersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new HostnameTlsSettingCiphers(\"example\", HostnameTlsSettingCiphersArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .hostname(\"sub.example.com\")\n            .values(\"ECDHE-RSA-AES128-GCM-SHA256\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:HostnameTlsSettingCiphers\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      hostname: sub.example.com\n      values:\n        - ECDHE-RSA-AES128-GCM-SHA256\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/hostnameTlsSettingCiphers:HostnameTlsSettingCiphers example \u003czone_id\u003e/\u003chostname\u003e\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Ports to use within the IP rule.\n"
                },
                "updatedAt": {
                    "type": "string"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Ciphers suites value.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "createdAt",
                "hostname",
                "updatedAt",
                "values",
                "zoneId"
            ],
            "inputProperties": {
                "hostname": {
                    "type": "string",
                    "description": "Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Ports to use within the IP rule.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Ciphers suites value.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostname",
                "values",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostnameTlsSettingCiphers resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ports": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Ports to use within the IP rule.\n"
                    },
                    "updatedAt": {
                        "type": "string"
                    },
                    "values": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Ciphers suites value.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/hyperdriveConfig:HyperdriveConfig": {
            "description": "The [Hyperdrive Config](https://developers.cloudflare.com/hyperdrive/) resource allows you to manage Cloudflare Hyperdrive Configs.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst noDefaults = new cloudflare.HyperdriveConfig(\"no_defaults\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"my-hyperdrive-config\",\n    origin: {\n        database: \"postgres\",\n        password: \"my-password\",\n        host: \"my-database.example.com\",\n        port: 5432,\n        scheme: \"postgres\",\n        user: \"my-user\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nno_defaults = cloudflare.HyperdriveConfig(\"no_defaults\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"my-hyperdrive-config\",\n    origin={\n        \"database\": \"postgres\",\n        \"password\": \"my-password\",\n        \"host\": \"my-database.example.com\",\n        \"port\": 5432,\n        \"scheme\": \"postgres\",\n        \"user\": \"my-user\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var noDefaults = new Cloudflare.HyperdriveConfig(\"no_defaults\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"my-hyperdrive-config\",\n        Origin = new Cloudflare.Inputs.HyperdriveConfigOriginArgs\n        {\n            Database = \"postgres\",\n            Password = \"my-password\",\n            Host = \"my-database.example.com\",\n            Port = 5432,\n            Scheme = \"postgres\",\n            User = \"my-user\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewHyperdriveConfig(ctx, \"no_defaults\", \u0026cloudflare.HyperdriveConfigArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"my-hyperdrive-config\"),\n\t\t\tOrigin: \u0026cloudflare.HyperdriveConfigOriginArgs{\n\t\t\t\tDatabase: pulumi.String(\"postgres\"),\n\t\t\t\tPassword: pulumi.String(\"my-password\"),\n\t\t\t\tHost:     pulumi.String(\"my-database.example.com\"),\n\t\t\t\tPort:     pulumi.Int(5432),\n\t\t\t\tScheme:   pulumi.String(\"postgres\"),\n\t\t\t\tUser:     pulumi.String(\"my-user\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.HyperdriveConfig;\nimport com.pulumi.cloudflare.HyperdriveConfigArgs;\nimport com.pulumi.cloudflare.inputs.HyperdriveConfigOriginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var noDefaults = new HyperdriveConfig(\"noDefaults\", HyperdriveConfigArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"my-hyperdrive-config\")\n            .origin(HyperdriveConfigOriginArgs.builder()\n                .database(\"postgres\")\n                .password(\"my-password\")\n                .host(\"my-database.example.com\")\n                .port(5432)\n                .scheme(\"postgres\")\n                .user(\"my-user\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  noDefaults:\n    type: cloudflare:HyperdriveConfig\n    name: no_defaults\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: my-hyperdrive-config\n      origin:\n        database: postgres\n        password: my-password\n        host: my-database.example.com\n        port: 5432\n        scheme: postgres\n        user: my-user\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/hyperdriveConfig:HyperdriveConfig example \u003caccount_id\u003e/\u003chyperdrive_config_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "caching": {
                    "$ref": "#/types/cloudflare:index/HyperdriveConfigCaching:HyperdriveConfigCaching",
                    "description": "The caching details for the Hyperdrive configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Hyperdrive configuration.\n"
                },
                "origin": {
                    "$ref": "#/types/cloudflare:index/HyperdriveConfigOrigin:HyperdriveConfigOrigin",
                    "description": "The origin details for the Hyperdrive configuration.\n"
                }
            },
            "required": [
                "accountId",
                "caching",
                "name",
                "origin"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "caching": {
                    "$ref": "#/types/cloudflare:index/HyperdriveConfigCaching:HyperdriveConfigCaching",
                    "description": "The caching details for the Hyperdrive configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Hyperdrive configuration.\n"
                },
                "origin": {
                    "$ref": "#/types/cloudflare:index/HyperdriveConfigOrigin:HyperdriveConfigOrigin",
                    "description": "The origin details for the Hyperdrive configuration.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "origin"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HyperdriveConfig resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "caching": {
                        "$ref": "#/types/cloudflare:index/HyperdriveConfigCaching:HyperdriveConfigCaching",
                        "description": "The caching details for the Hyperdrive configuration.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Hyperdrive configuration.\n"
                    },
                    "origin": {
                        "$ref": "#/types/cloudflare:index/HyperdriveConfigOrigin:HyperdriveConfigOrigin",
                        "description": "The origin details for the Hyperdrive configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/infrastructureAccessTarget:InfrastructureAccessTarget": {
            "description": "The [Infrastructure Access Target](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#4-add-a-target) resource allows you to configure Infrastructure Access Targets for an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.InfrastructureAccessTarget(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostname: \"example-target\",\n    ip: {\n        ipv4: {\n            ipAddr: \"198.51.100.1\",\n            virtualNetworkId: \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n        ipv6: {\n            ipAddr: \"2001:db8::\",\n            virtualNetworkId: \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    },\n});\nconst ipv4OnlyExample = new cloudflare.InfrastructureAccessTarget(\"ipv4_only_example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostname: \"example-ipv4-only\",\n    ip: {\n        ipv4: {\n            ipAddr: \"198.51.100.1\",\n            virtualNetworkId: \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.InfrastructureAccessTarget(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname=\"example-target\",\n    ip={\n        \"ipv4\": {\n            \"ip_addr\": \"198.51.100.1\",\n            \"virtual_network_id\": \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n        \"ipv6\": {\n            \"ip_addr\": \"2001:db8::\",\n            \"virtual_network_id\": \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    })\nipv4_only_example = cloudflare.InfrastructureAccessTarget(\"ipv4_only_example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname=\"example-ipv4-only\",\n    ip={\n        \"ipv4\": {\n            \"ip_addr\": \"198.51.100.1\",\n            \"virtual_network_id\": \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.InfrastructureAccessTarget(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Hostname = \"example-target\",\n        Ip = new Cloudflare.Inputs.InfrastructureAccessTargetIpArgs\n        {\n            Ipv4 = new Cloudflare.Inputs.InfrastructureAccessTargetIpIpv4Args\n            {\n                IpAddr = \"198.51.100.1\",\n                VirtualNetworkId = \"238dccd1-149b-463d-8228-560ab83a54fd\",\n            },\n            Ipv6 = new Cloudflare.Inputs.InfrastructureAccessTargetIpIpv6Args\n            {\n                IpAddr = \"2001:db8::\",\n                VirtualNetworkId = \"238dccd1-149b-463d-8228-560ab83a54fd\",\n            },\n        },\n    });\n\n    var ipv4OnlyExample = new Cloudflare.InfrastructureAccessTarget(\"ipv4_only_example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Hostname = \"example-ipv4-only\",\n        Ip = new Cloudflare.Inputs.InfrastructureAccessTargetIpArgs\n        {\n            Ipv4 = new Cloudflare.Inputs.InfrastructureAccessTargetIpIpv4Args\n            {\n                IpAddr = \"198.51.100.1\",\n                VirtualNetworkId = \"238dccd1-149b-463d-8228-560ab83a54fd\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewInfrastructureAccessTarget(ctx, \"example\", \u0026cloudflare.InfrastructureAccessTargetArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tHostname:  pulumi.String(\"example-target\"),\n\t\t\tIp: \u0026cloudflare.InfrastructureAccessTargetIpArgs{\n\t\t\t\tIpv4: \u0026cloudflare.InfrastructureAccessTargetIpIpv4Args{\n\t\t\t\t\tIpAddr:           pulumi.String(\"198.51.100.1\"),\n\t\t\t\t\tVirtualNetworkId: pulumi.String(\"238dccd1-149b-463d-8228-560ab83a54fd\"),\n\t\t\t\t},\n\t\t\t\tIpv6: \u0026cloudflare.InfrastructureAccessTargetIpIpv6Args{\n\t\t\t\t\tIpAddr:           pulumi.String(\"2001:db8::\"),\n\t\t\t\t\tVirtualNetworkId: pulumi.String(\"238dccd1-149b-463d-8228-560ab83a54fd\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewInfrastructureAccessTarget(ctx, \"ipv4_only_example\", \u0026cloudflare.InfrastructureAccessTargetArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tHostname:  pulumi.String(\"example-ipv4-only\"),\n\t\t\tIp: \u0026cloudflare.InfrastructureAccessTargetIpArgs{\n\t\t\t\tIpv4: \u0026cloudflare.InfrastructureAccessTargetIpIpv4Args{\n\t\t\t\t\tIpAddr:           pulumi.String(\"198.51.100.1\"),\n\t\t\t\t\tVirtualNetworkId: pulumi.String(\"238dccd1-149b-463d-8228-560ab83a54fd\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.InfrastructureAccessTarget;\nimport com.pulumi.cloudflare.InfrastructureAccessTargetArgs;\nimport com.pulumi.cloudflare.inputs.InfrastructureAccessTargetIpArgs;\nimport com.pulumi.cloudflare.inputs.InfrastructureAccessTargetIpIpv4Args;\nimport com.pulumi.cloudflare.inputs.InfrastructureAccessTargetIpIpv6Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new InfrastructureAccessTarget(\"example\", InfrastructureAccessTargetArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostname(\"example-target\")\n            .ip(InfrastructureAccessTargetIpArgs.builder()\n                .ipv4(InfrastructureAccessTargetIpIpv4Args.builder()\n                    .ipAddr(\"198.51.100.1\")\n                    .virtualNetworkId(\"238dccd1-149b-463d-8228-560ab83a54fd\")\n                    .build())\n                .ipv6(InfrastructureAccessTargetIpIpv6Args.builder()\n                    .ipAddr(\"2001:db8::\")\n                    .virtualNetworkId(\"238dccd1-149b-463d-8228-560ab83a54fd\")\n                    .build())\n                .build())\n            .build());\n\n        var ipv4OnlyExample = new InfrastructureAccessTarget(\"ipv4OnlyExample\", InfrastructureAccessTargetArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostname(\"example-ipv4-only\")\n            .ip(InfrastructureAccessTargetIpArgs.builder()\n                .ipv4(InfrastructureAccessTargetIpIpv4Args.builder()\n                    .ipAddr(\"198.51.100.1\")\n                    .virtualNetworkId(\"238dccd1-149b-463d-8228-560ab83a54fd\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:InfrastructureAccessTarget\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      hostname: example-target\n      ip:\n        ipv4:\n          ipAddr: 198.51.100.1\n          virtualNetworkId: 238dccd1-149b-463d-8228-560ab83a54fd\n        ipv6:\n          ipAddr: '2001:db8::'\n          virtualNetworkId: 238dccd1-149b-463d-8228-560ab83a54fd\n  ipv4OnlyExample:\n    type: cloudflare:InfrastructureAccessTarget\n    name: ipv4_only_example\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      hostname: example-ipv4-only\n      ip:\n        ipv4:\n          ipAddr: 198.51.100.1\n          virtualNetworkId: 238dccd1-149b-463d-8228-560ab83a54fd\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/infrastructureAccessTarget:InfrastructureAccessTarget example \u003caccount_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The date and time at which the target was created.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A non-unique field that refers to a target.\n"
                },
                "ip": {
                    "$ref": "#/types/cloudflare:index/InfrastructureAccessTargetIp:InfrastructureAccessTargetIp",
                    "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                },
                "modifiedAt": {
                    "type": "string",
                    "description": "The date and time at which the target was last modified.\n"
                }
            },
            "required": [
                "accountId",
                "createdAt",
                "hostname",
                "ip",
                "modifiedAt"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A non-unique field that refers to a target.\n"
                },
                "ip": {
                    "$ref": "#/types/cloudflare:index/InfrastructureAccessTargetIp:InfrastructureAccessTargetIp",
                    "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "hostname",
                "ip"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InfrastructureAccessTarget resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The date and time at which the target was created.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "A non-unique field that refers to a target.\n"
                    },
                    "ip": {
                        "$ref": "#/types/cloudflare:index/InfrastructureAccessTargetIp:InfrastructureAccessTargetIp",
                        "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                    },
                    "modifiedAt": {
                        "type": "string",
                        "description": "The date and time at which the target was last modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ipsecTunnel:IpsecTunnel": {
            "description": "Provides a resource, that manages IPsec tunnels for Magic Transit.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.IpsecTunnel(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"IPsec_1\",\n    customerEndpoint: \"203.0.113.1\",\n    cloudflareEndpoint: \"203.0.113.1\",\n    interfaceAddress: \"192.0.2.0/31\",\n    description: \"Tunnel for ISP X\",\n    healthCheckEnabled: true,\n    healthCheckTarget: \"203.0.113.1\",\n    healthCheckType: \"reply\",\n    psk: \"asdf12341234\",\n    allowNullCipher: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.IpsecTunnel(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"IPsec_1\",\n    customer_endpoint=\"203.0.113.1\",\n    cloudflare_endpoint=\"203.0.113.1\",\n    interface_address=\"192.0.2.0/31\",\n    description=\"Tunnel for ISP X\",\n    health_check_enabled=True,\n    health_check_target=\"203.0.113.1\",\n    health_check_type=\"reply\",\n    psk=\"asdf12341234\",\n    allow_null_cipher=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.IpsecTunnel(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"IPsec_1\",\n        CustomerEndpoint = \"203.0.113.1\",\n        CloudflareEndpoint = \"203.0.113.1\",\n        InterfaceAddress = \"192.0.2.0/31\",\n        Description = \"Tunnel for ISP X\",\n        HealthCheckEnabled = true,\n        HealthCheckTarget = \"203.0.113.1\",\n        HealthCheckType = \"reply\",\n        Psk = \"asdf12341234\",\n        AllowNullCipher = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewIpsecTunnel(ctx, \"example\", \u0026cloudflare.IpsecTunnelArgs{\n\t\t\tAccountId:          pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:               pulumi.String(\"IPsec_1\"),\n\t\t\tCustomerEndpoint:   pulumi.String(\"203.0.113.1\"),\n\t\t\tCloudflareEndpoint: pulumi.String(\"203.0.113.1\"),\n\t\t\tInterfaceAddress:   pulumi.String(\"192.0.2.0/31\"),\n\t\t\tDescription:        pulumi.String(\"Tunnel for ISP X\"),\n\t\t\tHealthCheckEnabled: pulumi.Bool(true),\n\t\t\tHealthCheckTarget:  pulumi.String(\"203.0.113.1\"),\n\t\t\tHealthCheckType:    pulumi.String(\"reply\"),\n\t\t\tPsk:                pulumi.String(\"asdf12341234\"),\n\t\t\tAllowNullCipher:    pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.IpsecTunnel;\nimport com.pulumi.cloudflare.IpsecTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IpsecTunnel(\"example\", IpsecTunnelArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"IPsec_1\")\n            .customerEndpoint(\"203.0.113.1\")\n            .cloudflareEndpoint(\"203.0.113.1\")\n            .interfaceAddress(\"192.0.2.0/31\")\n            .description(\"Tunnel for ISP X\")\n            .healthCheckEnabled(true)\n            .healthCheckTarget(\"203.0.113.1\")\n            .healthCheckType(\"reply\")\n            .psk(\"asdf12341234\")\n            .allowNullCipher(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:IpsecTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: IPsec_1\n      customerEndpoint: 203.0.113.1\n      cloudflareEndpoint: 203.0.113.1\n      interfaceAddress: 192.0.2.0/31\n      description: Tunnel for ISP X\n      healthCheckEnabled: true\n      healthCheckTarget: 203.0.113.1\n      healthCheckType: reply\n      psk: asdf12341234\n      allowNullCipher: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/ipsecTunnel:IpsecTunnel example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "allowNullCipher": {
                    "type": "boolean",
                    "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                },
                "cloudflareEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                },
                "customerEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the IPsec tunnel.\n"
                },
                "fqdnId": {
                    "type": "string",
                    "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                },
                "healthCheckDirection": {
                    "type": "string",
                    "description": "Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                },
                "healthCheckRate": {
                    "type": "string",
                    "description": "Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                },
                "hexId": {
                    "type": "string",
                    "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IPsec tunnel.\n"
                },
                "psk": {
                    "type": "string",
                    "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                },
                "replayProtection": {
                    "type": "boolean",
                    "description": "Specifies if replay protection is enabled. Defaults to `false`.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                }
            },
            "required": [
                "cloudflareEndpoint",
                "customerEndpoint",
                "fqdnId",
                "healthCheckDirection",
                "healthCheckEnabled",
                "healthCheckRate",
                "healthCheckTarget",
                "healthCheckType",
                "hexId",
                "interfaceAddress",
                "name",
                "psk",
                "remoteId",
                "userId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "allowNullCipher": {
                    "type": "boolean",
                    "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                },
                "cloudflareEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                },
                "customerEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the IPsec tunnel.\n"
                },
                "fqdnId": {
                    "type": "string",
                    "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                },
                "healthCheckDirection": {
                    "type": "string",
                    "description": "Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                },
                "healthCheckRate": {
                    "type": "string",
                    "description": "Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                },
                "hexId": {
                    "type": "string",
                    "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IPsec tunnel.\n"
                },
                "psk": {
                    "type": "string",
                    "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                },
                "replayProtection": {
                    "type": "boolean",
                    "description": "Specifies if replay protection is enabled. Defaults to `false`.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                }
            },
            "requiredInputs": [
                "cloudflareEndpoint",
                "customerEndpoint",
                "interfaceAddress",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpsecTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "allowNullCipher": {
                        "type": "boolean",
                        "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                    },
                    "cloudflareEndpoint": {
                        "type": "string",
                        "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                    },
                    "customerEndpoint": {
                        "type": "string",
                        "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the IPsec tunnel.\n"
                    },
                    "fqdnId": {
                        "type": "string",
                        "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                    },
                    "healthCheckDirection": {
                        "type": "string",
                        "description": "Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.\n"
                    },
                    "healthCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                    },
                    "healthCheckRate": {
                        "type": "string",
                        "description": "Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.\n"
                    },
                    "healthCheckTarget": {
                        "type": "string",
                        "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                    },
                    "healthCheckType": {
                        "type": "string",
                        "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                    },
                    "hexId": {
                        "type": "string",
                        "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                    },
                    "interfaceAddress": {
                        "type": "string",
                        "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the IPsec tunnel.\n"
                    },
                    "psk": {
                        "type": "string",
                        "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                        "secret": true
                    },
                    "remoteId": {
                        "type": "string",
                        "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                    },
                    "replayProtection": {
                        "type": "boolean",
                        "description": "Specifies if replay protection is enabled. Defaults to `false`.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/keylessCertificate:KeylessCertificate": {
            "description": "Provides a resource, that manages Keyless certificates.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.KeylessCertificate(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    bundleMethod: \"ubiquitous\",\n    name: \"example.com Keyless SSL\",\n    host: \"example.com\",\n    port: 24008,\n    enabled: true,\n    certificate: \"-----INSERT CERTIFICATE-----\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.KeylessCertificate(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    bundle_method=\"ubiquitous\",\n    name=\"example.com Keyless SSL\",\n    host=\"example.com\",\n    port=24008,\n    enabled=True,\n    certificate=\"-----INSERT CERTIFICATE-----\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.KeylessCertificate(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        BundleMethod = \"ubiquitous\",\n        Name = \"example.com Keyless SSL\",\n        Host = \"example.com\",\n        Port = 24008,\n        Enabled = true,\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewKeylessCertificate(ctx, \"example\", \u0026cloudflare.KeylessCertificateArgs{\n\t\t\tZoneId:       pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tBundleMethod: pulumi.String(\"ubiquitous\"),\n\t\t\tName:         pulumi.String(\"example.com Keyless SSL\"),\n\t\t\tHost:         pulumi.String(\"example.com\"),\n\t\t\tPort:         pulumi.Int(24008),\n\t\t\tEnabled:      pulumi.Bool(true),\n\t\t\tCertificate:  pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.KeylessCertificate;\nimport com.pulumi.cloudflare.KeylessCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new KeylessCertificate(\"example\", KeylessCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .bundleMethod(\"ubiquitous\")\n            .name(\"example.com Keyless SSL\")\n            .host(\"example.com\")\n            .port(24008)\n            .enabled(true)\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:KeylessCertificate\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      bundleMethod: ubiquitous\n      name: example.com Keyless SSL\n      host: example.com\n      port: 24008\n      enabled: true\n      certificate: '-----INSERT CERTIFICATE-----'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/keylessCertificate:KeylessCertificate example \u003czone_id\u003e/\u003ckeyless_certificate_id\u003e\n```\n\n",
            "properties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the KeyLess SSL is on.\n"
                },
                "host": {
                    "type": "string",
                    "description": "The KeyLess SSL host.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The KeyLess SSL name.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the KeyLess SSL.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "certificate",
                "host",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "certificate": {
                    "type": "string",
                    "description": "The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the KeyLess SSL is on.\n"
                },
                "host": {
                    "type": "string",
                    "description": "The KeyLess SSL host.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The KeyLess SSL name.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "certificate",
                "host",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KeylessCertificate resources.\n",
                "properties": {
                    "bundleMethod": {
                        "type": "string",
                        "description": "A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the KeyLess SSL is on.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "The KeyLess SSL host.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The KeyLess SSL name.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the KeyLess SSL.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/list:List": {
            "description": "## Example Usage\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/list:List example \u003caccount_id\u003e/\u003clist_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItem:ListItem"
                    },
                    "description": "The items in the list.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The type of items the list will contain. Must provide only one of: `ip`, `redirect`, `hostname`, `asn`..\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list.\n"
                }
            },
            "required": [
                "accountId",
                "kind",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItem:ListItem"
                    },
                    "description": "The items in the list.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The type of items the list will contain. Must provide only one of: `ip`, `redirect`, `hostname`, `asn`..\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "kind",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering List resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the list.\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ListItem:ListItem"
                        },
                        "description": "The items in the list.\n"
                    },
                    "kind": {
                        "type": "string",
                        "description": "The type of items the list will contain. Must provide only one of: `ip`, `redirect`, `hostname`, `asn`..\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the list.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/listItem:ListItem": {
            "description": "Provides individual list items (IPs, Redirects, ASNs, Hostnames) to be used in Edge Rules Engine\nacross all zones within the same account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// IP List\nconst exampleIpList = new cloudflare.List(\"example_ip_list\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_list\",\n    description: \"example IPs for a list\",\n    kind: \"ip\",\n});\n// IP List Item\nconst exampleIpItem = new cloudflare.ListItem(\"example_ip_item\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    listId: exampleIpList.id,\n    comment: \"List Item Comment\",\n    ip: \"192.0.2.0\",\n});\n// Redirect List\nconst exampleRedirectList = new cloudflare.List(\"example_redirect_list\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_list\",\n    description: \"example Redirects for a list\",\n    kind: \"redirect\",\n});\n// Redirect List Item\nconst exampleRedirectItem = new cloudflare.ListItem(\"example_redirect_item\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    listId: exampleIpList.id,\n    redirect: {\n        sourceUrl: \"https://source.tld/\",\n        targetUrl: \"https://target.tld\",\n        statusCode: 302,\n        subpathMatching: true,\n    },\n});\n// ASN List\nconst exampleAsnList = new cloudflare.List(\"example_asn_list\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_asn_list\",\n    description: \"example ASNs for a list\",\n    kind: \"asn\",\n});\n// ASN List Item\nconst exampleAsnItem = new cloudflare.ListItem(\"example_asn_item\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    listId: exampleAsnList.id,\n    comment: \"List Item Comment\",\n    asn: 6789,\n});\n// Hostname List\nconst exampleHostnameList = new cloudflare.List(\"example_hostname_list\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_hostname_list\",\n    description: \"example Hostnames for a list\",\n    kind: \"hostname\",\n});\n// Hostname List Item\nconst exampleHostnameItem = new cloudflare.ListItem(\"example_hostname_item\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    listId: exampleHostnameList.id,\n    comment: \"List Item Comment\",\n    hostname: {\n        urlHostname: \"example.com\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# IP List\nexample_ip_list = cloudflare.List(\"example_ip_list\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_list\",\n    description=\"example IPs for a list\",\n    kind=\"ip\")\n# IP List Item\nexample_ip_item = cloudflare.ListItem(\"example_ip_item\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    list_id=example_ip_list.id,\n    comment=\"List Item Comment\",\n    ip=\"192.0.2.0\")\n# Redirect List\nexample_redirect_list = cloudflare.List(\"example_redirect_list\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_list\",\n    description=\"example Redirects for a list\",\n    kind=\"redirect\")\n# Redirect List Item\nexample_redirect_item = cloudflare.ListItem(\"example_redirect_item\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    list_id=example_ip_list.id,\n    redirect={\n        \"source_url\": \"https://source.tld/\",\n        \"target_url\": \"https://target.tld\",\n        \"status_code\": 302,\n        \"subpath_matching\": True,\n    })\n# ASN List\nexample_asn_list = cloudflare.List(\"example_asn_list\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_asn_list\",\n    description=\"example ASNs for a list\",\n    kind=\"asn\")\n# ASN List Item\nexample_asn_item = cloudflare.ListItem(\"example_asn_item\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    list_id=example_asn_list.id,\n    comment=\"List Item Comment\",\n    asn=6789)\n# Hostname List\nexample_hostname_list = cloudflare.List(\"example_hostname_list\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_hostname_list\",\n    description=\"example Hostnames for a list\",\n    kind=\"hostname\")\n# Hostname List Item\nexample_hostname_item = cloudflare.ListItem(\"example_hostname_item\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    list_id=example_hostname_list.id,\n    comment=\"List Item Comment\",\n    hostname={\n        \"url_hostname\": \"example.com\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // IP List\n    var exampleIpList = new Cloudflare.List(\"example_ip_list\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_list\",\n        Description = \"example IPs for a list\",\n        Kind = \"ip\",\n    });\n\n    // IP List Item\n    var exampleIpItem = new Cloudflare.ListItem(\"example_ip_item\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ListId = exampleIpList.Id,\n        Comment = \"List Item Comment\",\n        Ip = \"192.0.2.0\",\n    });\n\n    // Redirect List\n    var exampleRedirectList = new Cloudflare.List(\"example_redirect_list\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_list\",\n        Description = \"example Redirects for a list\",\n        Kind = \"redirect\",\n    });\n\n    // Redirect List Item\n    var exampleRedirectItem = new Cloudflare.ListItem(\"example_redirect_item\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ListId = exampleIpList.Id,\n        Redirect = new Cloudflare.Inputs.ListItemRedirectArgs\n        {\n            SourceUrl = \"https://source.tld/\",\n            TargetUrl = \"https://target.tld\",\n            StatusCode = 302,\n            SubpathMatching = true,\n        },\n    });\n\n    // ASN List\n    var exampleAsnList = new Cloudflare.List(\"example_asn_list\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_asn_list\",\n        Description = \"example ASNs for a list\",\n        Kind = \"asn\",\n    });\n\n    // ASN List Item\n    var exampleAsnItem = new Cloudflare.ListItem(\"example_asn_item\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ListId = exampleAsnList.Id,\n        Comment = \"List Item Comment\",\n        Asn = 6789,\n    });\n\n    // Hostname List\n    var exampleHostnameList = new Cloudflare.List(\"example_hostname_list\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_hostname_list\",\n        Description = \"example Hostnames for a list\",\n        Kind = \"hostname\",\n    });\n\n    // Hostname List Item\n    var exampleHostnameItem = new Cloudflare.ListItem(\"example_hostname_item\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ListId = exampleHostnameList.Id,\n        Comment = \"List Item Comment\",\n        Hostname = new Cloudflare.Inputs.ListItemHostnameArgs\n        {\n            UrlHostname = \"example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// IP List\n\t\texampleIpList, err := cloudflare.NewList(ctx, \"example_ip_list\", \u0026cloudflare.ListArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"example_list\"),\n\t\t\tDescription: pulumi.String(\"example IPs for a list\"),\n\t\t\tKind:        pulumi.String(\"ip\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// IP List Item\n\t\t_, err = cloudflare.NewListItem(ctx, \"example_ip_item\", \u0026cloudflare.ListItemArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tListId:    exampleIpList.ID(),\n\t\t\tComment:   pulumi.String(\"List Item Comment\"),\n\t\t\tIp:        pulumi.String(\"192.0.2.0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Redirect List\n\t\t_, err = cloudflare.NewList(ctx, \"example_redirect_list\", \u0026cloudflare.ListArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"example_list\"),\n\t\t\tDescription: pulumi.String(\"example Redirects for a list\"),\n\t\t\tKind:        pulumi.String(\"redirect\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Redirect List Item\n\t\t_, err = cloudflare.NewListItem(ctx, \"example_redirect_item\", \u0026cloudflare.ListItemArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tListId:    exampleIpList.ID(),\n\t\t\tRedirect: \u0026cloudflare.ListItemRedirectArgs{\n\t\t\t\tSourceUrl:       pulumi.String(\"https://source.tld/\"),\n\t\t\t\tTargetUrl:       pulumi.String(\"https://target.tld\"),\n\t\t\t\tStatusCode:      pulumi.Int(302),\n\t\t\t\tSubpathMatching: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// ASN List\n\t\texampleAsnList, err := cloudflare.NewList(ctx, \"example_asn_list\", \u0026cloudflare.ListArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"example_asn_list\"),\n\t\t\tDescription: pulumi.String(\"example ASNs for a list\"),\n\t\t\tKind:        pulumi.String(\"asn\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// ASN List Item\n\t\t_, err = cloudflare.NewListItem(ctx, \"example_asn_item\", \u0026cloudflare.ListItemArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tListId:    exampleAsnList.ID(),\n\t\t\tComment:   pulumi.String(\"List Item Comment\"),\n\t\t\tAsn:       pulumi.Int(6789),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Hostname List\n\t\texampleHostnameList, err := cloudflare.NewList(ctx, \"example_hostname_list\", \u0026cloudflare.ListArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"example_hostname_list\"),\n\t\t\tDescription: pulumi.String(\"example Hostnames for a list\"),\n\t\t\tKind:        pulumi.String(\"hostname\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Hostname List Item\n\t\t_, err = cloudflare.NewListItem(ctx, \"example_hostname_item\", \u0026cloudflare.ListItemArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tListId:    exampleHostnameList.ID(),\n\t\t\tComment:   pulumi.String(\"List Item Comment\"),\n\t\t\tHostname: \u0026cloudflare.ListItemHostnameArgs{\n\t\t\t\tUrlHostname: pulumi.String(\"example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.List;\nimport com.pulumi.cloudflare.ListArgs;\nimport com.pulumi.cloudflare.ListItem;\nimport com.pulumi.cloudflare.ListItemArgs;\nimport com.pulumi.cloudflare.inputs.ListItemRedirectArgs;\nimport com.pulumi.cloudflare.inputs.ListItemHostnameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // IP List\n        var exampleIpList = new List(\"exampleIpList\", ListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_list\")\n            .description(\"example IPs for a list\")\n            .kind(\"ip\")\n            .build());\n\n        // IP List Item\n        var exampleIpItem = new ListItem(\"exampleIpItem\", ListItemArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .listId(exampleIpList.id())\n            .comment(\"List Item Comment\")\n            .ip(\"192.0.2.0\")\n            .build());\n\n        // Redirect List\n        var exampleRedirectList = new List(\"exampleRedirectList\", ListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_list\")\n            .description(\"example Redirects for a list\")\n            .kind(\"redirect\")\n            .build());\n\n        // Redirect List Item\n        var exampleRedirectItem = new ListItem(\"exampleRedirectItem\", ListItemArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .listId(exampleIpList.id())\n            .redirect(ListItemRedirectArgs.builder()\n                .sourceUrl(\"https://source.tld/\")\n                .targetUrl(\"https://target.tld\")\n                .statusCode(302)\n                .subpathMatching(true)\n                .build())\n            .build());\n\n        // ASN List\n        var exampleAsnList = new List(\"exampleAsnList\", ListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_asn_list\")\n            .description(\"example ASNs for a list\")\n            .kind(\"asn\")\n            .build());\n\n        // ASN List Item\n        var exampleAsnItem = new ListItem(\"exampleAsnItem\", ListItemArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .listId(exampleAsnList.id())\n            .comment(\"List Item Comment\")\n            .asn(6789)\n            .build());\n\n        // Hostname List\n        var exampleHostnameList = new List(\"exampleHostnameList\", ListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_hostname_list\")\n            .description(\"example Hostnames for a list\")\n            .kind(\"hostname\")\n            .build());\n\n        // Hostname List Item\n        var exampleHostnameItem = new ListItem(\"exampleHostnameItem\", ListItemArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .listId(exampleHostnameList.id())\n            .comment(\"List Item Comment\")\n            .hostname(ListItemHostnameArgs.builder()\n                .urlHostname(\"example.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # IP List\n  exampleIpList:\n    type: cloudflare:List\n    name: example_ip_list\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_list\n      description: example IPs for a list\n      kind: ip\n  # IP List Item\n  exampleIpItem:\n    type: cloudflare:ListItem\n    name: example_ip_item\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      listId: ${exampleIpList.id}\n      comment: List Item Comment\n      ip: 192.0.2.0\n  # Redirect List\n  exampleRedirectList:\n    type: cloudflare:List\n    name: example_redirect_list\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_list\n      description: example Redirects for a list\n      kind: redirect\n  # Redirect List Item\n  exampleRedirectItem:\n    type: cloudflare:ListItem\n    name: example_redirect_item\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      listId: ${exampleIpList.id}\n      redirect:\n        sourceUrl: https://source.tld/\n        targetUrl: https://target.tld\n        statusCode: 302\n        subpathMatching: true\n  # ASN List\n  exampleAsnList:\n    type: cloudflare:List\n    name: example_asn_list\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_asn_list\n      description: example ASNs for a list\n      kind: asn\n  # ASN List Item\n  exampleAsnItem:\n    type: cloudflare:ListItem\n    name: example_asn_item\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      listId: ${exampleAsnList.id}\n      comment: List Item Comment\n      asn: 6789\n  # Hostname List\n  exampleHostnameList:\n    type: cloudflare:List\n    name: example_hostname_list\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_hostname_list\n      description: example Hostnames for a list\n      kind: hostname\n  # Hostname List Item\n  exampleHostnameItem:\n    type: cloudflare:ListItem\n    name: example_hostname_item\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      listId: ${exampleHostnameList.id}\n      comment: List Item Comment\n      hostname:\n        urlHostname: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/listItem:ListItem example \u003caccount_id\u003e/\u003clist_id\u003e/\u003citem_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "asn": {
                    "type": "integer",
                    "description": "Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "An optional comment for the item.\n"
                },
                "hostname": {
                    "$ref": "#/types/cloudflare:index/ListItemHostname:ListItemHostname",
                    "description": "Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                },
                "listId": {
                    "type": "string",
                    "description": "The list identifier to target for the resource.\n"
                },
                "redirect": {
                    "$ref": "#/types/cloudflare:index/ListItemRedirect:ListItemRedirect",
                    "description": "Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                }
            },
            "required": [
                "accountId",
                "listId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "asn": {
                    "type": "integer",
                    "description": "Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "An optional comment for the item.\n"
                },
                "hostname": {
                    "$ref": "#/types/cloudflare:index/ListItemHostname:ListItemHostname",
                    "description": "Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                },
                "listId": {
                    "type": "string",
                    "description": "The list identifier to target for the resource.\n"
                },
                "redirect": {
                    "$ref": "#/types/cloudflare:index/ListItemRedirect:ListItemRedirect",
                    "description": "Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "listId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ListItem resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "asn": {
                        "type": "integer",
                        "description": "Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "An optional comment for the item.\n"
                    },
                    "hostname": {
                        "$ref": "#/types/cloudflare:index/ListItemHostname:ListItemHostname",
                        "description": "Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                    },
                    "listId": {
                        "type": "string",
                        "description": "The list identifier to target for the resource.\n"
                    },
                    "redirect": {
                        "$ref": "#/types/cloudflare:index/ListItemRedirect:ListItemRedirect",
                        "description": "Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancer:LoadBalancer": {
            "description": "Provides a Cloudflare Load Balancer resource. This sits in front of\na number of defined pools of origins and provides various options\nfor geographically-aware load balancing. Note that the load balancing\nfeature must be enabled in your Cloudflare account before you can use\nthis resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleLoadBalancerPool = new cloudflare.LoadBalancerPool(\"example\", {\n    name: \"example-lb-pool\",\n    origins: [{\n        name: \"example-1\",\n        address: \"192.0.2.1\",\n        enabled: false,\n    }],\n});\n// Define a load balancer which always points to a pool we define below.\n// In normal usage, would have different pools set for different pops\n// (cloudflare points-of-presence) and/or for different regions.\n// Within each pop or region we can define multiple pools in failover order.\nconst example = new cloudflare.LoadBalancer(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"example-load-balancer.example.com\",\n    fallbackPoolId: exampleLoadBalancerPool.id,\n    defaultPoolIds: [exampleLoadBalancerPool.id],\n    description: \"example load balancer using geo-balancing\",\n    proxied: true,\n    steeringPolicy: \"geo\",\n    popPools: [{\n        pop: \"LAX\",\n        poolIds: [exampleLoadBalancerPool.id],\n    }],\n    countryPools: [{\n        country: \"US\",\n        poolIds: [exampleLoadBalancerPool.id],\n    }],\n    regionPools: [{\n        region: \"WNAM\",\n        poolIds: [exampleLoadBalancerPool.id],\n    }],\n    rules: [{\n        name: \"example rule\",\n        condition: \"http.request.uri.path contains \\\"testing\\\"\",\n        fixedResponse: {\n            messageBody: \"hello\",\n            statusCode: 200,\n            contentType: \"html\",\n            location: \"www.example.com\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_load_balancer_pool = cloudflare.LoadBalancerPool(\"example\",\n    name=\"example-lb-pool\",\n    origins=[{\n        \"name\": \"example-1\",\n        \"address\": \"192.0.2.1\",\n        \"enabled\": False,\n    }])\n# Define a load balancer which always points to a pool we define below.\n# In normal usage, would have different pools set for different pops\n# (cloudflare points-of-presence) and/or for different regions.\n# Within each pop or region we can define multiple pools in failover order.\nexample = cloudflare.LoadBalancer(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"example-load-balancer.example.com\",\n    fallback_pool_id=example_load_balancer_pool.id,\n    default_pool_ids=[example_load_balancer_pool.id],\n    description=\"example load balancer using geo-balancing\",\n    proxied=True,\n    steering_policy=\"geo\",\n    pop_pools=[{\n        \"pop\": \"LAX\",\n        \"pool_ids\": [example_load_balancer_pool.id],\n    }],\n    country_pools=[{\n        \"country\": \"US\",\n        \"pool_ids\": [example_load_balancer_pool.id],\n    }],\n    region_pools=[{\n        \"region\": \"WNAM\",\n        \"pool_ids\": [example_load_balancer_pool.id],\n    }],\n    rules=[{\n        \"name\": \"example rule\",\n        \"condition\": \"http.request.uri.path contains \\\"testing\\\"\",\n        \"fixed_response\": {\n            \"message_body\": \"hello\",\n            \"status_code\": 200,\n            \"content_type\": \"html\",\n            \"location\": \"www.example.com\",\n        },\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleLoadBalancerPool = new Cloudflare.LoadBalancerPool(\"example\", new()\n    {\n        Name = \"example-lb-pool\",\n        Origins = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n            {\n                Name = \"example-1\",\n                Address = \"192.0.2.1\",\n                Enabled = false,\n            },\n        },\n    });\n\n    // Define a load balancer which always points to a pool we define below.\n    // In normal usage, would have different pools set for different pops\n    // (cloudflare points-of-presence) and/or for different regions.\n    // Within each pop or region we can define multiple pools in failover order.\n    var example = new Cloudflare.LoadBalancer(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"example-load-balancer.example.com\",\n        FallbackPoolId = exampleLoadBalancerPool.Id,\n        DefaultPoolIds = new[]\n        {\n            exampleLoadBalancerPool.Id,\n        },\n        Description = \"example load balancer using geo-balancing\",\n        Proxied = true,\n        SteeringPolicy = \"geo\",\n        PopPools = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPopPoolArgs\n            {\n                Pop = \"LAX\",\n                PoolIds = new[]\n                {\n                    exampleLoadBalancerPool.Id,\n                },\n            },\n        },\n        CountryPools = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerCountryPoolArgs\n            {\n                Country = \"US\",\n                PoolIds = new[]\n                {\n                    exampleLoadBalancerPool.Id,\n                },\n            },\n        },\n        RegionPools = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerRegionPoolArgs\n            {\n                Region = \"WNAM\",\n                PoolIds = new[]\n                {\n                    exampleLoadBalancerPool.Id,\n                },\n            },\n        },\n        Rules = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerRuleArgs\n            {\n                Name = \"example rule\",\n                Condition = \"http.request.uri.path contains \\\"testing\\\"\",\n                FixedResponse = new Cloudflare.Inputs.LoadBalancerRuleFixedResponseArgs\n                {\n                    MessageBody = \"hello\",\n                    StatusCode = 200,\n                    ContentType = \"html\",\n                    Location = \"www.example.com\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleLoadBalancerPool, err := cloudflare.NewLoadBalancerPool(ctx, \"example\", \u0026cloudflare.LoadBalancerPoolArgs{\n\t\t\tName: pulumi.String(\"example-lb-pool\"),\n\t\t\tOrigins: cloudflare.LoadBalancerPoolOriginArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginArgs{\n\t\t\t\t\tName:    pulumi.String(\"example-1\"),\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Define a load balancer which always points to a pool we define below.\n\t\t// In normal usage, would have different pools set for different pops\n\t\t// (cloudflare points-of-presence) and/or for different regions.\n\t\t// Within each pop or region we can define multiple pools in failover order.\n\t\t_, err = cloudflare.NewLoadBalancer(ctx, \"example\", \u0026cloudflare.LoadBalancerArgs{\n\t\t\tZoneId:         pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:           pulumi.String(\"example-load-balancer.example.com\"),\n\t\t\tFallbackPoolId: exampleLoadBalancerPool.ID(),\n\t\t\tDefaultPoolIds: pulumi.StringArray{\n\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t},\n\t\t\tDescription:    pulumi.String(\"example load balancer using geo-balancing\"),\n\t\t\tProxied:        pulumi.Bool(true),\n\t\t\tSteeringPolicy: pulumi.String(\"geo\"),\n\t\t\tPopPools: cloudflare.LoadBalancerPopPoolArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPopPoolArgs{\n\t\t\t\t\tPop: pulumi.String(\"LAX\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCountryPools: cloudflare.LoadBalancerCountryPoolArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerCountryPoolArgs{\n\t\t\t\t\tCountry: pulumi.String(\"US\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRegionPools: cloudflare.LoadBalancerRegionPoolArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerRegionPoolArgs{\n\t\t\t\t\tRegion: pulumi.String(\"WNAM\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRules: cloudflare.LoadBalancerRuleArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerRuleArgs{\n\t\t\t\t\tName:      pulumi.String(\"example rule\"),\n\t\t\t\t\tCondition: pulumi.String(\"http.request.uri.path contains \\\"testing\\\"\"),\n\t\t\t\t\tFixedResponse: \u0026cloudflare.LoadBalancerRuleFixedResponseArgs{\n\t\t\t\t\t\tMessageBody: pulumi.String(\"hello\"),\n\t\t\t\t\t\tStatusCode:  pulumi.Int(200),\n\t\t\t\t\t\tContentType: pulumi.String(\"html\"),\n\t\t\t\t\t\tLocation:    pulumi.String(\"www.example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LoadBalancerPool;\nimport com.pulumi.cloudflare.LoadBalancerPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginArgs;\nimport com.pulumi.cloudflare.LoadBalancer;\nimport com.pulumi.cloudflare.LoadBalancerArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPopPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerCountryPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerRegionPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerRuleArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerRuleFixedResponseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleLoadBalancerPool = new LoadBalancerPool(\"exampleLoadBalancerPool\", LoadBalancerPoolArgs.builder()\n            .name(\"example-lb-pool\")\n            .origins(LoadBalancerPoolOriginArgs.builder()\n                .name(\"example-1\")\n                .address(\"192.0.2.1\")\n                .enabled(false)\n                .build())\n            .build());\n\n        // Define a load balancer which always points to a pool we define below.\n        // In normal usage, would have different pools set for different pops\n        // (cloudflare points-of-presence) and/or for different regions.\n        // Within each pop or region we can define multiple pools in failover order.\n        var example = new LoadBalancer(\"example\", LoadBalancerArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"example-load-balancer.example.com\")\n            .fallbackPoolId(exampleLoadBalancerPool.id())\n            .defaultPoolIds(exampleLoadBalancerPool.id())\n            .description(\"example load balancer using geo-balancing\")\n            .proxied(true)\n            .steeringPolicy(\"geo\")\n            .popPools(LoadBalancerPopPoolArgs.builder()\n                .pop(\"LAX\")\n                .poolIds(exampleLoadBalancerPool.id())\n                .build())\n            .countryPools(LoadBalancerCountryPoolArgs.builder()\n                .country(\"US\")\n                .poolIds(exampleLoadBalancerPool.id())\n                .build())\n            .regionPools(LoadBalancerRegionPoolArgs.builder()\n                .region(\"WNAM\")\n                .poolIds(exampleLoadBalancerPool.id())\n                .build())\n            .rules(LoadBalancerRuleArgs.builder()\n                .name(\"example rule\")\n                .condition(\"http.request.uri.path contains \\\"testing\\\"\")\n                .fixedResponse(LoadBalancerRuleFixedResponseArgs.builder()\n                    .messageBody(\"hello\")\n                    .statusCode(200)\n                    .contentType(\"html\")\n                    .location(\"www.example.com\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Define a load balancer which always points to a pool we define below.\n  # In normal usage, would have different pools set for different pops\n  # (cloudflare points-of-presence) and/or for different regions.\n  # Within each pop or region we can define multiple pools in failover order.\n  example:\n    type: cloudflare:LoadBalancer\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: example-load-balancer.example.com\n      fallbackPoolId: ${exampleLoadBalancerPool.id}\n      defaultPoolIds:\n        - ${exampleLoadBalancerPool.id}\n      description: example load balancer using geo-balancing\n      proxied: true\n      steeringPolicy: geo\n      popPools:\n        - pop: LAX\n          poolIds:\n            - ${exampleLoadBalancerPool.id}\n      countryPools:\n        - country: US\n          poolIds:\n            - ${exampleLoadBalancerPool.id}\n      regionPools:\n        - region: WNAM\n          poolIds:\n            - ${exampleLoadBalancerPool.id}\n      rules:\n        - name: example rule\n          condition: http.request.uri.path contains \"testing\"\n          fixedResponse:\n            messageBody: hello\n            statusCode: 200\n            contentType: html\n            location: www.example.com\n  exampleLoadBalancerPool:\n    type: cloudflare:LoadBalancerPool\n    name: example\n    properties:\n      name: example-lb-pool\n      origins:\n        - name: example-1\n          address: 192.0.2.1\n          enabled: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/loadBalancer:LoadBalancer example \u003czone_id\u003e/\u003cload_balancer_id\u003e\n```\n\n",
            "properties": {
                "adaptiveRoutings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting"
                    },
                    "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                },
                "countryPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool"
                    },
                    "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true`.\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "locationStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy"
                    },
                    "description": "Controls location-based steering for non-proxied requests.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.\n"
                },
                "randomSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering"
                    },
                    "description": "Configures pool weights. When `steering_policy=\"random\"`, a random pool is selected with probability proportional to pool weights. When `steering_policy=\"least_outstanding_requests\"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy=\"least_connections\"`, pool weights are used to scale each pool's open connections.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                    },
                    "description": "A list of rules for this load balancer to execute.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`, `header`. Defaults to `none`.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerSessionAffinityAttribute:LoadBalancerSessionAffinityAttribute"
                    },
                    "description": "Configure attributes for session affinity.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `\"\"` Defaults to `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "createdOn",
                "defaultPoolIds",
                "fallbackPoolId",
                "modifiedOn",
                "name",
                "steeringPolicy",
                "ttl",
                "zoneId"
            ],
            "inputProperties": {
                "adaptiveRoutings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting"
                    },
                    "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                },
                "countryPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool"
                    },
                    "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                },
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true`.\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "locationStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy"
                    },
                    "description": "Controls location-based steering for non-proxied requests.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.\n"
                },
                "randomSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering"
                    },
                    "description": "Configures pool weights. When `steering_policy=\"random\"`, a random pool is selected with probability proportional to pool weights. When `steering_policy=\"least_outstanding_requests\"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy=\"least_connections\"`, pool weights are used to scale each pool's open connections.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                    },
                    "description": "A list of rules for this load balancer to execute.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`, `header`. Defaults to `none`.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerSessionAffinityAttribute:LoadBalancerSessionAffinityAttribute"
                    },
                    "description": "Configure attributes for session affinity.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `\"\"` Defaults to `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "defaultPoolIds",
                "fallbackPoolId",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancer resources.\n",
                "properties": {
                    "adaptiveRoutings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting"
                        },
                        "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                    },
                    "countryPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool"
                        },
                        "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "defaultPoolIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable the load balancer. Defaults to `true`.\n"
                    },
                    "fallbackPoolId": {
                        "type": "string",
                        "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                    },
                    "locationStrategies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy"
                        },
                        "description": "Controls location-based steering for non-proxied requests.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.\n"
                    },
                    "popPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                        },
                        "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.\n"
                    },
                    "randomSteerings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering"
                        },
                        "description": "Configures pool weights. When `steering_policy=\"random\"`, a random pool is selected with probability proportional to pool weights. When `steering_policy=\"least_outstanding_requests\"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy=\"least_connections\"`, pool weights are used to scale each pool's open connections.\n"
                    },
                    "regionPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                        },
                        "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                        },
                        "description": "A list of rules for this load balancer to execute.\n"
                    },
                    "sessionAffinity": {
                        "type": "string",
                        "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`, `header`. Defaults to `none`.\n"
                    },
                    "sessionAffinityAttributes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerSessionAffinityAttribute:LoadBalancerSessionAffinityAttribute"
                        },
                        "description": "Configure attributes for session affinity.\n"
                    },
                    "sessionAffinityTtl": {
                        "type": "integer",
                        "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                    },
                    "steeringPolicy": {
                        "type": "string",
                        "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `\"\"` Defaults to `\"\"`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor": {
            "description": "If Cloudflare's Load Balancing to load-balance across multiple\norigin servers or data centers, you configure one of these Monitors\nto actively check the availability of those servers over HTTP(S) or\nTCP.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor example \u003caccount_id\u003e/\u003cload_balancer_monitor_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is \"http\" or \"https\".\n"
                },
                "consecutiveDown": {
                    "type": "integer",
                    "description": "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.\n"
                },
                "consecutiveUp": {
                    "type": "integer",
                    "description": "To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number to use for the healthcheck, required when creating a TCP monitor.\n"
                },
                "probeZone": {
                    "type": "string",
                    "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.\n"
                }
            },
            "required": [
                "accountId",
                "createdOn",
                "method",
                "modifiedOn",
                "path"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is \"http\" or \"https\".\n"
                },
                "consecutiveDown": {
                    "type": "integer",
                    "description": "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.\n"
                },
                "consecutiveUp": {
                    "type": "integer",
                    "description": "To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number to use for the healthcheck, required when creating a TCP monitor.\n"
                },
                "probeZone": {
                    "type": "string",
                    "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerMonitor resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "consecutiveDown": {
                        "type": "integer",
                        "description": "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.\n"
                    },
                    "consecutiveUp": {
                        "type": "integer",
                        "description": "To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "expectedCodes": {
                        "type": "string",
                        "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                        },
                        "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The method to use for the health check.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port number to use for the healthcheck, required when creating a TCP monitor.\n"
                    },
                    "probeZone": {
                        "type": "string",
                        "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerPool:LoadBalancerPool": {
            "description": "Provides a Cloudflare Load Balancer pool resource. This provides a\npool of origins that can be used by a Cloudflare Load Balancer.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LoadBalancerPool(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example-pool\",\n    origins: [\n        {\n            name: \"example-1\",\n            address: \"192.0.2.1\",\n            enabled: false,\n            headers: [{\n                header: \"Host\",\n                values: [\"example-1\"],\n            }],\n        },\n        {\n            name: \"example-2\",\n            address: \"192.0.2.2\",\n            headers: [{\n                header: \"Host\",\n                values: [\"example-2\"],\n            }],\n        },\n    ],\n    latitude: 55,\n    longitude: -12,\n    description: \"example load balancer pool\",\n    enabled: false,\n    minimumOrigins: 1,\n    notificationEmail: \"someone@example.com\",\n    loadSheddings: [{\n        defaultPercent: 55,\n        defaultPolicy: \"random\",\n        sessionPercent: 12,\n        sessionPolicy: \"hash\",\n    }],\n    originSteerings: [{\n        policy: \"random\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LoadBalancerPool(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example-pool\",\n    origins=[\n        {\n            \"name\": \"example-1\",\n            \"address\": \"192.0.2.1\",\n            \"enabled\": False,\n            \"headers\": [{\n                \"header\": \"Host\",\n                \"values\": [\"example-1\"],\n            }],\n        },\n        {\n            \"name\": \"example-2\",\n            \"address\": \"192.0.2.2\",\n            \"headers\": [{\n                \"header\": \"Host\",\n                \"values\": [\"example-2\"],\n            }],\n        },\n    ],\n    latitude=55,\n    longitude=-12,\n    description=\"example load balancer pool\",\n    enabled=False,\n    minimum_origins=1,\n    notification_email=\"someone@example.com\",\n    load_sheddings=[{\n        \"default_percent\": 55,\n        \"default_policy\": \"random\",\n        \"session_percent\": 12,\n        \"session_policy\": \"hash\",\n    }],\n    origin_steerings=[{\n        \"policy\": \"random\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.LoadBalancerPool(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example-pool\",\n        Origins = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n            {\n                Name = \"example-1\",\n                Address = \"192.0.2.1\",\n                Enabled = false,\n                Headers = new[]\n                {\n                    new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs\n                    {\n                        Header = \"Host\",\n                        Values = new[]\n                        {\n                            \"example-1\",\n                        },\n                    },\n                },\n            },\n            new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n            {\n                Name = \"example-2\",\n                Address = \"192.0.2.2\",\n                Headers = new[]\n                {\n                    new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs\n                    {\n                        Header = \"Host\",\n                        Values = new[]\n                        {\n                            \"example-2\",\n                        },\n                    },\n                },\n            },\n        },\n        Latitude = 55,\n        Longitude = -12,\n        Description = \"example load balancer pool\",\n        Enabled = false,\n        MinimumOrigins = 1,\n        NotificationEmail = \"someone@example.com\",\n        LoadSheddings = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolLoadSheddingArgs\n            {\n                DefaultPercent = 55,\n                DefaultPolicy = \"random\",\n                SessionPercent = 12,\n                SessionPolicy = \"hash\",\n            },\n        },\n        OriginSteerings = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolOriginSteeringArgs\n            {\n                Policy = \"random\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerPool(ctx, \"example\", \u0026cloudflare.LoadBalancerPoolArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example-pool\"),\n\t\t\tOrigins: cloudflare.LoadBalancerPoolOriginArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginArgs{\n\t\t\t\t\tName:    pulumi.String(\"example-1\"),\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tHeaders: cloudflare.LoadBalancerPoolOriginHeaderArray{\n\t\t\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginHeaderArgs{\n\t\t\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"example-1\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginArgs{\n\t\t\t\t\tName:    pulumi.String(\"example-2\"),\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.2\"),\n\t\t\t\t\tHeaders: cloudflare.LoadBalancerPoolOriginHeaderArray{\n\t\t\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginHeaderArgs{\n\t\t\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"example-2\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tLatitude:          pulumi.Float64(55),\n\t\t\tLongitude:         pulumi.Float64(-12),\n\t\t\tDescription:       pulumi.String(\"example load balancer pool\"),\n\t\t\tEnabled:           pulumi.Bool(false),\n\t\t\tMinimumOrigins:    pulumi.Int(1),\n\t\t\tNotificationEmail: pulumi.String(\"someone@example.com\"),\n\t\t\tLoadSheddings: cloudflare.LoadBalancerPoolLoadSheddingArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolLoadSheddingArgs{\n\t\t\t\t\tDefaultPercent: pulumi.Float64(55),\n\t\t\t\t\tDefaultPolicy:  pulumi.String(\"random\"),\n\t\t\t\t\tSessionPercent: pulumi.Float64(12),\n\t\t\t\t\tSessionPolicy:  pulumi.String(\"hash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tOriginSteerings: cloudflare.LoadBalancerPoolOriginSteeringArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginSteeringArgs{\n\t\t\t\t\tPolicy: pulumi.String(\"random\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LoadBalancerPool;\nimport com.pulumi.cloudflare.LoadBalancerPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPoolLoadSheddingArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginSteeringArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LoadBalancerPool(\"example\", LoadBalancerPoolArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example-pool\")\n            .origins(            \n                LoadBalancerPoolOriginArgs.builder()\n                    .name(\"example-1\")\n                    .address(\"192.0.2.1\")\n                    .enabled(false)\n                    .headers(LoadBalancerPoolOriginHeaderArgs.builder()\n                        .header(\"Host\")\n                        .values(\"example-1\")\n                        .build())\n                    .build(),\n                LoadBalancerPoolOriginArgs.builder()\n                    .name(\"example-2\")\n                    .address(\"192.0.2.2\")\n                    .headers(LoadBalancerPoolOriginHeaderArgs.builder()\n                        .header(\"Host\")\n                        .values(\"example-2\")\n                        .build())\n                    .build())\n            .latitude(55)\n            .longitude(-12)\n            .description(\"example load balancer pool\")\n            .enabled(false)\n            .minimumOrigins(1)\n            .notificationEmail(\"someone@example.com\")\n            .loadSheddings(LoadBalancerPoolLoadSheddingArgs.builder()\n                .defaultPercent(55)\n                .defaultPolicy(\"random\")\n                .sessionPercent(12)\n                .sessionPolicy(\"hash\")\n                .build())\n            .originSteerings(LoadBalancerPoolOriginSteeringArgs.builder()\n                .policy(\"random\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:LoadBalancerPool\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example-pool\n      origins:\n        - name: example-1\n          address: 192.0.2.1\n          enabled: false\n          headers:\n            - header: Host\n              values:\n                - example-1\n        - name: example-2\n          address: 192.0.2.2\n          headers:\n            - header: Host\n              values:\n                - example-2\n      latitude: 55\n      longitude: -12\n      description: example load balancer pool\n      enabled: false\n      minimumOrigins: 1\n      notificationEmail: someone@example.com\n      loadSheddings:\n        - defaultPercent: 55\n          defaultPolicy: random\n          sessionPercent: 12\n          sessionPolicy: hash\n      originSteerings:\n        - policy: random\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/loadBalancerPool:LoadBalancerPool example \u003caccount_id\u003e/\u003cload_balancer_pool_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). Defaults to `true`.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude this pool is physically located at; used for proximity steering.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude this pool is physically located at; used for proximity steering.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name (tag) for the pool.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "originSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                    },
                    "description": "Set an origin steering policy to control origin selection within a pool.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.\n"
                }
            },
            "required": [
                "accountId",
                "checkRegions",
                "createdOn",
                "modifiedOn",
                "name",
                "origins"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). Defaults to `true`.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude this pool is physically located at; used for proximity steering.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude this pool is physically located at; used for proximity steering.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name (tag) for the pool.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "originSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                    },
                    "description": "Set an origin steering policy to control origin selection within a pool.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "origins"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerPool resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable (the default) this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). Defaults to `true`.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "The latitude this pool is physically located at; used for proximity steering.\n"
                    },
                    "loadSheddings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                        },
                        "description": "Setting for controlling load shedding for this pool.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "The longitude this pool is physically located at; used for proximity steering.\n"
                    },
                    "minimumOrigins": {
                        "type": "integer",
                        "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "monitor": {
                        "type": "string",
                        "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A short name (tag) for the pool.\n"
                    },
                    "notificationEmail": {
                        "type": "string",
                        "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                    },
                    "originSteerings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                        },
                        "description": "Set an origin steering policy to control origin selection within a pool.\n"
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                        },
                        "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpullRetention:LogpullRetention": {
            "description": "Allows management of the Logpull Retention settings used to control whether or not to retain HTTP request logs.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpullRetention(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpullRetention(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.LogpullRetention(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogpullRetention(ctx, \"example\", \u0026cloudflare.LogpullRetentionArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LogpullRetention;\nimport com.pulumi.cloudflare.LogpullRetentionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LogpullRetention(\"example\", LogpullRetentionArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(\"true\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:LogpullRetention\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: 'true'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/logpullRetention:LogpullRetention example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpullRetention resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether you wish to retain logs or not.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpushJob:LogpushJob": {
            "description": "## Example Usage\n\n## Import\n\nImport an account-scoped job.\n\n```sh\n$ pulumi import cloudflare:index/logpushJob:LogpushJob example account/\u003caccount_id\u003e/\u003cjob_id\u003e\n```\n\nImport a zone-scoped job.\n\n```sh\n$ pulumi import cloudflare:index/logpushJob:LogpushJob example zone/\u003czone_id\u003e/\u003cjob_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`, `page_shield_events`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable the job.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.\n",
                    "deprecationMessage": "`frequency` has been deprecated in favour of using `max_upload_interval_seconds` instead."
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of logpush job to create. Available values: `edge`, `instant-logs`, `\"\"`.\n"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "maxUploadBytes": {
                    "type": "integer",
                    "description": "The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.\n"
                },
                "maxUploadIntervalSeconds": {
                    "type": "integer",
                    "description": "The maximum interval in seconds for log batches. Value must be between 30 and 300.\n"
                },
                "maxUploadRecords": {
                    "type": "integer",
                    "description": "The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create.\n"
                },
                "outputOptions": {
                    "$ref": "#/types/cloudflare:index/LogpushJobOutputOptions:LogpushJobOutputOptions",
                    "description": "Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                }
            },
            "required": [
                "dataset",
                "destinationConf"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`, `page_shield_events`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable the job.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.\n",
                    "deprecationMessage": "`frequency` has been deprecated in favour of using `max_upload_interval_seconds` instead."
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of logpush job to create. Available values: `edge`, `instant-logs`, `\"\"`.\n"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "maxUploadBytes": {
                    "type": "integer",
                    "description": "The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.\n"
                },
                "maxUploadIntervalSeconds": {
                    "type": "integer",
                    "description": "The maximum interval in seconds for log batches. Value must be between 30 and 300.\n"
                },
                "maxUploadRecords": {
                    "type": "integer",
                    "description": "The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create.\n"
                },
                "outputOptions": {
                    "$ref": "#/types/cloudflare:index/LogpushJobOutputOptions:LogpushJobOutputOptions",
                    "description": "Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                }
            },
            "requiredInputs": [
                "dataset",
                "destinationConf"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpushJob resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                    },
                    "dataset": {
                        "type": "string",
                        "description": "The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`, `page_shield_events`.\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable the job.\n"
                    },
                    "filter": {
                        "type": "string",
                        "description": "Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).\n"
                    },
                    "frequency": {
                        "type": "string",
                        "description": "A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.\n",
                        "deprecationMessage": "`frequency` has been deprecated in favour of using `max_upload_interval_seconds` instead."
                    },
                    "kind": {
                        "type": "string",
                        "description": "The kind of logpush job to create. Available values: `edge`, `instant-logs`, `\"\"`.\n"
                    },
                    "logpullOptions": {
                        "type": "string",
                        "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                    },
                    "maxUploadBytes": {
                        "type": "integer",
                        "description": "The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.\n"
                    },
                    "maxUploadIntervalSeconds": {
                        "type": "integer",
                        "description": "The maximum interval in seconds for log batches. Value must be between 30 and 300.\n"
                    },
                    "maxUploadRecords": {
                        "type": "integer",
                        "description": "The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the logpush job to create.\n"
                    },
                    "outputOptions": {
                        "$ref": "#/types/cloudflare:index/LogpushJobOutputOptions:LogpushJobOutputOptions",
                        "description": "Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.\n"
                    },
                    "ownershipChallenge": {
                        "type": "string",
                        "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpushOwnershipChallenge:LogpushOwnershipChallenge": {
            "description": "Provides a resource which manages Cloudflare Logpush ownership\nchallenges to use in a Logpush Job. On it's own, doesn't do much\nhowever this resource should be used in conjunction to create\nLogpush jobs.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpushOwnershipChallenge(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    destinationConf: \"s3://my-bucket-path?region=us-west-2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpushOwnershipChallenge(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    destination_conf=\"s3://my-bucket-path?region=us-west-2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.LogpushOwnershipChallenge(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        DestinationConf = \"s3://my-bucket-path?region=us-west-2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogpushOwnershipChallenge(ctx, \"example\", \u0026cloudflare.LogpushOwnershipChallengeArgs{\n\t\t\tZoneId:          pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tDestinationConf: pulumi.String(\"s3://my-bucket-path?region=us-west-2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LogpushOwnershipChallenge;\nimport com.pulumi.cloudflare.LogpushOwnershipChallengeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LogpushOwnershipChallenge(\"example\", LogpushOwnershipChallengeArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .destinationConf(\"s3://my-bucket-path?region=us-west-2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:LogpushOwnershipChallenge\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      destinationConf: s3://my-bucket-path?region=us-west-2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ownershipChallengeFilename": {
                    "type": "string",
                    "description": "The filename of the ownership challenge which\tcontains the contents required for Logpush Job creation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                }
            },
            "required": [
                "destinationConf",
                "ownershipChallengeFilename"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                }
            },
            "requiredInputs": [
                "destinationConf"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpushOwnershipChallenge resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ownershipChallengeFilename": {
                        "type": "string",
                        "description": "The filename of the ownership challenge which\tcontains the contents required for Logpush Job creation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset": {
            "description": "Magic Firewall is a network-level firewall to protect networks that are onboarded to Cloudflare's Magic Transit. This resource\ncreates a root ruleset on the account level and contains one or more rules. Rules can be crafted in Wireshark syntax and\nare evaluated in order, with the first rule having the highest priority.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MagicFirewallRuleset(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"Magic Transit Ruleset\",\n    description: \"Global mitigations\",\n    rules: [\n        {\n            action: \"allow\",\n            expression: \"tcp.dstport in { 32768..65535 }\",\n            description: \"Allow TCP Ephemeral Ports\",\n            enabled: \"true\",\n        },\n        {\n            action: \"block\",\n            expression: \"ip.len \u003e= 0\",\n            description: \"Block all\",\n            enabled: \"true\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MagicFirewallRuleset(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"Magic Transit Ruleset\",\n    description=\"Global mitigations\",\n    rules=[\n        {\n            \"action\": \"allow\",\n            \"expression\": \"tcp.dstport in { 32768..65535 }\",\n            \"description\": \"Allow TCP Ephemeral Ports\",\n            \"enabled\": \"true\",\n        },\n        {\n            \"action\": \"block\",\n            \"expression\": \"ip.len \u003e= 0\",\n            \"description\": \"Block all\",\n            \"enabled\": \"true\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.MagicFirewallRuleset(\"example\", new()\n    {\n        AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Name = \"Magic Transit Ruleset\",\n        Description = \"Global mitigations\",\n        Rules = new[]\n        {\n            \n            {\n                { \"action\", \"allow\" },\n                { \"expression\", \"tcp.dstport in { 32768..65535 }\" },\n                { \"description\", \"Allow TCP Ephemeral Ports\" },\n                { \"enabled\", \"true\" },\n            },\n            \n            {\n                { \"action\", \"block\" },\n                { \"expression\", \"ip.len \u003e= 0\" },\n                { \"description\", \"Block all\" },\n                { \"enabled\", \"true\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMagicFirewallRuleset(ctx, \"example\", \u0026cloudflare.MagicFirewallRulesetArgs{\n\t\t\tAccountId:   pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:        pulumi.String(\"Magic Transit Ruleset\"),\n\t\t\tDescription: pulumi.String(\"Global mitigations\"),\n\t\t\tRules: pulumi.StringMapArray{\n\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\"action\":      pulumi.String(\"allow\"),\n\t\t\t\t\t\"expression\":  pulumi.String(\"tcp.dstport in { 32768..65535 }\"),\n\t\t\t\t\t\"description\": pulumi.String(\"Allow TCP Ephemeral Ports\"),\n\t\t\t\t\t\"enabled\":     pulumi.String(\"true\"),\n\t\t\t\t},\n\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\"action\":      pulumi.String(\"block\"),\n\t\t\t\t\t\"expression\":  pulumi.String(\"ip.len \u003e= 0\"),\n\t\t\t\t\t\"description\": pulumi.String(\"Block all\"),\n\t\t\t\t\t\"enabled\":     pulumi.String(\"true\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.MagicFirewallRuleset;\nimport com.pulumi.cloudflare.MagicFirewallRulesetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MagicFirewallRuleset(\"example\", MagicFirewallRulesetArgs.builder()\n            .accountId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .name(\"Magic Transit Ruleset\")\n            .description(\"Global mitigations\")\n            .rules(            \n                Map.ofEntries(\n                    Map.entry(\"action\", \"allow\"),\n                    Map.entry(\"expression\", \"tcp.dstport in { 32768..65535 }\"),\n                    Map.entry(\"description\", \"Allow TCP Ephemeral Ports\"),\n                    Map.entry(\"enabled\", \"true\")\n                ),\n                Map.ofEntries(\n                    Map.entry(\"action\", \"block\"),\n                    Map.entry(\"expression\", \"ip.len \u003e= 0\"),\n                    Map.entry(\"description\", \"Block all\"),\n                    Map.entry(\"enabled\", \"true\")\n                ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:MagicFirewallRuleset\n    properties:\n      accountId: d41d8cd98f00b204e9800998ecf8427e\n      name: Magic Transit Ruleset\n      description: Global mitigations\n      rules:\n        - action: allow\n          expression: tcp.dstport in { 32768..65535 }\n          description: Allow TCP Ephemeral Ports\n          enabled: 'true'\n        - action: block\n          expression: ip.len \u003e= 0\n          description: Block all\n          enabled: 'true'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing Magic Firewall Ruleset can be imported using the account ID and ruleset ID\n\n```sh\n$ pulumi import cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ruleset.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ruleset.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MagicFirewallRuleset resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the ruleset is being created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that can be used to annotate the rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ruleset.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/magicWanGreTunnel:MagicWanGreTunnel": {
            "description": "Provides a resource, that manages GRE tunnels for Magic Transit.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MagicWanGreTunnel(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"GRE_1\",\n    customerGreEndpoint: \"203.0.113.1\",\n    cloudflareGreEndpoint: \"203.0.113.2\",\n    interfaceAddress: \"192.0.2.0/31\",\n    description: \"Tunnel for ISP X\",\n    ttl: 64,\n    mtu: 1476,\n    healthCheckEnabled: true,\n    healthCheckTarget: \"203.0.113.1\",\n    healthCheckType: \"reply\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MagicWanGreTunnel(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"GRE_1\",\n    customer_gre_endpoint=\"203.0.113.1\",\n    cloudflare_gre_endpoint=\"203.0.113.2\",\n    interface_address=\"192.0.2.0/31\",\n    description=\"Tunnel for ISP X\",\n    ttl=64,\n    mtu=1476,\n    health_check_enabled=True,\n    health_check_target=\"203.0.113.1\",\n    health_check_type=\"reply\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.MagicWanGreTunnel(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"GRE_1\",\n        CustomerGreEndpoint = \"203.0.113.1\",\n        CloudflareGreEndpoint = \"203.0.113.2\",\n        InterfaceAddress = \"192.0.2.0/31\",\n        Description = \"Tunnel for ISP X\",\n        Ttl = 64,\n        Mtu = 1476,\n        HealthCheckEnabled = true,\n        HealthCheckTarget = \"203.0.113.1\",\n        HealthCheckType = \"reply\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMagicWanGreTunnel(ctx, \"example\", \u0026cloudflare.MagicWanGreTunnelArgs{\n\t\t\tAccountId:             pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:                  pulumi.String(\"GRE_1\"),\n\t\t\tCustomerGreEndpoint:   pulumi.String(\"203.0.113.1\"),\n\t\t\tCloudflareGreEndpoint: pulumi.String(\"203.0.113.2\"),\n\t\t\tInterfaceAddress:      pulumi.String(\"192.0.2.0/31\"),\n\t\t\tDescription:           pulumi.String(\"Tunnel for ISP X\"),\n\t\t\tTtl:                   pulumi.Int(64),\n\t\t\tMtu:                   pulumi.Int(1476),\n\t\t\tHealthCheckEnabled:    pulumi.Bool(true),\n\t\t\tHealthCheckTarget:     pulumi.String(\"203.0.113.1\"),\n\t\t\tHealthCheckType:       pulumi.String(\"reply\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.MagicWanGreTunnel;\nimport com.pulumi.cloudflare.MagicWanGreTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MagicWanGreTunnel(\"example\", MagicWanGreTunnelArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"GRE_1\")\n            .customerGreEndpoint(\"203.0.113.1\")\n            .cloudflareGreEndpoint(\"203.0.113.2\")\n            .interfaceAddress(\"192.0.2.0/31\")\n            .description(\"Tunnel for ISP X\")\n            .ttl(64)\n            .mtu(1476)\n            .healthCheckEnabled(true)\n            .healthCheckTarget(\"203.0.113.1\")\n            .healthCheckType(\"reply\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:MagicWanGreTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: GRE_1\n      customerGreEndpoint: 203.0.113.1\n      cloudflareGreEndpoint: 203.0.113.2\n      interfaceAddress: 192.0.2.0/31\n      description: Tunnel for ISP X\n      ttl: 64\n      mtu: 1476\n      healthCheckEnabled: true\n      healthCheckTarget: 203.0.113.1\n      healthCheckType: reply\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/magicWanGreTunnel:MagicWanGreTunnel example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "cloudflareGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                },
                "customerGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the GRE tunnel intent.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the GRE tunnel.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time To Live (TTL) in number of hops of the GRE tunnel.\n"
                }
            },
            "required": [
                "cloudflareGreEndpoint",
                "customerGreEndpoint",
                "healthCheckEnabled",
                "healthCheckTarget",
                "healthCheckType",
                "interfaceAddress",
                "mtu",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "cloudflareGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                },
                "customerGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the GRE tunnel intent.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the GRE tunnel.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time To Live (TTL) in number of hops of the GRE tunnel.\n"
                }
            },
            "requiredInputs": [
                "cloudflareGreEndpoint",
                "customerGreEndpoint",
                "interfaceAddress",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MagicWanGreTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudflareGreEndpoint": {
                        "type": "string",
                        "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                    },
                    "customerGreEndpoint": {
                        "type": "string",
                        "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the GRE tunnel intent.\n"
                    },
                    "healthCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies if ICMP tunnel health checks are enabled.\n"
                    },
                    "healthCheckTarget": {
                        "type": "string",
                        "description": "The IP address of the customer endpoint that will receive tunnel health checks.\n"
                    },
                    "healthCheckType": {
                        "type": "string",
                        "description": "Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.\n"
                    },
                    "interfaceAddress": {
                        "type": "string",
                        "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the GRE tunnel.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Time To Live (TTL) in number of hops of the GRE tunnel.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/magicWanIpsecTunnel:MagicWanIpsecTunnel": {
            "description": "Provides a resource, that manages IPsec tunnels for Magic Transit.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MagicWanIpsecTunnel(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"IPsec_1\",\n    customerEndpoint: \"203.0.113.1\",\n    cloudflareEndpoint: \"203.0.113.1\",\n    interfaceAddress: \"192.0.2.0/31\",\n    description: \"Tunnel for ISP X\",\n    healthCheckEnabled: true,\n    healthCheckTarget: \"203.0.113.1\",\n    healthCheckType: \"reply\",\n    psk: \"asdf12341234\",\n    allowNullCipher: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MagicWanIpsecTunnel(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"IPsec_1\",\n    customer_endpoint=\"203.0.113.1\",\n    cloudflare_endpoint=\"203.0.113.1\",\n    interface_address=\"192.0.2.0/31\",\n    description=\"Tunnel for ISP X\",\n    health_check_enabled=True,\n    health_check_target=\"203.0.113.1\",\n    health_check_type=\"reply\",\n    psk=\"asdf12341234\",\n    allow_null_cipher=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.MagicWanIpsecTunnel(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"IPsec_1\",\n        CustomerEndpoint = \"203.0.113.1\",\n        CloudflareEndpoint = \"203.0.113.1\",\n        InterfaceAddress = \"192.0.2.0/31\",\n        Description = \"Tunnel for ISP X\",\n        HealthCheckEnabled = true,\n        HealthCheckTarget = \"203.0.113.1\",\n        HealthCheckType = \"reply\",\n        Psk = \"asdf12341234\",\n        AllowNullCipher = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMagicWanIpsecTunnel(ctx, \"example\", \u0026cloudflare.MagicWanIpsecTunnelArgs{\n\t\t\tAccountId:          pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:               pulumi.String(\"IPsec_1\"),\n\t\t\tCustomerEndpoint:   pulumi.String(\"203.0.113.1\"),\n\t\t\tCloudflareEndpoint: pulumi.String(\"203.0.113.1\"),\n\t\t\tInterfaceAddress:   pulumi.String(\"192.0.2.0/31\"),\n\t\t\tDescription:        pulumi.String(\"Tunnel for ISP X\"),\n\t\t\tHealthCheckEnabled: pulumi.Bool(true),\n\t\t\tHealthCheckTarget:  pulumi.String(\"203.0.113.1\"),\n\t\t\tHealthCheckType:    pulumi.String(\"reply\"),\n\t\t\tPsk:                pulumi.String(\"asdf12341234\"),\n\t\t\tAllowNullCipher:    pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.MagicWanIpsecTunnel;\nimport com.pulumi.cloudflare.MagicWanIpsecTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MagicWanIpsecTunnel(\"example\", MagicWanIpsecTunnelArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"IPsec_1\")\n            .customerEndpoint(\"203.0.113.1\")\n            .cloudflareEndpoint(\"203.0.113.1\")\n            .interfaceAddress(\"192.0.2.0/31\")\n            .description(\"Tunnel for ISP X\")\n            .healthCheckEnabled(true)\n            .healthCheckTarget(\"203.0.113.1\")\n            .healthCheckType(\"reply\")\n            .psk(\"asdf12341234\")\n            .allowNullCipher(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:MagicWanIpsecTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: IPsec_1\n      customerEndpoint: 203.0.113.1\n      cloudflareEndpoint: 203.0.113.1\n      interfaceAddress: 192.0.2.0/31\n      description: Tunnel for ISP X\n      healthCheckEnabled: true\n      healthCheckTarget: 203.0.113.1\n      healthCheckType: reply\n      psk: asdf12341234\n      allowNullCipher: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/magicWanIpsecTunnel:MagicWanIpsecTunnel example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "allowNullCipher": {
                    "type": "boolean",
                    "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                },
                "cloudflareEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                },
                "customerEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the IPsec tunnel.\n"
                },
                "fqdnId": {
                    "type": "string",
                    "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                },
                "healthCheckDirection": {
                    "type": "string",
                    "description": "Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                },
                "healthCheckRate": {
                    "type": "string",
                    "description": "Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                },
                "hexId": {
                    "type": "string",
                    "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IPsec tunnel.\n"
                },
                "psk": {
                    "type": "string",
                    "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                },
                "replayProtection": {
                    "type": "boolean",
                    "description": "Specifies if replay protection is enabled. Defaults to `false`.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                }
            },
            "required": [
                "cloudflareEndpoint",
                "customerEndpoint",
                "fqdnId",
                "healthCheckDirection",
                "healthCheckEnabled",
                "healthCheckRate",
                "healthCheckTarget",
                "healthCheckType",
                "hexId",
                "interfaceAddress",
                "name",
                "psk",
                "remoteId",
                "userId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "allowNullCipher": {
                    "type": "boolean",
                    "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                },
                "cloudflareEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                },
                "customerEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the IPsec tunnel.\n"
                },
                "fqdnId": {
                    "type": "string",
                    "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                },
                "healthCheckDirection": {
                    "type": "string",
                    "description": "Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                },
                "healthCheckRate": {
                    "type": "string",
                    "description": "Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                },
                "hexId": {
                    "type": "string",
                    "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IPsec tunnel.\n"
                },
                "psk": {
                    "type": "string",
                    "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                },
                "replayProtection": {
                    "type": "boolean",
                    "description": "Specifies if replay protection is enabled. Defaults to `false`.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                }
            },
            "requiredInputs": [
                "cloudflareEndpoint",
                "customerEndpoint",
                "interfaceAddress",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MagicWanIpsecTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "allowNullCipher": {
                        "type": "boolean",
                        "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                    },
                    "cloudflareEndpoint": {
                        "type": "string",
                        "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                    },
                    "customerEndpoint": {
                        "type": "string",
                        "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the IPsec tunnel.\n"
                    },
                    "fqdnId": {
                        "type": "string",
                        "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                    },
                    "healthCheckDirection": {
                        "type": "string",
                        "description": "Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.\n"
                    },
                    "healthCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                    },
                    "healthCheckRate": {
                        "type": "string",
                        "description": "Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.\n"
                    },
                    "healthCheckTarget": {
                        "type": "string",
                        "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                    },
                    "healthCheckType": {
                        "type": "string",
                        "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                    },
                    "hexId": {
                        "type": "string",
                        "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                    },
                    "interfaceAddress": {
                        "type": "string",
                        "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the IPsec tunnel.\n"
                    },
                    "psk": {
                        "type": "string",
                        "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                        "secret": true
                    },
                    "remoteId": {
                        "type": "string",
                        "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                    },
                    "replayProtection": {
                        "type": "boolean",
                        "description": "Specifies if replay protection is enabled. Defaults to `false`.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/magicWanStaticRoute:MagicWanStaticRoute": {
            "description": "Provides a resource, that manages Cloudflare static routes for Magic\nTransit or Magic WAN. Static routes are used to route traffic\nthrough GRE tunnels.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MagicWanStaticRoute(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    description: \"New route for new prefix 192.0.2.0/24\",\n    prefix: \"192.0.2.0/24\",\n    nexthop: \"10.0.0.0\",\n    priority: 100,\n    weight: 10,\n    coloNames: [\"den01\"],\n    coloRegions: [\"APAC\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MagicWanStaticRoute(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    description=\"New route for new prefix 192.0.2.0/24\",\n    prefix=\"192.0.2.0/24\",\n    nexthop=\"10.0.0.0\",\n    priority=100,\n    weight=10,\n    colo_names=[\"den01\"],\n    colo_regions=[\"APAC\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.MagicWanStaticRoute(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Description = \"New route for new prefix 192.0.2.0/24\",\n        Prefix = \"192.0.2.0/24\",\n        Nexthop = \"10.0.0.0\",\n        Priority = 100,\n        Weight = 10,\n        ColoNames = new[]\n        {\n            \"den01\",\n        },\n        ColoRegions = new[]\n        {\n            \"APAC\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMagicWanStaticRoute(ctx, \"example\", \u0026cloudflare.MagicWanStaticRouteArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tDescription: pulumi.String(\"New route for new prefix 192.0.2.0/24\"),\n\t\t\tPrefix:      pulumi.String(\"192.0.2.0/24\"),\n\t\t\tNexthop:     pulumi.String(\"10.0.0.0\"),\n\t\t\tPriority:    pulumi.Int(100),\n\t\t\tWeight:      pulumi.Int(10),\n\t\t\tColoNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"den01\"),\n\t\t\t},\n\t\t\tColoRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"APAC\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.MagicWanStaticRoute;\nimport com.pulumi.cloudflare.MagicWanStaticRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MagicWanStaticRoute(\"example\", MagicWanStaticRouteArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .description(\"New route for new prefix 192.0.2.0/24\")\n            .prefix(\"192.0.2.0/24\")\n            .nexthop(\"10.0.0.0\")\n            .priority(100)\n            .weight(10)\n            .coloNames(\"den01\")\n            .coloRegions(\"APAC\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:MagicWanStaticRoute\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      description: New route for new prefix 192.0.2.0/24\n      prefix: 192.0.2.0/24\n      nexthop: 10.0.0.0\n      priority: 100\n      weight: 10\n      coloNames:\n        - den01\n      coloRegions:\n        - APAC\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/magicWanStaticRoute:MagicWanStaticRoute example \u003caccount_id\u003e/\u003cstatic_route_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation regions for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation names for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation regions for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation names for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MagicWanStaticRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "coloNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Cloudflare colocation regions for this static route.\n"
                    },
                    "coloRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Cloudflare colocation names for this static route.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the static route.\n"
                    },
                    "nexthop": {
                        "type": "string",
                        "description": "The nexthop IP address where traffic will be routed to.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "Your network prefix using CIDR notation.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority for the static route.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/managedHeaders:ManagedHeaders": {
            "description": "The [Cloudflare Managed Headers](https://developers.cloudflare.com/rules/transform/managed-transforms/)\nallows you to add or remove some predefined headers to one's\nrequests or origin responses.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Enable security headers using Managed Meaders\nconst example = new cloudflare.ManagedHeaders(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    managedRequestHeaders: [{\n        id: \"add_true_client_ip_headers\",\n        enabled: true,\n    }],\n    managedResponseHeaders: [{\n        id: \"remove_x-powered-by_header\",\n        enabled: true,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Enable security headers using Managed Meaders\nexample = cloudflare.ManagedHeaders(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    managed_request_headers=[{\n        \"id\": \"add_true_client_ip_headers\",\n        \"enabled\": True,\n    }],\n    managed_response_headers=[{\n        \"id\": \"remove_x-powered-by_header\",\n        \"enabled\": True,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Enable security headers using Managed Meaders\n    var example = new Cloudflare.ManagedHeaders(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        ManagedRequestHeaders = new[]\n        {\n            new Cloudflare.Inputs.ManagedHeadersManagedRequestHeaderArgs\n            {\n                Id = \"add_true_client_ip_headers\",\n                Enabled = true,\n            },\n        },\n        ManagedResponseHeaders = new[]\n        {\n            new Cloudflare.Inputs.ManagedHeadersManagedResponseHeaderArgs\n            {\n                Id = \"remove_x-powered-by_header\",\n                Enabled = true,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Enable security headers using Managed Meaders\n\t\t_, err := cloudflare.NewManagedHeaders(ctx, \"example\", \u0026cloudflare.ManagedHeadersArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tManagedRequestHeaders: cloudflare.ManagedHeadersManagedRequestHeaderArray{\n\t\t\t\t\u0026cloudflare.ManagedHeadersManagedRequestHeaderArgs{\n\t\t\t\t\tId:      pulumi.String(\"add_true_client_ip_headers\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\tManagedResponseHeaders: cloudflare.ManagedHeadersManagedResponseHeaderArray{\n\t\t\t\t\u0026cloudflare.ManagedHeadersManagedResponseHeaderArgs{\n\t\t\t\t\tId:      pulumi.String(\"remove_x-powered-by_header\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ManagedHeaders;\nimport com.pulumi.cloudflare.ManagedHeadersArgs;\nimport com.pulumi.cloudflare.inputs.ManagedHeadersManagedRequestHeaderArgs;\nimport com.pulumi.cloudflare.inputs.ManagedHeadersManagedResponseHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Enable security headers using Managed Meaders\n        var example = new ManagedHeaders(\"example\", ManagedHeadersArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .managedRequestHeaders(ManagedHeadersManagedRequestHeaderArgs.builder()\n                .id(\"add_true_client_ip_headers\")\n                .enabled(true)\n                .build())\n            .managedResponseHeaders(ManagedHeadersManagedResponseHeaderArgs.builder()\n                .id(\"remove_x-powered-by_header\")\n                .enabled(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Enable security headers using Managed Meaders\n  example:\n    type: cloudflare:ManagedHeaders\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      managedRequestHeaders:\n        - id: add_true_client_ip_headers\n          enabled: true\n      managedResponseHeaders:\n        - id: remove_x-powered-by_header\n          enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "managedRequestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader"
                    },
                    "description": "The list of managed request headers.\n"
                },
                "managedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader"
                    },
                    "description": "The list of managed response headers.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "managedRequestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader"
                    },
                    "description": "The list of managed request headers.\n"
                },
                "managedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader"
                    },
                    "description": "The list of managed response headers.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedHeaders resources.\n",
                "properties": {
                    "managedRequestHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader"
                        },
                        "description": "The list of managed request headers.\n"
                    },
                    "managedResponseHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader"
                        },
                        "description": "The list of managed response headers.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/mtlsCertificate:MtlsCertificate": {
            "description": "Provides a Cloudflare mTLS certificate resource. These certificates may be used with mTLS enabled Cloudflare services.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MtlsCertificate(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example\",\n    certificates: `-----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----`,\n    privateKey: `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n-----END PRIVATE KEY-----`,\n    ca: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MtlsCertificate(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example\",\n    certificates=\"\"\"-----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----\"\"\",\n    private_key=\"\"\"-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n-----END PRIVATE KEY-----\"\"\",\n    ca=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.MtlsCertificate(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example\",\n        Certificates = @\"-----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----\",\n        PrivateKey = @\"-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n-----END PRIVATE KEY-----\",\n        Ca = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMtlsCertificate(ctx, \"example\", \u0026cloudflare.MtlsCertificateArgs{\n\t\t\tAccountId:    pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:         pulumi.String(\"example\"),\n\t\t\tCertificates: pulumi.String(\"-----BEGIN CERTIFICATE-----\\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\\n-----END CERTIFICATE-----\"),\n\t\t\tPrivateKey:   pulumi.String(\"-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\\n-----END PRIVATE KEY-----\"),\n\t\t\tCa:           pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.MtlsCertificate;\nimport com.pulumi.cloudflare.MtlsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MtlsCertificate(\"example\", MtlsCertificateArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example\")\n            .certificates(\"\"\"\n-----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----            \"\"\")\n            .privateKey(\"\"\"\n-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n-----END PRIVATE KEY-----            \"\"\")\n            .ca(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:MtlsCertificate\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example\n      certificates: |-\n        -----BEGIN CERTIFICATE-----\n        MIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n        -----END CERTIFICATE-----\n      privateKey: |-\n        -----BEGIN PRIVATE KEY-----\n        MIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n        -----END PRIVATE KEY-----\n      ca: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/mtlsCertificate:MtlsCertificate example \u003caccount_id\u003e/\u003cmtls_certificate_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ca": {
                    "type": "boolean",
                    "description": "Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "certificates": {
                    "type": "string",
                    "description": "Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "name": {
                    "type": "string",
                    "description": "Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The certificate's private key. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "signature": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                },
                "uploadedOn": {
                    "type": "string",
                    "description": "**Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "ca",
                "certificates",
                "expiresOn",
                "issuer",
                "serialNumber",
                "signature",
                "uploadedOn"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "ca": {
                    "type": "boolean",
                    "description": "Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "certificates": {
                    "type": "string",
                    "description": "Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "The certificate's private key. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "ca",
                "certificates"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MtlsCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ca": {
                        "type": "boolean",
                        "description": "Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "certificates": {
                        "type": "string",
                        "description": "Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "issuer": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The certificate's private key. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "serialNumber": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "uploadedOn": {
                        "type": "string",
                        "description": "**Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/notificationPolicy:NotificationPolicy": {
            "description": "Provides a resource, that manages a notification policy for\nCloudflare's products. The delivery mechanisms supported are email,\nwebhooks, and PagerDuty.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/notificationPolicy:NotificationPolicy example \u003caccount_id\u003e/\u003cpolicy_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "alertType": {
                    "type": "string",
                    "description": "The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `image_notification`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.\n"
                },
                "created": {
                    "type": "string",
                    "description": "When the notification policy was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the notification policy.\n"
                },
                "emailIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                    },
                    "description": "The email ID to which the notification should be dispatched.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "The status of the notification policy.\n"
                },
                "filters": {
                    "$ref": "#/types/cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters",
                    "description": "An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).\n"
                },
                "modified": {
                    "type": "string",
                    "description": "When the notification policy was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n"
                },
                "pagerdutyIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                    },
                    "description": "The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.\n"
                },
                "webhooksIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                    },
                    "description": "The unique ID of a configured webhooks endpoint to which the notification should be dispatched.\n"
                }
            },
            "required": [
                "accountId",
                "alertType",
                "created",
                "enabled",
                "modified",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "alertType": {
                    "type": "string",
                    "description": "The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `image_notification`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the notification policy.\n"
                },
                "emailIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                    },
                    "description": "The email ID to which the notification should be dispatched.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "The status of the notification policy.\n"
                },
                "filters": {
                    "$ref": "#/types/cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters",
                    "description": "An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n"
                },
                "pagerdutyIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                    },
                    "description": "The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.\n"
                },
                "webhooksIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                    },
                    "description": "The unique ID of a configured webhooks endpoint to which the notification should be dispatched.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "alertType",
                "enabled",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "alertType": {
                        "type": "string",
                        "description": "The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `image_notification`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "When the notification policy was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the notification policy.\n"
                    },
                    "emailIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                        },
                        "description": "The email ID to which the notification should be dispatched.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "The status of the notification policy.\n"
                    },
                    "filters": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters",
                        "description": "An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).\n"
                    },
                    "modified": {
                        "type": "string",
                        "description": "When the notification policy was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the notification policy.\n"
                    },
                    "pagerdutyIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                        },
                        "description": "The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.\n"
                    },
                    "webhooksIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                        },
                        "description": "The unique ID of a configured webhooks endpoint to which the notification should be dispatched.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks": {
            "description": "Provides a resource, that manages a webhook destination. These destinations can be tied to the notification policies created for Cloudflare's products.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.NotificationPolicyWebhooks(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Webhooks destination\",\n    url: \"https://example.com\",\n    secret: \"my-secret\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.NotificationPolicyWebhooks(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Webhooks destination\",\n    url=\"https://example.com\",\n    secret=\"my-secret\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.NotificationPolicyWebhooks(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Webhooks destination\",\n        Url = \"https://example.com\",\n        Secret = \"my-secret\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewNotificationPolicyWebhooks(ctx, \"example\", \u0026cloudflare.NotificationPolicyWebhooksArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"Webhooks destination\"),\n\t\t\tUrl:       pulumi.String(\"https://example.com\"),\n\t\t\tSecret:    pulumi.String(\"my-secret\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.NotificationPolicyWebhooks;\nimport com.pulumi.cloudflare.NotificationPolicyWebhooksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new NotificationPolicyWebhooks(\"example\", NotificationPolicyWebhooksArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Webhooks destination\")\n            .url(\"https://example.com\")\n            .secret(\"my-secret\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:NotificationPolicyWebhooks\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Webhooks destination\n      url: https://example.com\n      secret: my-secret\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks example \u003caccount_id\u003e/\u003cnotification_webhook_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp of when the notification webhook was created.\n"
                },
                "lastFailure": {
                    "type": "string",
                    "description": "Timestamp of when the notification webhook last failed.\n"
                },
                "lastSuccess": {
                    "type": "string",
                    "description": "Timestamp of when the notification webhook was last successful.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the webhook destination.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.\n"
                },
                "type": {
                    "type": "string"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "createdAt",
                "lastFailure",
                "lastSuccess",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the webhook destination.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationPolicyWebhooks resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp of when the notification webhook was created.\n"
                    },
                    "lastFailure": {
                        "type": "string",
                        "description": "Timestamp of when the notification webhook last failed.\n"
                    },
                    "lastSuccess": {
                        "type": "string",
                        "description": "Timestamp of when the notification webhook was last successful.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the webhook destination.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.\n"
                    },
                    "type": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/observatoryScheduledTest:ObservatoryScheduledTest": {
            "description": "Provides a Cloudflare Observatory Scheduled Test resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ObservatoryScheduledTest(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    url: \"example.com\",\n    region: \"us-central1\",\n    frequency: \"WEEKLY\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ObservatoryScheduledTest(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    url=\"example.com\",\n    region=\"us-central1\",\n    frequency=\"WEEKLY\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ObservatoryScheduledTest(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Url = \"example.com\",\n        Region = \"us-central1\",\n        Frequency = \"WEEKLY\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewObservatoryScheduledTest(ctx, \"example\", \u0026cloudflare.ObservatoryScheduledTestArgs{\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tUrl:       pulumi.String(\"example.com\"),\n\t\t\tRegion:    pulumi.String(\"us-central1\"),\n\t\t\tFrequency: pulumi.String(\"WEEKLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ObservatoryScheduledTest;\nimport com.pulumi.cloudflare.ObservatoryScheduledTestArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ObservatoryScheduledTest(\"example\", ObservatoryScheduledTestArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .url(\"example.com\")\n            .region(\"us-central1\")\n            .frequency(\"WEEKLY\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ObservatoryScheduledTest\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      url: example.com\n      region: us-central1\n      frequency: WEEKLY\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/observatoryScheduledTest:ObservatoryScheduledTest example \u003czone_id\u003e:\u003curl\u003e:\u003cregion\u003e\n```\n\n",
            "properties": {
                "frequency": {
                    "type": "string",
                    "description": "The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "region": {
                    "type": "string",
                    "description": "The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "url": {
                    "type": "string",
                    "description": "The page to run the test on. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "frequency",
                "region",
                "url",
                "zoneId"
            ],
            "inputProperties": {
                "frequency": {
                    "type": "string",
                    "description": "The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string",
                    "description": "The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The page to run the test on. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "frequency",
                "region",
                "url",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ObservatoryScheduledTest resources.\n",
                "properties": {
                    "frequency": {
                        "type": "string",
                        "description": "The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The page to run the test on. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/originCaCertificate:OriginCaCertificate": {
            "description": "Provides a Cloudflare Origin CA certificate used to protect traffic to your origin without involving a third party Certificate Authority.\n\n\u003e Since v3.32.0\n   all authentication schemes are supported for managing Origin CA certificates.\n   Versions prior to v3.32.0 will still need to use `api_user_service_key`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as tls from \"@pulumi/tls\";\n\nconst example = new tls.index.PrivateKey(\"example\", {algorithm: \"RSA\"});\nconst exampleCertRequest = new tls.index.CertRequest(\"example\", {\n    privateKeyPem: example.privateKeyPem,\n    subject: [{\n        commonName: \"\",\n        organization: \"Terraform Test\",\n    }],\n});\nconst exampleOriginCaCertificate = new cloudflare.OriginCaCertificate(\"example\", {\n    csr: exampleCertRequest.certRequestPem,\n    hostnames: [\"example.com\"],\n    requestType: \"origin-rsa\",\n    requestedValidity: 7,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_tls as tls\n\nexample = tls.index.PrivateKey(\"example\", algorithm=RSA)\nexample_cert_request = tls.index.CertRequest(\"example\",\n    private_key_pem=example.private_key_pem,\n    subject=[{\n        commonName: ,\n        organization: Terraform Test,\n    }])\nexample_origin_ca_certificate = cloudflare.OriginCaCertificate(\"example\",\n    csr=example_cert_request[\"certRequestPem\"],\n    hostnames=[\"example.com\"],\n    request_type=\"origin-rsa\",\n    requested_validity=7)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Tls = Pulumi.Tls;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Tls.Index.PrivateKey(\"example\", new()\n    {\n        Algorithm = \"RSA\",\n    });\n\n    var exampleCertRequest = new Tls.Index.CertRequest(\"example\", new()\n    {\n        PrivateKeyPem = example.PrivateKeyPem,\n        Subject = new[]\n        {\n            \n            {\n                { \"commonName\", \"\" },\n                { \"organization\", \"Terraform Test\" },\n            },\n        },\n    });\n\n    var exampleOriginCaCertificate = new Cloudflare.OriginCaCertificate(\"example\", new()\n    {\n        Csr = exampleCertRequest.CertRequestPem,\n        Hostnames = new[]\n        {\n            \"example.com\",\n        },\n        RequestType = \"origin-rsa\",\n        RequestedValidity = 7,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-tls/sdk/v4/go/tls\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := tls.NewPrivateKey(ctx, \"example\", \u0026tls.PrivateKeyArgs{\n\t\t\tAlgorithm: \"RSA\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCertRequest, err := tls.NewCertRequest(ctx, \"example\", \u0026tls.CertRequestArgs{\n\t\t\tPrivateKeyPem: example.PrivateKeyPem,\n\t\t\tSubject: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"commonName\":   \"\",\n\t\t\t\t\t\"organization\": \"Terraform Test\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewOriginCaCertificate(ctx, \"example\", \u0026cloudflare.OriginCaCertificateArgs{\n\t\t\tCsr: exampleCertRequest.CertRequestPem,\n\t\t\tHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t},\n\t\t\tRequestType:       pulumi.String(\"origin-rsa\"),\n\t\t\tRequestedValidity: pulumi.Int(7),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.tls.privateKey;\nimport com.pulumi.tls.PrivateKeyArgs;\nimport com.pulumi.tls.certRequest;\nimport com.pulumi.tls.CertRequestArgs;\nimport com.pulumi.cloudflare.OriginCaCertificate;\nimport com.pulumi.cloudflare.OriginCaCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PrivateKey(\"example\", PrivateKeyArgs.builder()\n            .algorithm(\"RSA\")\n            .build());\n\n        var exampleCertRequest = new CertRequest(\"exampleCertRequest\", CertRequestArgs.builder()\n            .privateKeyPem(example.privateKeyPem())\n            .subject(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n        var exampleOriginCaCertificate = new OriginCaCertificate(\"exampleOriginCaCertificate\", OriginCaCertificateArgs.builder()\n            .csr(exampleCertRequest.certRequestPem())\n            .hostnames(\"example.com\")\n            .requestType(\"origin-rsa\")\n            .requestedValidity(7)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: tls:privateKey\n    properties:\n      algorithm: RSA\n  exampleCertRequest:\n    type: tls:certRequest\n    name: example\n    properties:\n      privateKeyPem: ${example.privateKeyPem}\n      subject:\n        - commonName:\n          organization: Terraform Test\n  exampleOriginCaCertificate:\n    type: cloudflare:OriginCaCertificate\n    name: example\n    properties:\n      csr: ${exampleCertRequest.certRequestPem}\n      hostnames:\n        - example.com\n      requestType: origin-rsa\n      requestedValidity: 7\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/originCaCertificate:OriginCaCertificate example \u003ccertificate_id\u003e\n```\n\n",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The Origin CA certificate.\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The datetime when the certificate will expire.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "certificate",
                "csr",
                "expiresOn",
                "hostnames",
                "requestType",
                "requestedValidity"
            ],
            "inputProperties": {
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "csr",
                "hostnames",
                "requestType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OriginCaCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The Origin CA certificate.\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "The datetime when the certificate will expire.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "minDaysForRenewal": {
                        "type": "integer"
                    },
                    "requestType": {
                        "type": "string",
                        "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "requestedValidity": {
                        "type": "integer",
                        "description": "The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pageRule:PageRule": {
            "description": "Provides a Cloudflare page rule resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a page rule to the domain\nconst foobar = new cloudflare.PageRule(\"foobar\", {\n    zoneId: cloudflareZoneId,\n    target: `sub.${cloudflareZone}/page`,\n    priority: 1,\n    actions: {\n        ssl: \"flexible\",\n        emailObfuscation: \"on\",\n        minifies: [{\n            html: \"off\",\n            css: \"on\",\n            js: \"on\",\n        }],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a page rule to the domain\nfoobar = cloudflare.PageRule(\"foobar\",\n    zone_id=cloudflare_zone_id,\n    target=f\"sub.{cloudflare_zone}/page\",\n    priority=1,\n    actions={\n        \"ssl\": \"flexible\",\n        \"email_obfuscation\": \"on\",\n        \"minifies\": [{\n            \"html\": \"off\",\n            \"css\": \"on\",\n            \"js\": \"on\",\n        }],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Add a page rule to the domain\n    var foobar = new Cloudflare.PageRule(\"foobar\", new()\n    {\n        ZoneId = cloudflareZoneId,\n        Target = $\"sub.{cloudflareZone}/page\",\n        Priority = 1,\n        Actions = new Cloudflare.Inputs.PageRuleActionsArgs\n        {\n            Ssl = \"flexible\",\n            EmailObfuscation = \"on\",\n            Minifies = new[]\n            {\n                new Cloudflare.Inputs.PageRuleActionsMinifyArgs\n                {\n                    Html = \"off\",\n                    Css = \"on\",\n                    Js = \"on\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Add a page rule to the domain\n\t\t_, err := cloudflare.NewPageRule(ctx, \"foobar\", \u0026cloudflare.PageRuleArgs{\n\t\t\tZoneId:   pulumi.Any(cloudflareZoneId),\n\t\t\tTarget:   pulumi.Sprintf(\"sub.%v/page\", cloudflareZone),\n\t\t\tPriority: pulumi.Int(1),\n\t\t\tActions: \u0026cloudflare.PageRuleActionsArgs{\n\t\t\t\tSsl:              pulumi.String(\"flexible\"),\n\t\t\t\tEmailObfuscation: pulumi.String(\"on\"),\n\t\t\t\tMinifies: cloudflare.PageRuleActionsMinifyArray{\n\t\t\t\t\t\u0026cloudflare.PageRuleActionsMinifyArgs{\n\t\t\t\t\t\tHtml: pulumi.String(\"off\"),\n\t\t\t\t\t\tCss:  pulumi.String(\"on\"),\n\t\t\t\t\t\tJs:   pulumi.String(\"on\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.PageRule;\nimport com.pulumi.cloudflare.PageRuleArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Add a page rule to the domain\n        var foobar = new PageRule(\"foobar\", PageRuleArgs.builder()\n            .zoneId(cloudflareZoneId)\n            .target(String.format(\"sub.%s/page\", cloudflareZone))\n            .priority(1)\n            .actions(PageRuleActionsArgs.builder()\n                .ssl(\"flexible\")\n                .emailObfuscation(\"on\")\n                .minifies(PageRuleActionsMinifyArgs.builder()\n                    .html(\"off\")\n                    .css(\"on\")\n                    .js(\"on\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Add a page rule to the domain\n  foobar:\n    type: cloudflare:PageRule\n    properties:\n      zoneId: ${cloudflareZoneId}\n      target: sub.${cloudflareZone}/page\n      priority: 1\n      actions:\n        ssl: flexible\n        emailObfuscation: on\n        minifies:\n          - html: off\n            css: on\n            js: on\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nPage rules can be imported using a composite ID formed of zone ID and page rule ID, e.g.\n\n```sh\n$ pulumi import cloudflare:index/pageRule:PageRule default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43\n```\n",
            "properties": {
                "actions": {
                    "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n"
                }
            },
            "required": [
                "actions",
                "target",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "actions",
                "target",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PageRule resources.\n",
                "properties": {
                    "actions": {
                        "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                        "description": "The actions taken by the page rule, options given below.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Whether the page rule is active or disabled.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The URL pattern to target with the page rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the page rule should be added.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pagesDomain:PagesDomain": {
            "description": "Provides a resource for managing Cloudflare Pages domains.\n\n\u003e A DNS record for the domain is not automatically created. You need to create\n   a `cloudflare.Record` resource for the domain you want to use.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst my_domain = new cloudflare.PagesDomain(\"my-domain\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    projectName: \"my-example-project\",\n    domain: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_domain = cloudflare.PagesDomain(\"my-domain\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    project_name=\"my-example-project\",\n    domain=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_domain = new Cloudflare.PagesDomain(\"my-domain\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ProjectName = \"my-example-project\",\n        Domain = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewPagesDomain(ctx, \"my-domain\", \u0026cloudflare.PagesDomainArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tProjectName: pulumi.String(\"my-example-project\"),\n\t\t\tDomain:      pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.PagesDomain;\nimport com.pulumi.cloudflare.PagesDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var my_domain = new PagesDomain(\"my-domain\", PagesDomainArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .projectName(\"my-example-project\")\n            .domain(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  my-domain:\n    type: cloudflare:PagesDomain\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      projectName: my-example-project\n      domain: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/pagesDomain:PagesDomain example \u003caccount_id\u003e/\u003cproject_name\u003e/\u003cdomain-name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "domain": {
                    "type": "string",
                    "description": "Custom domain. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "projectName": {
                    "type": "string",
                    "description": "Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the custom domain.\n"
                }
            },
            "required": [
                "accountId",
                "domain",
                "projectName",
                "status"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "domain": {
                    "type": "string",
                    "description": "Custom domain. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "projectName": {
                    "type": "string",
                    "description": "Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "domain",
                "projectName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PagesDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "domain": {
                        "type": "string",
                        "description": "Custom domain. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "projectName": {
                        "type": "string",
                        "description": "Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the custom domain.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pagesProject:PagesProject": {
            "description": "Provides a resource which manages Cloudflare Pages projects.\n\n\u003e If you are using a `source` block configuration, you must first have a\n   connected GitHub or GitLab account connected to Cloudflare. See the\n   [Getting Started with Pages] documentation on how to link your accounts.\n\n## Import\n\n!\u003e It is not possible to import a pages project with secret environment variables. If you have a secret environment variable, you must remove it from your project before importing it.\n\n```sh\n$ pulumi import cloudflare:index/pagesProject:PagesProject example \u003caccount_id\u003e/\u003cproject_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "buildConfig": {
                    "$ref": "#/types/cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig",
                    "description": "Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "When the project was created.\n"
                },
                "deploymentConfigs": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs",
                    "description": "Configuration for deployments in a project.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of associated custom domains for the project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the project.\n"
                },
                "productionBranch": {
                    "type": "string",
                    "description": "The name of the branch that is used for the production environment.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/PagesProjectSource:PagesProjectSource",
                    "description": "Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).\n"
                },
                "subdomain": {
                    "type": "string",
                    "description": "The Cloudflare subdomain associated with the project.\n"
                }
            },
            "required": [
                "accountId",
                "createdOn",
                "deploymentConfigs",
                "domains",
                "name",
                "productionBranch",
                "subdomain"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "buildConfig": {
                    "$ref": "#/types/cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig",
                    "description": "Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).\n"
                },
                "deploymentConfigs": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs",
                    "description": "Configuration for deployments in a project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the project.\n"
                },
                "productionBranch": {
                    "type": "string",
                    "description": "The name of the branch that is used for the production environment.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/PagesProjectSource:PagesProjectSource",
                    "description": "Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "productionBranch"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PagesProject resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "buildConfig": {
                        "$ref": "#/types/cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig",
                        "description": "Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "When the project was created.\n"
                    },
                    "deploymentConfigs": {
                        "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs",
                        "description": "Configuration for deployments in a project.\n"
                    },
                    "domains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of associated custom domains for the project.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the project.\n"
                    },
                    "productionBranch": {
                        "type": "string",
                        "description": "The name of the branch that is used for the production environment.\n"
                    },
                    "source": {
                        "$ref": "#/types/cloudflare:index/PagesProjectSource:PagesProjectSource",
                        "description": "Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).\n"
                    },
                    "subdomain": {
                        "type": "string",
                        "description": "The Cloudflare subdomain associated with the project.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/queue:Queue": {
            "description": "Provides the ability to manage Cloudflare Workers Queue features.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Queue(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"my-queue\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Queue(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"my-queue\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Queue(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"my-queue\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewQueue(ctx, \"example\", \u0026cloudflare.QueueArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"my-queue\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Queue;\nimport com.pulumi.cloudflare.QueueArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Queue(\"example\", QueueArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"my-queue\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Queue\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: my-queue\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/queue:Queue example \u003caccount_id\u003e/\u003cqueue_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the queue.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the queue.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Queue resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the queue.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/r2Bucket:R2Bucket": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.R2Bucket(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"terraform-bucket\",\n    location: \"enam\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.R2Bucket(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"terraform-bucket\",\n    location=\"enam\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.R2Bucket(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"terraform-bucket\",\n        Location = \"enam\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewR2Bucket(ctx, \"example\", \u0026cloudflare.R2BucketArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"terraform-bucket\"),\n\t\t\tLocation:  pulumi.String(\"enam\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.R2Bucket;\nimport com.pulumi.cloudflare.R2BucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new R2Bucket(\"example\", R2BucketArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"terraform-bucket\")\n            .location(\"enam\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:R2Bucket\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: terraform-bucket\n      location: enam\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e Available location values can be found in the [R2 documentation](https://developers.cloudflare.com/r2/reference/data-location/#available-hints).\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/r2Bucket:R2Bucket default \u003caccount id\u003e/\u003cbucket name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location hint of the R2 bucket. Available values: `WNAM`, `ENAM`, `WEUR`, `EEUR`, `APAC`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the R2 bucket.\n"
                }
            },
            "required": [
                "accountId",
                "location",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location hint of the R2 bucket. Available values: `WNAM`, `ENAM`, `WEUR`, `EEUR`, `APAC`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the R2 bucket.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering R2Bucket resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location hint of the R2 bucket. Available values: `WNAM`, `ENAM`, `WEUR`, `EEUR`, `APAC`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the R2 bucket.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/rateLimit:RateLimit": {
            "description": "Provides a Cloudflare rate limit resource for a given zone. This can\nbe used to limit the traffic you receive zone-wide, or matching more\nspecific types of requests/responses.\n\n\u003e `cloudflare.RateLimit` is in a deprecation phase until January 15th, 2025.\n  During this time period, this resource is still\n  fully supported but you are strongly advised to move to the\n  `cloudflare.Ruleset` resource. Full details can be found in the\n  developer documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.RateLimit(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    threshold: 2000,\n    period: 2,\n    match: {\n        request: {\n            urlPattern: `${cloudflareZone}/*`,\n            schemes: [\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            methods: [\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        },\n        response: {\n            statuses: [\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            originTraffic: false,\n            headers: [\n                {\n                    name: \"Host\",\n                    op: \"eq\",\n                    value: \"localhost\",\n                },\n                {\n                    name: \"X-Example\",\n                    op: \"ne\",\n                    value: \"my-example\",\n                },\n            ],\n        },\n    },\n    action: {\n        mode: \"simulate\",\n        timeout: 43200,\n        response: {\n            contentType: \"text/plain\",\n            body: \"custom response body\",\n        },\n    },\n    correlate: {\n        by: \"nat\",\n    },\n    disabled: false,\n    description: \"example rate limit for a zone\",\n    bypassUrlPatterns: [\n        \"example.com/bypass1\",\n        \"example.com/bypass2\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.RateLimit(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    threshold=2000,\n    period=2,\n    match={\n        \"request\": {\n            \"url_pattern\": f\"{cloudflare_zone}/*\",\n            \"schemes\": [\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            \"methods\": [\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        },\n        \"response\": {\n            \"statuses\": [\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            \"origin_traffic\": False,\n            \"headers\": [\n                {\n                    \"name\": \"Host\",\n                    \"op\": \"eq\",\n                    \"value\": \"localhost\",\n                },\n                {\n                    \"name\": \"X-Example\",\n                    \"op\": \"ne\",\n                    \"value\": \"my-example\",\n                },\n            ],\n        },\n    },\n    action={\n        \"mode\": \"simulate\",\n        \"timeout\": 43200,\n        \"response\": {\n            \"content_type\": \"text/plain\",\n            \"body\": \"custom response body\",\n        },\n    },\n    correlate={\n        \"by\": \"nat\",\n    },\n    disabled=False,\n    description=\"example rate limit for a zone\",\n    bypass_url_patterns=[\n        \"example.com/bypass1\",\n        \"example.com/bypass2\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.RateLimit(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Threshold = 2000,\n        Period = 2,\n        Match = new Cloudflare.Inputs.RateLimitMatchArgs\n        {\n            Request = new Cloudflare.Inputs.RateLimitMatchRequestArgs\n            {\n                UrlPattern = $\"{cloudflareZone}/*\",\n                Schemes = new[]\n                {\n                    \"HTTP\",\n                    \"HTTPS\",\n                },\n                Methods = new[]\n                {\n                    \"GET\",\n                    \"POST\",\n                    \"PUT\",\n                    \"DELETE\",\n                    \"PATCH\",\n                    \"HEAD\",\n                },\n            },\n            Response = new Cloudflare.Inputs.RateLimitMatchResponseArgs\n            {\n                Statuses = new[]\n                {\n                    200,\n                    201,\n                    202,\n                    301,\n                    429,\n                },\n                OriginTraffic = false,\n                Headers = new[]\n                {\n                    \n                    {\n                        { \"name\", \"Host\" },\n                        { \"op\", \"eq\" },\n                        { \"value\", \"localhost\" },\n                    },\n                    \n                    {\n                        { \"name\", \"X-Example\" },\n                        { \"op\", \"ne\" },\n                        { \"value\", \"my-example\" },\n                    },\n                },\n            },\n        },\n        Action = new Cloudflare.Inputs.RateLimitActionArgs\n        {\n            Mode = \"simulate\",\n            Timeout = 43200,\n            Response = new Cloudflare.Inputs.RateLimitActionResponseArgs\n            {\n                ContentType = \"text/plain\",\n                Body = \"custom response body\",\n            },\n        },\n        Correlate = new Cloudflare.Inputs.RateLimitCorrelateArgs\n        {\n            By = \"nat\",\n        },\n        Disabled = false,\n        Description = \"example rate limit for a zone\",\n        BypassUrlPatterns = new[]\n        {\n            \"example.com/bypass1\",\n            \"example.com/bypass2\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewRateLimit(ctx, \"example\", \u0026cloudflare.RateLimitArgs{\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tThreshold: pulumi.Int(2000),\n\t\t\tPeriod:    pulumi.Int(2),\n\t\t\tMatch: \u0026cloudflare.RateLimitMatchArgs{\n\t\t\t\tRequest: \u0026cloudflare.RateLimitMatchRequestArgs{\n\t\t\t\t\tUrlPattern: pulumi.Sprintf(\"%v/*\", cloudflareZone),\n\t\t\t\t\tSchemes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"HTTP\"),\n\t\t\t\t\t\tpulumi.String(\"HTTPS\"),\n\t\t\t\t\t},\n\t\t\t\t\tMethods: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GET\"),\n\t\t\t\t\t\tpulumi.String(\"POST\"),\n\t\t\t\t\t\tpulumi.String(\"PUT\"),\n\t\t\t\t\t\tpulumi.String(\"DELETE\"),\n\t\t\t\t\t\tpulumi.String(\"PATCH\"),\n\t\t\t\t\t\tpulumi.String(\"HEAD\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponse: \u0026cloudflare.RateLimitMatchResponseArgs{\n\t\t\t\t\tStatuses: pulumi.IntArray{\n\t\t\t\t\t\tpulumi.Int(200),\n\t\t\t\t\t\tpulumi.Int(201),\n\t\t\t\t\t\tpulumi.Int(202),\n\t\t\t\t\t\tpulumi.Int(301),\n\t\t\t\t\t\tpulumi.Int(429),\n\t\t\t\t\t},\n\t\t\t\t\tOriginTraffic: pulumi.Bool(false),\n\t\t\t\t\tHeaders: pulumi.StringMapArray{\n\t\t\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\t\t\"name\":  pulumi.String(\"Host\"),\n\t\t\t\t\t\t\t\"op\":    pulumi.String(\"eq\"),\n\t\t\t\t\t\t\t\"value\": pulumi.String(\"localhost\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\t\t\"name\":  pulumi.String(\"X-Example\"),\n\t\t\t\t\t\t\t\"op\":    pulumi.String(\"ne\"),\n\t\t\t\t\t\t\t\"value\": pulumi.String(\"my-example\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: \u0026cloudflare.RateLimitActionArgs{\n\t\t\t\tMode:    pulumi.String(\"simulate\"),\n\t\t\t\tTimeout: pulumi.Int(43200),\n\t\t\t\tResponse: \u0026cloudflare.RateLimitActionResponseArgs{\n\t\t\t\t\tContentType: pulumi.String(\"text/plain\"),\n\t\t\t\t\tBody:        pulumi.String(\"custom response body\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCorrelate: \u0026cloudflare.RateLimitCorrelateArgs{\n\t\t\t\tBy: pulumi.String(\"nat\"),\n\t\t\t},\n\t\t\tDisabled:    pulumi.Bool(false),\n\t\t\tDescription: pulumi.String(\"example rate limit for a zone\"),\n\t\t\tBypassUrlPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com/bypass1\"),\n\t\t\t\tpulumi.String(\"example.com/bypass2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.RateLimit;\nimport com.pulumi.cloudflare.RateLimitArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitMatchArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitMatchRequestArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitMatchResponseArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitActionArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitActionResponseArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitCorrelateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new RateLimit(\"example\", RateLimitArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .threshold(2000)\n            .period(2)\n            .match(RateLimitMatchArgs.builder()\n                .request(RateLimitMatchRequestArgs.builder()\n                    .urlPattern(String.format(\"%s/*\", cloudflareZone))\n                    .schemes(                    \n                        \"HTTP\",\n                        \"HTTPS\")\n                    .methods(                    \n                        \"GET\",\n                        \"POST\",\n                        \"PUT\",\n                        \"DELETE\",\n                        \"PATCH\",\n                        \"HEAD\")\n                    .build())\n                .response(RateLimitMatchResponseArgs.builder()\n                    .statuses(                    \n                        200,\n                        201,\n                        202,\n                        301,\n                        429)\n                    .originTraffic(false)\n                    .headers(                    \n                        Map.ofEntries(\n                            Map.entry(\"name\", \"Host\"),\n                            Map.entry(\"op\", \"eq\"),\n                            Map.entry(\"value\", \"localhost\")\n                        ),\n                        Map.ofEntries(\n                            Map.entry(\"name\", \"X-Example\"),\n                            Map.entry(\"op\", \"ne\"),\n                            Map.entry(\"value\", \"my-example\")\n                        ))\n                    .build())\n                .build())\n            .action(RateLimitActionArgs.builder()\n                .mode(\"simulate\")\n                .timeout(43200)\n                .response(RateLimitActionResponseArgs.builder()\n                    .contentType(\"text/plain\")\n                    .body(\"custom response body\")\n                    .build())\n                .build())\n            .correlate(RateLimitCorrelateArgs.builder()\n                .by(\"nat\")\n                .build())\n            .disabled(false)\n            .description(\"example rate limit for a zone\")\n            .bypassUrlPatterns(            \n                \"example.com/bypass1\",\n                \"example.com/bypass2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:RateLimit\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      threshold: 2000\n      period: 2\n      match:\n        request:\n          urlPattern: ${cloudflareZone}/*\n          schemes:\n            - HTTP\n            - HTTPS\n          methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n            - PATCH\n            - HEAD\n        response:\n          statuses:\n            - 200\n            - 201\n            - 202\n            - 301\n            - 429\n          originTraffic: false\n          headers:\n            - name: Host\n              op: eq\n              value: localhost\n            - name: X-Example\n              op: ne\n              value: my-example\n      action:\n        mode: simulate\n        timeout: 43200\n        response:\n          contentType: text/plain\n          body: custom response body\n      correlate:\n        by: nat\n      disabled: false\n      description: example rate limit for a zone\n      bypassUrlPatterns:\n        - example.com/bypass1\n        - example.com/bypass2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/rateLimit:RateLimit example \u003czone_id\u003e/\u003crate_limit_id\u003e\n```\n\n",
            "properties": {
                "action": {
                    "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Defaults to `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "action",
                "match",
                "period",
                "threshold",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Defaults to `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "period",
                "threshold",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RateLimit resources.\n",
                "properties": {
                    "action": {
                        "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                        "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                    },
                    "bypassUrlPatterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "correlate": {
                        "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                        "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether this ratelimit is currently disabled. Defaults to `false`.\n"
                    },
                    "match": {
                        "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                        "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.\n"
                    },
                    "threshold": {
                        "type": "integer",
                        "description": "The threshold that triggers the rate limit mitigations, combine with period.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/record:Record": {
            "description": "Provides a Cloudflare record resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a record to the domain\nconst example = new cloudflare.Record(\"example\", {\n    zoneId: cloudflareZoneId,\n    name: \"terraform\",\n    content: \"192.0.2.1\",\n    type: \"A\",\n    ttl: 3600,\n});\n// Add a record requiring a data map\nconst _sipTls = new cloudflare.Record(\"_sip_tls\", {\n    zoneId: cloudflareZoneId,\n    name: \"_sip._tls\",\n    type: \"SRV\",\n    data: {\n        service: \"_sip\",\n        proto: \"_tls\",\n        name: \"terraform-srv\",\n        priority: 0,\n        weight: 0,\n        port: 443,\n        target: \"example.com\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a record to the domain\nexample = cloudflare.Record(\"example\",\n    zone_id=cloudflare_zone_id,\n    name=\"terraform\",\n    content=\"192.0.2.1\",\n    type=\"A\",\n    ttl=3600)\n# Add a record requiring a data map\n_sip_tls = cloudflare.Record(\"_sip_tls\",\n    zone_id=cloudflare_zone_id,\n    name=\"_sip._tls\",\n    type=\"SRV\",\n    data={\n        \"service\": \"_sip\",\n        \"proto\": \"_tls\",\n        \"name\": \"terraform-srv\",\n        \"priority\": 0,\n        \"weight\": 0,\n        \"port\": 443,\n        \"target\": \"example.com\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Add a record to the domain\n    var example = new Cloudflare.Record(\"example\", new()\n    {\n        ZoneId = cloudflareZoneId,\n        Name = \"terraform\",\n        Content = \"192.0.2.1\",\n        Type = \"A\",\n        Ttl = 3600,\n    });\n\n    // Add a record requiring a data map\n    var _sipTls = new Cloudflare.Record(\"_sip_tls\", new()\n    {\n        ZoneId = cloudflareZoneId,\n        Name = \"_sip._tls\",\n        Type = \"SRV\",\n        Data = new Cloudflare.Inputs.RecordDataArgs\n        {\n            Service = \"_sip\",\n            Proto = \"_tls\",\n            Name = \"terraform-srv\",\n            Priority = 0,\n            Weight = 0,\n            Port = 443,\n            Target = \"example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Add a record to the domain\n\t\t_, err := cloudflare.NewRecord(ctx, \"example\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId:  pulumi.Any(cloudflareZoneId),\n\t\t\tName:    pulumi.String(\"terraform\"),\n\t\t\tContent: pulumi.String(\"192.0.2.1\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t\tTtl:     pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Add a record requiring a data map\n\t\t_, err = cloudflare.NewRecord(ctx, \"_sip_tls\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId: pulumi.Any(cloudflareZoneId),\n\t\t\tName:   pulumi.String(\"_sip._tls\"),\n\t\t\tType:   pulumi.String(\"SRV\"),\n\t\t\tData: \u0026cloudflare.RecordDataArgs{\n\t\t\t\tService:  pulumi.String(\"_sip\"),\n\t\t\t\tProto:    pulumi.String(\"_tls\"),\n\t\t\t\tName:     pulumi.String(\"terraform-srv\"),\n\t\t\t\tPriority: pulumi.Int(0),\n\t\t\t\tWeight:   pulumi.Int(0),\n\t\t\t\tPort:     pulumi.Int(443),\n\t\t\t\tTarget:   pulumi.String(\"example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Record;\nimport com.pulumi.cloudflare.RecordArgs;\nimport com.pulumi.cloudflare.inputs.RecordDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Add a record to the domain\n        var example = new Record(\"example\", RecordArgs.builder()\n            .zoneId(cloudflareZoneId)\n            .name(\"terraform\")\n            .content(\"192.0.2.1\")\n            .type(\"A\")\n            .ttl(3600)\n            .build());\n\n        // Add a record requiring a data map\n        var _sipTls = new Record(\"_sipTls\", RecordArgs.builder()\n            .zoneId(cloudflareZoneId)\n            .name(\"_sip._tls\")\n            .type(\"SRV\")\n            .data(RecordDataArgs.builder()\n                .service(\"_sip\")\n                .proto(\"_tls\")\n                .name(\"terraform-srv\")\n                .priority(0)\n                .weight(0)\n                .port(443)\n                .target(\"example.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Add a record to the domain\n  example:\n    type: cloudflare:Record\n    properties:\n      zoneId: ${cloudflareZoneId}\n      name: terraform\n      content: 192.0.2.1\n      type: A\n      ttl: 3600\n  # Add a record requiring a data map\n  _sipTls:\n    type: cloudflare:Record\n    name: _sip_tls\n    properties:\n      zoneId: ${cloudflareZoneId}\n      name: _sip._tls\n      type: SRV\n      data:\n        service: _sip\n        proto: _tls\n        name: terraform-srv\n        priority: 0\n        weight: 0\n        port: 443\n        target: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/record:Record example \u003czone_id\u003e/\u003crecord_id\u003e\n```\n\n",
            "properties": {
                "allowOverwrite": {
                    "type": "boolean"
                },
                "comment": {
                    "type": "string",
                    "description": "Comments or notes about the DNS record. This field has no effect on DNS responses.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The content of the record. Must provide only one of `data`, `content`, `value`.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was created.\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Must provide only one of `data`, `content`, `value`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The FQDN of the record.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key-value map of string metadata Cloudflare associates with the record.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record.\n"
                },
                "proxiable": {
                    "type": "boolean",
                    "description": "Shows whether this record can be proxied.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Custom tags for the DNS record.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the record. Must provide only one of `data`, `content`, `value`.\n",
                    "deprecationMessage": "`value` is deprecated in favour of `content` and will be removed in the next major release."
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "content",
                "createdOn",
                "hostname",
                "metadata",
                "modifiedOn",
                "name",
                "proxiable",
                "ttl",
                "type",
                "value",
                "zoneId"
            ],
            "inputProperties": {
                "allowOverwrite": {
                    "type": "boolean"
                },
                "comment": {
                    "type": "string",
                    "description": "Comments or notes about the DNS record. This field has no effect on DNS responses.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The content of the record. Must provide only one of `data`, `content`, `value`.\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Must provide only one of `data`, `content`, `value`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Custom tags for the DNS record.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "The value of the record. Must provide only one of `data`, `content`, `value`.\n",
                    "deprecationMessage": "`value` is deprecated in favour of `content` and will be removed in the next major release."
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Record resources.\n",
                "properties": {
                    "allowOverwrite": {
                        "type": "boolean"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Comments or notes about the DNS record. This field has no effect on DNS responses.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "The content of the record. Must provide only one of `data`, `content`, `value`.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was created.\n"
                    },
                    "data": {
                        "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                        "description": "Map of attributes that constitute the record value. Must provide only one of `data`, `content`, `value`.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The FQDN of the record.\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key-value map of string metadata Cloudflare associates with the record.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the record. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the record.\n"
                    },
                    "proxiable": {
                        "type": "boolean",
                        "description": "Shows whether this record can be proxied.\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the record gets Cloudflare's origin protection.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Custom tags for the DNS record.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL of the record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the record. Must provide only one of `data`, `content`, `value`.\n",
                        "deprecationMessage": "`value` is deprecated in favour of `content` and will be removed in the next major release."
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/regionalHostname:RegionalHostname": {
            "description": "Provides a Data Localization Suite Regional Hostname.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Regionalized hostname record resources are managed independently from the\n// Regionalized Hostname resources.\nconst example = new cloudflare.Record(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"example.com\",\n    content: \"192.0.2.1\",\n    type: \"A\",\n    ttl: 3600,\n});\n// The cloudflare_regional_hostname resource may exist with or without its\n// corresponding record resource.\nconst exampleRegionalHostname = new cloudflare.RegionalHostname(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname: \"example.com\",\n    regionKey: \"eu\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Regionalized hostname record resources are managed independently from the\n# Regionalized Hostname resources.\nexample = cloudflare.Record(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"example.com\",\n    content=\"192.0.2.1\",\n    type=\"A\",\n    ttl=3600)\n# The cloudflare_regional_hostname resource may exist with or without its\n# corresponding record resource.\nexample_regional_hostname = cloudflare.RegionalHostname(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname=\"example.com\",\n    region_key=\"eu\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Regionalized hostname record resources are managed independently from the\n    // Regionalized Hostname resources.\n    var example = new Cloudflare.Record(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"example.com\",\n        Content = \"192.0.2.1\",\n        Type = \"A\",\n        Ttl = 3600,\n    });\n\n    // The cloudflare_regional_hostname resource may exist with or without its\n    // corresponding record resource.\n    var exampleRegionalHostname = new Cloudflare.RegionalHostname(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Hostname = \"example.com\",\n        RegionKey = \"eu\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Regionalized hostname record resources are managed independently from the\n\t\t// Regionalized Hostname resources.\n\t\t_, err := cloudflare.NewRecord(ctx, \"example\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:    pulumi.String(\"example.com\"),\n\t\t\tContent: pulumi.String(\"192.0.2.1\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t\tTtl:     pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// The cloudflare_regional_hostname resource may exist with or without its\n\t\t// corresponding record resource.\n\t\t_, err = cloudflare.NewRegionalHostname(ctx, \"example\", \u0026cloudflare.RegionalHostnameArgs{\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tHostname:  pulumi.String(\"example.com\"),\n\t\t\tRegionKey: pulumi.String(\"eu\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Record;\nimport com.pulumi.cloudflare.RecordArgs;\nimport com.pulumi.cloudflare.RegionalHostname;\nimport com.pulumi.cloudflare.RegionalHostnameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Regionalized hostname record resources are managed independently from the\n        // Regionalized Hostname resources.\n        var example = new Record(\"example\", RecordArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"example.com\")\n            .content(\"192.0.2.1\")\n            .type(\"A\")\n            .ttl(3600)\n            .build());\n\n        // The cloudflare_regional_hostname resource may exist with or without its\n        // corresponding record resource.\n        var exampleRegionalHostname = new RegionalHostname(\"exampleRegionalHostname\", RegionalHostnameArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .hostname(\"example.com\")\n            .regionKey(\"eu\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Regionalized hostname record resources are managed independently from the\n  # Regionalized Hostname resources.\n  example:\n    type: cloudflare:Record\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: example.com\n      content: 192.0.2.1\n      type: A\n      ttl: 3600\n  # The cloudflare_regional_hostname resource may exist with or without its\n  # corresponding record resource.\n  exampleRegionalHostname:\n    type: cloudflare:RegionalHostname\n    name: example\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      hostname: example.com\n      regionKey: eu\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the hostname was created.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname to regionalize.\n"
                },
                "regionKey": {
                    "type": "string",
                    "description": "The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "createdOn",
                "hostname",
                "regionKey",
                "zoneId"
            ],
            "inputProperties": {
                "hostname": {
                    "type": "string",
                    "description": "The hostname to regionalize.\n"
                },
                "regionKey": {
                    "type": "string",
                    "description": "The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "regionKey",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RegionalHostname resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the hostname was created.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname to regionalize.\n"
                    },
                    "regionKey": {
                        "type": "string",
                        "description": "The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/regionalTieredCache:RegionalTieredCache": {
            "description": "Instructs Cloudflare to check a regional hub data center on the way to your upper tier.\nThis can help improve performance for smart and custom tiered cache topologies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.RegionalTieredCache(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    value: \"on\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.RegionalTieredCache(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    value=\"on\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.RegionalTieredCache(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Value = \"on\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewRegionalTieredCache(ctx, \"example\", \u0026cloudflare.RegionalTieredCacheArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tValue:  pulumi.String(\"on\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.RegionalTieredCache;\nimport com.pulumi.cloudflare.RegionalTieredCacheArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new RegionalTieredCache(\"example\", RegionalTieredCacheArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .value(\"on\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:RegionalTieredCache\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      value: on\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/regionalTieredCache:RegionalTieredCache example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "value": {
                    "type": "string",
                    "description": "Value of the Regional Tiered Cache zone setting.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "value",
                "zoneId"
            ],
            "inputProperties": {
                "value": {
                    "type": "string",
                    "description": "Value of the Regional Tiered Cache zone setting.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "value",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RegionalTieredCache resources.\n",
                "properties": {
                    "value": {
                        "type": "string",
                        "description": "Value of the Regional Tiered Cache zone setting.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/riskBehavior:RiskBehavior": {
            "description": "The [Risk Behavior](https://developers.cloudflare.com/cloudflare-one/insights/risk-score/) resource allows you to configure Cloudflare Risk Behaviors for an account.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "behaviors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RiskBehaviorBehavior:RiskBehaviorBehavior"
                    },
                    "description": "Zero Trust risk behaviors configured on this account\n"
                }
            },
            "required": [
                "accountId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "behaviors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RiskBehaviorBehavior:RiskBehaviorBehavior"
                    },
                    "description": "Zero Trust risk behaviors configured on this account\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RiskBehavior resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "behaviors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/RiskBehaviorBehavior:RiskBehaviorBehavior"
                        },
                        "description": "Zero Trust risk behaviors configured on this account\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ruleset:Ruleset": {
            "description": "The [Cloudflare Ruleset Engine](https://developers.cloudflare.com/firewall/cf-rulesets)\nallows you to create and deploy rules and rulesets.\n\nThe engine syntax, inspired by the Wireshark Display Filter language, is the\nsame syntax used in custom Firewall Rules. Cloudflare uses the Ruleset Engine\nin different products, allowing you to configure several products using the same\nbasic syntax.\n\n## Import\n\nImport an account scoped Ruleset configuration.\n\n```sh\n$ pulumi import cloudflare:index/ruleset:Ruleset example account/\u003caccount_id\u003e/\u003cruleset_id\u003e\n```\n\nImport a zone scoped Ruleset configuration.\n\n```sh\n$ pulumi import cloudflare:index/ruleset:Ruleset example zone/\u003czone_id\u003e/\u003cruleset_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset and its intended use.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "description",
                "kind",
                "name",
                "phase"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset and its intended use.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "kind",
                "name",
                "phase"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Ruleset resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Brief summary of the ruleset and its intended use.\n"
                    },
                    "kind": {
                        "type": "string",
                        "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the ruleset.\n"
                    },
                    "phase": {
                        "type": "string",
                        "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                        },
                        "description": "List of rules to apply to the ruleset.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/spectrumApplication:SpectrumApplication": {
            "description": "Provides a Cloudflare Spectrum Application. You can extend the power\nof Cloudflare's DDoS, TLS, and IP Firewall to your other TCP-based\nservices.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.SpectrumApplication(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    protocol: \"tcp/22\",\n    trafficType: \"direct\",\n    dns: {\n        type: \"CNAME\",\n        name: \"ssh.example.com\",\n    },\n    originDirects: [\"tcp://192.0.2.1:22\"],\n    edgeIps: {\n        type: \"static\",\n        ips: [\n            \"203.0.113.1\",\n            \"203.0.113.2\",\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.SpectrumApplication(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    protocol=\"tcp/22\",\n    traffic_type=\"direct\",\n    dns={\n        \"type\": \"CNAME\",\n        \"name\": \"ssh.example.com\",\n    },\n    origin_directs=[\"tcp://192.0.2.1:22\"],\n    edge_ips={\n        \"type\": \"static\",\n        \"ips\": [\n            \"203.0.113.1\",\n            \"203.0.113.2\",\n        ],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.SpectrumApplication(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Protocol = \"tcp/22\",\n        TrafficType = \"direct\",\n        Dns = new Cloudflare.Inputs.SpectrumApplicationDnsArgs\n        {\n            Type = \"CNAME\",\n            Name = \"ssh.example.com\",\n        },\n        OriginDirects = new[]\n        {\n            \"tcp://192.0.2.1:22\",\n        },\n        EdgeIps = new Cloudflare.Inputs.SpectrumApplicationEdgeIpsArgs\n        {\n            Type = \"static\",\n            Ips = new[]\n            {\n                \"203.0.113.1\",\n                \"203.0.113.2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewSpectrumApplication(ctx, \"example\", \u0026cloudflare.SpectrumApplicationArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tProtocol:    pulumi.String(\"tcp/22\"),\n\t\t\tTrafficType: pulumi.String(\"direct\"),\n\t\t\tDns: \u0026cloudflare.SpectrumApplicationDnsArgs{\n\t\t\t\tType: pulumi.String(\"CNAME\"),\n\t\t\t\tName: pulumi.String(\"ssh.example.com\"),\n\t\t\t},\n\t\t\tOriginDirects: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tcp://192.0.2.1:22\"),\n\t\t\t},\n\t\t\tEdgeIps: \u0026cloudflare.SpectrumApplicationEdgeIpsArgs{\n\t\t\t\tType: pulumi.String(\"static\"),\n\t\t\t\tIps: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"203.0.113.1\"),\n\t\t\t\t\tpulumi.String(\"203.0.113.2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.SpectrumApplication;\nimport com.pulumi.cloudflare.SpectrumApplicationArgs;\nimport com.pulumi.cloudflare.inputs.SpectrumApplicationDnsArgs;\nimport com.pulumi.cloudflare.inputs.SpectrumApplicationEdgeIpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SpectrumApplication(\"example\", SpectrumApplicationArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .protocol(\"tcp/22\")\n            .trafficType(\"direct\")\n            .dns(SpectrumApplicationDnsArgs.builder()\n                .type(\"CNAME\")\n                .name(\"ssh.example.com\")\n                .build())\n            .originDirects(\"tcp://192.0.2.1:22\")\n            .edgeIps(SpectrumApplicationEdgeIpsArgs.builder()\n                .type(\"static\")\n                .ips(                \n                    \"203.0.113.1\",\n                    \"203.0.113.2\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:SpectrumApplication\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      protocol: tcp/22\n      trafficType: direct\n      dns:\n        type: CNAME\n        name: ssh.example.com\n      originDirects:\n        - tcp://192.0.2.1:22\n      edgeIps:\n        type: static\n        ips:\n          - 203.0.113.1\n          - 203.0.113.2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/spectrumApplication:SpectrumApplication example \u003czone_id\u003e/\u003cspectrum_application_id\u003e\n```\n\n",
            "properties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": "Enables Argo Smart Routing.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application.\n"
                },
                "edgeIps": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationEdgeIps:SpectrumApplicationEdgeIps",
                    "description": "The anycast edge IP configuration for the hostname of this application.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "Origin port to proxy traffice to. Conflicts with `origin_port_range`.\n"
                },
                "originPortRange": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                    "description": "Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflare's edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Available values: `direct`, `http`, `https`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "argoSmartRouting",
                "dns",
                "edgeIps",
                "ipFirewall",
                "protocol",
                "proxyProtocol",
                "tls",
                "trafficType",
                "zoneId"
            ],
            "inputProperties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": "Enables Argo Smart Routing.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application.\n"
                },
                "edgeIps": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationEdgeIps:SpectrumApplicationEdgeIps",
                    "description": "The anycast edge IP configuration for the hostname of this application.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "Origin port to proxy traffice to. Conflicts with `origin_port_range`.\n"
                },
                "originPortRange": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                    "description": "Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflare's edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Available values: `direct`, `http`, `https`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "dns",
                "protocol",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SpectrumApplication resources.\n",
                "properties": {
                    "argoSmartRouting": {
                        "type": "boolean",
                        "description": "Enables Argo Smart Routing.\n"
                    },
                    "dns": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                        "description": "The name and type of DNS record for the Spectrum application.\n"
                    },
                    "edgeIps": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationEdgeIps:SpectrumApplicationEdgeIps",
                        "description": "The anycast edge IP configuration for the hostname of this application.\n"
                    },
                    "ipFirewall": {
                        "type": "boolean",
                        "description": "Enables the IP Firewall for this application.\n"
                    },
                    "originDirects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                    },
                    "originDns": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                        "description": "A destination DNS addresses to the origin.\n"
                    },
                    "originPort": {
                        "type": "integer",
                        "description": "Origin port to proxy traffice to. Conflicts with `origin_port_range`.\n"
                    },
                    "originPortRange": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                        "description": "Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The port configuration at Cloudflare's edge. e.g. `tcp/22`.\n"
                    },
                    "proxyProtocol": {
                        "type": "string",
                        "description": "Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.\n"
                    },
                    "tls": {
                        "type": "string",
                        "description": "TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.\n"
                    },
                    "trafficType": {
                        "type": "string",
                        "description": "Sets application type. Available values: `direct`, `http`, `https`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/splitTunnel:SplitTunnel": {
            "description": "Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either\ninclude or exclude lists of routes from the WARP client's tunnel.\n\n## Import\n\nSplit Tunnels for default device policies must use \"default\" as the policy ID.\n\n```sh\n$ pulumi import cloudflare:index/splitTunnel:SplitTunnel example \u003caccount_id\u003e/\u003cpolicy_id\u003e/\u003cmode\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this split tunnel policy.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes.\n"
                }
            },
            "required": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this split tunnel policy.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SplitTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The settings policy for which to configure this split tunnel policy.\n"
                    },
                    "tunnels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                        },
                        "description": "The value of the tunnel attributes.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/staticRoute:StaticRoute": {
            "description": "Provides a resource, that manages Cloudflare static routes for Magic\nTransit or Magic WAN. Static routes are used to route traffic\nthrough GRE tunnels.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.StaticRoute(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    description: \"New route for new prefix 192.0.2.0/24\",\n    prefix: \"192.0.2.0/24\",\n    nexthop: \"10.0.0.0\",\n    priority: 100,\n    weight: 10,\n    coloNames: [\"den01\"],\n    coloRegions: [\"APAC\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.StaticRoute(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    description=\"New route for new prefix 192.0.2.0/24\",\n    prefix=\"192.0.2.0/24\",\n    nexthop=\"10.0.0.0\",\n    priority=100,\n    weight=10,\n    colo_names=[\"den01\"],\n    colo_regions=[\"APAC\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.StaticRoute(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Description = \"New route for new prefix 192.0.2.0/24\",\n        Prefix = \"192.0.2.0/24\",\n        Nexthop = \"10.0.0.0\",\n        Priority = 100,\n        Weight = 10,\n        ColoNames = new[]\n        {\n            \"den01\",\n        },\n        ColoRegions = new[]\n        {\n            \"APAC\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewStaticRoute(ctx, \"example\", \u0026cloudflare.StaticRouteArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tDescription: pulumi.String(\"New route for new prefix 192.0.2.0/24\"),\n\t\t\tPrefix:      pulumi.String(\"192.0.2.0/24\"),\n\t\t\tNexthop:     pulumi.String(\"10.0.0.0\"),\n\t\t\tPriority:    pulumi.Int(100),\n\t\t\tWeight:      pulumi.Int(10),\n\t\t\tColoNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"den01\"),\n\t\t\t},\n\t\t\tColoRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"APAC\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.StaticRoute;\nimport com.pulumi.cloudflare.StaticRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new StaticRoute(\"example\", StaticRouteArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .description(\"New route for new prefix 192.0.2.0/24\")\n            .prefix(\"192.0.2.0/24\")\n            .nexthop(\"10.0.0.0\")\n            .priority(100)\n            .weight(10)\n            .coloNames(\"den01\")\n            .coloRegions(\"APAC\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:StaticRoute\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      description: New route for new prefix 192.0.2.0/24\n      prefix: 192.0.2.0/24\n      nexthop: 10.0.0.0\n      priority: 100\n      weight: 10\n      coloNames:\n        - den01\n      coloRegions:\n        - APAC\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/staticRoute:StaticRoute example \u003caccount_id\u003e/\u003cstatic_route_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation regions for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation names for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation regions for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Cloudflare colocation names for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StaticRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "coloNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Cloudflare colocation regions for this static route.\n"
                    },
                    "coloRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Cloudflare colocation names for this static route.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the static route.\n"
                    },
                    "nexthop": {
                        "type": "string",
                        "description": "The nexthop IP address where traffic will be routed to.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "Your network prefix using CIDR notation.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority for the static route.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsAccount:TeamsAccount": {
            "description": "Provides a Cloudflare Teams Account resource. The Teams Account\nresource defines configuration for secure web gateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TeamsAccount(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tlsDecryptEnabled: true,\n    protocolDetectionEnabled: true,\n    blockPage: {\n        footerText: \"hello\",\n        headerText: \"hello\",\n        logoPath: \"https://example.com/logo.jpg\",\n        backgroundColor: \"#000000\",\n    },\n    bodyScanning: {\n        inspectionMode: \"deep\",\n    },\n    antivirus: {\n        enabledDownloadPhase: true,\n        enabledUploadPhase: false,\n        failClosed: true,\n        notificationSettings: {\n            enabled: true,\n            message: \"you are blocked\",\n            supportUrl: \"https://example.com/blocked\",\n        },\n    },\n    fips: {\n        tls: true,\n    },\n    proxy: {\n        tcp: true,\n        udp: true,\n        rootCa: true,\n        virtualIp: false,\n        disableForTime: 3600,\n    },\n    urlBrowserIsolationEnabled: true,\n    logging: {\n        redactPii: true,\n        settingsByRuleType: {\n            dns: {\n                logAll: false,\n                logBlocks: true,\n            },\n            http: {\n                logAll: true,\n                logBlocks: true,\n            },\n            l4: {\n                logAll: false,\n                logBlocks: true,\n            },\n        },\n    },\n    extendedEmailMatching: {\n        enabled: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TeamsAccount(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tls_decrypt_enabled=True,\n    protocol_detection_enabled=True,\n    block_page={\n        \"footer_text\": \"hello\",\n        \"header_text\": \"hello\",\n        \"logo_path\": \"https://example.com/logo.jpg\",\n        \"background_color\": \"#000000\",\n    },\n    body_scanning={\n        \"inspection_mode\": \"deep\",\n    },\n    antivirus={\n        \"enabled_download_phase\": True,\n        \"enabled_upload_phase\": False,\n        \"fail_closed\": True,\n        \"notification_settings\": {\n            \"enabled\": True,\n            \"message\": \"you are blocked\",\n            \"support_url\": \"https://example.com/blocked\",\n        },\n    },\n    fips={\n        \"tls\": True,\n    },\n    proxy={\n        \"tcp\": True,\n        \"udp\": True,\n        \"root_ca\": True,\n        \"virtual_ip\": False,\n        \"disable_for_time\": 3600,\n    },\n    url_browser_isolation_enabled=True,\n    logging={\n        \"redact_pii\": True,\n        \"settings_by_rule_type\": {\n            \"dns\": {\n                \"log_all\": False,\n                \"log_blocks\": True,\n            },\n            \"http\": {\n                \"log_all\": True,\n                \"log_blocks\": True,\n            },\n            \"l4\": {\n                \"log_all\": False,\n                \"log_blocks\": True,\n            },\n        },\n    },\n    extended_email_matching={\n        \"enabled\": True,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TeamsAccount(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TlsDecryptEnabled = true,\n        ProtocolDetectionEnabled = true,\n        BlockPage = new Cloudflare.Inputs.TeamsAccountBlockPageArgs\n        {\n            FooterText = \"hello\",\n            HeaderText = \"hello\",\n            LogoPath = \"https://example.com/logo.jpg\",\n            BackgroundColor = \"#000000\",\n        },\n        BodyScanning = new Cloudflare.Inputs.TeamsAccountBodyScanningArgs\n        {\n            InspectionMode = \"deep\",\n        },\n        Antivirus = new Cloudflare.Inputs.TeamsAccountAntivirusArgs\n        {\n            EnabledDownloadPhase = true,\n            EnabledUploadPhase = false,\n            FailClosed = true,\n            NotificationSettings = new Cloudflare.Inputs.TeamsAccountAntivirusNotificationSettingsArgs\n            {\n                Enabled = true,\n                Message = \"you are blocked\",\n                SupportUrl = \"https://example.com/blocked\",\n            },\n        },\n        Fips = new Cloudflare.Inputs.TeamsAccountFipsArgs\n        {\n            Tls = true,\n        },\n        Proxy = new Cloudflare.Inputs.TeamsAccountProxyArgs\n        {\n            Tcp = true,\n            Udp = true,\n            RootCa = true,\n            VirtualIp = false,\n            DisableForTime = 3600,\n        },\n        UrlBrowserIsolationEnabled = true,\n        Logging = new Cloudflare.Inputs.TeamsAccountLoggingArgs\n        {\n            RedactPii = true,\n            SettingsByRuleType = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeArgs\n            {\n                Dns = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeDnsArgs\n                {\n                    LogAll = false,\n                    LogBlocks = true,\n                },\n                Http = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeHttpArgs\n                {\n                    LogAll = true,\n                    LogBlocks = true,\n                },\n                L4 = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeL4Args\n                {\n                    LogAll = false,\n                    LogBlocks = true,\n                },\n            },\n        },\n        ExtendedEmailMatching = new Cloudflare.Inputs.TeamsAccountExtendedEmailMatchingArgs\n        {\n            Enabled = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsAccount(ctx, \"example\", \u0026cloudflare.TeamsAccountArgs{\n\t\t\tAccountId:                pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTlsDecryptEnabled:        pulumi.Bool(true),\n\t\t\tProtocolDetectionEnabled: pulumi.Bool(true),\n\t\t\tBlockPage: \u0026cloudflare.TeamsAccountBlockPageArgs{\n\t\t\t\tFooterText:      pulumi.String(\"hello\"),\n\t\t\t\tHeaderText:      pulumi.String(\"hello\"),\n\t\t\t\tLogoPath:        pulumi.String(\"https://example.com/logo.jpg\"),\n\t\t\t\tBackgroundColor: pulumi.String(\"#000000\"),\n\t\t\t},\n\t\t\tBodyScanning: \u0026cloudflare.TeamsAccountBodyScanningArgs{\n\t\t\t\tInspectionMode: pulumi.String(\"deep\"),\n\t\t\t},\n\t\t\tAntivirus: \u0026cloudflare.TeamsAccountAntivirusArgs{\n\t\t\t\tEnabledDownloadPhase: pulumi.Bool(true),\n\t\t\t\tEnabledUploadPhase:   pulumi.Bool(false),\n\t\t\t\tFailClosed:           pulumi.Bool(true),\n\t\t\t\tNotificationSettings: \u0026cloudflare.TeamsAccountAntivirusNotificationSettingsArgs{\n\t\t\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\t\t\tMessage:    pulumi.String(\"you are blocked\"),\n\t\t\t\t\tSupportUrl: pulumi.String(\"https://example.com/blocked\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tFips: \u0026cloudflare.TeamsAccountFipsArgs{\n\t\t\t\tTls: pulumi.Bool(true),\n\t\t\t},\n\t\t\tProxy: \u0026cloudflare.TeamsAccountProxyArgs{\n\t\t\t\tTcp:            pulumi.Bool(true),\n\t\t\t\tUdp:            pulumi.Bool(true),\n\t\t\t\tRootCa:         pulumi.Bool(true),\n\t\t\t\tVirtualIp:      pulumi.Bool(false),\n\t\t\t\tDisableForTime: pulumi.Int(3600),\n\t\t\t},\n\t\t\tUrlBrowserIsolationEnabled: pulumi.Bool(true),\n\t\t\tLogging: \u0026cloudflare.TeamsAccountLoggingArgs{\n\t\t\t\tRedactPii: pulumi.Bool(true),\n\t\t\t\tSettingsByRuleType: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeArgs{\n\t\t\t\t\tDns: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeDnsArgs{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(false),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tHttp: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeHttpArgs{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(true),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tL4: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeL4Args{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(false),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tExtendedEmailMatching: \u0026cloudflare.TeamsAccountExtendedEmailMatchingArgs{\n\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsAccount;\nimport com.pulumi.cloudflare.TeamsAccountArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountBlockPageArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountBodyScanningArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountAntivirusArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountAntivirusNotificationSettingsArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountFipsArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountProxyArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeDnsArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeHttpArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeL4Args;\nimport com.pulumi.cloudflare.inputs.TeamsAccountExtendedEmailMatchingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TeamsAccount(\"example\", TeamsAccountArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tlsDecryptEnabled(true)\n            .protocolDetectionEnabled(true)\n            .blockPage(TeamsAccountBlockPageArgs.builder()\n                .footerText(\"hello\")\n                .headerText(\"hello\")\n                .logoPath(\"https://example.com/logo.jpg\")\n                .backgroundColor(\"#000000\")\n                .build())\n            .bodyScanning(TeamsAccountBodyScanningArgs.builder()\n                .inspectionMode(\"deep\")\n                .build())\n            .antivirus(TeamsAccountAntivirusArgs.builder()\n                .enabledDownloadPhase(true)\n                .enabledUploadPhase(false)\n                .failClosed(true)\n                .notificationSettings(TeamsAccountAntivirusNotificationSettingsArgs.builder()\n                    .enabled(true)\n                    .message(\"you are blocked\")\n                    .supportUrl(\"https://example.com/blocked\")\n                    .build())\n                .build())\n            .fips(TeamsAccountFipsArgs.builder()\n                .tls(true)\n                .build())\n            .proxy(TeamsAccountProxyArgs.builder()\n                .tcp(true)\n                .udp(true)\n                .rootCa(true)\n                .virtualIp(false)\n                .disableForTime(3600)\n                .build())\n            .urlBrowserIsolationEnabled(true)\n            .logging(TeamsAccountLoggingArgs.builder()\n                .redactPii(true)\n                .settingsByRuleType(TeamsAccountLoggingSettingsByRuleTypeArgs.builder()\n                    .dns(TeamsAccountLoggingSettingsByRuleTypeDnsArgs.builder()\n                        .logAll(false)\n                        .logBlocks(true)\n                        .build())\n                    .http(TeamsAccountLoggingSettingsByRuleTypeHttpArgs.builder()\n                        .logAll(true)\n                        .logBlocks(true)\n                        .build())\n                    .l4(TeamsAccountLoggingSettingsByRuleTypeL4Args.builder()\n                        .logAll(false)\n                        .logBlocks(true)\n                        .build())\n                    .build())\n                .build())\n            .extendedEmailMatching(TeamsAccountExtendedEmailMatchingArgs.builder()\n                .enabled(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TeamsAccount\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tlsDecryptEnabled: true\n      protocolDetectionEnabled: true\n      blockPage:\n        footerText: hello\n        headerText: hello\n        logoPath: https://example.com/logo.jpg\n        backgroundColor: '#000000'\n      bodyScanning:\n        inspectionMode: deep\n      antivirus:\n        enabledDownloadPhase: true\n        enabledUploadPhase: false\n        failClosed: true\n        notificationSettings:\n          enabled: true\n          message: you are blocked\n          supportUrl: https://example.com/blocked\n      fips:\n        tls: true\n      proxy:\n        tcp: true\n        udp: true\n        rootCa: true\n        virtualIp: false\n        disableForTime: 3600\n      urlBrowserIsolationEnabled: true\n      logging:\n        redactPii: true\n        settingsByRuleType:\n          dns:\n            logAll: false\n            logBlocks: true\n          http:\n            logAll: true\n            logBlocks: true\n          l4:\n            logAll: false\n            logBlocks: true\n      extendedEmailMatching:\n        enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/teamsAccount:TeamsAccount example \u003caccount_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean",
                    "description": "Whether to enable the activity log.\n"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                    "description": "Configuration block for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "bodyScanning": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBodyScanning:TeamsAccountBodyScanning",
                    "description": "Configuration for body scanning.\n"
                },
                "certificate": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountCertificate:TeamsAccountCertificate",
                    "description": "Configuration for TLS interception certificate. This will be required starting Feb 2025.\n"
                },
                "customCertificate": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountCustomCertificate:TeamsAccountCustomCertificate",
                    "description": "Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.\n",
                    "deprecationMessage": "Use `certificate` instead. Continuing to use custom_certificate may result in inconsistent configuration."
                },
                "extendedEmailMatching": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountExtendedEmailMatching:TeamsAccountExtendedEmailMatching",
                    "description": "Configuration for extended e-mail matching.\n"
                },
                "fips": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountFips:TeamsAccountFips",
                    "description": "Configure compliance with Federal Information Processing Standards.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLogging:TeamsAccountLogging"
                },
                "nonIdentityBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Enable non-identity onramp for Browser Isolation. Defaults to `false`.\n"
                },
                "payloadLog": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountPayloadLog:TeamsAccountPayloadLog",
                    "description": "Configuration for DLP Payload Logging.\n"
                },
                "protocolDetectionEnabled": {
                    "type": "boolean",
                    "description": "Indicator that protocol detection is enabled.\n"
                },
                "proxy": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountProxy:TeamsAccountProxy",
                    "description": "Configuration block for specifying which protocols are proxied.\n"
                },
                "sshSessionLog": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountSshSessionLog:TeamsAccountSshSessionLog",
                    "description": "Configuration for SSH Session Logging.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                },
                "urlBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Safely browse websites in Browser Isolation through a URL. Defaults to `false`.\n"
                }
            },
            "required": [
                "accountId",
                "extendedEmailMatching"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean",
                    "description": "Whether to enable the activity log.\n"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                    "description": "Configuration block for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "bodyScanning": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBodyScanning:TeamsAccountBodyScanning",
                    "description": "Configuration for body scanning.\n"
                },
                "certificate": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountCertificate:TeamsAccountCertificate",
                    "description": "Configuration for TLS interception certificate. This will be required starting Feb 2025.\n"
                },
                "customCertificate": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountCustomCertificate:TeamsAccountCustomCertificate",
                    "description": "Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.\n",
                    "deprecationMessage": "Use `certificate` instead. Continuing to use custom_certificate may result in inconsistent configuration."
                },
                "extendedEmailMatching": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountExtendedEmailMatching:TeamsAccountExtendedEmailMatching",
                    "description": "Configuration for extended e-mail matching.\n"
                },
                "fips": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountFips:TeamsAccountFips",
                    "description": "Configure compliance with Federal Information Processing Standards.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLogging:TeamsAccountLogging"
                },
                "nonIdentityBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Enable non-identity onramp for Browser Isolation. Defaults to `false`.\n"
                },
                "payloadLog": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountPayloadLog:TeamsAccountPayloadLog",
                    "description": "Configuration for DLP Payload Logging.\n"
                },
                "protocolDetectionEnabled": {
                    "type": "boolean",
                    "description": "Indicator that protocol detection is enabled.\n"
                },
                "proxy": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountProxy:TeamsAccountProxy",
                    "description": "Configuration block for specifying which protocols are proxied.\n"
                },
                "sshSessionLog": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountSshSessionLog:TeamsAccountSshSessionLog",
                    "description": "Configuration for SSH Session Logging.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                },
                "urlBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Safely browse websites in Browser Isolation through a URL. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsAccount resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "activityLogEnabled": {
                        "type": "boolean",
                        "description": "Whether to enable the activity log.\n"
                    },
                    "antivirus": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                        "description": "Configuration block for antivirus traffic scanning.\n"
                    },
                    "blockPage": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                        "description": "Configuration for a custom block page.\n"
                    },
                    "bodyScanning": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountBodyScanning:TeamsAccountBodyScanning",
                        "description": "Configuration for body scanning.\n"
                    },
                    "certificate": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountCertificate:TeamsAccountCertificate",
                        "description": "Configuration for TLS interception certificate. This will be required starting Feb 2025.\n"
                    },
                    "customCertificate": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountCustomCertificate:TeamsAccountCustomCertificate",
                        "description": "Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.\n",
                        "deprecationMessage": "Use `certificate` instead. Continuing to use custom_certificate may result in inconsistent configuration."
                    },
                    "extendedEmailMatching": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountExtendedEmailMatching:TeamsAccountExtendedEmailMatching",
                        "description": "Configuration for extended e-mail matching.\n"
                    },
                    "fips": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountFips:TeamsAccountFips",
                        "description": "Configure compliance with Federal Information Processing Standards.\n"
                    },
                    "logging": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountLogging:TeamsAccountLogging"
                    },
                    "nonIdentityBrowserIsolationEnabled": {
                        "type": "boolean",
                        "description": "Enable non-identity onramp for Browser Isolation. Defaults to `false`.\n"
                    },
                    "payloadLog": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountPayloadLog:TeamsAccountPayloadLog",
                        "description": "Configuration for DLP Payload Logging.\n"
                    },
                    "protocolDetectionEnabled": {
                        "type": "boolean",
                        "description": "Indicator that protocol detection is enabled.\n"
                    },
                    "proxy": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountProxy:TeamsAccountProxy",
                        "description": "Configuration block for specifying which protocols are proxied.\n"
                    },
                    "sshSessionLog": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountSshSessionLog:TeamsAccountSshSessionLog",
                        "description": "Configuration for SSH Session Logging.\n"
                    },
                    "tlsDecryptEnabled": {
                        "type": "boolean",
                        "description": "Indicator that decryption of TLS traffic is enabled.\n"
                    },
                    "urlBrowserIsolationEnabled": {
                        "type": "boolean",
                        "description": "Safely browse websites in Browser Isolation through a URL. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsList:TeamsList": {
            "description": "Provides a Cloudflare Teams List resource. Teams lists are\nreferenced when creating secure web gateway policies or device\nposture rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TeamsList(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Corporate devices\",\n    type: \"SERIAL\",\n    description: \"Serial numbers for all corporate devices.\",\n    items: [\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TeamsList(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Corporate devices\",\n    type=\"SERIAL\",\n    description=\"Serial numbers for all corporate devices.\",\n    items=[\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TeamsList(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Corporate devices\",\n        Type = \"SERIAL\",\n        Description = \"Serial numbers for all corporate devices.\",\n        Items = new[]\n        {\n            \"8GE8721REF\",\n            \"5RE8543EGG\",\n            \"1YE2880LNP\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsList(ctx, \"example\", \u0026cloudflare.TeamsListArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"Corporate devices\"),\n\t\t\tType:        pulumi.String(\"SERIAL\"),\n\t\t\tDescription: pulumi.String(\"Serial numbers for all corporate devices.\"),\n\t\t\tItems: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"8GE8721REF\"),\n\t\t\t\tpulumi.String(\"5RE8543EGG\"),\n\t\t\t\tpulumi.String(\"1YE2880LNP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsList;\nimport com.pulumi.cloudflare.TeamsListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TeamsList(\"example\", TeamsListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Corporate devices\")\n            .type(\"SERIAL\")\n            .description(\"Serial numbers for all corporate devices.\")\n            .items(            \n                \"8GE8721REF\",\n                \"5RE8543EGG\",\n                \"1YE2880LNP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TeamsList\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Corporate devices\n      type: SERIAL\n      description: Serial numbers for all corporate devices.\n      items:\n        - 8GE8721REF\n        - 5RE8543EGG\n        - 1YE2880LNP\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/teamsList:TeamsList example \u003caccount_id\u003e/\u003cteams_list_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "itemsWithDescriptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsListItemsWithDescription:TeamsListItemsWithDescription"
                    },
                    "description": "The items of the teams list that has explicit description.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "itemsWithDescriptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsListItemsWithDescription:TeamsListItemsWithDescription"
                    },
                    "description": "The items of the teams list that has explicit description.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsList resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams list.\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The items of the teams list.\n"
                    },
                    "itemsWithDescriptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/TeamsListItemsWithDescription:TeamsListItemsWithDescription"
                        },
                        "description": "The items of the teams list that has explicit description.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams list.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsLocation:TeamsLocation": {
            "description": "Provides a Cloudflare Teams Location resource. Teams Locations are\nreferenced when creating secure web gateway policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TeamsLocation(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"office\",\n    clientDefault: true,\n    ecsSupport: false,\n    networks: [\n        {\n            network: \"203.0.113.1/32\",\n        },\n        {\n            network: \"203.0.113.2/32\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TeamsLocation(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"office\",\n    client_default=True,\n    ecs_support=False,\n    networks=[\n        {\n            \"network\": \"203.0.113.1/32\",\n        },\n        {\n            \"network\": \"203.0.113.2/32\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TeamsLocation(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"office\",\n        ClientDefault = true,\n        EcsSupport = false,\n        Networks = new[]\n        {\n            new Cloudflare.Inputs.TeamsLocationNetworkArgs\n            {\n                Network = \"203.0.113.1/32\",\n            },\n            new Cloudflare.Inputs.TeamsLocationNetworkArgs\n            {\n                Network = \"203.0.113.2/32\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsLocation(ctx, \"example\", \u0026cloudflare.TeamsLocationArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:          pulumi.String(\"office\"),\n\t\t\tClientDefault: pulumi.Bool(true),\n\t\t\tEcsSupport:    pulumi.Bool(false),\n\t\t\tNetworks: cloudflare.TeamsLocationNetworkArray{\n\t\t\t\t\u0026cloudflare.TeamsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.1/32\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.TeamsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.2/32\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsLocation;\nimport com.pulumi.cloudflare.TeamsLocationArgs;\nimport com.pulumi.cloudflare.inputs.TeamsLocationNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TeamsLocation(\"example\", TeamsLocationArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"office\")\n            .clientDefault(true)\n            .ecsSupport(false)\n            .networks(            \n                TeamsLocationNetworkArgs.builder()\n                    .network(\"203.0.113.1/32\")\n                    .build(),\n                TeamsLocationNetworkArgs.builder()\n                    .network(\"203.0.113.2/32\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TeamsLocation\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: office\n      clientDefault: true\n      ecsSupport: false\n      networks:\n        - network: 203.0.113.1/32\n        - network: 203.0.113.2/32\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/teamsLocation:TeamsLocation example \u003caccount_id\u003e/\u003cteams_location_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "anonymizedLogsEnabled": {
                    "type": "boolean",
                    "description": "Indicator that anonymized logs are enabled.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "dohSubdomain": {
                    "type": "string",
                    "description": "The FQDN that DoH clients should be pointed at.\n"
                },
                "ecsSupport": {
                    "type": "boolean",
                    "description": "Indicator that this location needs to resolve EDNS queries.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Client IP address.\n"
                },
                "ipv4Destination": {
                    "type": "string",
                    "description": "IP to direct all IPv4 DNS queries to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                },
                "policyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "accountId",
                "anonymizedLogsEnabled",
                "dohSubdomain",
                "ip",
                "ipv4Destination",
                "name",
                "policyIds"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "ecsSupport": {
                    "type": "boolean",
                    "description": "Indicator that this location needs to resolve EDNS queries.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsLocation resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "anonymizedLogsEnabled": {
                        "type": "boolean",
                        "description": "Indicator that anonymized logs are enabled.\n"
                    },
                    "clientDefault": {
                        "type": "boolean",
                        "description": "Indicator that this is the default location.\n"
                    },
                    "dohSubdomain": {
                        "type": "string",
                        "description": "The FQDN that DoH clients should be pointed at.\n"
                    },
                    "ecsSupport": {
                        "type": "boolean",
                        "description": "Indicator that this location needs to resolve EDNS queries.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "Client IP address.\n"
                    },
                    "ipv4Destination": {
                        "type": "string",
                        "description": "IP to direct all IPv4 DNS queries to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams location.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                        },
                        "description": "The networks CIDRs that comprise the location.\n"
                    },
                    "policyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint": {
            "description": "Provides a Cloudflare Teams Proxy Endpoint resource. Teams Proxy\nEndpoints are used for pointing proxy clients at Cloudflare Secure\nGateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TeamsProxyEndpoint(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"office\",\n    ips: [\"192.0.2.0/24\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TeamsProxyEndpoint(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"office\",\n    ips=[\"192.0.2.0/24\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TeamsProxyEndpoint(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"office\",\n        Ips = new[]\n        {\n            \"192.0.2.0/24\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsProxyEndpoint(ctx, \"example\", \u0026cloudflare.TeamsProxyEndpointArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"office\"),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.0.2.0/24\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsProxyEndpoint;\nimport com.pulumi.cloudflare.TeamsProxyEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TeamsProxyEndpoint(\"example\", TeamsProxyEndpointArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"office\")\n            .ips(\"192.0.2.0/24\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TeamsProxyEndpoint\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: office\n      ips:\n        - 192.0.2.0/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint example \u003caccount_id\u003e/\u003cproxy_endpoint_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams proxy endpoint.\n"
                },
                "subdomain": {
                    "type": "string",
                    "description": "The FQDN that proxy clients should be pointed at.\n"
                }
            },
            "required": [
                "accountId",
                "ips",
                "name",
                "subdomain"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams proxy endpoint.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "ips",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsProxyEndpoint resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams proxy endpoint.\n"
                    },
                    "subdomain": {
                        "type": "string",
                        "description": "The FQDN that proxy clients should be pointed at.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsRule:TeamsRule": {
            "description": "Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TeamsRule(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"office\",\n    description: \"desc\",\n    precedence: 1,\n    action: \"block\",\n    filters: [\"http\"],\n    traffic: \"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n    ruleSettings: {\n        blockPageEnabled: true,\n        blockPageReason: \"access not permitted\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TeamsRule(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"office\",\n    description=\"desc\",\n    precedence=1,\n    action=\"block\",\n    filters=[\"http\"],\n    traffic=\"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n    rule_settings={\n        \"block_page_enabled\": True,\n        \"block_page_reason\": \"access not permitted\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TeamsRule(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"office\",\n        Description = \"desc\",\n        Precedence = 1,\n        Action = \"block\",\n        Filters = new[]\n        {\n            \"http\",\n        },\n        Traffic = \"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n        RuleSettings = new Cloudflare.Inputs.TeamsRuleRuleSettingsArgs\n        {\n            BlockPageEnabled = true,\n            BlockPageReason = \"access not permitted\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsRule(ctx, \"example\", \u0026cloudflare.TeamsRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"office\"),\n\t\t\tDescription: pulumi.String(\"desc\"),\n\t\t\tPrecedence:  pulumi.Int(1),\n\t\t\tAction:      pulumi.String(\"block\"),\n\t\t\tFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http\"),\n\t\t\t},\n\t\t\tTraffic: pulumi.String(\"http.request.uri == \\\"https://www.example.com/malicious\\\"\"),\n\t\t\tRuleSettings: \u0026cloudflare.TeamsRuleRuleSettingsArgs{\n\t\t\t\tBlockPageEnabled: pulumi.Bool(true),\n\t\t\t\tBlockPageReason:  pulumi.String(\"access not permitted\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsRule;\nimport com.pulumi.cloudflare.TeamsRuleArgs;\nimport com.pulumi.cloudflare.inputs.TeamsRuleRuleSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TeamsRule(\"example\", TeamsRuleArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"office\")\n            .description(\"desc\")\n            .precedence(1)\n            .action(\"block\")\n            .filters(\"http\")\n            .traffic(\"http.request.uri == \\\"https://www.example.com/malicious\\\"\")\n            .ruleSettings(TeamsRuleRuleSettingsArgs.builder()\n                .blockPageEnabled(true)\n                .blockPageReason(\"access not permitted\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TeamsRule\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: office\n      description: desc\n      precedence: 1\n      action: block\n      filters:\n        - http\n      traffic: http.request.uri == \"https://www.example.com/malicious\"\n      ruleSettings:\n        blockPageEnabled: true\n        blockPageReason: access not permitted\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/teamsRule:TeamsRule example \u003caccount_id\u003e/\u003cteams_rule_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                    "description": "Additional rule settings.\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                },
                "version": {
                    "type": "integer"
                }
            },
            "required": [
                "accountId",
                "action",
                "description",
                "devicePosture",
                "identity",
                "name",
                "precedence",
                "ruleSettings",
                "traffic",
                "version"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                    "description": "Additional rule settings.\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "action",
                "description",
                "name",
                "precedence"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams rule.\n"
                    },
                    "devicePosture": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for device_posture check matching.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicator of rule enablement.\n"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for identity matching.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the teams rule.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The evaluation precedence of the teams rule.\n"
                    },
                    "ruleSettings": {
                        "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                        "description": "Additional rule settings.\n"
                    },
                    "traffic": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for traffic matching.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tieredCache:TieredCache": {
            "description": "Provides a resource, that manages Cloudflare Tiered Cache settings.\nThis allows you to adjust topologies for your zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TieredCache(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    cacheType: \"smart\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TieredCache(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    cache_type=\"smart\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TieredCache(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        CacheType = \"smart\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTieredCache(ctx, \"example\", \u0026cloudflare.TieredCacheArgs{\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tCacheType: pulumi.String(\"smart\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TieredCache;\nimport com.pulumi.cloudflare.TieredCacheArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TieredCache(\"example\", TieredCacheArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .cacheType(\"smart\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TieredCache\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      cacheType: smart\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cacheType": {
                    "type": "string",
                    "description": "The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "cacheType",
                "zoneId"
            ],
            "inputProperties": {
                "cacheType": {
                    "type": "string",
                    "description": "The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "cacheType",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TieredCache resources.\n",
                "properties": {
                    "cacheType": {
                        "type": "string",
                        "description": "The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/totalTls:TotalTls": {
            "description": "Provides a resource which manages Total TLS for a zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TotalTls(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n    certificateAuthority: \"lets_encrypt\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TotalTls(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True,\n    certificate_authority=\"lets_encrypt\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TotalTls(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n        CertificateAuthority = \"lets_encrypt\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTotalTls(ctx, \"example\", \u0026cloudflare.TotalTlsArgs{\n\t\t\tZoneId:               pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled:              pulumi.Bool(true),\n\t\t\tCertificateAuthority: pulumi.String(\"lets_encrypt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TotalTls;\nimport com.pulumi.cloudflare.TotalTlsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TotalTls(\"example\", TotalTlsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(true)\n            .certificateAuthority(\"lets_encrypt\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TotalTls\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: true\n      certificateAuthority: lets_encrypt\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/totalTls:TotalTls example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable Total TLS for the zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable Total TLS for the zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TotalTls resources.\n",
                "properties": {
                    "certificateAuthority": {
                        "type": "string",
                        "description": "The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable Total TLS for the zone.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnel:Tunnel": {
            "description": "Tunnel exposes applications running on your local web server on any\nnetwork with an internet connection without manually adding DNS\nrecords or configuring a firewall or router.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Tunnel(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"my-tunnel\",\n    secret: \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Tunnel(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"my-tunnel\",\n    secret=\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Tunnel(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"my-tunnel\",\n        Secret = \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTunnel(ctx, \"example\", \u0026cloudflare.TunnelArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"my-tunnel\"),\n\t\t\tSecret:    pulumi.String(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Tunnel;\nimport com.pulumi.cloudflare.TunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Tunnel(\"example\", TunnelArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"my-tunnel\")\n            .secret(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Tunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: my-tunnel\n      secret: AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/tunnel:Tunnel example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Usable CNAME for accessing the Tunnel.\n"
                },
                "configSrc": {
                    "type": "string",
                    "description": "Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                },
                "tunnelToken": {
                    "type": "string",
                    "description": "Token used by a connector to authenticate and run the tunnel.\n",
                    "secret": true
                }
            },
            "required": [
                "accountId",
                "cname",
                "name",
                "secret",
                "tunnelToken"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configSrc": {
                    "type": "string",
                    "description": "Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "secret"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "cname": {
                        "type": "string",
                        "description": "Usable CNAME for accessing the Tunnel.\n"
                    },
                    "configSrc": {
                        "type": "string",
                        "description": "Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "secret": {
                        "type": "string",
                        "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "tunnelToken": {
                        "type": "string",
                        "description": "Token used by a connector to authenticate and run the tunnel.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnelConfig:TunnelConfig": {
            "description": "Provides a Cloudflare Tunnel configuration resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleTunnel = new cloudflare.ZeroTrustTunnelCloudflared(\"example_tunnel\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_tunnel\",\n    secret: \"\u003c32 character secret\u003e\",\n});\nconst exampleConfig = new cloudflare.TunnelConfig(\"example_config\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tunnelId: exampleTunnel.id,\n    config: {\n        warpRouting: {\n            enabled: true,\n        },\n        originRequest: {\n            connectTimeout: \"1m0s\",\n            tlsTimeout: \"1m0s\",\n            tcpKeepAlive: \"1m0s\",\n            noHappyEyeballs: false,\n            keepAliveConnections: 1024,\n            keepAliveTimeout: \"1m0s\",\n            httpHostHeader: \"baz\",\n            originServerName: \"foobar\",\n            caPool: \"/path/to/unsigned/ca/pool\",\n            noTlsVerify: false,\n            disableChunkedEncoding: false,\n            bastionMode: false,\n            proxyAddress: \"10.0.0.1\",\n            proxyPort: 8123,\n            proxyType: \"socks\",\n            ipRules: [{\n                prefix: \"/web\",\n                ports: [\n                    80,\n                    443,\n                ],\n                allow: false,\n            }],\n        },\n        ingressRules: [\n            {\n                hostname: \"foo\",\n                path: \"/bar\",\n                service: \"http://10.0.0.2:8080\",\n                originRequest: {\n                    connectTimeout: \"2m0s\",\n                    access: {\n                        required: true,\n                        teamName: \"terraform\",\n                        audTags: [\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"],\n                    },\n                },\n            },\n            {\n                service: \"https://10.0.0.3:8081\",\n            },\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_tunnel = cloudflare.ZeroTrustTunnelCloudflared(\"example_tunnel\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_tunnel\",\n    secret=\"\u003c32 character secret\u003e\")\nexample_config = cloudflare.TunnelConfig(\"example_config\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tunnel_id=example_tunnel.id,\n    config={\n        \"warp_routing\": {\n            \"enabled\": True,\n        },\n        \"origin_request\": {\n            \"connect_timeout\": \"1m0s\",\n            \"tls_timeout\": \"1m0s\",\n            \"tcp_keep_alive\": \"1m0s\",\n            \"no_happy_eyeballs\": False,\n            \"keep_alive_connections\": 1024,\n            \"keep_alive_timeout\": \"1m0s\",\n            \"http_host_header\": \"baz\",\n            \"origin_server_name\": \"foobar\",\n            \"ca_pool\": \"/path/to/unsigned/ca/pool\",\n            \"no_tls_verify\": False,\n            \"disable_chunked_encoding\": False,\n            \"bastion_mode\": False,\n            \"proxy_address\": \"10.0.0.1\",\n            \"proxy_port\": 8123,\n            \"proxy_type\": \"socks\",\n            \"ip_rules\": [{\n                \"prefix\": \"/web\",\n                \"ports\": [\n                    80,\n                    443,\n                ],\n                \"allow\": False,\n            }],\n        },\n        \"ingress_rules\": [\n            {\n                \"hostname\": \"foo\",\n                \"path\": \"/bar\",\n                \"service\": \"http://10.0.0.2:8080\",\n                \"origin_request\": {\n                    \"connect_timeout\": \"2m0s\",\n                    \"access\": {\n                        \"required\": True,\n                        \"team_name\": \"terraform\",\n                        \"aud_tags\": [\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"],\n                    },\n                },\n            },\n            {\n                \"service\": \"https://10.0.0.3:8081\",\n            },\n        ],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleTunnel = new Cloudflare.ZeroTrustTunnelCloudflared(\"example_tunnel\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_tunnel\",\n        Secret = \"\u003c32 character secret\u003e\",\n    });\n\n    var exampleConfig = new Cloudflare.TunnelConfig(\"example_config\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TunnelId = exampleTunnel.Id,\n        Config = new Cloudflare.Inputs.TunnelConfigConfigArgs\n        {\n            WarpRouting = new Cloudflare.Inputs.TunnelConfigConfigWarpRoutingArgs\n            {\n                Enabled = true,\n            },\n            OriginRequest = new Cloudflare.Inputs.TunnelConfigConfigOriginRequestArgs\n            {\n                ConnectTimeout = \"1m0s\",\n                TlsTimeout = \"1m0s\",\n                TcpKeepAlive = \"1m0s\",\n                NoHappyEyeballs = false,\n                KeepAliveConnections = 1024,\n                KeepAliveTimeout = \"1m0s\",\n                HttpHostHeader = \"baz\",\n                OriginServerName = \"foobar\",\n                CaPool = \"/path/to/unsigned/ca/pool\",\n                NoTlsVerify = false,\n                DisableChunkedEncoding = false,\n                BastionMode = false,\n                ProxyAddress = \"10.0.0.1\",\n                ProxyPort = 8123,\n                ProxyType = \"socks\",\n                IpRules = new[]\n                {\n                    new Cloudflare.Inputs.TunnelConfigConfigOriginRequestIpRuleArgs\n                    {\n                        Prefix = \"/web\",\n                        Ports = new[]\n                        {\n                            80,\n                            443,\n                        },\n                        Allow = false,\n                    },\n                },\n            },\n            IngressRules = new[]\n            {\n                new Cloudflare.Inputs.TunnelConfigConfigIngressRuleArgs\n                {\n                    Hostname = \"foo\",\n                    Path = \"/bar\",\n                    Service = \"http://10.0.0.2:8080\",\n                    OriginRequest = new Cloudflare.Inputs.TunnelConfigConfigIngressRuleOriginRequestArgs\n                    {\n                        ConnectTimeout = \"2m0s\",\n                        Access = new Cloudflare.Inputs.TunnelConfigConfigIngressRuleOriginRequestAccessArgs\n                        {\n                            Required = true,\n                            TeamName = \"terraform\",\n                            AudTags = new[]\n                            {\n                                \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n                            },\n                        },\n                    },\n                },\n                new Cloudflare.Inputs.TunnelConfigConfigIngressRuleArgs\n                {\n                    Service = \"https://10.0.0.3:8081\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleTunnel, err := cloudflare.NewZeroTrustTunnelCloudflared(ctx, \"example_tunnel\", \u0026cloudflare.ZeroTrustTunnelCloudflaredArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example_tunnel\"),\n\t\t\tSecret:    pulumi.String(\"\u003c32 character secret\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewTunnelConfig(ctx, \"example_config\", \u0026cloudflare.TunnelConfigArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTunnelId:  exampleTunnel.ID(),\n\t\t\tConfig: \u0026cloudflare.TunnelConfigConfigArgs{\n\t\t\t\tWarpRouting: \u0026cloudflare.TunnelConfigConfigWarpRoutingArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\tOriginRequest: \u0026cloudflare.TunnelConfigConfigOriginRequestArgs{\n\t\t\t\t\tConnectTimeout:         pulumi.String(\"1m0s\"),\n\t\t\t\t\tTlsTimeout:             pulumi.String(\"1m0s\"),\n\t\t\t\t\tTcpKeepAlive:           pulumi.String(\"1m0s\"),\n\t\t\t\t\tNoHappyEyeballs:        pulumi.Bool(false),\n\t\t\t\t\tKeepAliveConnections:   pulumi.Int(1024),\n\t\t\t\t\tKeepAliveTimeout:       pulumi.String(\"1m0s\"),\n\t\t\t\t\tHttpHostHeader:         pulumi.String(\"baz\"),\n\t\t\t\t\tOriginServerName:       pulumi.String(\"foobar\"),\n\t\t\t\t\tCaPool:                 pulumi.String(\"/path/to/unsigned/ca/pool\"),\n\t\t\t\t\tNoTlsVerify:            pulumi.Bool(false),\n\t\t\t\t\tDisableChunkedEncoding: pulumi.Bool(false),\n\t\t\t\t\tBastionMode:            pulumi.Bool(false),\n\t\t\t\t\tProxyAddress:           pulumi.String(\"10.0.0.1\"),\n\t\t\t\t\tProxyPort:              pulumi.Int(8123),\n\t\t\t\t\tProxyType:              pulumi.String(\"socks\"),\n\t\t\t\t\tIpRules: cloudflare.TunnelConfigConfigOriginRequestIpRuleArray{\n\t\t\t\t\t\t\u0026cloudflare.TunnelConfigConfigOriginRequestIpRuleArgs{\n\t\t\t\t\t\t\tPrefix: pulumi.String(\"/web\"),\n\t\t\t\t\t\t\tPorts: pulumi.IntArray{\n\t\t\t\t\t\t\t\tpulumi.Int(80),\n\t\t\t\t\t\t\t\tpulumi.Int(443),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAllow: pulumi.Bool(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tIngressRules: cloudflare.TunnelConfigConfigIngressRuleArray{\n\t\t\t\t\t\u0026cloudflare.TunnelConfigConfigIngressRuleArgs{\n\t\t\t\t\t\tHostname: pulumi.String(\"foo\"),\n\t\t\t\t\t\tPath:     pulumi.String(\"/bar\"),\n\t\t\t\t\t\tService:  pulumi.String(\"http://10.0.0.2:8080\"),\n\t\t\t\t\t\tOriginRequest: \u0026cloudflare.TunnelConfigConfigIngressRuleOriginRequestArgs{\n\t\t\t\t\t\t\tConnectTimeout: pulumi.String(\"2m0s\"),\n\t\t\t\t\t\t\tAccess: \u0026cloudflare.TunnelConfigConfigIngressRuleOriginRequestAccessArgs{\n\t\t\t\t\t\t\t\tRequired: pulumi.Bool(true),\n\t\t\t\t\t\t\t\tTeamName: pulumi.String(\"terraform\"),\n\t\t\t\t\t\t\t\tAudTags: pulumi.StringArray{\n\t\t\t\t\t\t\t\t\tpulumi.String(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\u0026cloudflare.TunnelConfigConfigIngressRuleArgs{\n\t\t\t\t\t\tService: pulumi.String(\"https://10.0.0.3:8081\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflared;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflaredArgs;\nimport com.pulumi.cloudflare.TunnelConfig;\nimport com.pulumi.cloudflare.TunnelConfigArgs;\nimport com.pulumi.cloudflare.inputs.TunnelConfigConfigArgs;\nimport com.pulumi.cloudflare.inputs.TunnelConfigConfigWarpRoutingArgs;\nimport com.pulumi.cloudflare.inputs.TunnelConfigConfigOriginRequestArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleTunnel = new ZeroTrustTunnelCloudflared(\"exampleTunnel\", ZeroTrustTunnelCloudflaredArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_tunnel\")\n            .secret(\"\u003c32 character secret\u003e\")\n            .build());\n\n        var exampleConfig = new TunnelConfig(\"exampleConfig\", TunnelConfigArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tunnelId(exampleTunnel.id())\n            .config(TunnelConfigConfigArgs.builder()\n                .warpRouting(TunnelConfigConfigWarpRoutingArgs.builder()\n                    .enabled(true)\n                    .build())\n                .originRequest(TunnelConfigConfigOriginRequestArgs.builder()\n                    .connectTimeout(\"1m0s\")\n                    .tlsTimeout(\"1m0s\")\n                    .tcpKeepAlive(\"1m0s\")\n                    .noHappyEyeballs(false)\n                    .keepAliveConnections(1024)\n                    .keepAliveTimeout(\"1m0s\")\n                    .httpHostHeader(\"baz\")\n                    .originServerName(\"foobar\")\n                    .caPool(\"/path/to/unsigned/ca/pool\")\n                    .noTlsVerify(false)\n                    .disableChunkedEncoding(false)\n                    .bastionMode(false)\n                    .proxyAddress(\"10.0.0.1\")\n                    .proxyPort(\"8123\")\n                    .proxyType(\"socks\")\n                    .ipRules(TunnelConfigConfigOriginRequestIpRuleArgs.builder()\n                        .prefix(\"/web\")\n                        .ports(                        \n                            80,\n                            443)\n                        .allow(false)\n                        .build())\n                    .build())\n                .ingressRules(                \n                    TunnelConfigConfigIngressRuleArgs.builder()\n                        .hostname(\"foo\")\n                        .path(\"/bar\")\n                        .service(\"http://10.0.0.2:8080\")\n                        .originRequest(TunnelConfigConfigIngressRuleOriginRequestArgs.builder()\n                            .connectTimeout(\"2m0s\")\n                            .access(TunnelConfigConfigIngressRuleOriginRequestAccessArgs.builder()\n                                .required(true)\n                                .teamName(\"terraform\")\n                                .audTags(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")\n                                .build())\n                            .build())\n                        .build(),\n                    TunnelConfigConfigIngressRuleArgs.builder()\n                        .service(\"https://10.0.0.3:8081\")\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleTunnel:\n    type: cloudflare:ZeroTrustTunnelCloudflared\n    name: example_tunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_tunnel\n      secret: \u003c32 character secret\u003e\n  exampleConfig:\n    type: cloudflare:TunnelConfig\n    name: example_config\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tunnelId: ${exampleTunnel.id}\n      config:\n        warpRouting:\n          enabled: true\n        originRequest:\n          connectTimeout: 1m0s\n          tlsTimeout: 1m0s\n          tcpKeepAlive: 1m0s\n          noHappyEyeballs: false\n          keepAliveConnections: 1024\n          keepAliveTimeout: 1m0s\n          httpHostHeader: baz\n          originServerName: foobar\n          caPool: /path/to/unsigned/ca/pool\n          noTlsVerify: false\n          disableChunkedEncoding: false\n          bastionMode: false\n          proxyAddress: 10.0.0.1\n          proxyPort: '8123'\n          proxyType: socks\n          ipRules:\n            - prefix: /web\n              ports:\n                - 80\n                - 443\n              allow: false\n        ingressRules:\n          - hostname: foo\n            path: /bar\n            service: http://10.0.0.2:8080\n            originRequest:\n              connectTimeout: 2m0s\n              access:\n                required: true\n                teamName: terraform\n                audTags:\n                  - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n          - service: https://10.0.0.3:8081\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/tunnelConfig:TunnelConfig example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfig:TunnelConfigConfig",
                    "description": "Configuration block for Tunnel Configuration.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "Identifier of the Tunnel to target for this configuration.\n"
                }
            },
            "required": [
                "accountId",
                "config",
                "tunnelId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfig:TunnelConfigConfig",
                    "description": "Configuration block for Tunnel Configuration.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "Identifier of the Tunnel to target for this configuration.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "config",
                "tunnelId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TunnelConfig resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "config": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfig:TunnelConfigConfig",
                        "description": "Configuration block for Tunnel Configuration.\n"
                    },
                    "tunnelId": {
                        "type": "string",
                        "description": "Identifier of the Tunnel to target for this configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnelRoute:TunnelRoute": {
            "description": "Provides a resource, that manages Cloudflare tunnel routes for Zero\nTrust. Tunnel routes are used to direct IP traffic through\nCloudflare Tunnels.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/tunnelRoute:TunnelRoute example \u003caccount_id\u003e/\u003cnetwork_cidr\u003e/\u003cvirtual_network_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "The ID of the tunnel that will service the tunnel route.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "network",
                "tunnelId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "The ID of the tunnel that will service the tunnel route.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "network",
                "tunnelId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TunnelRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Description of the tunnel route.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                    },
                    "tunnelId": {
                        "type": "string",
                        "description": "The ID of the tunnel that will service the tunnel route.\n"
                    },
                    "virtualNetworkId": {
                        "type": "string",
                        "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork": {
            "description": "Provides a resource, that manages Cloudflare tunnel virtual networks\nfor Zero Trust. Tunnel virtual networks are used for segregation of\nTunnel IP Routes via Virtualized Networks to handle overlapping\nprivate IPs in your origins.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TunnelVirtualNetwork(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"vnet-for-documentation\",\n    comment: \"New tunnel virtual network for documentation\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TunnelVirtualNetwork(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"vnet-for-documentation\",\n    comment=\"New tunnel virtual network for documentation\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TunnelVirtualNetwork(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"vnet-for-documentation\",\n        Comment = \"New tunnel virtual network for documentation\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTunnelVirtualNetwork(ctx, \"example\", \u0026cloudflare.TunnelVirtualNetworkArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"vnet-for-documentation\"),\n\t\t\tComment:   pulumi.String(\"New tunnel virtual network for documentation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TunnelVirtualNetwork;\nimport com.pulumi.cloudflare.TunnelVirtualNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TunnelVirtualNetwork(\"example\", TunnelVirtualNetworkArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"vnet-for-documentation\")\n            .comment(\"New tunnel virtual network for documentation\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TunnelVirtualNetwork\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: vnet-for-documentation\n      comment: New tunnel virtual network for documentation\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork example \u003caccount_id\u003e/\u003cvnet_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel virtual network.\n"
                },
                "isDefaultNetwork": {
                    "type": "boolean",
                    "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the virtual network is created.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel virtual network.\n"
                },
                "isDefaultNetwork": {
                    "type": "boolean",
                    "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the virtual network is created.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TunnelVirtualNetwork resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Description of the tunnel virtual network.\n"
                    },
                    "isDefaultNetwork": {
                        "type": "boolean",
                        "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the virtual network is created.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/turnstileWidget:TurnstileWidget": {
            "description": "The [Turnstile Widget](https://developers.cloudflare.com/turnstile/) resource allows you to manage Cloudflare Turnstile Widgets.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TurnstileWidget(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example widget\",\n    botFightMode: false,\n    domains: [\"example.com\"],\n    mode: \"invisible\",\n    region: \"world\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TurnstileWidget(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example widget\",\n    bot_fight_mode=False,\n    domains=[\"example.com\"],\n    mode=\"invisible\",\n    region=\"world\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TurnstileWidget(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example widget\",\n        BotFightMode = false,\n        Domains = new[]\n        {\n            \"example.com\",\n        },\n        Mode = \"invisible\",\n        Region = \"world\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTurnstileWidget(ctx, \"example\", \u0026cloudflare.TurnstileWidgetArgs{\n\t\t\tAccountId:    pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:         pulumi.String(\"example widget\"),\n\t\t\tBotFightMode: pulumi.Bool(false),\n\t\t\tDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t},\n\t\t\tMode:   pulumi.String(\"invisible\"),\n\t\t\tRegion: pulumi.String(\"world\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TurnstileWidget;\nimport com.pulumi.cloudflare.TurnstileWidgetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TurnstileWidget(\"example\", TurnstileWidgetArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example widget\")\n            .botFightMode(false)\n            .domains(\"example.com\")\n            .mode(\"invisible\")\n            .region(\"world\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TurnstileWidget\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example widget\n      botFightMode: false\n      domains:\n        - example.com\n      mode: invisible\n      region: world\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/turnstileWidget:TurnstileWidget example \u003caccount_id\u003e/\u003csite_key\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "botFightMode": {
                    "type": "boolean",
                    "description": "If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Domains where the widget is deployed\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Widget Mode. Available values: `non-interactive`, `invisible`, `managed`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human readable widget name.\n"
                },
                "offlabel": {
                    "type": "boolean",
                    "description": "Do not show any Cloudflare branding on the widget (Enterprise only).\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region where this widget can be used.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "Secret key for this widget.\n",
                    "secret": true
                }
            },
            "required": [
                "accountId",
                "botFightMode",
                "domains",
                "mode",
                "name",
                "offlabel",
                "region",
                "secret"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "botFightMode": {
                    "type": "boolean",
                    "description": "If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Domains where the widget is deployed\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Widget Mode. Available values: `non-interactive`, `invisible`, `managed`\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human readable widget name.\n"
                },
                "offlabel": {
                    "type": "boolean",
                    "description": "Do not show any Cloudflare branding on the widget (Enterprise only).\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region where this widget can be used.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "domains",
                "mode",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TurnstileWidget resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "botFightMode": {
                        "type": "boolean",
                        "description": "If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).\n"
                    },
                    "domains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Domains where the widget is deployed\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Widget Mode. Available values: `non-interactive`, `invisible`, `managed`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human readable widget name.\n"
                    },
                    "offlabel": {
                        "type": "boolean",
                        "description": "Do not show any Cloudflare branding on the widget (Enterprise only).\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "Region where this widget can be used.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "Secret key for this widget.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/urlNormalizationSettings:UrlNormalizationSettings": {
            "description": "Provides a resource to manage URL Normalization Settings.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.UrlNormalizationSettings(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    type: \"cloudflare\",\n    scope: \"incoming\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.UrlNormalizationSettings(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    type=\"cloudflare\",\n    scope=\"incoming\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.UrlNormalizationSettings(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Type = \"cloudflare\",\n        Scope = \"incoming\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewUrlNormalizationSettings(ctx, \"example\", \u0026cloudflare.UrlNormalizationSettingsArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tType:   pulumi.String(\"cloudflare\"),\n\t\t\tScope:  pulumi.String(\"incoming\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.UrlNormalizationSettings;\nimport com.pulumi.cloudflare.UrlNormalizationSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new UrlNormalizationSettings(\"example\", UrlNormalizationSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .type(\"cloudflare\")\n            .scope(\"incoming\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:UrlNormalizationSettings\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      type: cloudflare\n      scope: incoming\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "scope": {
                    "type": "string",
                    "description": "The scope of the URL normalization.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of URL normalization performed by Cloudflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "scope",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "scope": {
                    "type": "string",
                    "description": "The scope of the URL normalization.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of URL normalization performed by Cloudflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "scope",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UrlNormalizationSettings resources.\n",
                "properties": {
                    "scope": {
                        "type": "string",
                        "description": "The scope of the URL normalization.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of URL normalization performed by Cloudflare.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/userAgentBlockingRule:UserAgentBlockingRule": {
            "description": "Provides a resource to manage User Agent Blocking Rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example1 = new cloudflare.UserAgentBlockingRule(\"example_1\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    mode: \"js_challenge\",\n    paused: false,\n    description: \"My description 1\",\n    configuration: {\n        target: \"ua\",\n        value: \"Chrome\",\n    },\n});\nconst example2 = new cloudflare.UserAgentBlockingRule(\"example_2\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    mode: \"challenge\",\n    paused: true,\n    description: \"My description 22\",\n    configuration: {\n        target: \"ua\",\n        value: \"Mozilla\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample1 = cloudflare.UserAgentBlockingRule(\"example_1\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    mode=\"js_challenge\",\n    paused=False,\n    description=\"My description 1\",\n    configuration={\n        \"target\": \"ua\",\n        \"value\": \"Chrome\",\n    })\nexample2 = cloudflare.UserAgentBlockingRule(\"example_2\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    mode=\"challenge\",\n    paused=True,\n    description=\"My description 22\",\n    configuration={\n        \"target\": \"ua\",\n        \"value\": \"Mozilla\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example1 = new Cloudflare.UserAgentBlockingRule(\"example_1\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Mode = \"js_challenge\",\n        Paused = false,\n        Description = \"My description 1\",\n        Configuration = new Cloudflare.Inputs.UserAgentBlockingRuleConfigurationArgs\n        {\n            Target = \"ua\",\n            Value = \"Chrome\",\n        },\n    });\n\n    var example2 = new Cloudflare.UserAgentBlockingRule(\"example_2\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Mode = \"challenge\",\n        Paused = true,\n        Description = \"My description 22\",\n        Configuration = new Cloudflare.Inputs.UserAgentBlockingRuleConfigurationArgs\n        {\n            Target = \"ua\",\n            Value = \"Mozilla\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewUserAgentBlockingRule(ctx, \"example_1\", \u0026cloudflare.UserAgentBlockingRuleArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tMode:        pulumi.String(\"js_challenge\"),\n\t\t\tPaused:      pulumi.Bool(false),\n\t\t\tDescription: pulumi.String(\"My description 1\"),\n\t\t\tConfiguration: \u0026cloudflare.UserAgentBlockingRuleConfigurationArgs{\n\t\t\t\tTarget: pulumi.String(\"ua\"),\n\t\t\t\tValue:  pulumi.String(\"Chrome\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewUserAgentBlockingRule(ctx, \"example_2\", \u0026cloudflare.UserAgentBlockingRuleArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tMode:        pulumi.String(\"challenge\"),\n\t\t\tPaused:      pulumi.Bool(true),\n\t\t\tDescription: pulumi.String(\"My description 22\"),\n\t\t\tConfiguration: \u0026cloudflare.UserAgentBlockingRuleConfigurationArgs{\n\t\t\t\tTarget: pulumi.String(\"ua\"),\n\t\t\t\tValue:  pulumi.String(\"Mozilla\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.UserAgentBlockingRule;\nimport com.pulumi.cloudflare.UserAgentBlockingRuleArgs;\nimport com.pulumi.cloudflare.inputs.UserAgentBlockingRuleConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example1 = new UserAgentBlockingRule(\"example1\", UserAgentBlockingRuleArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .mode(\"js_challenge\")\n            .paused(false)\n            .description(\"My description 1\")\n            .configuration(UserAgentBlockingRuleConfigurationArgs.builder()\n                .target(\"ua\")\n                .value(\"Chrome\")\n                .build())\n            .build());\n\n        var example2 = new UserAgentBlockingRule(\"example2\", UserAgentBlockingRuleArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .mode(\"challenge\")\n            .paused(true)\n            .description(\"My description 22\")\n            .configuration(UserAgentBlockingRuleConfigurationArgs.builder()\n                .target(\"ua\")\n                .value(\"Mozilla\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example1:\n    type: cloudflare:UserAgentBlockingRule\n    name: example_1\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      mode: js_challenge\n      paused: false\n      description: My description 1\n      configuration:\n        target: ua\n        value: Chrome\n  example2:\n    type: cloudflare:UserAgentBlockingRule\n    name: example_2\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      mode: challenge\n      paused: true\n      description: My description 22\n      configuration:\n        target: ua\n        value: Mozilla\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/userAgentBlockingRule:UserAgentBlockingRule example \u003czone_id\u003e/\u003cuser_agent_blocking_rule_id\u003e\n```\n\n",
            "properties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration",
                    "description": "The configuration object for the current rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An informative summary of the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "When true, indicates that the rule is currently paused.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "configuration",
                "description",
                "mode",
                "paused",
                "zoneId"
            ],
            "inputProperties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration",
                    "description": "The configuration object for the current rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An informative summary of the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "When true, indicates that the rule is currently paused.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configuration",
                "description",
                "mode",
                "paused",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAgentBlockingRule resources.\n",
                "properties": {
                    "configuration": {
                        "$ref": "#/types/cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration",
                        "description": "The configuration object for the current rule.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An informative summary of the rule.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "When true, indicates that the rule is currently paused.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoom:WaitingRoom": {
            "description": "Provides a Cloudflare Waiting Room resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Waiting Room\nconst example = new cloudflare.WaitingRoom(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"foo\",\n    host: \"foo.example.com\",\n    path: \"/\",\n    newUsersPerMinute: 200,\n    totalActiveUsers: 200,\n    cookieSuffix: \"queue1\",\n    additionalRoutes: [\n        {\n            host: \"shop1.example.com\",\n            path: \"/example-path\",\n        },\n        {\n            host: \"shop2.example.com\",\n        },\n    ],\n    queueingStatusCode: 200,\n    enabledOriginCommands: [\"revoke\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Waiting Room\nexample = cloudflare.WaitingRoom(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"foo\",\n    host=\"foo.example.com\",\n    path=\"/\",\n    new_users_per_minute=200,\n    total_active_users=200,\n    cookie_suffix=\"queue1\",\n    additional_routes=[\n        {\n            \"host\": \"shop1.example.com\",\n            \"path\": \"/example-path\",\n        },\n        {\n            \"host\": \"shop2.example.com\",\n        },\n    ],\n    queueing_status_code=200,\n    enabled_origin_commands=[\"revoke\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Waiting Room\n    var example = new Cloudflare.WaitingRoom(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"foo\",\n        Host = \"foo.example.com\",\n        Path = \"/\",\n        NewUsersPerMinute = 200,\n        TotalActiveUsers = 200,\n        CookieSuffix = \"queue1\",\n        AdditionalRoutes = new[]\n        {\n            new Cloudflare.Inputs.WaitingRoomAdditionalRouteArgs\n            {\n                Host = \"shop1.example.com\",\n                Path = \"/example-path\",\n            },\n            new Cloudflare.Inputs.WaitingRoomAdditionalRouteArgs\n            {\n                Host = \"shop2.example.com\",\n            },\n        },\n        QueueingStatusCode = 200,\n        EnabledOriginCommands = new[]\n        {\n            \"revoke\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Waiting Room\n\t\t_, err := cloudflare.NewWaitingRoom(ctx, \"example\", \u0026cloudflare.WaitingRoomArgs{\n\t\t\tZoneId:            pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:              pulumi.String(\"foo\"),\n\t\t\tHost:              pulumi.String(\"foo.example.com\"),\n\t\t\tPath:              pulumi.String(\"/\"),\n\t\t\tNewUsersPerMinute: pulumi.Int(200),\n\t\t\tTotalActiveUsers:  pulumi.Int(200),\n\t\t\tCookieSuffix:      pulumi.String(\"queue1\"),\n\t\t\tAdditionalRoutes: cloudflare.WaitingRoomAdditionalRouteArray{\n\t\t\t\t\u0026cloudflare.WaitingRoomAdditionalRouteArgs{\n\t\t\t\t\tHost: pulumi.String(\"shop1.example.com\"),\n\t\t\t\t\tPath: pulumi.String(\"/example-path\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.WaitingRoomAdditionalRouteArgs{\n\t\t\t\t\tHost: pulumi.String(\"shop2.example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tQueueingStatusCode: pulumi.Int(200),\n\t\t\tEnabledOriginCommands: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"revoke\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoom;\nimport com.pulumi.cloudflare.WaitingRoomArgs;\nimport com.pulumi.cloudflare.inputs.WaitingRoomAdditionalRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Waiting Room\n        var example = new WaitingRoom(\"example\", WaitingRoomArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"foo\")\n            .host(\"foo.example.com\")\n            .path(\"/\")\n            .newUsersPerMinute(200)\n            .totalActiveUsers(200)\n            .cookieSuffix(\"queue1\")\n            .additionalRoutes(            \n                WaitingRoomAdditionalRouteArgs.builder()\n                    .host(\"shop1.example.com\")\n                    .path(\"/example-path\")\n                    .build(),\n                WaitingRoomAdditionalRouteArgs.builder()\n                    .host(\"shop2.example.com\")\n                    .build())\n            .queueingStatusCode(200)\n            .enabledOriginCommands(\"revoke\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Waiting Room\n  example:\n    type: cloudflare:WaitingRoom\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: foo\n      host: foo.example.com\n      path: /\n      newUsersPerMinute: 200\n      totalActiveUsers: 200\n      cookieSuffix: queue1\n      additionalRoutes:\n        - host: shop1.example.com\n          path: /example-path\n        - host: shop2.example.com\n      queueingStatusCode: 200\n      enabledOriginCommands:\n        - revoke\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUse the Zone ID and Waiting Room ID to import.\n\n```sh\n$ pulumi import cloudflare:index/waitingRoom:WaitingRoom default \u003czone_id\u003e/\u003cwaiting_room_id\u003e\n```\n\n",
            "properties": {
                "additionalRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WaitingRoomAdditionalRoute:WaitingRoomAdditionalRoute"
                    },
                    "description": "A list of additional hostname and paths combination to be applied on the waiting room.\n"
                },
                "cookieSuffix": {
                    "type": "string",
                    "description": "A cookie suffix to be appended to the Cloudflare waiting room cookie name.\n"
                },
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "defaultTemplateLanguage": {
                    "type": "string",
                    "description": "The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`. Defaults to `en-US`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to add more details about the waiting room.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "enabledOriginCommands": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of enabled origin commands for the waiting room. Available values: `revoke`.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                },
                "jsonResponseEnabled": {
                    "type": "boolean",
                    "description": "If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the host to enable the waiting room on. Defaults to `/`.\n"
                },
                "queueAll": {
                    "type": "boolean",
                    "description": "If queue_all is true, then all traffic will be sent to the waiting room.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.\n"
                },
                "queueingStatusCode": {
                    "type": "integer",
                    "description": "HTTP status code returned to a user while in the queue. Defaults to `200`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "Suspends the waiting room.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "host",
                "name",
                "newUsersPerMinute",
                "totalActiveUsers",
                "zoneId"
            ],
            "inputProperties": {
                "additionalRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WaitingRoomAdditionalRoute:WaitingRoomAdditionalRoute"
                    },
                    "description": "A list of additional hostname and paths combination to be applied on the waiting room.\n"
                },
                "cookieSuffix": {
                    "type": "string",
                    "description": "A cookie suffix to be appended to the Cloudflare waiting room cookie name.\n"
                },
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "defaultTemplateLanguage": {
                    "type": "string",
                    "description": "The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`. Defaults to `en-US`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to add more details about the waiting room.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "enabledOriginCommands": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of enabled origin commands for the waiting room. Available values: `revoke`.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                },
                "jsonResponseEnabled": {
                    "type": "boolean",
                    "description": "If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the host to enable the waiting room on. Defaults to `/`.\n"
                },
                "queueAll": {
                    "type": "boolean",
                    "description": "If queue_all is true, then all traffic will be sent to the waiting room.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.\n"
                },
                "queueingStatusCode": {
                    "type": "integer",
                    "description": "HTTP status code returned to a user while in the queue. Defaults to `200`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "Suspends the waiting room.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "host",
                "name",
                "newUsersPerMinute",
                "totalActiveUsers",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoom resources.\n",
                "properties": {
                    "additionalRoutes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WaitingRoomAdditionalRoute:WaitingRoomAdditionalRoute"
                        },
                        "description": "A list of additional hostname and paths combination to be applied on the waiting room.\n"
                    },
                    "cookieSuffix": {
                        "type": "string",
                        "description": "A cookie suffix to be appended to the Cloudflare waiting room cookie name.\n"
                    },
                    "customPageHtml": {
                        "type": "string",
                        "description": "This is a templated html file that will be rendered at the edge.\n"
                    },
                    "defaultTemplateLanguage": {
                        "type": "string",
                        "description": "The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`. Defaults to `en-US`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description to add more details about the waiting room.\n"
                    },
                    "disableSessionRenewal": {
                        "type": "boolean",
                        "description": "Disables automatic renewal of session cookies.\n"
                    },
                    "enabledOriginCommands": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of enabled origin commands for the waiting room. Available values: `revoke`.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                    },
                    "jsonResponseEnabled": {
                        "type": "boolean",
                        "description": "If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "newUsersPerMinute": {
                        "type": "integer",
                        "description": "The number of new users that will be let into the route every minute.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path within the host to enable the waiting room on. Defaults to `/`.\n"
                    },
                    "queueAll": {
                        "type": "boolean",
                        "description": "If queue_all is true, then all traffic will be sent to the waiting room.\n"
                    },
                    "queueingMethod": {
                        "type": "string",
                        "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.\n"
                    },
                    "queueingStatusCode": {
                        "type": "integer",
                        "description": "HTTP status code returned to a user while in the queue. Defaults to `200`.\n"
                    },
                    "sessionDuration": {
                        "type": "integer",
                        "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "Suspends the waiting room.\n"
                    },
                    "totalActiveUsers": {
                        "type": "integer",
                        "description": "The total number of active user sessions on the route at a point in time.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoomEvent:WaitingRoomEvent": {
            "description": "Provides a Cloudflare Waiting Room Event resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Waiting Room Event\nconst example = new cloudflare.WaitingRoomEvent(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    waitingRoomId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"foo\",\n    eventStartTime: \"2006-01-02T15:04:05Z\",\n    eventEndTime: \"2006-01-02T20:04:05Z\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Waiting Room Event\nexample = cloudflare.WaitingRoomEvent(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    waiting_room_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"foo\",\n    event_start_time=\"2006-01-02T15:04:05Z\",\n    event_end_time=\"2006-01-02T20:04:05Z\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Waiting Room Event\n    var example = new Cloudflare.WaitingRoomEvent(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        WaitingRoomId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Name = \"foo\",\n        EventStartTime = \"2006-01-02T15:04:05Z\",\n        EventEndTime = \"2006-01-02T20:04:05Z\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Waiting Room Event\n\t\t_, err := cloudflare.NewWaitingRoomEvent(ctx, \"example\", \u0026cloudflare.WaitingRoomEventArgs{\n\t\t\tZoneId:         pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tWaitingRoomId:  pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:           pulumi.String(\"foo\"),\n\t\t\tEventStartTime: pulumi.String(\"2006-01-02T15:04:05Z\"),\n\t\t\tEventEndTime:   pulumi.String(\"2006-01-02T20:04:05Z\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoomEvent;\nimport com.pulumi.cloudflare.WaitingRoomEventArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Waiting Room Event\n        var example = new WaitingRoomEvent(\"example\", WaitingRoomEventArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .waitingRoomId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .name(\"foo\")\n            .eventStartTime(\"2006-01-02T15:04:05Z\")\n            .eventEndTime(\"2006-01-02T20:04:05Z\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Waiting Room Event\n  example:\n    type: cloudflare:WaitingRoomEvent\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      waitingRoomId: d41d8cd98f00b204e9800998ecf8427e\n      name: foo\n      eventStartTime: 2006-01-02T15:04:05Z\n      eventEndTime: 2006-01-02T20:04:05Z\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUse the Zone ID, Waiting Room ID, and Event ID to import.\n\n```sh\n$ pulumi import cloudflare:index/waitingRoomEvent:WaitingRoomEvent default \u003czone_id\u003e/\u003cwaiting_room_id\u003e/\u003cwaiting_room_event_id\u003e\n```\n\n",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to let users add more details about the event.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "eventEndTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "eventStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Last modified time.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "prequeueStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.\n"
                },
                "shuffleAtEventStart": {
                    "type": "boolean",
                    "description": "Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "createdOn",
                "eventEndTime",
                "eventStartTime",
                "modifiedOn",
                "name",
                "waitingRoomId",
                "zoneId"
            ],
            "inputProperties": {
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to let users add more details about the event.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "eventEndTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "eventStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "prequeueStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.\n"
                },
                "shuffleAtEventStart": {
                    "type": "boolean",
                    "description": "Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "eventEndTime",
                "eventStartTime",
                "name",
                "waitingRoomId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoomEvent resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "customPageHtml": {
                        "type": "string",
                        "description": "This is a templated html file that will be rendered at the edge.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description to let users add more details about the event.\n"
                    },
                    "disableSessionRenewal": {
                        "type": "boolean",
                        "description": "Disables automatic renewal of session cookies.\n"
                    },
                    "eventEndTime": {
                        "type": "string",
                        "description": "ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "eventStartTime": {
                        "type": "string",
                        "description": "ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Last modified time.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "newUsersPerMinute": {
                        "type": "integer",
                        "description": "The number of new users that will be let into the route every minute.\n"
                    },
                    "prequeueStartTime": {
                        "type": "string",
                        "description": "ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.\n"
                    },
                    "queueingMethod": {
                        "type": "string",
                        "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.\n"
                    },
                    "sessionDuration": {
                        "type": "integer",
                        "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.\n"
                    },
                    "shuffleAtEventStart": {
                        "type": "boolean",
                        "description": "Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.\n"
                    },
                    "totalActiveUsers": {
                        "type": "integer",
                        "description": "The total number of active user sessions on the route at a point in time.\n"
                    },
                    "waitingRoomId": {
                        "type": "string",
                        "description": "The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoomRules:WaitingRoomRules": {
            "description": "Provides a Cloudflare Waiting Room Rules resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WaitingRoomRules(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    waitingRoomId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    rules: [\n        {\n            description: \"bypass ip list\",\n            expression: \"src.ip in {192.0.2.0 192.0.2.1}\",\n            action: \"bypass_waiting_room\",\n            status: \"enabled\",\n        },\n        {\n            description: \"bypass query string\",\n            expression: \"http.request.uri.query contains \\\"bypass=true\\\"\",\n            action: \"bypass_waiting_room\",\n            status: \"enabled\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WaitingRoomRules(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    waiting_room_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    rules=[\n        {\n            \"description\": \"bypass ip list\",\n            \"expression\": \"src.ip in {192.0.2.0 192.0.2.1}\",\n            \"action\": \"bypass_waiting_room\",\n            \"status\": \"enabled\",\n        },\n        {\n            \"description\": \"bypass query string\",\n            \"expression\": \"http.request.uri.query contains \\\"bypass=true\\\"\",\n            \"action\": \"bypass_waiting_room\",\n            \"status\": \"enabled\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WaitingRoomRules(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        WaitingRoomId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Rules = new[]\n        {\n            new Cloudflare.Inputs.WaitingRoomRulesRuleArgs\n            {\n                Description = \"bypass ip list\",\n                Expression = \"src.ip in {192.0.2.0 192.0.2.1}\",\n                Action = \"bypass_waiting_room\",\n                Status = \"enabled\",\n            },\n            new Cloudflare.Inputs.WaitingRoomRulesRuleArgs\n            {\n                Description = \"bypass query string\",\n                Expression = \"http.request.uri.query contains \\\"bypass=true\\\"\",\n                Action = \"bypass_waiting_room\",\n                Status = \"enabled\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWaitingRoomRules(ctx, \"example\", \u0026cloudflare.WaitingRoomRulesArgs{\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tWaitingRoomId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tRules: cloudflare.WaitingRoomRulesRuleArray{\n\t\t\t\t\u0026cloudflare.WaitingRoomRulesRuleArgs{\n\t\t\t\t\tDescription: pulumi.String(\"bypass ip list\"),\n\t\t\t\t\tExpression:  pulumi.String(\"src.ip in {192.0.2.0 192.0.2.1}\"),\n\t\t\t\t\tAction:      pulumi.String(\"bypass_waiting_room\"),\n\t\t\t\t\tStatus:      pulumi.String(\"enabled\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.WaitingRoomRulesRuleArgs{\n\t\t\t\t\tDescription: pulumi.String(\"bypass query string\"),\n\t\t\t\t\tExpression:  pulumi.String(\"http.request.uri.query contains \\\"bypass=true\\\"\"),\n\t\t\t\t\tAction:      pulumi.String(\"bypass_waiting_room\"),\n\t\t\t\t\tStatus:      pulumi.String(\"enabled\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoomRules;\nimport com.pulumi.cloudflare.WaitingRoomRulesArgs;\nimport com.pulumi.cloudflare.inputs.WaitingRoomRulesRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WaitingRoomRules(\"example\", WaitingRoomRulesArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .waitingRoomId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .rules(            \n                WaitingRoomRulesRuleArgs.builder()\n                    .description(\"bypass ip list\")\n                    .expression(\"src.ip in {192.0.2.0 192.0.2.1}\")\n                    .action(\"bypass_waiting_room\")\n                    .status(\"enabled\")\n                    .build(),\n                WaitingRoomRulesRuleArgs.builder()\n                    .description(\"bypass query string\")\n                    .expression(\"http.request.uri.query contains \\\"bypass=true\\\"\")\n                    .action(\"bypass_waiting_room\")\n                    .status(\"enabled\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WaitingRoomRules\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      waitingRoomId: d41d8cd98f00b204e9800998ecf8427e\n      rules:\n        - description: bypass ip list\n          expression: src.ip in {192.0.2.0 192.0.2.1}\n          action: bypass_waiting_room\n          status: enabled\n        - description: bypass query string\n          expression: http.request.uri.query contains \"bypass=true\"\n          action: bypass_waiting_room\n          status: enabled\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/waitingRoomRules:WaitingRoomRules default \u003czone_id\u003e/\u003cwaiting_room_id\u003e\n```\n\n",
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "waitingRoomId",
                "zoneId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "waitingRoomId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoomRules resources.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule"
                        },
                        "description": "List of rules to apply to the ruleset.\n"
                    },
                    "waitingRoomId": {
                        "type": "string",
                        "description": "The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoomSettings:WaitingRoomSettings": {
            "description": "Configure zone-wide settings for Cloudflare waiting rooms.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WaitingRoomSettings(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    searchEngineCrawlerBypass: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WaitingRoomSettings(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    search_engine_crawler_bypass=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WaitingRoomSettings(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        SearchEngineCrawlerBypass = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWaitingRoomSettings(ctx, \"example\", \u0026cloudflare.WaitingRoomSettingsArgs{\n\t\t\tZoneId:                    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tSearchEngineCrawlerBypass: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoomSettings;\nimport com.pulumi.cloudflare.WaitingRoomSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WaitingRoomSettings(\"example\", WaitingRoomSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .searchEngineCrawlerBypass(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WaitingRoomSettings\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      searchEngineCrawlerBypass: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/waitingRoomSettings:WaitingRoomSettings example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "searchEngineCrawlerBypass": {
                    "type": "boolean",
                    "description": "Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "searchEngineCrawlerBypass": {
                    "type": "boolean",
                    "description": "Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoomSettings resources.\n",
                "properties": {
                    "searchEngineCrawlerBypass": {
                        "type": "boolean",
                        "description": "Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/web3Hostname:Web3Hostname": {
            "description": "Manages Web3 hostnames for IPFS and Ethereum gateways.\n",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the hostname.\n"
                },
                "dnslink": {
                    "type": "string",
                    "description": "DNSLink value used if the target is ipfs.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Last modification time.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The hostname that will point to the target gateway via CNAME.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the hostname's activation.\n"
                },
                "target": {
                    "type": "string",
                    "description": "Target gateway of the hostname.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "createdOn",
                "modifiedOn",
                "name",
                "status",
                "target",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the hostname.\n"
                },
                "dnslink": {
                    "type": "string",
                    "description": "DNSLink value used if the target is ipfs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The hostname that will point to the target gateway via CNAME.\n"
                },
                "target": {
                    "type": "string",
                    "description": "Target gateway of the hostname.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "name",
                "target",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Web3Hostname resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the hostname.\n"
                    },
                    "dnslink": {
                        "type": "string",
                        "description": "DNSLink value used if the target is ipfs.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Last modification time.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The hostname that will point to the target gateway via CNAME.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the hostname's activation.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "Target gateway of the hostname.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/webAnalyticsRule:WebAnalyticsRule": {
            "description": "Provides a Cloudflare Web Analytics Rule resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WebAnalyticsSite(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    zoneTag: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    autoInstall: true,\n});\nconst exampleWebAnalyticsRule = new cloudflare.WebAnalyticsRule(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    rulesetId: example.rulesetId,\n    host: \"*\",\n    paths: [\"/excluded\"],\n    inclusive: false,\n    isPaused: false,\n}, {\n    dependsOn: [example],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WebAnalyticsSite(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    zone_tag=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    auto_install=True)\nexample_web_analytics_rule = cloudflare.WebAnalyticsRule(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    ruleset_id=example.ruleset_id,\n    host=\"*\",\n    paths=[\"/excluded\"],\n    inclusive=False,\n    is_paused=False,\n    opts = pulumi.ResourceOptions(depends_on=[example]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WebAnalyticsSite(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ZoneTag = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        AutoInstall = true,\n    });\n\n    var exampleWebAnalyticsRule = new Cloudflare.WebAnalyticsRule(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        RulesetId = example.RulesetId,\n        Host = \"*\",\n        Paths = new[]\n        {\n            \"/excluded\",\n        },\n        Inclusive = false,\n        IsPaused = false,\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            example,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.NewWebAnalyticsSite(ctx, \"example\", \u0026cloudflare.WebAnalyticsSiteArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tZoneTag:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tAutoInstall: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWebAnalyticsRule(ctx, \"example\", \u0026cloudflare.WebAnalyticsRuleArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tRulesetId: example.RulesetId,\n\t\t\tHost:      pulumi.String(\"*\"),\n\t\t\tPaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"/excluded\"),\n\t\t\t},\n\t\t\tInclusive: pulumi.Bool(false),\n\t\t\tIsPaused:  pulumi.Bool(false),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texample,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WebAnalyticsSite;\nimport com.pulumi.cloudflare.WebAnalyticsSiteArgs;\nimport com.pulumi.cloudflare.WebAnalyticsRule;\nimport com.pulumi.cloudflare.WebAnalyticsRuleArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WebAnalyticsSite(\"example\", WebAnalyticsSiteArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .zoneTag(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .autoInstall(true)\n            .build());\n\n        var exampleWebAnalyticsRule = new WebAnalyticsRule(\"exampleWebAnalyticsRule\", WebAnalyticsRuleArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .rulesetId(example.rulesetId())\n            .host(\"*\")\n            .paths(\"/excluded\")\n            .inclusive(false)\n            .isPaused(false)\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(example)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WebAnalyticsSite\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      zoneTag: 0da42c8d2132a9ddaf714f9e7c920711\n      autoInstall: true\n  exampleWebAnalyticsRule:\n    type: cloudflare:WebAnalyticsRule\n    name: example\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      rulesetId: ${example.rulesetId}\n      host: '*'\n      paths:\n        - /excluded\n      inclusive: false\n      isPaused: false\n    options:\n      dependson:\n        - ${example}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/webAnalyticsRule:WebAnalyticsRule example \u003caccount_id\u003e/\u003cruleset_id\u003e/\u003crule_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "host": {
                    "type": "string",
                    "description": "The host to apply the rule to.\n"
                },
                "inclusive": {
                    "type": "boolean",
                    "description": "Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.\n"
                },
                "isPaused": {
                    "type": "boolean",
                    "description": "Whether the rule is paused or not.\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of paths to apply the rule to.\n"
                },
                "rulesetId": {
                    "type": "string",
                    "description": "The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "host",
                "inclusive",
                "isPaused",
                "paths",
                "rulesetId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "host": {
                    "type": "string",
                    "description": "The host to apply the rule to.\n"
                },
                "inclusive": {
                    "type": "boolean",
                    "description": "Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.\n"
                },
                "isPaused": {
                    "type": "boolean",
                    "description": "Whether the rule is paused or not.\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of paths to apply the rule to.\n"
                },
                "rulesetId": {
                    "type": "string",
                    "description": "The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "host",
                "inclusive",
                "isPaused",
                "paths",
                "rulesetId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WebAnalyticsRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "host": {
                        "type": "string",
                        "description": "The host to apply the rule to.\n"
                    },
                    "inclusive": {
                        "type": "boolean",
                        "description": "Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.\n"
                    },
                    "isPaused": {
                        "type": "boolean",
                        "description": "Whether the rule is paused or not.\n"
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of paths to apply the rule to.\n"
                    },
                    "rulesetId": {
                        "type": "string",
                        "description": "The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/webAnalyticsSite:WebAnalyticsSite": {
            "description": "Provides a Cloudflare Web Analytics Site resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WebAnalyticsSite(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    zoneTag: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    autoInstall: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WebAnalyticsSite(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    zone_tag=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    auto_install=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WebAnalyticsSite(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ZoneTag = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        AutoInstall = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWebAnalyticsSite(ctx, \"example\", \u0026cloudflare.WebAnalyticsSiteArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tZoneTag:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tAutoInstall: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WebAnalyticsSite;\nimport com.pulumi.cloudflare.WebAnalyticsSiteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WebAnalyticsSite(\"example\", WebAnalyticsSiteArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .zoneTag(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .autoInstall(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WebAnalyticsSite\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      zoneTag: 0da42c8d2132a9ddaf714f9e7c920711\n      autoInstall: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/webAnalyticsSite:WebAnalyticsSite example \u003caccount_id\u003e/\u003csite_tag\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "autoInstall": {
                    "type": "boolean",
                    "description": "Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "host": {
                    "type": "string",
                    "description": "The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "rulesetId": {
                    "type": "string",
                    "description": "The ID for the ruleset associated to this Web Analytics Site.\n"
                },
                "siteTag": {
                    "type": "string",
                    "description": "The Web Analytics site tag.\n"
                },
                "siteToken": {
                    "type": "string",
                    "description": "The token for the Web Analytics site.\n",
                    "secret": true
                },
                "snippet": {
                    "type": "string",
                    "description": "The encoded JS snippet to add to your site's HTML page if auto_install is false.\n",
                    "secret": true
                },
                "zoneTag": {
                    "type": "string",
                    "description": "The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "autoInstall",
                "rulesetId",
                "siteTag",
                "siteToken",
                "snippet"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "autoInstall": {
                    "type": "boolean",
                    "description": "Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "host": {
                    "type": "string",
                    "description": "The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneTag": {
                    "type": "string",
                    "description": "The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "autoInstall"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WebAnalyticsSite resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "autoInstall": {
                        "type": "boolean",
                        "description": "Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "host": {
                        "type": "string",
                        "description": "The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "rulesetId": {
                        "type": "string",
                        "description": "The ID for the ruleset associated to this Web Analytics Site.\n"
                    },
                    "siteTag": {
                        "type": "string",
                        "description": "The Web Analytics site tag.\n"
                    },
                    "siteToken": {
                        "type": "string",
                        "description": "The token for the Web Analytics site.\n",
                        "secret": true
                    },
                    "snippet": {
                        "type": "string",
                        "description": "The encoded JS snippet to add to your site's HTML page if auto_install is false.\n",
                        "secret": true
                    },
                    "zoneTag": {
                        "type": "string",
                        "description": "The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerCronTrigger:WorkerCronTrigger": {
            "description": "Worker Cron Triggers allow users to map a cron expression to a Worker script\nusing a `ScheduledEvent` listener that enables Workers to be executed on a\nschedule. Worker Cron Triggers are ideal for running periodic jobs for\nmaintenance or calling third-party APIs to collect up-to-date data.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst exampleScript = new cloudflare.WorkersScript(\"example_script\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example-script\",\n    content: std.file({\n        input: \"path/to/my.js\",\n    }).then(invoke =\u003e invoke.result),\n});\nconst exampleTrigger = new cloudflare.WorkerCronTrigger(\"example_trigger\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    scriptName: exampleScript.name,\n    schedules: [\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\nexample_script = cloudflare.WorkersScript(\"example_script\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example-script\",\n    content=std.file(input=\"path/to/my.js\").result)\nexample_trigger = cloudflare.WorkerCronTrigger(\"example_trigger\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    script_name=example_script.name,\n    schedules=[\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleScript = new Cloudflare.WorkersScript(\"example_script\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example-script\",\n        Content = Std.File.Invoke(new()\n        {\n            Input = \"path/to/my.js\",\n        }).Apply(invoke =\u003e invoke.Result),\n    });\n\n    var exampleTrigger = new Cloudflare.WorkerCronTrigger(\"example_trigger\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ScriptName = exampleScript.Name,\n        Schedules = new[]\n        {\n            \"*/5 * * * *\",\n            \"10 7 * * mon-fri\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"path/to/my.js\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleScript, err := cloudflare.NewWorkersScript(ctx, \"example_script\", \u0026cloudflare.WorkersScriptArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example-script\"),\n\t\t\tContent:   pulumi.String(invokeFile.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerCronTrigger(ctx, \"example_trigger\", \u0026cloudflare.WorkerCronTriggerArgs{\n\t\t\tAccountId:  pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tScriptName: exampleScript.Name,\n\t\t\tSchedules: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*/5 * * * *\"),\n\t\t\t\tpulumi.String(\"10 7 * * mon-fri\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkersScriptArgs;\nimport com.pulumi.cloudflare.WorkerCronTrigger;\nimport com.pulumi.cloudflare.WorkerCronTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleScript = new WorkersScript(\"exampleScript\", WorkersScriptArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example-script\")\n            .content(StdFunctions.file(FileArgs.builder()\n                .input(\"path/to/my.js\")\n                .build()).result())\n            .build());\n\n        var exampleTrigger = new WorkerCronTrigger(\"exampleTrigger\", WorkerCronTriggerArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .scriptName(exampleScript.name())\n            .schedules(            \n                \"*/5 * * * *\",\n                \"10 7 * * mon-fri\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleScript:\n    type: cloudflare:WorkersScript\n    name: example_script\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example-script\n      content:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: path/to/my.js\n          Return: result\n  exampleTrigger:\n    type: cloudflare:WorkerCronTrigger\n    name: example_trigger\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      scriptName: ${exampleScript.name}\n      schedules:\n        - '*/5 * * * *'\n        - 10 7 * * mon-fri\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workerCronTrigger:WorkerCronTrigger example \u003caccount_id\u003e/\u003cscript_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cron expressions to execute the Worker script.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules.\n"
                }
            },
            "required": [
                "accountId",
                "schedules",
                "scriptName"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cron expressions to execute the Worker script.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "schedules",
                "scriptName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerCronTrigger resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "schedules": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cron expressions to execute the Worker script.\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script to target for the schedules.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerDomain:WorkerDomain": {
            "description": "Creates a Worker Custom Domain.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WorkerDomain(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostname: \"subdomain.example.com\",\n    service: \"my-service\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WorkerDomain(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname=\"subdomain.example.com\",\n    service=\"my-service\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WorkerDomain(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Hostname = \"subdomain.example.com\",\n        Service = \"my-service\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkerDomain(ctx, \"example\", \u0026cloudflare.WorkerDomainArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tHostname:  pulumi.String(\"subdomain.example.com\"),\n\t\t\tService:   pulumi.String(\"my-service\"),\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkerDomain;\nimport com.pulumi.cloudflare.WorkerDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WorkerDomain(\"example\", WorkerDomainArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostname(\"subdomain.example.com\")\n            .service(\"my-service\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WorkerDomain\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      hostname: subdomain.example.com\n      service: my-service\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workerDomain:WorkerDomain example \u003caccount_id\u003e/\u003cworker_domain_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment. Defaults to `production`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname of the Worker Domain.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Name of worker script to attach the domain to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "hostname",
                "service",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment. Defaults to `production`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname of the Worker Domain.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Name of worker script to attach the domain to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "hostname",
                "service",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "environment": {
                        "type": "string",
                        "description": "The name of the Worker environment. Defaults to `production`.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname of the Worker Domain.\n"
                    },
                    "service": {
                        "type": "string",
                        "description": "Name of worker script to attach the domain to.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerRoute:WorkerRoute": {
            "description": "Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myScript = new cloudflare.WorkersScript(\"my_script\", {});\n// Runs the specified worker script for all URLs that match `example.com/*`\nconst myRoute = new cloudflare.WorkerRoute(\"my_route\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    pattern: \"example.com/*\",\n    scriptName: myScript.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_script = cloudflare.WorkersScript(\"my_script\")\n# Runs the specified worker script for all URLs that match `example.com/*`\nmy_route = cloudflare.WorkerRoute(\"my_route\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    pattern=\"example.com/*\",\n    script_name=my_script.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myScript = new Cloudflare.WorkersScript(\"my_script\");\n\n    // Runs the specified worker script for all URLs that match `example.com/*`\n    var myRoute = new Cloudflare.WorkerRoute(\"my_route\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Pattern = \"example.com/*\",\n        ScriptName = myScript.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyScript, err := cloudflare.NewWorkersScript(ctx, \"my_script\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Runs the specified worker script for all URLs that match `example.com/*`\n\t\t_, err = cloudflare.NewWorkerRoute(ctx, \"my_route\", \u0026cloudflare.WorkerRouteArgs{\n\t\t\tZoneId:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tPattern:    pulumi.String(\"example.com/*\"),\n\t\t\tScriptName: myScript.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkerRoute;\nimport com.pulumi.cloudflare.WorkerRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myScript = new WorkersScript(\"myScript\");\n\n        // Runs the specified worker script for all URLs that match `example.com/*`\n        var myRoute = new WorkerRoute(\"myRoute\", WorkerRouteArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .pattern(\"example.com/*\")\n            .scriptName(myScript.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Runs the specified worker script for all URLs that match `example.com/*`\n  myRoute:\n    type: cloudflare:WorkerRoute\n    name: my_route\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      pattern: example.com/*\n      scriptName: ${myScript.name}\n  myScript:\n    type: cloudflare:WorkersScript\n    name: my_script\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workerRoute:WorkerRoute example \u003czone_id\u003e/\u003croute_id\u003e\n```\n\n",
            "properties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script name to invoke for requests that match the route pattern.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "pattern",
                "zoneId"
            ],
            "inputProperties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script name to invoke for requests that match the route pattern.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "pattern",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerRoute resources.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script name to invoke for requests that match the route pattern.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerScript:WorkerScript": {
            "description": "Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst myNamespace = new cloudflare.WorkersKvNamespace(\"my_namespace\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"example\",\n});\n// Sets the script with the name \"script_1\"\nconst myScript = new cloudflare.WorkerScript(\"my_script\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"script_1\",\n    content: std.file({\n        input: \"script.js\",\n    }).then(invoke =\u003e invoke.result),\n    kvNamespaceBindings: [{\n        name: \"MY_EXAMPLE_KV_NAMESPACE\",\n        namespaceId: myNamespace.id,\n    }],\n    plainTextBindings: [{\n        name: \"MY_EXAMPLE_PLAIN_TEXT\",\n        text: \"foobar\",\n    }],\n    secretTextBindings: [{\n        name: \"MY_EXAMPLE_SECRET_TEXT\",\n        text: secretFooValue,\n    }],\n    webassemblyBindings: [{\n        name: \"MY_EXAMPLE_WASM\",\n        module: std.filebase64({\n            input: \"example.wasm\",\n        }).then(invoke =\u003e invoke.result),\n    }],\n    serviceBindings: [{\n        name: \"MY_SERVICE_BINDING\",\n        service: \"MY_SERVICE\",\n        environment: \"production\",\n    }],\n    r2BucketBindings: [{\n        name: \"MY_BUCKET\",\n        bucketName: \"MY_BUCKET_NAME\",\n    }],\n    analyticsEngineBindings: [{\n        name: \"MY_DATASET\",\n        dataset: \"dataset1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\nmy_namespace = cloudflare.WorkersKvNamespace(\"my_namespace\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"example\")\n# Sets the script with the name \"script_1\"\nmy_script = cloudflare.WorkerScript(\"my_script\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"script_1\",\n    content=std.file(input=\"script.js\").result,\n    kv_namespace_bindings=[{\n        \"name\": \"MY_EXAMPLE_KV_NAMESPACE\",\n        \"namespace_id\": my_namespace.id,\n    }],\n    plain_text_bindings=[{\n        \"name\": \"MY_EXAMPLE_PLAIN_TEXT\",\n        \"text\": \"foobar\",\n    }],\n    secret_text_bindings=[{\n        \"name\": \"MY_EXAMPLE_SECRET_TEXT\",\n        \"text\": secret_foo_value,\n    }],\n    webassembly_bindings=[{\n        \"name\": \"MY_EXAMPLE_WASM\",\n        \"module\": std.filebase64(input=\"example.wasm\").result,\n    }],\n    service_bindings=[{\n        \"name\": \"MY_SERVICE_BINDING\",\n        \"service\": \"MY_SERVICE\",\n        \"environment\": \"production\",\n    }],\n    r2_bucket_bindings=[{\n        \"name\": \"MY_BUCKET\",\n        \"bucket_name\": \"MY_BUCKET_NAME\",\n    }],\n    analytics_engine_bindings=[{\n        \"name\": \"MY_DATASET\",\n        \"dataset\": \"dataset1\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myNamespace = new Cloudflare.WorkersKvNamespace(\"my_namespace\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"example\",\n    });\n\n    // Sets the script with the name \"script_1\"\n    var myScript = new Cloudflare.WorkerScript(\"my_script\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"script_1\",\n        Content = Std.File.Invoke(new()\n        {\n            Input = \"script.js\",\n        }).Apply(invoke =\u003e invoke.Result),\n        KvNamespaceBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptKvNamespaceBindingArgs\n            {\n                Name = \"MY_EXAMPLE_KV_NAMESPACE\",\n                NamespaceId = myNamespace.Id,\n            },\n        },\n        PlainTextBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptPlainTextBindingArgs\n            {\n                Name = \"MY_EXAMPLE_PLAIN_TEXT\",\n                Text = \"foobar\",\n            },\n        },\n        SecretTextBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptSecretTextBindingArgs\n            {\n                Name = \"MY_EXAMPLE_SECRET_TEXT\",\n                Text = secretFooValue,\n            },\n        },\n        WebassemblyBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptWebassemblyBindingArgs\n            {\n                Name = \"MY_EXAMPLE_WASM\",\n                Module = Std.Filebase64.Invoke(new()\n                {\n                    Input = \"example.wasm\",\n                }).Apply(invoke =\u003e invoke.Result),\n            },\n        },\n        ServiceBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptServiceBindingArgs\n            {\n                Name = \"MY_SERVICE_BINDING\",\n                Service = \"MY_SERVICE\",\n                Environment = \"production\",\n            },\n        },\n        R2BucketBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptR2BucketBindingArgs\n            {\n                Name = \"MY_BUCKET\",\n                BucketName = \"MY_BUCKET_NAME\",\n            },\n        },\n        AnalyticsEngineBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptAnalyticsEngineBindingArgs\n            {\n                Name = \"MY_DATASET\",\n                Dataset = \"dataset1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyNamespace, err := cloudflare.NewWorkersKvNamespace(ctx, \"my_namespace\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"script.js\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeFilebase641, err := std.Filebase64(ctx, \u0026std.Filebase64Args{\n\t\t\tInput: \"example.wasm\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sets the script with the name \"script_1\"\n\t\t_, err = cloudflare.NewWorkerScript(ctx, \"my_script\", \u0026cloudflare.WorkerScriptArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"script_1\"),\n\t\t\tContent:   pulumi.String(invokeFile.Result),\n\t\t\tKvNamespaceBindings: cloudflare.WorkerScriptKvNamespaceBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptKvNamespaceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_EXAMPLE_KV_NAMESPACE\"),\n\t\t\t\t\tNamespaceId: myNamespace.ID(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPlainTextBindings: cloudflare.WorkerScriptPlainTextBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptPlainTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_PLAIN_TEXT\"),\n\t\t\t\t\tText: pulumi.String(\"foobar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tSecretTextBindings: cloudflare.WorkerScriptSecretTextBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptSecretTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_SECRET_TEXT\"),\n\t\t\t\t\tText: pulumi.Any(secretFooValue),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWebassemblyBindings: cloudflare.WorkerScriptWebassemblyBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptWebassemblyBindingArgs{\n\t\t\t\t\tName:   pulumi.String(\"MY_EXAMPLE_WASM\"),\n\t\t\t\t\tModule: pulumi.String(invokeFilebase641.Result),\n\t\t\t\t},\n\t\t\t},\n\t\t\tServiceBindings: cloudflare.WorkerScriptServiceBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptServiceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_SERVICE_BINDING\"),\n\t\t\t\t\tService:     pulumi.String(\"MY_SERVICE\"),\n\t\t\t\t\tEnvironment: pulumi.String(\"production\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tR2BucketBindings: cloudflare.WorkerScriptR2BucketBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptR2BucketBindingArgs{\n\t\t\t\t\tName:       pulumi.String(\"MY_BUCKET\"),\n\t\t\t\t\tBucketName: pulumi.String(\"MY_BUCKET_NAME\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tAnalyticsEngineBindings: cloudflare.WorkerScriptAnalyticsEngineBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptAnalyticsEngineBindingArgs{\n\t\t\t\t\tName:    pulumi.String(\"MY_DATASET\"),\n\t\t\t\t\tDataset: pulumi.String(\"dataset1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport com.pulumi.cloudflare.WorkerScript;\nimport com.pulumi.cloudflare.WorkerScriptArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptKvNamespaceBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptPlainTextBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptSecretTextBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptWebassemblyBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptServiceBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptR2BucketBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptAnalyticsEngineBindingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myNamespace = new WorkersKvNamespace(\"myNamespace\", WorkersKvNamespaceArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"example\")\n            .build());\n\n        // Sets the script with the name \"script_1\"\n        var myScript = new WorkerScript(\"myScript\", WorkerScriptArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"script_1\")\n            .content(StdFunctions.file(FileArgs.builder()\n                .input(\"script.js\")\n                .build()).result())\n            .kvNamespaceBindings(WorkerScriptKvNamespaceBindingArgs.builder()\n                .name(\"MY_EXAMPLE_KV_NAMESPACE\")\n                .namespaceId(myNamespace.id())\n                .build())\n            .plainTextBindings(WorkerScriptPlainTextBindingArgs.builder()\n                .name(\"MY_EXAMPLE_PLAIN_TEXT\")\n                .text(\"foobar\")\n                .build())\n            .secretTextBindings(WorkerScriptSecretTextBindingArgs.builder()\n                .name(\"MY_EXAMPLE_SECRET_TEXT\")\n                .text(secretFooValue)\n                .build())\n            .webassemblyBindings(WorkerScriptWebassemblyBindingArgs.builder()\n                .name(\"MY_EXAMPLE_WASM\")\n                .module(StdFunctions.filebase64(Filebase64Args.builder()\n                    .input(\"example.wasm\")\n                    .build()).result())\n                .build())\n            .serviceBindings(WorkerScriptServiceBindingArgs.builder()\n                .name(\"MY_SERVICE_BINDING\")\n                .service(\"MY_SERVICE\")\n                .environment(\"production\")\n                .build())\n            .r2BucketBindings(WorkerScriptR2BucketBindingArgs.builder()\n                .name(\"MY_BUCKET\")\n                .bucketName(\"MY_BUCKET_NAME\")\n                .build())\n            .analyticsEngineBindings(WorkerScriptAnalyticsEngineBindingArgs.builder()\n                .name(\"MY_DATASET\")\n                .dataset(\"dataset1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myNamespace:\n    type: cloudflare:WorkersKvNamespace\n    name: my_namespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      title: example\n  # Sets the script with the name \"script_1\"\n  myScript:\n    type: cloudflare:WorkerScript\n    name: my_script\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: script_1\n      content:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: script.js\n          Return: result\n      kvNamespaceBindings:\n        - name: MY_EXAMPLE_KV_NAMESPACE\n          namespaceId: ${myNamespace.id}\n      plainTextBindings:\n        - name: MY_EXAMPLE_PLAIN_TEXT\n          text: foobar\n      secretTextBindings:\n        - name: MY_EXAMPLE_SECRET_TEXT\n          text: ${secretFooValue}\n      webassemblyBindings:\n        - name: MY_EXAMPLE_WASM\n          module:\n            fn::invoke:\n              Function: std:filebase64\n              Arguments:\n                input: example.wasm\n              Return: result\n      serviceBindings:\n        - name: MY_SERVICE_BINDING\n          service: MY_SERVICE\n          environment: production\n      r2BucketBindings:\n        - name: MY_BUCKET\n          bucketName: MY_BUCKET_NAME\n      analyticsEngineBindings:\n        - name: MY_DATASET\n          dataset: dataset1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workerScript:WorkerScript example \u003caccount_id\u003e/\u003cscript_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "analyticsEngineBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding"
                    }
                },
                "compatibilityDate": {
                    "type": "string",
                    "description": "The date to use for the compatibility flag.\n"
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Compatibility flags used for Worker Scripts.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "d1DatabaseBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptD1DatabaseBinding:WorkerScriptD1DatabaseBinding"
                    }
                },
                "dispatchNamespace": {
                    "type": "string",
                    "description": "Name of the Workers for Platforms dispatch namespace.\n"
                },
                "hyperdriveConfigBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptHyperdriveConfigBinding:WorkerScriptHyperdriveConfigBinding"
                    }
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "logpush": {
                    "type": "boolean",
                    "description": "Enabling allows Worker events to be sent to a defined Logpush destination.\n"
                },
                "module": {
                    "type": "boolean",
                    "description": "Whether to upload Worker as a module.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "placements": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlacement:WorkerScriptPlacement"
                    }
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                    }
                },
                "queueBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptQueueBinding:WorkerScriptQueueBinding"
                    }
                },
                "r2BucketBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                    }
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding"
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                    }
                }
            },
            "required": [
                "accountId",
                "compatibilityFlags",
                "content",
                "name",
                "tags"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "analyticsEngineBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding"
                    }
                },
                "compatibilityDate": {
                    "type": "string",
                    "description": "The date to use for the compatibility flag.\n"
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Compatibility flags used for Worker Scripts.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "d1DatabaseBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptD1DatabaseBinding:WorkerScriptD1DatabaseBinding"
                    }
                },
                "dispatchNamespace": {
                    "type": "string",
                    "description": "Name of the Workers for Platforms dispatch namespace.\n"
                },
                "hyperdriveConfigBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptHyperdriveConfigBinding:WorkerScriptHyperdriveConfigBinding"
                    }
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "logpush": {
                    "type": "boolean",
                    "description": "Enabling allows Worker events to be sent to a defined Logpush destination.\n"
                },
                "module": {
                    "type": "boolean",
                    "description": "Whether to upload Worker as a module.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "placements": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlacement:WorkerScriptPlacement"
                    }
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                    }
                },
                "queueBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptQueueBinding:WorkerScriptQueueBinding"
                    }
                },
                "r2BucketBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                    }
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding"
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                    }
                }
            },
            "requiredInputs": [
                "accountId",
                "content",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerScript resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "analyticsEngineBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding"
                        }
                    },
                    "compatibilityDate": {
                        "type": "string",
                        "description": "The date to use for the compatibility flag.\n"
                    },
                    "compatibilityFlags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Compatibility flags used for Worker Scripts.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "The script content.\n"
                    },
                    "d1DatabaseBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptD1DatabaseBinding:WorkerScriptD1DatabaseBinding"
                        }
                    },
                    "dispatchNamespace": {
                        "type": "string",
                        "description": "Name of the Workers for Platforms dispatch namespace.\n"
                    },
                    "hyperdriveConfigBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptHyperdriveConfigBinding:WorkerScriptHyperdriveConfigBinding"
                        }
                    },
                    "kvNamespaceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                        }
                    },
                    "logpush": {
                        "type": "boolean",
                        "description": "Enabling allows Worker events to be sent to a defined Logpush destination.\n"
                    },
                    "module": {
                        "type": "boolean",
                        "description": "Whether to upload Worker as a module.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "placements": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptPlacement:WorkerScriptPlacement"
                        }
                    },
                    "plainTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                        }
                    },
                    "queueBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptQueueBinding:WorkerScriptQueueBinding"
                        }
                    },
                    "r2BucketBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding"
                        }
                    },
                    "secretTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                        }
                    },
                    "serviceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding"
                        }
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webassemblyBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerSecret:WorkerSecret": {
            "description": "Provides a Cloudflare Worker secret resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst mySecret = new cloudflare.WorkerSecret(\"my_secret\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"MY_EXAMPLE_SECRET_TEXT\",\n    scriptName: \"script_1\",\n    secretText: \"my_secret_value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_secret = cloudflare.WorkerSecret(\"my_secret\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"MY_EXAMPLE_SECRET_TEXT\",\n    script_name=\"script_1\",\n    secret_text=\"my_secret_value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mySecret = new Cloudflare.WorkerSecret(\"my_secret\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"MY_EXAMPLE_SECRET_TEXT\",\n        ScriptName = \"script_1\",\n        SecretText = \"my_secret_value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkerSecret(ctx, \"my_secret\", \u0026cloudflare.WorkerSecretArgs{\n\t\t\tAccountId:  pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:       pulumi.String(\"MY_EXAMPLE_SECRET_TEXT\"),\n\t\t\tScriptName: pulumi.String(\"script_1\"),\n\t\t\tSecretText: pulumi.String(\"my_secret_value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkerSecret;\nimport com.pulumi.cloudflare.WorkerSecretArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mySecret = new WorkerSecret(\"mySecret\", WorkerSecretArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"MY_EXAMPLE_SECRET_TEXT\")\n            .scriptName(\"script_1\")\n            .secretText(\"my_secret_value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mySecret:\n    type: cloudflare:WorkerSecret\n    name: my_secret\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: MY_EXAMPLE_SECRET_TEXT\n      scriptName: script_1\n      secretText: my_secret_value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workerSecret:WorkerSecret example \u003caccount_id\u003e/\u003cscript_name\u003e/\u003csecret_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "secretText": {
                    "type": "string",
                    "description": "The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                }
            },
            "required": [
                "accountId",
                "name",
                "scriptName",
                "secretText"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "scriptName": {
                    "type": "string",
                    "description": "The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "secretText": {
                    "type": "string",
                    "description": "The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "scriptName",
                "secretText"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerSecret resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "secretText": {
                        "type": "string",
                        "description": "The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersCronTrigger:WorkersCronTrigger": {
            "description": "Worker Cron Triggers allow users to map a cron expression to a Worker script\nusing a `ScheduledEvent` listener that enables Workers to be executed on a\nschedule. Worker Cron Triggers are ideal for running periodic jobs for\nmaintenance or calling third-party APIs to collect up-to-date data.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst exampleScript = new cloudflare.WorkersScript(\"example_script\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example-script\",\n    content: std.file({\n        input: \"path/to/my.js\",\n    }).then(invoke =\u003e invoke.result),\n});\nconst exampleTrigger = new cloudflare.WorkersCronTrigger(\"example_trigger\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    scriptName: exampleScript.name,\n    schedules: [\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\nexample_script = cloudflare.WorkersScript(\"example_script\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example-script\",\n    content=std.file(input=\"path/to/my.js\").result)\nexample_trigger = cloudflare.WorkersCronTrigger(\"example_trigger\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    script_name=example_script.name,\n    schedules=[\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleScript = new Cloudflare.WorkersScript(\"example_script\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example-script\",\n        Content = Std.File.Invoke(new()\n        {\n            Input = \"path/to/my.js\",\n        }).Apply(invoke =\u003e invoke.Result),\n    });\n\n    var exampleTrigger = new Cloudflare.WorkersCronTrigger(\"example_trigger\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ScriptName = exampleScript.Name,\n        Schedules = new[]\n        {\n            \"*/5 * * * *\",\n            \"10 7 * * mon-fri\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"path/to/my.js\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleScript, err := cloudflare.NewWorkersScript(ctx, \"example_script\", \u0026cloudflare.WorkersScriptArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example-script\"),\n\t\t\tContent:   pulumi.String(invokeFile.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkersCronTrigger(ctx, \"example_trigger\", \u0026cloudflare.WorkersCronTriggerArgs{\n\t\t\tAccountId:  pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tScriptName: exampleScript.Name,\n\t\t\tSchedules: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*/5 * * * *\"),\n\t\t\t\tpulumi.String(\"10 7 * * mon-fri\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkersScriptArgs;\nimport com.pulumi.cloudflare.WorkersCronTrigger;\nimport com.pulumi.cloudflare.WorkersCronTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleScript = new WorkersScript(\"exampleScript\", WorkersScriptArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example-script\")\n            .content(StdFunctions.file(FileArgs.builder()\n                .input(\"path/to/my.js\")\n                .build()).result())\n            .build());\n\n        var exampleTrigger = new WorkersCronTrigger(\"exampleTrigger\", WorkersCronTriggerArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .scriptName(exampleScript.name())\n            .schedules(            \n                \"*/5 * * * *\",\n                \"10 7 * * mon-fri\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleScript:\n    type: cloudflare:WorkersScript\n    name: example_script\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example-script\n      content:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: path/to/my.js\n          Return: result\n  exampleTrigger:\n    type: cloudflare:WorkersCronTrigger\n    name: example_trigger\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      scriptName: ${exampleScript.name}\n      schedules:\n        - '*/5 * * * *'\n        - 10 7 * * mon-fri\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersCronTrigger:WorkersCronTrigger example \u003caccount_id\u003e/\u003cscript_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cron expressions to execute the Worker script.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules.\n"
                }
            },
            "required": [
                "accountId",
                "schedules",
                "scriptName"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cron expressions to execute the Worker script.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "schedules",
                "scriptName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersCronTrigger resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "schedules": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cron expressions to execute the Worker script.\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script to target for the schedules.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersDomain:WorkersDomain": {
            "description": "Creates a Worker Custom Domain.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WorkersDomain(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostname: \"subdomain.example.com\",\n    service: \"my-service\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WorkersDomain(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname=\"subdomain.example.com\",\n    service=\"my-service\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WorkersDomain(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Hostname = \"subdomain.example.com\",\n        Service = \"my-service\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkersDomain(ctx, \"example\", \u0026cloudflare.WorkersDomainArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tHostname:  pulumi.String(\"subdomain.example.com\"),\n\t\t\tService:   pulumi.String(\"my-service\"),\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersDomain;\nimport com.pulumi.cloudflare.WorkersDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WorkersDomain(\"example\", WorkersDomainArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostname(\"subdomain.example.com\")\n            .service(\"my-service\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WorkersDomain\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      hostname: subdomain.example.com\n      service: my-service\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersDomain:WorkersDomain example \u003caccount_id\u003e/\u003cworker_domain_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment. Defaults to `production`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname of the Worker Domain.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Name of worker script to attach the domain to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "hostname",
                "service",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment. Defaults to `production`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname of the Worker Domain.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Name of worker script to attach the domain to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "hostname",
                "service",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "environment": {
                        "type": "string",
                        "description": "The name of the Worker environment. Defaults to `production`.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname of the Worker Domain.\n"
                    },
                    "service": {
                        "type": "string",
                        "description": "Name of worker script to attach the domain to.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersForPlatformsDispatchNamespace:WorkersForPlatformsDispatchNamespace": {
            "description": "The [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/) resource allows you\nto manage Cloudflare Workers for Platforms dispatch namespaces.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst example = new cloudflare.WorkersForPlatformsDispatchNamespace(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example-namespace\",\n});\nconst customerWorker1 = new cloudflare.WorkersScript(\"customer_worker_1\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"customer-worker-1\",\n    content: std.file({\n        input: \"script.js\",\n    }).then(invoke =\u003e invoke.result),\n    dispatchNamespace: example.name,\n    tags: [\"free\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\nexample = cloudflare.WorkersForPlatformsDispatchNamespace(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example-namespace\")\ncustomer_worker1 = cloudflare.WorkersScript(\"customer_worker_1\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"customer-worker-1\",\n    content=std.file(input=\"script.js\").result,\n    dispatch_namespace=example.name,\n    tags=[\"free\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WorkersForPlatformsDispatchNamespace(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example-namespace\",\n    });\n\n    var customerWorker1 = new Cloudflare.WorkersScript(\"customer_worker_1\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"customer-worker-1\",\n        Content = Std.File.Invoke(new()\n        {\n            Input = \"script.js\",\n        }).Apply(invoke =\u003e invoke.Result),\n        DispatchNamespace = example.Name,\n        Tags = new[]\n        {\n            \"free\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.NewWorkersForPlatformsDispatchNamespace(ctx, \"example\", \u0026cloudflare.WorkersForPlatformsDispatchNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"script.js\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkersScript(ctx, \"customer_worker_1\", \u0026cloudflare.WorkersScriptArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:              pulumi.String(\"customer-worker-1\"),\n\t\t\tContent:           pulumi.String(invokeFile.Result),\n\t\t\tDispatchNamespace: example.Name,\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"free\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersForPlatformsDispatchNamespace;\nimport com.pulumi.cloudflare.WorkersForPlatformsDispatchNamespaceArgs;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkersScriptArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WorkersForPlatformsDispatchNamespace(\"example\", WorkersForPlatformsDispatchNamespaceArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example-namespace\")\n            .build());\n\n        var customerWorker1 = new WorkersScript(\"customerWorker1\", WorkersScriptArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"customer-worker-1\")\n            .content(StdFunctions.file(FileArgs.builder()\n                .input(\"script.js\")\n                .build()).result())\n            .dispatchNamespace(example.name())\n            .tags(\"free\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WorkersForPlatformsDispatchNamespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example-namespace\n  customerWorker1:\n    type: cloudflare:WorkersScript\n    name: customer_worker_1\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: customer-worker-1\n      content:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: script.js\n          Return: result\n      dispatchNamespace: ${example.name}\n      tags:\n        - free\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersForPlatformsDispatchNamespace:WorkersForPlatformsDispatchNamespace example \u003caccount_id\u003e/\u003cnamespace_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Workers for Platforms namespace.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Workers for Platforms namespace.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersForPlatformsDispatchNamespace resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Workers for Platforms namespace.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersForPlatformsNamespace:WorkersForPlatformsNamespace": {
            "description": "The [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/) resource allows you\nto manage Cloudflare Workers for Platforms namespaces.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst example = new cloudflare.WorkersForPlatformsNamespace(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example-namespace\",\n});\nconst customerWorker1 = new cloudflare.WorkersScript(\"customer_worker_1\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"customer-worker-1\",\n    content: std.file({\n        input: \"script.js\",\n    }).then(invoke =\u003e invoke.result),\n    dispatchNamespace: example.name,\n    tags: [\"free\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\nexample = cloudflare.WorkersForPlatformsNamespace(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example-namespace\")\ncustomer_worker1 = cloudflare.WorkersScript(\"customer_worker_1\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"customer-worker-1\",\n    content=std.file(input=\"script.js\").result,\n    dispatch_namespace=example.name,\n    tags=[\"free\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WorkersForPlatformsNamespace(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example-namespace\",\n    });\n\n    var customerWorker1 = new Cloudflare.WorkersScript(\"customer_worker_1\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"customer-worker-1\",\n        Content = Std.File.Invoke(new()\n        {\n            Input = \"script.js\",\n        }).Apply(invoke =\u003e invoke.Result),\n        DispatchNamespace = example.Name,\n        Tags = new[]\n        {\n            \"free\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.NewWorkersForPlatformsNamespace(ctx, \"example\", \u0026cloudflare.WorkersForPlatformsNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"script.js\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkersScript(ctx, \"customer_worker_1\", \u0026cloudflare.WorkersScriptArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:              pulumi.String(\"customer-worker-1\"),\n\t\t\tContent:           pulumi.String(invokeFile.Result),\n\t\t\tDispatchNamespace: example.Name,\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"free\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersForPlatformsNamespace;\nimport com.pulumi.cloudflare.WorkersForPlatformsNamespaceArgs;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkersScriptArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WorkersForPlatformsNamespace(\"example\", WorkersForPlatformsNamespaceArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example-namespace\")\n            .build());\n\n        var customerWorker1 = new WorkersScript(\"customerWorker1\", WorkersScriptArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"customer-worker-1\")\n            .content(StdFunctions.file(FileArgs.builder()\n                .input(\"script.js\")\n                .build()).result())\n            .dispatchNamespace(example.name())\n            .tags(\"free\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WorkersForPlatformsNamespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example-namespace\n  customerWorker1:\n    type: cloudflare:WorkersScript\n    name: customer_worker_1\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: customer-worker-1\n      content:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: script.js\n          Return: result\n      dispatchNamespace: ${example.name}\n      tags:\n        - free\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersForPlatformsNamespace:WorkersForPlatformsNamespace example \u003caccount_id\u003e/\u003cnamespace_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Workers for Platforms namespace.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Workers for Platforms namespace.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersForPlatformsNamespace resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Workers for Platforms namespace.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKv:WorkersKv": {
            "description": "Provides a resource to manage a Cloudflare Workers KV Pair.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleNs = new cloudflare.WorkersKvNamespace(\"example_ns\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"test-namespace\",\n});\nconst example = new cloudflare.WorkersKv(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    namespaceId: exampleNs.id,\n    key: \"test-key\",\n    value: \"test value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_ns = cloudflare.WorkersKvNamespace(\"example_ns\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"test-namespace\")\nexample = cloudflare.WorkersKv(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    namespace_id=example_ns.id,\n    key=\"test-key\",\n    value=\"test value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleNs = new Cloudflare.WorkersKvNamespace(\"example_ns\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"test-namespace\",\n    });\n\n    var example = new Cloudflare.WorkersKv(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        NamespaceId = exampleNs.Id,\n        Key = \"test-key\",\n        Value = \"test value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleNs, err := cloudflare.NewWorkersKvNamespace(ctx, \"example_ns\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"test-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkersKv(ctx, \"example\", \u0026cloudflare.WorkersKvArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tNamespaceId: exampleNs.ID(),\n\t\t\tKey:         pulumi.String(\"test-key\"),\n\t\t\tValue:       pulumi.String(\"test value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport com.pulumi.cloudflare.WorkersKv;\nimport com.pulumi.cloudflare.WorkersKvArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleNs = new WorkersKvNamespace(\"exampleNs\", WorkersKvNamespaceArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"test-namespace\")\n            .build());\n\n        var example = new WorkersKv(\"example\", WorkersKvArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .namespaceId(exampleNs.id())\n            .key(\"test-key\")\n            .value(\"test value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleNs:\n    type: cloudflare:WorkersKvNamespace\n    name: example_ns\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      title: test-namespace\n  example:\n    type: cloudflare:WorkersKv\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      namespaceId: ${exampleNs.id}\n      key: test-key\n      value: test value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersKv:WorkersKv example \u003caccount_id\u003e/\u003cnamespace_id\u003e/\u003ckey_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Name of the KV pair. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the KV pair.\n"
                }
            },
            "required": [
                "accountId",
                "key",
                "namespaceId",
                "value"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Name of the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the KV pair.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "key",
                "namespaceId",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKv resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Name of the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of the KV pair.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKvNamespace:WorkersKvNamespace": {
            "description": "Provides the ability to manage Cloudflare Workers KV Namespace features.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WorkersKvNamespace(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"test-namespace\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WorkersKvNamespace(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"test-namespace\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WorkersKvNamespace(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"test-namespace\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkersKvNamespace(ctx, \"example\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"test-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WorkersKvNamespace(\"example\", WorkersKvNamespaceArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"test-namespace\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WorkersKvNamespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      title: test-namespace\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersKvNamespace:WorkersKvNamespace example \u003caccount_id\u003e/\u003cnamespace_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title value of the Worker KV Namespace.\n"
                }
            },
            "required": [
                "accountId",
                "title"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title value of the Worker KV Namespace.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKvNamespace resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title value of the Worker KV Namespace.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersRoute:WorkersRoute": {
            "description": "Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myScript = new cloudflare.WorkersScript(\"my_script\", {});\n// Runs the specified worker script for all URLs that match `example.com/*`\nconst myRoute = new cloudflare.WorkersRoute(\"my_route\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    pattern: \"example.com/*\",\n    scriptName: myScript.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_script = cloudflare.WorkersScript(\"my_script\")\n# Runs the specified worker script for all URLs that match `example.com/*`\nmy_route = cloudflare.WorkersRoute(\"my_route\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    pattern=\"example.com/*\",\n    script_name=my_script.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myScript = new Cloudflare.WorkersScript(\"my_script\");\n\n    // Runs the specified worker script for all URLs that match `example.com/*`\n    var myRoute = new Cloudflare.WorkersRoute(\"my_route\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Pattern = \"example.com/*\",\n        ScriptName = myScript.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyScript, err := cloudflare.NewWorkersScript(ctx, \"my_script\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Runs the specified worker script for all URLs that match `example.com/*`\n\t\t_, err = cloudflare.NewWorkersRoute(ctx, \"my_route\", \u0026cloudflare.WorkersRouteArgs{\n\t\t\tZoneId:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tPattern:    pulumi.String(\"example.com/*\"),\n\t\t\tScriptName: myScript.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkersRoute;\nimport com.pulumi.cloudflare.WorkersRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myScript = new WorkersScript(\"myScript\");\n\n        // Runs the specified worker script for all URLs that match `example.com/*`\n        var myRoute = new WorkersRoute(\"myRoute\", WorkersRouteArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .pattern(\"example.com/*\")\n            .scriptName(myScript.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Runs the specified worker script for all URLs that match `example.com/*`\n  myRoute:\n    type: cloudflare:WorkersRoute\n    name: my_route\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      pattern: example.com/*\n      scriptName: ${myScript.name}\n  myScript:\n    type: cloudflare:WorkersScript\n    name: my_script\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersRoute:WorkersRoute example \u003czone_id\u003e/\u003croute_id\u003e\n```\n\n",
            "properties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script name to invoke for requests that match the route pattern.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "pattern",
                "zoneId"
            ],
            "inputProperties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script name to invoke for requests that match the route pattern.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "pattern",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersRoute resources.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script name to invoke for requests that match the route pattern.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersScript:WorkersScript": {
            "description": "Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as std from \"@pulumi/std\";\n\nconst myNamespace = new cloudflare.WorkersKvNamespace(\"my_namespace\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"example\",\n});\n// Sets the script with the name \"script_1\"\nconst myScript = new cloudflare.WorkersScript(\"my_script\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"script_1\",\n    content: std.file({\n        input: \"script.js\",\n    }).then(invoke =\u003e invoke.result),\n    kvNamespaceBindings: [{\n        name: \"MY_EXAMPLE_KV_NAMESPACE\",\n        namespaceId: myNamespace.id,\n    }],\n    plainTextBindings: [{\n        name: \"MY_EXAMPLE_PLAIN_TEXT\",\n        text: \"foobar\",\n    }],\n    secretTextBindings: [{\n        name: \"MY_EXAMPLE_SECRET_TEXT\",\n        text: secretFooValue,\n    }],\n    webassemblyBindings: [{\n        name: \"MY_EXAMPLE_WASM\",\n        module: std.filebase64({\n            input: \"example.wasm\",\n        }).then(invoke =\u003e invoke.result),\n    }],\n    serviceBindings: [{\n        name: \"MY_SERVICE_BINDING\",\n        service: \"MY_SERVICE\",\n        environment: \"production\",\n    }],\n    r2BucketBindings: [{\n        name: \"MY_BUCKET\",\n        bucketName: \"MY_BUCKET_NAME\",\n    }],\n    analyticsEngineBindings: [{\n        name: \"MY_DATASET\",\n        dataset: \"dataset1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_std as std\n\nmy_namespace = cloudflare.WorkersKvNamespace(\"my_namespace\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"example\")\n# Sets the script with the name \"script_1\"\nmy_script = cloudflare.WorkersScript(\"my_script\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"script_1\",\n    content=std.file(input=\"script.js\").result,\n    kv_namespace_bindings=[{\n        \"name\": \"MY_EXAMPLE_KV_NAMESPACE\",\n        \"namespace_id\": my_namespace.id,\n    }],\n    plain_text_bindings=[{\n        \"name\": \"MY_EXAMPLE_PLAIN_TEXT\",\n        \"text\": \"foobar\",\n    }],\n    secret_text_bindings=[{\n        \"name\": \"MY_EXAMPLE_SECRET_TEXT\",\n        \"text\": secret_foo_value,\n    }],\n    webassembly_bindings=[{\n        \"name\": \"MY_EXAMPLE_WASM\",\n        \"module\": std.filebase64(input=\"example.wasm\").result,\n    }],\n    service_bindings=[{\n        \"name\": \"MY_SERVICE_BINDING\",\n        \"service\": \"MY_SERVICE\",\n        \"environment\": \"production\",\n    }],\n    r2_bucket_bindings=[{\n        \"name\": \"MY_BUCKET\",\n        \"bucket_name\": \"MY_BUCKET_NAME\",\n    }],\n    analytics_engine_bindings=[{\n        \"name\": \"MY_DATASET\",\n        \"dataset\": \"dataset1\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myNamespace = new Cloudflare.WorkersKvNamespace(\"my_namespace\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"example\",\n    });\n\n    // Sets the script with the name \"script_1\"\n    var myScript = new Cloudflare.WorkersScript(\"my_script\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"script_1\",\n        Content = Std.File.Invoke(new()\n        {\n            Input = \"script.js\",\n        }).Apply(invoke =\u003e invoke.Result),\n        KvNamespaceBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptKvNamespaceBindingArgs\n            {\n                Name = \"MY_EXAMPLE_KV_NAMESPACE\",\n                NamespaceId = myNamespace.Id,\n            },\n        },\n        PlainTextBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptPlainTextBindingArgs\n            {\n                Name = \"MY_EXAMPLE_PLAIN_TEXT\",\n                Text = \"foobar\",\n            },\n        },\n        SecretTextBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptSecretTextBindingArgs\n            {\n                Name = \"MY_EXAMPLE_SECRET_TEXT\",\n                Text = secretFooValue,\n            },\n        },\n        WebassemblyBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptWebassemblyBindingArgs\n            {\n                Name = \"MY_EXAMPLE_WASM\",\n                Module = Std.Filebase64.Invoke(new()\n                {\n                    Input = \"example.wasm\",\n                }).Apply(invoke =\u003e invoke.Result),\n            },\n        },\n        ServiceBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptServiceBindingArgs\n            {\n                Name = \"MY_SERVICE_BINDING\",\n                Service = \"MY_SERVICE\",\n                Environment = \"production\",\n            },\n        },\n        R2BucketBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptR2BucketBindingArgs\n            {\n                Name = \"MY_BUCKET\",\n                BucketName = \"MY_BUCKET_NAME\",\n            },\n        },\n        AnalyticsEngineBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkersScriptAnalyticsEngineBindingArgs\n            {\n                Name = \"MY_DATASET\",\n                Dataset = \"dataset1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyNamespace, err := cloudflare.NewWorkersKvNamespace(ctx, \"my_namespace\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"script.js\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeFilebase641, err := std.Filebase64(ctx, \u0026std.Filebase64Args{\n\t\t\tInput: \"example.wasm\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sets the script with the name \"script_1\"\n\t\t_, err = cloudflare.NewWorkersScript(ctx, \"my_script\", \u0026cloudflare.WorkersScriptArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"script_1\"),\n\t\t\tContent:   pulumi.String(invokeFile.Result),\n\t\t\tKvNamespaceBindings: cloudflare.WorkersScriptKvNamespaceBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptKvNamespaceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_EXAMPLE_KV_NAMESPACE\"),\n\t\t\t\t\tNamespaceId: myNamespace.ID(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPlainTextBindings: cloudflare.WorkersScriptPlainTextBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptPlainTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_PLAIN_TEXT\"),\n\t\t\t\t\tText: pulumi.String(\"foobar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tSecretTextBindings: cloudflare.WorkersScriptSecretTextBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptSecretTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_SECRET_TEXT\"),\n\t\t\t\t\tText: pulumi.Any(secretFooValue),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWebassemblyBindings: cloudflare.WorkersScriptWebassemblyBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptWebassemblyBindingArgs{\n\t\t\t\t\tName:   pulumi.String(\"MY_EXAMPLE_WASM\"),\n\t\t\t\t\tModule: pulumi.String(invokeFilebase641.Result),\n\t\t\t\t},\n\t\t\t},\n\t\t\tServiceBindings: cloudflare.WorkersScriptServiceBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptServiceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_SERVICE_BINDING\"),\n\t\t\t\t\tService:     pulumi.String(\"MY_SERVICE\"),\n\t\t\t\t\tEnvironment: pulumi.String(\"production\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tR2BucketBindings: cloudflare.WorkersScriptR2BucketBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptR2BucketBindingArgs{\n\t\t\t\t\tName:       pulumi.String(\"MY_BUCKET\"),\n\t\t\t\t\tBucketName: pulumi.String(\"MY_BUCKET_NAME\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tAnalyticsEngineBindings: cloudflare.WorkersScriptAnalyticsEngineBindingArray{\n\t\t\t\t\u0026cloudflare.WorkersScriptAnalyticsEngineBindingArgs{\n\t\t\t\t\tName:    pulumi.String(\"MY_DATASET\"),\n\t\t\t\t\tDataset: pulumi.String(\"dataset1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport com.pulumi.cloudflare.WorkersScript;\nimport com.pulumi.cloudflare.WorkersScriptArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptKvNamespaceBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptPlainTextBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptSecretTextBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptWebassemblyBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptServiceBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptR2BucketBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkersScriptAnalyticsEngineBindingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myNamespace = new WorkersKvNamespace(\"myNamespace\", WorkersKvNamespaceArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"example\")\n            .build());\n\n        // Sets the script with the name \"script_1\"\n        var myScript = new WorkersScript(\"myScript\", WorkersScriptArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"script_1\")\n            .content(StdFunctions.file(FileArgs.builder()\n                .input(\"script.js\")\n                .build()).result())\n            .kvNamespaceBindings(WorkersScriptKvNamespaceBindingArgs.builder()\n                .name(\"MY_EXAMPLE_KV_NAMESPACE\")\n                .namespaceId(myNamespace.id())\n                .build())\n            .plainTextBindings(WorkersScriptPlainTextBindingArgs.builder()\n                .name(\"MY_EXAMPLE_PLAIN_TEXT\")\n                .text(\"foobar\")\n                .build())\n            .secretTextBindings(WorkersScriptSecretTextBindingArgs.builder()\n                .name(\"MY_EXAMPLE_SECRET_TEXT\")\n                .text(secretFooValue)\n                .build())\n            .webassemblyBindings(WorkersScriptWebassemblyBindingArgs.builder()\n                .name(\"MY_EXAMPLE_WASM\")\n                .module(StdFunctions.filebase64(Filebase64Args.builder()\n                    .input(\"example.wasm\")\n                    .build()).result())\n                .build())\n            .serviceBindings(WorkersScriptServiceBindingArgs.builder()\n                .name(\"MY_SERVICE_BINDING\")\n                .service(\"MY_SERVICE\")\n                .environment(\"production\")\n                .build())\n            .r2BucketBindings(WorkersScriptR2BucketBindingArgs.builder()\n                .name(\"MY_BUCKET\")\n                .bucketName(\"MY_BUCKET_NAME\")\n                .build())\n            .analyticsEngineBindings(WorkersScriptAnalyticsEngineBindingArgs.builder()\n                .name(\"MY_DATASET\")\n                .dataset(\"dataset1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myNamespace:\n    type: cloudflare:WorkersKvNamespace\n    name: my_namespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      title: example\n  # Sets the script with the name \"script_1\"\n  myScript:\n    type: cloudflare:WorkersScript\n    name: my_script\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: script_1\n      content:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: script.js\n          Return: result\n      kvNamespaceBindings:\n        - name: MY_EXAMPLE_KV_NAMESPACE\n          namespaceId: ${myNamespace.id}\n      plainTextBindings:\n        - name: MY_EXAMPLE_PLAIN_TEXT\n          text: foobar\n      secretTextBindings:\n        - name: MY_EXAMPLE_SECRET_TEXT\n          text: ${secretFooValue}\n      webassemblyBindings:\n        - name: MY_EXAMPLE_WASM\n          module:\n            fn::invoke:\n              Function: std:filebase64\n              Arguments:\n                input: example.wasm\n              Return: result\n      serviceBindings:\n        - name: MY_SERVICE_BINDING\n          service: MY_SERVICE\n          environment: production\n      r2BucketBindings:\n        - name: MY_BUCKET\n          bucketName: MY_BUCKET_NAME\n      analyticsEngineBindings:\n        - name: MY_DATASET\n          dataset: dataset1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersScript:WorkersScript example \u003caccount_id\u003e/\u003cscript_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "analyticsEngineBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptAnalyticsEngineBinding:WorkersScriptAnalyticsEngineBinding"
                    }
                },
                "compatibilityDate": {
                    "type": "string",
                    "description": "The date to use for the compatibility flag.\n"
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Compatibility flags used for Worker Scripts.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "d1DatabaseBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptD1DatabaseBinding:WorkersScriptD1DatabaseBinding"
                    }
                },
                "dispatchNamespace": {
                    "type": "string",
                    "description": "Name of the Workers for Platforms dispatch namespace.\n"
                },
                "hyperdriveConfigBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptHyperdriveConfigBinding:WorkersScriptHyperdriveConfigBinding"
                    }
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptKvNamespaceBinding:WorkersScriptKvNamespaceBinding"
                    }
                },
                "logpush": {
                    "type": "boolean",
                    "description": "Enabling allows Worker events to be sent to a defined Logpush destination.\n"
                },
                "module": {
                    "type": "boolean",
                    "description": "Whether to upload Worker as a module.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "placements": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptPlacement:WorkersScriptPlacement"
                    }
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptPlainTextBinding:WorkersScriptPlainTextBinding"
                    }
                },
                "queueBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptQueueBinding:WorkersScriptQueueBinding"
                    }
                },
                "r2BucketBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptR2BucketBinding:WorkersScriptR2BucketBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptSecretTextBinding:WorkersScriptSecretTextBinding"
                    }
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptServiceBinding:WorkersScriptServiceBinding"
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptWebassemblyBinding:WorkersScriptWebassemblyBinding"
                    }
                }
            },
            "required": [
                "accountId",
                "compatibilityFlags",
                "content",
                "name",
                "tags"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "analyticsEngineBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptAnalyticsEngineBinding:WorkersScriptAnalyticsEngineBinding"
                    }
                },
                "compatibilityDate": {
                    "type": "string",
                    "description": "The date to use for the compatibility flag.\n"
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Compatibility flags used for Worker Scripts.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "d1DatabaseBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptD1DatabaseBinding:WorkersScriptD1DatabaseBinding"
                    }
                },
                "dispatchNamespace": {
                    "type": "string",
                    "description": "Name of the Workers for Platforms dispatch namespace.\n"
                },
                "hyperdriveConfigBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptHyperdriveConfigBinding:WorkersScriptHyperdriveConfigBinding"
                    }
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptKvNamespaceBinding:WorkersScriptKvNamespaceBinding"
                    }
                },
                "logpush": {
                    "type": "boolean",
                    "description": "Enabling allows Worker events to be sent to a defined Logpush destination.\n"
                },
                "module": {
                    "type": "boolean",
                    "description": "Whether to upload Worker as a module.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "placements": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptPlacement:WorkersScriptPlacement"
                    }
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptPlainTextBinding:WorkersScriptPlainTextBinding"
                    }
                },
                "queueBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptQueueBinding:WorkersScriptQueueBinding"
                    }
                },
                "r2BucketBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptR2BucketBinding:WorkersScriptR2BucketBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptSecretTextBinding:WorkersScriptSecretTextBinding"
                    }
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptServiceBinding:WorkersScriptServiceBinding"
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkersScriptWebassemblyBinding:WorkersScriptWebassemblyBinding"
                    }
                }
            },
            "requiredInputs": [
                "accountId",
                "content",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersScript resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "analyticsEngineBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptAnalyticsEngineBinding:WorkersScriptAnalyticsEngineBinding"
                        }
                    },
                    "compatibilityDate": {
                        "type": "string",
                        "description": "The date to use for the compatibility flag.\n"
                    },
                    "compatibilityFlags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Compatibility flags used for Worker Scripts.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "The script content.\n"
                    },
                    "d1DatabaseBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptD1DatabaseBinding:WorkersScriptD1DatabaseBinding"
                        }
                    },
                    "dispatchNamespace": {
                        "type": "string",
                        "description": "Name of the Workers for Platforms dispatch namespace.\n"
                    },
                    "hyperdriveConfigBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptHyperdriveConfigBinding:WorkersScriptHyperdriveConfigBinding"
                        }
                    },
                    "kvNamespaceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptKvNamespaceBinding:WorkersScriptKvNamespaceBinding"
                        }
                    },
                    "logpush": {
                        "type": "boolean",
                        "description": "Enabling allows Worker events to be sent to a defined Logpush destination.\n"
                    },
                    "module": {
                        "type": "boolean",
                        "description": "Whether to upload Worker as a module.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "placements": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptPlacement:WorkersScriptPlacement"
                        }
                    },
                    "plainTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptPlainTextBinding:WorkersScriptPlainTextBinding"
                        }
                    },
                    "queueBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptQueueBinding:WorkersScriptQueueBinding"
                        }
                    },
                    "r2BucketBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptR2BucketBinding:WorkersScriptR2BucketBinding"
                        }
                    },
                    "secretTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptSecretTextBinding:WorkersScriptSecretTextBinding"
                        }
                    },
                    "serviceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptServiceBinding:WorkersScriptServiceBinding"
                        }
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webassemblyBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkersScriptWebassemblyBinding:WorkersScriptWebassemblyBinding"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersSecret:WorkersSecret": {
            "description": "Provides a Cloudflare Worker secret resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst mySecret = new cloudflare.WorkersSecret(\"my_secret\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"MY_EXAMPLE_SECRET_TEXT\",\n    scriptName: \"script_1\",\n    secretText: \"my_secret_value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_secret = cloudflare.WorkersSecret(\"my_secret\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"MY_EXAMPLE_SECRET_TEXT\",\n    script_name=\"script_1\",\n    secret_text=\"my_secret_value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mySecret = new Cloudflare.WorkersSecret(\"my_secret\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"MY_EXAMPLE_SECRET_TEXT\",\n        ScriptName = \"script_1\",\n        SecretText = \"my_secret_value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkersSecret(ctx, \"my_secret\", \u0026cloudflare.WorkersSecretArgs{\n\t\t\tAccountId:  pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:       pulumi.String(\"MY_EXAMPLE_SECRET_TEXT\"),\n\t\t\tScriptName: pulumi.String(\"script_1\"),\n\t\t\tSecretText: pulumi.String(\"my_secret_value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersSecret;\nimport com.pulumi.cloudflare.WorkersSecretArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mySecret = new WorkersSecret(\"mySecret\", WorkersSecretArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"MY_EXAMPLE_SECRET_TEXT\")\n            .scriptName(\"script_1\")\n            .secretText(\"my_secret_value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mySecret:\n    type: cloudflare:WorkersSecret\n    name: my_secret\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: MY_EXAMPLE_SECRET_TEXT\n      scriptName: script_1\n      secretText: my_secret_value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/workersSecret:WorkersSecret example \u003caccount_id\u003e/\u003cscript_name\u003e/\u003csecret_name\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "secretText": {
                    "type": "string",
                    "description": "The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                }
            },
            "required": [
                "accountId",
                "name",
                "scriptName",
                "secretText"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "scriptName": {
                    "type": "string",
                    "description": "The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "secretText": {
                    "type": "string",
                    "description": "The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "scriptName",
                "secretText"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersSecret resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "secretText": {
                        "type": "string",
                        "description": "The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessApplication:ZeroTrustAccessApplication": {
            "description": "Provides a Cloudflare Access Application resource. Access\nApplications are used to restrict access to a whole application using an\nauthorisation gateway managed by Cloudflare.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessApplication:ZeroTrustAccessApplication example \u003caccount_id\u003e/\u003capplication_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherLogoUrl": {
                    "type": "string",
                    "description": "The logo URL of the app launcher.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the application.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                },
                "bgColor": {
                    "type": "string",
                    "description": "The background color of the app launcher.\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationCorsHeader:ZeroTrustAccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via identity based rules.\n"
                },
                "customNonIdentityDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via non identity rules.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The custom pages selected for the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "footerLinks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationFooterLink:ZeroTrustAccessApplicationFooterLink"
                    },
                    "description": "The footer links of the app launcher.\n"
                },
                "headerBgColor": {
                    "type": "string",
                    "description": "The background color of the header bar in the app launcher.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean",
                    "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                },
                "landingPageDesign": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationLandingPageDesign:ZeroTrustAccessApplicationLandingPageDesign",
                    "description": "The landing page design of the app launcher.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "optionsPreflightBypass": {
                    "type": "boolean",
                    "description": "Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.\n"
                },
                "saasApp": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasApp:ZeroTrustAccessApplicationSaasApp",
                    "description": "SaaS configuration for the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string",
                    "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                },
                "scimConfig": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationScimConfig:ZeroTrustAccessApplicationScimConfig",
                    "description": "Configuration for provisioning to this application via SCIM. This is currently in closed beta.\n"
                },
                "selfHostedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.\n"
                },
                "serviceAuth401Redirect": {
                    "type": "boolean",
                    "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                },
                "skipAppLauncherLoginPage": {
                    "type": "boolean",
                    "description": "Option to skip the App Launcher landing page. Defaults to `false`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean",
                    "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The itags associated with the application.\n"
                },
                "targetCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationTargetCriteria:ZeroTrustAccessApplicationTargetCriteria"
                    },
                    "description": "The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "aud",
                "domain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherLogoUrl": {
                    "type": "string",
                    "description": "The logo URL of the app launcher.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                },
                "bgColor": {
                    "type": "string",
                    "description": "The background color of the app launcher.\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationCorsHeader:ZeroTrustAccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via identity based rules.\n"
                },
                "customNonIdentityDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application via non identity rules.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The custom pages selected for the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "footerLinks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationFooterLink:ZeroTrustAccessApplicationFooterLink"
                    },
                    "description": "The footer links of the app launcher.\n"
                },
                "headerBgColor": {
                    "type": "string",
                    "description": "The background color of the header bar in the app launcher.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean",
                    "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                },
                "landingPageDesign": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationLandingPageDesign:ZeroTrustAccessApplicationLandingPageDesign",
                    "description": "The landing page design of the app launcher.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "optionsPreflightBypass": {
                    "type": "boolean",
                    "description": "Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.\n"
                },
                "saasApp": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasApp:ZeroTrustAccessApplicationSaasApp",
                    "description": "SaaS configuration for the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string",
                    "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                },
                "scimConfig": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationScimConfig:ZeroTrustAccessApplicationScimConfig",
                    "description": "Configuration for provisioning to this application via SCIM. This is currently in closed beta.\n"
                },
                "selfHostedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.\n"
                },
                "serviceAuth401Redirect": {
                    "type": "boolean",
                    "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                },
                "skipAppLauncherLoginPage": {
                    "type": "boolean",
                    "description": "Option to skip the App Launcher landing page. Defaults to `false`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean",
                    "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The itags associated with the application.\n"
                },
                "targetCriterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationTargetCriteria:ZeroTrustAccessApplicationTargetCriteria"
                    },
                    "description": "The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessApplication resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "allowAuthenticateViaWarp": {
                        "type": "boolean",
                        "description": "When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.\n"
                    },
                    "allowedIdps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identity providers selected for the application.\n"
                    },
                    "appLauncherLogoUrl": {
                        "type": "string",
                        "description": "The logo URL of the app launcher.\n"
                    },
                    "appLauncherVisible": {
                        "type": "boolean",
                        "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the application.\n"
                    },
                    "autoRedirectToIdentity": {
                        "type": "boolean",
                        "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                    },
                    "bgColor": {
                        "type": "string",
                        "description": "The background color of the app launcher.\n"
                    },
                    "corsHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationCorsHeader:ZeroTrustAccessApplicationCorsHeader"
                        },
                        "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                    },
                    "customDenyMessage": {
                        "type": "string",
                        "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                    },
                    "customDenyUrl": {
                        "type": "string",
                        "description": "Option that redirects to a custom URL when a user is denied access to the application via identity based rules.\n"
                    },
                    "customNonIdentityDenyUrl": {
                        "type": "string",
                        "description": "Option that redirects to a custom URL when a user is denied access to the application via non identity rules.\n"
                    },
                    "customPages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The custom pages selected for the application.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.\n"
                    },
                    "enableBindingCookie": {
                        "type": "boolean",
                        "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                    },
                    "footerLinks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationFooterLink:ZeroTrustAccessApplicationFooterLink"
                        },
                        "description": "The footer links of the app launcher.\n"
                    },
                    "headerBgColor": {
                        "type": "string",
                        "description": "The background color of the header bar in the app launcher.\n"
                    },
                    "httpOnlyCookieAttribute": {
                        "type": "boolean",
                        "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                    },
                    "landingPageDesign": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationLandingPageDesign:ZeroTrustAccessApplicationLandingPageDesign",
                        "description": "The landing page design of the app launcher.\n"
                    },
                    "logoUrl": {
                        "type": "string",
                        "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "optionsPreflightBypass": {
                        "type": "boolean",
                        "description": "Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.\n"
                    },
                    "saasApp": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationSaasApp:ZeroTrustAccessApplicationSaasApp",
                        "description": "SaaS configuration for the Access Application.\n"
                    },
                    "sameSiteCookieAttribute": {
                        "type": "string",
                        "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                    },
                    "scimConfig": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationScimConfig:ZeroTrustAccessApplicationScimConfig",
                        "description": "Configuration for provisioning to this application via SCIM. This is currently in closed beta.\n"
                    },
                    "selfHostedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.\n"
                    },
                    "serviceAuth401Redirect": {
                        "type": "boolean",
                        "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                    },
                    "skipAppLauncherLoginPage": {
                        "type": "boolean",
                        "description": "Option to skip the App Launcher landing page. Defaults to `false`.\n"
                    },
                    "skipInterstitial": {
                        "type": "boolean",
                        "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The itags associated with the application.\n"
                    },
                    "targetCriterias": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessApplicationTargetCriteria:ZeroTrustAccessApplicationTargetCriteria"
                        },
                        "description": "The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessCustomPage:ZeroTrustAccessCustomPage": {
            "description": "Provides a resource to customize the pages your end users will see\nwhen trying to reach applications behind Cloudflare Access.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustAccessCustomPage(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"example\",\n    type: \"forbidden\",\n    customHtml: \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustAccessCustomPage(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"example\",\n    type=\"forbidden\",\n    custom_html=\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustAccessCustomPage(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"example\",\n        Type = \"forbidden\",\n        CustomHtml = \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustAccessCustomPage(ctx, \"example\", \u0026cloudflare.ZeroTrustAccessCustomPageArgs{\n\t\t\tZoneId:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:       pulumi.String(\"example\"),\n\t\t\tType:       pulumi.String(\"forbidden\"),\n\t\t\tCustomHtml: pulumi.String(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustAccessCustomPage;\nimport com.pulumi.cloudflare.ZeroTrustAccessCustomPageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustAccessCustomPage(\"example\", ZeroTrustAccessCustomPageArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"example\")\n            .type(\"forbidden\")\n            .customHtml(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustAccessCustomPage\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: example\n      type: forbidden\n      customHtml: \u003chtml\u003e\u003cbody\u003e\u003ch1\u003eForbidden\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps to display on the custom page.\n"
                },
                "customHtml": {
                    "type": "string",
                    "description": "Custom HTML to display on the custom page.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Custom Page configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps to display on the custom page.\n"
                },
                "customHtml": {
                    "type": "string",
                    "description": "Custom HTML to display on the custom page.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Custom Page configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessCustomPage resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "appCount": {
                        "type": "integer",
                        "description": "Number of apps to display on the custom page.\n"
                    },
                    "customHtml": {
                        "type": "string",
                        "description": "Custom HTML to display on the custom page.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Custom Page configuration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessGroup:ZeroTrustAccessGroup": {
            "description": "Provides a Cloudflare Access Group resource. Access Groups are used\nin conjunction with Access Policies to restrict access to a\nparticular resource based on group membership.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessGroup:ZeroTrustAccessGroup example \u003caccount_id\u003e/\u003cgroup_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExclude:ZeroTrustAccessGroupExclude"
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupInclude:ZeroTrustAccessGroupInclude"
                    }
                },
                "name": {
                    "type": "string"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequire:ZeroTrustAccessGroupRequire"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "includes",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExclude:ZeroTrustAccessGroupExclude"
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupInclude:ZeroTrustAccessGroupInclude"
                    }
                },
                "name": {
                    "type": "string"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequire:ZeroTrustAccessGroupRequire"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessGroup resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupExclude:ZeroTrustAccessGroupExclude"
                        }
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupInclude:ZeroTrustAccessGroupInclude"
                        }
                    },
                    "name": {
                        "type": "string"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessGroupRequire:ZeroTrustAccessGroupRequire"
                        }
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessIdentityProvider:ZeroTrustAccessIdentityProvider": {
            "description": "Provides a Cloudflare Access Identity Provider resource. Identity\nProviders are used as an authentication or authorisation source\nwithin Access.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// one time pin\nconst pinLogin = new cloudflare.ZeroTrustAccessIdentityProvider(\"pin_login\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"PIN login\",\n    type: \"onetimepin\",\n});\n// oauth\nconst githubOauth = new cloudflare.ZeroTrustAccessIdentityProvider(\"github_oauth\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"GitHub OAuth\",\n    type: \"github\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n    }],\n});\n// saml\nconst jumpcloudSaml = new cloudflare.ZeroTrustAccessIdentityProvider(\"jumpcloud_saml\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"JumpCloud SAML\",\n    type: \"saml\",\n    configs: [{\n        issuerUrl: \"jumpcloud\",\n        ssoTargetUrl: \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n        attributes: [\n            \"email\",\n            \"username\",\n        ],\n        signRequest: false,\n        idpPublicCert: `MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o`,\n    }],\n});\n// okta\nconst okta = new cloudflare.ZeroTrustAccessIdentityProvider(\"okta\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Okta\",\n    type: \"okta\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n        apiToken: \"okta_api_token\",\n        oktaAccount: \"https://example.com\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# one time pin\npin_login = cloudflare.ZeroTrustAccessIdentityProvider(\"pin_login\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"PIN login\",\n    type=\"onetimepin\")\n# oauth\ngithub_oauth = cloudflare.ZeroTrustAccessIdentityProvider(\"github_oauth\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"GitHub OAuth\",\n    type=\"github\",\n    configs=[{\n        \"client_id\": \"example\",\n        \"client_secret\": \"secret_key\",\n    }])\n# saml\njumpcloud_saml = cloudflare.ZeroTrustAccessIdentityProvider(\"jumpcloud_saml\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"JumpCloud SAML\",\n    type=\"saml\",\n    configs=[{\n        \"issuer_url\": \"jumpcloud\",\n        \"sso_target_url\": \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n        \"attributes\": [\n            \"email\",\n            \"username\",\n        ],\n        \"sign_request\": False,\n        \"idp_public_cert\": \"\"\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\"\"\",\n    }])\n# okta\nokta = cloudflare.ZeroTrustAccessIdentityProvider(\"okta\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Okta\",\n    type=\"okta\",\n    configs=[{\n        \"client_id\": \"example\",\n        \"client_secret\": \"secret_key\",\n        \"api_token\": \"okta_api_token\",\n        \"okta_account\": \"https://example.com\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // one time pin\n    var pinLogin = new Cloudflare.ZeroTrustAccessIdentityProvider(\"pin_login\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"PIN login\",\n        Type = \"onetimepin\",\n    });\n\n    // oauth\n    var githubOauth = new Cloudflare.ZeroTrustAccessIdentityProvider(\"github_oauth\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"GitHub OAuth\",\n        Type = \"github\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustAccessIdentityProviderConfigArgs\n            {\n                ClientId = \"example\",\n                ClientSecret = \"secret_key\",\n            },\n        },\n    });\n\n    // saml\n    var jumpcloudSaml = new Cloudflare.ZeroTrustAccessIdentityProvider(\"jumpcloud_saml\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"JumpCloud SAML\",\n        Type = \"saml\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustAccessIdentityProviderConfigArgs\n            {\n                IssuerUrl = \"jumpcloud\",\n                SsoTargetUrl = \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n                Attributes = new[]\n                {\n                    \"email\",\n                    \"username\",\n                },\n                SignRequest = false,\n                IdpPublicCert = @\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\",\n            },\n        },\n    });\n\n    // okta\n    var okta = new Cloudflare.ZeroTrustAccessIdentityProvider(\"okta\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Okta\",\n        Type = \"okta\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustAccessIdentityProviderConfigArgs\n            {\n                ClientId = \"example\",\n                ClientSecret = \"secret_key\",\n                ApiToken = \"okta_api_token\",\n                OktaAccount = \"https://example.com\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// one time pin\n\t\t_, err := cloudflare.NewZeroTrustAccessIdentityProvider(ctx, \"pin_login\", \u0026cloudflare.ZeroTrustAccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"PIN login\"),\n\t\t\tType:      pulumi.String(\"onetimepin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// oauth\n\t\t_, err = cloudflare.NewZeroTrustAccessIdentityProvider(ctx, \"github_oauth\", \u0026cloudflare.ZeroTrustAccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"GitHub OAuth\"),\n\t\t\tType:      pulumi.String(\"github\"),\n\t\t\tConfigs: cloudflare.ZeroTrustAccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustAccessIdentityProviderConfigArgs{\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// saml\n\t\t_, err = cloudflare.NewZeroTrustAccessIdentityProvider(ctx, \"jumpcloud_saml\", \u0026cloudflare.ZeroTrustAccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"JumpCloud SAML\"),\n\t\t\tType:      pulumi.String(\"saml\"),\n\t\t\tConfigs: cloudflare.ZeroTrustAccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustAccessIdentityProviderConfigArgs{\n\t\t\t\t\tIssuerUrl:    pulumi.String(\"jumpcloud\"),\n\t\t\t\t\tSsoTargetUrl: pulumi.String(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\"),\n\t\t\t\t\tAttributes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"email\"),\n\t\t\t\t\t\tpulumi.String(\"username\"),\n\t\t\t\t\t},\n\t\t\t\t\tSignRequest:   pulumi.Bool(false),\n\t\t\t\t\tIdpPublicCert: pulumi.String(\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// okta\n\t\t_, err = cloudflare.NewZeroTrustAccessIdentityProvider(ctx, \"okta\", \u0026cloudflare.ZeroTrustAccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"Okta\"),\n\t\t\tType:      pulumi.String(\"okta\"),\n\t\t\tConfigs: cloudflare.ZeroTrustAccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustAccessIdentityProviderConfigArgs{\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t\tApiToken:     pulumi.String(\"okta_api_token\"),\n\t\t\t\t\tOktaAccount:  pulumi.String(\"https://example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustAccessIdentityProvider;\nimport com.pulumi.cloudflare.ZeroTrustAccessIdentityProviderArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustAccessIdentityProviderConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // one time pin\n        var pinLogin = new ZeroTrustAccessIdentityProvider(\"pinLogin\", ZeroTrustAccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"PIN login\")\n            .type(\"onetimepin\")\n            .build());\n\n        // oauth\n        var githubOauth = new ZeroTrustAccessIdentityProvider(\"githubOauth\", ZeroTrustAccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"GitHub OAuth\")\n            .type(\"github\")\n            .configs(ZeroTrustAccessIdentityProviderConfigArgs.builder()\n                .clientId(\"example\")\n                .clientSecret(\"secret_key\")\n                .build())\n            .build());\n\n        // saml\n        var jumpcloudSaml = new ZeroTrustAccessIdentityProvider(\"jumpcloudSaml\", ZeroTrustAccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"JumpCloud SAML\")\n            .type(\"saml\")\n            .configs(ZeroTrustAccessIdentityProviderConfigArgs.builder()\n                .issuerUrl(\"jumpcloud\")\n                .ssoTargetUrl(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\")\n                .attributes(                \n                    \"email\",\n                    \"username\")\n                .signRequest(false)\n                .idpPublicCert(\"\"\"\nMIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o                \"\"\")\n                .build())\n            .build());\n\n        // okta\n        var okta = new ZeroTrustAccessIdentityProvider(\"okta\", ZeroTrustAccessIdentityProviderArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Okta\")\n            .type(\"okta\")\n            .configs(ZeroTrustAccessIdentityProviderConfigArgs.builder()\n                .clientId(\"example\")\n                .clientSecret(\"secret_key\")\n                .apiToken(\"okta_api_token\")\n                .oktaAccount(\"https://example.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # one time pin\n  pinLogin:\n    type: cloudflare:ZeroTrustAccessIdentityProvider\n    name: pin_login\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: PIN login\n      type: onetimepin\n  # oauth\n  githubOauth:\n    type: cloudflare:ZeroTrustAccessIdentityProvider\n    name: github_oauth\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: GitHub OAuth\n      type: github\n      configs:\n        - clientId: example\n          clientSecret: secret_key\n  # saml\n  jumpcloudSaml:\n    type: cloudflare:ZeroTrustAccessIdentityProvider\n    name: jumpcloud_saml\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: JumpCloud SAML\n      type: saml\n      configs:\n        - issuerUrl: jumpcloud\n          ssoTargetUrl: https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\n          attributes:\n            - email\n            - username\n          signRequest: false\n          idpPublicCert: |-\n            MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\n            uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n  # okta\n  okta:\n    type: cloudflare:ZeroTrustAccessIdentityProvider\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Okta\n      type: okta\n      configs:\n        - clientId: example\n          clientSecret: secret_key\n          apiToken: okta_api_token\n          oktaAccount: https://example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessIdentityProvider:ZeroTrustAccessIdentityProvider example \u003caccount_id\u003e/\u003cidentity_provider_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessIdentityProviderConfig:ZeroTrustAccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "scimConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessIdentityProviderScimConfig:ZeroTrustAccessIdentityProviderScimConfig"
                    },
                    "description": "Configuration for SCIM settings for a given IDP.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "configs",
                "name",
                "scimConfigs",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessIdentityProviderConfig:ZeroTrustAccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "scimConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessIdentityProviderScimConfig:ZeroTrustAccessIdentityProviderScimConfig"
                    },
                    "description": "Configuration for SCIM settings for a given IDP.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessIdentityProvider resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessIdentityProviderConfig:ZeroTrustAccessIdentityProviderConfig"
                        },
                        "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Identity Provider configuration.\n"
                    },
                    "scimConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessIdentityProviderScimConfig:ZeroTrustAccessIdentityProviderScimConfig"
                        },
                        "description": "Configuration for SCIM settings for a given IDP.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessMtlsCertificate:ZeroTrustAccessMtlsCertificate": {
            "description": "Provides a Cloudflare Access Mutual TLS Certificate resource.\nMutual TLS authentication ensures that the traffic is secure and\ntrusted in both directions between a client and server and can be\n used with Access to only allows requests from devices with a\n corresponding client certificate.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myCert = new cloudflare.ZeroTrustAccessMtlsCertificate(\"my_cert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"My Root Cert\",\n    certificate: caPem,\n    associatedHostnames: [\"staging.example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_cert = cloudflare.ZeroTrustAccessMtlsCertificate(\"my_cert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"My Root Cert\",\n    certificate=ca_pem,\n    associated_hostnames=[\"staging.example.com\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCert = new Cloudflare.ZeroTrustAccessMtlsCertificate(\"my_cert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"My Root Cert\",\n        Certificate = caPem,\n        AssociatedHostnames = new[]\n        {\n            \"staging.example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustAccessMtlsCertificate(ctx, \"my_cert\", \u0026cloudflare.ZeroTrustAccessMtlsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:        pulumi.String(\"My Root Cert\"),\n\t\t\tCertificate: pulumi.Any(caPem),\n\t\t\tAssociatedHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"staging.example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustAccessMtlsCertificate;\nimport com.pulumi.cloudflare.ZeroTrustAccessMtlsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCert = new ZeroTrustAccessMtlsCertificate(\"myCert\", ZeroTrustAccessMtlsCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"My Root Cert\")\n            .certificate(caPem)\n            .associatedHostnames(\"staging.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCert:\n    type: cloudflare:ZeroTrustAccessMtlsCertificate\n    name: my_cert\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: My Root Cert\n      certificate: ${caPem}\n      associatedHostnames:\n        - staging.example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAccount level import.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessMtlsCertificate:ZeroTrustAccessMtlsCertificate cloudflare_zero_sd -t_access_mtls_certificate.example account/\u003caccount_id\u003e/\u003cmutual_tls_certificate_id\u003e\n```\n\nZone level import.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessMtlsCertificate:ZeroTrustAccessMtlsCertificate cloudflare_zero_sd -t_access_mtls_certificate.example zone/\u003czone_id\u003e/\u003cmutual_tls_certificate_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "fingerprint": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "fingerprint",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessMtlsCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "associatedHostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames that will be prompted for this certificate.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The Root CA for your certificates.\n"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessMtlsHostnameSettings:ZeroTrustAccessMtlsHostnameSettings": {
            "description": "Provides a Cloudflare Access Mutual TLS Certificate Settings resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustAccessMtlsHostnameSettings(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    settings: [{\n        hostname: \"example.com\",\n        clientCertificateForwarding: true,\n        chinaNetwork: false,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustAccessMtlsHostnameSettings(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    settings=[{\n        \"hostname\": \"example.com\",\n        \"client_certificate_forwarding\": True,\n        \"china_network\": False,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustAccessMtlsHostnameSettings(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Settings = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustAccessMtlsHostnameSettingsSettingArgs\n            {\n                Hostname = \"example.com\",\n                ClientCertificateForwarding = true,\n                ChinaNetwork = false,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustAccessMtlsHostnameSettings(ctx, \"example\", \u0026cloudflare.ZeroTrustAccessMtlsHostnameSettingsArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tSettings: cloudflare.ZeroTrustAccessMtlsHostnameSettingsSettingArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustAccessMtlsHostnameSettingsSettingArgs{\n\t\t\t\t\tHostname:                    pulumi.String(\"example.com\"),\n\t\t\t\t\tClientCertificateForwarding: pulumi.Bool(true),\n\t\t\t\t\tChinaNetwork:                pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustAccessMtlsHostnameSettings;\nimport com.pulumi.cloudflare.ZeroTrustAccessMtlsHostnameSettingsArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustAccessMtlsHostnameSettingsSettingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustAccessMtlsHostnameSettings(\"example\", ZeroTrustAccessMtlsHostnameSettingsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .settings(ZeroTrustAccessMtlsHostnameSettingsSettingArgs.builder()\n                .hostname(\"example.com\")\n                .clientCertificateForwarding(true)\n                .chinaNetwork(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustAccessMtlsHostnameSettings\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      settings:\n        - hostname: example.com\n          clientCertificateForwarding: true\n          chinaNetwork: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAccount level mTLS hostname settings import.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessMtlsHostnameSettings:ZeroTrustAccessMtlsHostnameSettings example account/\u003caccount_id\u003e\n```\n\nZone level mTLS hostname settings import.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessMtlsHostnameSettings:ZeroTrustAccessMtlsHostnameSettings example zone/\u003czone_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessMtlsHostnameSettingsSetting:ZeroTrustAccessMtlsHostnameSettingsSetting"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessMtlsHostnameSettingsSetting:ZeroTrustAccessMtlsHostnameSettingsSetting"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessMtlsHostnameSettings resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "settings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessMtlsHostnameSettingsSetting:ZeroTrustAccessMtlsHostnameSettingsSetting"
                        }
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessOrganization:ZeroTrustAccessOrganization": {
            "description": "A Zero Trust organization defines the user login experience.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.\n"
                },
                "authDomain": {
                    "type": "string",
                    "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "When set to true, users skip the identity provider selection step during login.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessOrganizationCustomPage:ZeroTrustAccessOrganizationCustomPage"
                    },
                    "description": "Custom pages for your Zero Trust organization.\n"
                },
                "isUiReadOnly": {
                    "type": "boolean",
                    "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                },
                "loginDesigns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessOrganizationLoginDesign:ZeroTrustAccessOrganizationLoginDesign"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your Zero Trust organization.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "uiReadOnlyToggleReason": {
                    "type": "string",
                    "description": "A description of the reason why the UI read only field is being toggled.\n"
                },
                "userSeatExpirationInactiveTime": {
                    "type": "string",
                    "description": "The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.\n"
                },
                "warpAuthSessionDuration": {
                    "type": "string",
                    "description": "The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "authDomain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowAuthenticateViaWarp": {
                    "type": "boolean",
                    "description": "When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.\n"
                },
                "authDomain": {
                    "type": "string",
                    "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "When set to true, users skip the identity provider selection step during login.\n"
                },
                "customPages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessOrganizationCustomPage:ZeroTrustAccessOrganizationCustomPage"
                    },
                    "description": "Custom pages for your Zero Trust organization.\n"
                },
                "isUiReadOnly": {
                    "type": "boolean",
                    "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                },
                "loginDesigns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessOrganizationLoginDesign:ZeroTrustAccessOrganizationLoginDesign"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your Zero Trust organization.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "uiReadOnlyToggleReason": {
                    "type": "string",
                    "description": "A description of the reason why the UI read only field is being toggled.\n"
                },
                "userSeatExpirationInactiveTime": {
                    "type": "string",
                    "description": "The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.\n"
                },
                "warpAuthSessionDuration": {
                    "type": "string",
                    "description": "The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "authDomain",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessOrganization resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "allowAuthenticateViaWarp": {
                        "type": "boolean",
                        "description": "When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.\n"
                    },
                    "authDomain": {
                        "type": "string",
                        "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                    },
                    "autoRedirectToIdentity": {
                        "type": "boolean",
                        "description": "When set to true, users skip the identity provider selection step during login.\n"
                    },
                    "customPages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessOrganizationCustomPage:ZeroTrustAccessOrganizationCustomPage"
                        },
                        "description": "Custom pages for your Zero Trust organization.\n"
                    },
                    "isUiReadOnly": {
                        "type": "boolean",
                        "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                    },
                    "loginDesigns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessOrganizationLoginDesign:ZeroTrustAccessOrganizationLoginDesign"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of your Zero Trust organization.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                    },
                    "uiReadOnlyToggleReason": {
                        "type": "string",
                        "description": "A description of the reason why the UI read only field is being toggled.\n"
                    },
                    "userSeatExpirationInactiveTime": {
                        "type": "string",
                        "description": "The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.\n"
                    },
                    "warpAuthSessionDuration": {
                        "type": "string",
                        "description": "The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy": {
            "description": "Provides a Cloudflare Access Policy resource. Access Policies are\nused in conjunction with Access Applications to restrict access to\na particular resource.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in most cases using either is fine.\n   However, if you're using a scoped access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\" zone needs to use the `zone_id` argument.\n   If 'application_id' is omitted, the policy created can be reused by multiple access applications.\n   Any cloudflare.AccessApplication resource can reference reusable policies through its `policies` argument.\n   To destroy a reusable policy and remove it from all applications' policies lists on the same apply, preemptively set the\n   lifecycle option `create_before_destroy` to true on the 'cloudflare_access_policy' resource.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy example account/\u003caccount_id\u003e/\u003capplication_id\u003e/\u003cpolicy_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyApprovalGroup:ZeroTrustAccessPolicyApprovalGroup"
                    }
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "connectionRules": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyConnectionRules:ZeroTrustAccessPolicyConnectionRules",
                    "description": "The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExclude:ZeroTrustAccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyInclude:ZeroTrustAccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "isolationRequired": {
                    "type": "boolean",
                    "description": "Require this application to be served in an isolated browser for users matching this policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Required when using `application_id`.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequire:ZeroTrustAccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "decision",
                "includes",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyApprovalGroup:ZeroTrustAccessPolicyApprovalGroup"
                    }
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "connectionRules": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyConnectionRules:ZeroTrustAccessPolicyConnectionRules",
                    "description": "The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExclude:ZeroTrustAccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyInclude:ZeroTrustAccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "isolationRequired": {
                    "type": "boolean",
                    "description": "Require this application to be served in an isolated browser for users matching this policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Required when using `application_id`.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequire:ZeroTrustAccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see Access Groups.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "decision",
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "approvalGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyApprovalGroup:ZeroTrustAccessPolicyApprovalGroup"
                        }
                    },
                    "approvalRequired": {
                        "type": "boolean"
                    },
                    "connectionRules": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyConnectionRules:ZeroTrustAccessPolicyConnectionRules",
                        "description": "The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.\n"
                    },
                    "decision": {
                        "type": "string",
                        "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyExclude:ZeroTrustAccessPolicyExclude"
                        },
                        "description": "A series of access conditions, see Access Groups.\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyInclude:ZeroTrustAccessPolicyInclude"
                        },
                        "description": "A series of access conditions, see Access Groups.\n"
                    },
                    "isolationRequired": {
                        "type": "boolean",
                        "description": "Require this application to be served in an isolated browser for users matching this policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Policy.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The unique precedence for policies on a single application. Required when using `application_id`.\n"
                    },
                    "purposeJustificationPrompt": {
                        "type": "string",
                        "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                    },
                    "purposeJustificationRequired": {
                        "type": "boolean",
                        "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustAccessPolicyRequire:ZeroTrustAccessPolicyRequire"
                        },
                        "description": "A series of access conditions, see Access Groups.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessServiceToken:ZeroTrustAccessServiceToken": {
            "description": "Access Service Tokens are used for service-to-service communication\nwhen an application is behind Cloudflare Access.\n\n## Import\n\nIf you are importing an Access Service Token you will not have the\n\nclient_secret available in the state for use. The client_secret is only\n\navailable once, at creation. In most cases, it is better to just create a new\n\nresource should you need to reference it in other resources.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessServiceToken:ZeroTrustAccessServiceToken example \u003caccount_id\u003e/\u003cservice_token_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                },
                "duration": {
                    "type": "string",
                    "description": "Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Date when the token expires.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "clientId",
                "clientSecret",
                "duration",
                "expiresAt",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "duration": {
                    "type": "string",
                    "description": "Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessServiceToken resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "duration": {
                        "type": "string",
                        "description": "Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Date when the token expires.\n"
                    },
                    "minDaysForRenewal": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the token's intent.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessShortLivedCertificate:ZeroTrustAccessShortLivedCertificate": {
            "description": "Cloudflare Access can replace traditional SSH key models with\nshort-lived certificates issued to your users based on the token\ngenerated by their Access login.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\n   most cases using either is fine. However, if you're using a scoped\n   access token, you must provide the argument that matches the token's\n   scope. For example, an access token that is scoped to the \"example.com\"\n   zone needs to use the `zone_id` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// account level\nconst example = new cloudflare.ZeroTrustAccessShortLivedCertificate(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    applicationId: \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n});\n// zone level\nconst anotherExample = new cloudflare.ZeroTrustAccessShortLivedCertificate(\"another_example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    applicationId: \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# account level\nexample = cloudflare.ZeroTrustAccessShortLivedCertificate(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    application_id=\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n# zone level\nanother_example = cloudflare.ZeroTrustAccessShortLivedCertificate(\"another_example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    application_id=\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // account level\n    var example = new Cloudflare.ZeroTrustAccessShortLivedCertificate(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ApplicationId = \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n    });\n\n    // zone level\n    var anotherExample = new Cloudflare.ZeroTrustAccessShortLivedCertificate(\"another_example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        ApplicationId = \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// account level\n\t\t_, err := cloudflare.NewZeroTrustAccessShortLivedCertificate(ctx, \"example\", \u0026cloudflare.ZeroTrustAccessShortLivedCertificateArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tApplicationId: pulumi.String(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// zone level\n\t\t_, err = cloudflare.NewZeroTrustAccessShortLivedCertificate(ctx, \"another_example\", \u0026cloudflare.ZeroTrustAccessShortLivedCertificateArgs{\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tApplicationId: pulumi.String(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustAccessShortLivedCertificate;\nimport com.pulumi.cloudflare.ZeroTrustAccessShortLivedCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // account level\n        var example = new ZeroTrustAccessShortLivedCertificate(\"example\", ZeroTrustAccessShortLivedCertificateArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .applicationId(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n            .build());\n\n        // zone level\n        var anotherExample = new ZeroTrustAccessShortLivedCertificate(\"anotherExample\", ZeroTrustAccessShortLivedCertificateArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .applicationId(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # account level\n  example:\n    type: cloudflare:ZeroTrustAccessShortLivedCertificate\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      applicationId: 6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\n  # zone level\n  anotherExample:\n    type: cloudflare:ZeroTrustAccessShortLivedCertificate\n    name: another_example\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      applicationId: fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAccount level CA certificate import.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessShortLivedCertificate:ZeroTrustAccessShortLivedCertificate example account/\u003caccount_id\u003e/\u003capplication_id\u003e\n```\n\nZone level CA certificate import.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustAccessShortLivedCertificate:ZeroTrustAccessShortLivedCertificate example account/\u003czone_id\u003e/\u003capplication_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the CA certificate.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Cryptographic public key of the generated CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "applicationId",
                "aud",
                "publicKey",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "applicationId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessShortLivedCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The Access Application ID to associate with the CA certificate.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the CA certificate.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Cryptographic public key of the generated CA certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustAccessTag:ZeroTrustAccessTag": {
            "description": "Provides a resource to customize the pages your end users will see\nwhen trying to reach applications behind Cloudflare Access.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps associated with the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Tag.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "appCount",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "appCount": {
                    "type": "integer",
                    "description": "Number of apps associated with the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Tag.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustAccessTag resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "appCount": {
                        "type": "integer",
                        "description": "Number of apps associated with the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Tag.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDeviceCertificates:ZeroTrustDeviceCertificates": {
            "description": "Provides a Cloudflare device policy certificates resource. Device\npolicy certificate resources enable client device certificate\ngeneration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustDeviceCertificates(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustDeviceCertificates(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustDeviceCertificates(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDeviceCertificates(ctx, \"example\", \u0026cloudflare.ZeroTrustDeviceCertificatesArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDeviceCertificates;\nimport com.pulumi.cloudflare.ZeroTrustDeviceCertificatesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustDeviceCertificates(\"example\", ZeroTrustDeviceCertificatesArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustDeviceCertificates\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDeviceCertificates:ZeroTrustDeviceCertificates example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if certificate generation is enabled.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if certificate generation is enabled.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDeviceCertificates resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "`true` if certificate generation is enabled.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDeviceManagedNetworks:ZeroTrustDeviceManagedNetworks": {
            "description": "Provides a Cloudflare Device Managed Network resource. Device managed networks allow for building location-aware device settings policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst managedNetworks = new cloudflare.ZeroTrustDeviceManagedNetworks(\"managed_networks\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"managed-network-1\",\n    type: \"tls\",\n    config: {\n        tlsSockaddr: \"foobar:1234\",\n        sha256: \"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmanaged_networks = cloudflare.ZeroTrustDeviceManagedNetworks(\"managed_networks\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"managed-network-1\",\n    type=\"tls\",\n    config={\n        \"tls_sockaddr\": \"foobar:1234\",\n        \"sha256\": \"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var managedNetworks = new Cloudflare.ZeroTrustDeviceManagedNetworks(\"managed_networks\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"managed-network-1\",\n        Type = \"tls\",\n        Config = new Cloudflare.Inputs.ZeroTrustDeviceManagedNetworksConfigArgs\n        {\n            TlsSockaddr = \"foobar:1234\",\n            Sha256 = \"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDeviceManagedNetworks(ctx, \"managed_networks\", \u0026cloudflare.ZeroTrustDeviceManagedNetworksArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"managed-network-1\"),\n\t\t\tType:      pulumi.String(\"tls\"),\n\t\t\tConfig: \u0026cloudflare.ZeroTrustDeviceManagedNetworksConfigArgs{\n\t\t\t\tTlsSockaddr: pulumi.String(\"foobar:1234\"),\n\t\t\t\tSha256:      pulumi.String(\"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDeviceManagedNetworks;\nimport com.pulumi.cloudflare.ZeroTrustDeviceManagedNetworksArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDeviceManagedNetworksConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var managedNetworks = new ZeroTrustDeviceManagedNetworks(\"managedNetworks\", ZeroTrustDeviceManagedNetworksArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"managed-network-1\")\n            .type(\"tls\")\n            .config(ZeroTrustDeviceManagedNetworksConfigArgs.builder()\n                .tlsSockaddr(\"foobar:1234\")\n                .sha256(\"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  managedNetworks:\n    type: cloudflare:ZeroTrustDeviceManagedNetworks\n    name: managed_networks\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: managed-network-1\n      type: tls\n      config:\n        tlsSockaddr: foobar:1234\n        sha256: b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDeviceManagedNetworks:ZeroTrustDeviceManagedNetworks example \u003caccount_id\u003e/\u003cdevice_managed_networks_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDeviceManagedNetworksConfig:ZeroTrustDeviceManagedNetworksConfig",
                    "description": "The configuration containing information for the WARP client to detect the managed network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Managed Network. Must be unique.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of Device Managed Network. Available values: `tls`.\n"
                }
            },
            "required": [
                "accountId",
                "config",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDeviceManagedNetworksConfig:ZeroTrustDeviceManagedNetworksConfig",
                    "description": "The configuration containing information for the WARP client to detect the managed network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Managed Network. Must be unique.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of Device Managed Network. Available values: `tls`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "config",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDeviceManagedNetworks resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "config": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDeviceManagedNetworksConfig:ZeroTrustDeviceManagedNetworksConfig",
                        "description": "The configuration containing information for the WARP client to detect the managed network.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Device Managed Network. Must be unique.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of Device Managed Network. Available values: `tls`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDevicePostureIntegration:ZeroTrustDevicePostureIntegration": {
            "description": "Provides a Cloudflare Device Posture Integration resource. Device\nposture integrations configure third-party data providers for device\nposture rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustDevicePostureIntegration(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Device posture integration\",\n    type: \"workspace_one\",\n    interval: \"24h\",\n    configs: [{\n        apiUrl: \"https://example.com/api\",\n        authUrl: \"https://example.com/connect/token\",\n        clientId: \"client-id\",\n        clientSecret: \"client-secret\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustDevicePostureIntegration(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Device posture integration\",\n    type=\"workspace_one\",\n    interval=\"24h\",\n    configs=[{\n        \"api_url\": \"https://example.com/api\",\n        \"auth_url\": \"https://example.com/connect/token\",\n        \"client_id\": \"client-id\",\n        \"client_secret\": \"client-secret\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustDevicePostureIntegration(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Device posture integration\",\n        Type = \"workspace_one\",\n        Interval = \"24h\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustDevicePostureIntegrationConfigArgs\n            {\n                ApiUrl = \"https://example.com/api\",\n                AuthUrl = \"https://example.com/connect/token\",\n                ClientId = \"client-id\",\n                ClientSecret = \"client-secret\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDevicePostureIntegration(ctx, \"example\", \u0026cloudflare.ZeroTrustDevicePostureIntegrationArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"Device posture integration\"),\n\t\t\tType:      pulumi.String(\"workspace_one\"),\n\t\t\tInterval:  pulumi.String(\"24h\"),\n\t\t\tConfigs: cloudflare.ZeroTrustDevicePostureIntegrationConfigArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustDevicePostureIntegrationConfigArgs{\n\t\t\t\t\tApiUrl:       pulumi.String(\"https://example.com/api\"),\n\t\t\t\t\tAuthUrl:      pulumi.String(\"https://example.com/connect/token\"),\n\t\t\t\t\tClientId:     pulumi.String(\"client-id\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"client-secret\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDevicePostureIntegration;\nimport com.pulumi.cloudflare.ZeroTrustDevicePostureIntegrationArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDevicePostureIntegrationConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustDevicePostureIntegration(\"example\", ZeroTrustDevicePostureIntegrationArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Device posture integration\")\n            .type(\"workspace_one\")\n            .interval(\"24h\")\n            .configs(ZeroTrustDevicePostureIntegrationConfigArgs.builder()\n                .apiUrl(\"https://example.com/api\")\n                .authUrl(\"https://example.com/connect/token\")\n                .clientId(\"client-id\")\n                .clientSecret(\"client-secret\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustDevicePostureIntegration\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Device posture integration\n      type: workspace_one\n      interval: 24h\n      configs:\n        - apiUrl: https://example.com/api\n          authUrl: https://example.com/connect/token\n          clientId: client-id\n          clientSecret: client-secret\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDevicePostureIntegration:ZeroTrustDevicePostureIntegration example \u003caccount_id\u003e/\u003cdevice_posture_integration_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureIntegrationConfig:ZeroTrustDevicePostureIntegrationConfig"
                    },
                    "description": "The device posture integration's connection authorization parameters.\n"
                },
                "identifier": {
                    "type": "string"
                },
                "interval": {
                    "type": "string",
                    "description": "Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture integration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureIntegrationConfig:ZeroTrustDevicePostureIntegrationConfig"
                    },
                    "description": "The device posture integration's connection authorization parameters.\n"
                },
                "identifier": {
                    "type": "string"
                },
                "interval": {
                    "type": "string",
                    "description": "Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture integration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDevicePostureIntegration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureIntegrationConfig:ZeroTrustDevicePostureIntegrationConfig"
                        },
                        "description": "The device posture integration's connection authorization parameters.\n"
                    },
                    "identifier": {
                        "type": "string"
                    },
                    "interval": {
                        "type": "string",
                        "description": "Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture integration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDevicePostureRule:ZeroTrustDevicePostureRule": {
            "description": "Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst eaxmple = new cloudflare.ZeroTrustDevicePostureRule(\"eaxmple\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Corporate devices posture rule\",\n    type: \"os_version\",\n    description: \"Device posture rule for corporate devices.\",\n    schedule: \"24h\",\n    expiration: \"24h\",\n    matches: [{\n        platform: \"linux\",\n    }],\n    inputs: [{\n        id: corporateDevices.id,\n        version: \"1.0.0\",\n        operator: \"\u003c\",\n        osDistroName: \"ubuntu\",\n        osDistroRevision: \"1.0.0\",\n        osVersionExtra: \"(a)\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\neaxmple = cloudflare.ZeroTrustDevicePostureRule(\"eaxmple\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Corporate devices posture rule\",\n    type=\"os_version\",\n    description=\"Device posture rule for corporate devices.\",\n    schedule=\"24h\",\n    expiration=\"24h\",\n    matches=[{\n        \"platform\": \"linux\",\n    }],\n    inputs=[{\n        \"id\": corporate_devices[\"id\"],\n        \"version\": \"1.0.0\",\n        \"operator\": \"\u003c\",\n        \"os_distro_name\": \"ubuntu\",\n        \"os_distro_revision\": \"1.0.0\",\n        \"os_version_extra\": \"(a)\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var eaxmple = new Cloudflare.ZeroTrustDevicePostureRule(\"eaxmple\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Corporate devices posture rule\",\n        Type = \"os_version\",\n        Description = \"Device posture rule for corporate devices.\",\n        Schedule = \"24h\",\n        Expiration = \"24h\",\n        Matches = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustDevicePostureRuleMatchArgs\n            {\n                Platform = \"linux\",\n            },\n        },\n        Inputs = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustDevicePostureRuleInputArgs\n            {\n                Id = corporateDevices.Id,\n                Version = \"1.0.0\",\n                Operator = \"\u003c\",\n                OsDistroName = \"ubuntu\",\n                OsDistroRevision = \"1.0.0\",\n                OsVersionExtra = \"(a)\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDevicePostureRule(ctx, \"eaxmple\", \u0026cloudflare.ZeroTrustDevicePostureRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"Corporate devices posture rule\"),\n\t\t\tType:        pulumi.String(\"os_version\"),\n\t\t\tDescription: pulumi.String(\"Device posture rule for corporate devices.\"),\n\t\t\tSchedule:    pulumi.String(\"24h\"),\n\t\t\tExpiration:  pulumi.String(\"24h\"),\n\t\t\tMatches: cloudflare.ZeroTrustDevicePostureRuleMatchArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustDevicePostureRuleMatchArgs{\n\t\t\t\t\tPlatform: pulumi.String(\"linux\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tInputs: cloudflare.ZeroTrustDevicePostureRuleInputTypeArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustDevicePostureRuleInputTypeArgs{\n\t\t\t\t\tId:               pulumi.Any(corporateDevices.Id),\n\t\t\t\t\tVersion:          pulumi.String(\"1.0.0\"),\n\t\t\t\t\tOperator:         pulumi.String(\"\u003c\"),\n\t\t\t\t\tOsDistroName:     pulumi.String(\"ubuntu\"),\n\t\t\t\t\tOsDistroRevision: pulumi.String(\"1.0.0\"),\n\t\t\t\t\tOsVersionExtra:   pulumi.String(\"(a)\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDevicePostureRule;\nimport com.pulumi.cloudflare.ZeroTrustDevicePostureRuleArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDevicePostureRuleMatchArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDevicePostureRuleInputArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var eaxmple = new ZeroTrustDevicePostureRule(\"eaxmple\", ZeroTrustDevicePostureRuleArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Corporate devices posture rule\")\n            .type(\"os_version\")\n            .description(\"Device posture rule for corporate devices.\")\n            .schedule(\"24h\")\n            .expiration(\"24h\")\n            .matches(ZeroTrustDevicePostureRuleMatchArgs.builder()\n                .platform(\"linux\")\n                .build())\n            .inputs(ZeroTrustDevicePostureRuleInputArgs.builder()\n                .id(corporateDevices.id())\n                .version(\"1.0.0\")\n                .operator(\"\u003c\")\n                .osDistroName(\"ubuntu\")\n                .osDistroRevision(\"1.0.0\")\n                .osVersionExtra(\"(a)\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  eaxmple:\n    type: cloudflare:ZeroTrustDevicePostureRule\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Corporate devices posture rule\n      type: os_version\n      description: Device posture rule for corporate devices.\n      schedule: 24h\n      expiration: 24h\n      matches:\n        - platform: linux\n      inputs:\n        - id: ${corporateDevices.id}\n          version: 1.0.0\n          operator: \u003c\n          osDistroName: ubuntu\n          osDistroRevision: 1.0.0\n          osVersionExtra: (a)\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDevicePostureRule:ZeroTrustDevicePostureRule example \u003caccount_id\u003e/\u003cdevice_posture_rule_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleInput:ZeroTrustDevicePostureRuleInput"
                    },
                    "description": "Required for all rule types except `warp`, `gateway`, and `tanium`.\n"
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleMatch:ZeroTrustDevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                }
            },
            "required": [
                "accountId",
                "inputs",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleInput:ZeroTrustDevicePostureRuleInput"
                    },
                    "description": "Required for all rule types except `warp`, `gateway`, and `tanium`.\n"
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleMatch:ZeroTrustDevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDevicePostureRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string",
                        "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                    },
                    "inputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleInput:ZeroTrustDevicePostureRuleInput"
                        },
                        "description": "Required for all rule types except `warp`, `gateway`, and `tanium`.\n"
                    },
                    "matches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustDevicePostureRuleMatch:ZeroTrustDevicePostureRuleMatch"
                        },
                        "description": "The conditions that the client must match to run the rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture rule.\n"
                    },
                    "schedule": {
                        "type": "string",
                        "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDeviceProfiles:ZeroTrustDeviceProfiles": {
            "description": "Provides a Cloudflare Device Settings Policy resource. Device policies configure settings applied to WARP devices.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst developerWarpPolicy = new cloudflare.ZeroTrustDeviceProfiles(\"developer_warp_policy\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Developers WARP settings policy\",\n    description: \"Developers WARP settings policy description\",\n    precedence: 10,\n    match: \"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n    \"default\": false,\n    enabled: true,\n    allowModeSwitch: true,\n    allowUpdates: true,\n    allowedToLeave: true,\n    autoConnect: 0,\n    captivePortal: 5,\n    disableAutoFallback: true,\n    supportUrl: \"https://cloudflare.com\",\n    switchLocked: true,\n    serviceModeV2Mode: \"warp\",\n    serviceModeV2Port: 3000,\n    excludeOfficeIps: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ndeveloper_warp_policy = cloudflare.ZeroTrustDeviceProfiles(\"developer_warp_policy\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Developers WARP settings policy\",\n    description=\"Developers WARP settings policy description\",\n    precedence=10,\n    match=\"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n    default=False,\n    enabled=True,\n    allow_mode_switch=True,\n    allow_updates=True,\n    allowed_to_leave=True,\n    auto_connect=0,\n    captive_portal=5,\n    disable_auto_fallback=True,\n    support_url=\"https://cloudflare.com\",\n    switch_locked=True,\n    service_mode_v2_mode=\"warp\",\n    service_mode_v2_port=3000,\n    exclude_office_ips=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var developerWarpPolicy = new Cloudflare.ZeroTrustDeviceProfiles(\"developer_warp_policy\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Developers WARP settings policy\",\n        Description = \"Developers WARP settings policy description\",\n        Precedence = 10,\n        Match = \"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n        Default = false,\n        Enabled = true,\n        AllowModeSwitch = true,\n        AllowUpdates = true,\n        AllowedToLeave = true,\n        AutoConnect = 0,\n        CaptivePortal = 5,\n        DisableAutoFallback = true,\n        SupportUrl = \"https://cloudflare.com\",\n        SwitchLocked = true,\n        ServiceModeV2Mode = \"warp\",\n        ServiceModeV2Port = 3000,\n        ExcludeOfficeIps = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDeviceProfiles(ctx, \"developer_warp_policy\", \u0026cloudflare.ZeroTrustDeviceProfilesArgs{\n\t\t\tAccountId:           pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:                pulumi.String(\"Developers WARP settings policy\"),\n\t\t\tDescription:         pulumi.String(\"Developers WARP settings policy description\"),\n\t\t\tPrecedence:          pulumi.Int(10),\n\t\t\tMatch:               pulumi.String(\"any(identity.groups.name[*] in {\\\"Developers\\\"})\"),\n\t\t\tDefault:             pulumi.Bool(false),\n\t\t\tEnabled:             pulumi.Bool(true),\n\t\t\tAllowModeSwitch:     pulumi.Bool(true),\n\t\t\tAllowUpdates:        pulumi.Bool(true),\n\t\t\tAllowedToLeave:      pulumi.Bool(true),\n\t\t\tAutoConnect:         pulumi.Int(0),\n\t\t\tCaptivePortal:       pulumi.Int(5),\n\t\t\tDisableAutoFallback: pulumi.Bool(true),\n\t\t\tSupportUrl:          pulumi.String(\"https://cloudflare.com\"),\n\t\t\tSwitchLocked:        pulumi.Bool(true),\n\t\t\tServiceModeV2Mode:   pulumi.String(\"warp\"),\n\t\t\tServiceModeV2Port:   pulumi.Int(3000),\n\t\t\tExcludeOfficeIps:    pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDeviceProfiles;\nimport com.pulumi.cloudflare.ZeroTrustDeviceProfilesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var developerWarpPolicy = new ZeroTrustDeviceProfiles(\"developerWarpPolicy\", ZeroTrustDeviceProfilesArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Developers WARP settings policy\")\n            .description(\"Developers WARP settings policy description\")\n            .precedence(10)\n            .match(\"any(identity.groups.name[*] in {\\\"Developers\\\"})\")\n            .default_(false)\n            .enabled(true)\n            .allowModeSwitch(true)\n            .allowUpdates(true)\n            .allowedToLeave(true)\n            .autoConnect(0)\n            .captivePortal(5)\n            .disableAutoFallback(true)\n            .supportUrl(\"https://cloudflare.com\")\n            .switchLocked(true)\n            .serviceModeV2Mode(\"warp\")\n            .serviceModeV2Port(3000)\n            .excludeOfficeIps(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  developerWarpPolicy:\n    type: cloudflare:ZeroTrustDeviceProfiles\n    name: developer_warp_policy\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Developers WARP settings policy\n      description: Developers WARP settings policy description\n      precedence: 10\n      match: any(identity.groups.name[*] in {\"Developers\"})\n      default: false\n      enabled: true\n      allowModeSwitch: true\n      allowUpdates: true\n      allowedToLeave: true\n      autoConnect: 0\n      captivePortal: 5\n      disableAutoFallback: true\n      supportUrl: https://cloudflare.com\n      switchLocked: true\n      serviceModeV2Mode: warp\n      serviceModeV2Port: 3000\n      excludeOfficeIps: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nFor default device settings policies you must use \"default\" as the policy ID.\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDeviceProfiles:ZeroTrustDeviceProfiles example \u003caccount_id\u003e/\u003cdevice_policy_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowModeSwitch": {
                    "type": "boolean",
                    "description": "Whether to allow mode switch for this policy.\n"
                },
                "allowUpdates": {
                    "type": "boolean",
                    "description": "Whether to allow updates under this policy.\n"
                },
                "allowedToLeave": {
                    "type": "boolean",
                    "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                },
                "autoConnect": {
                    "type": "integer",
                    "description": "The amount of time in seconds to reconnect after having been disabled.\n"
                },
                "captivePortal": {
                    "type": "integer",
                    "description": "The captive portal value for this policy. Defaults to `180`.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Whether the policy refers to the default account policy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of Policy.\n"
                },
                "disableAutoFallback": {
                    "type": "boolean",
                    "description": "Whether to disable auto fallback for this policy.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                },
                "excludeOfficeIps": {
                    "type": "boolean",
                    "description": "Whether to add Microsoft IPs to split tunnel exclusions.\n"
                },
                "match": {
                    "type": "string",
                    "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                },
                "serviceModeV2Mode": {
                    "type": "string",
                    "description": "The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.\n"
                },
                "serviceModeV2Port": {
                    "type": "integer",
                    "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "The support URL that will be opened when sending feedback.\n"
                },
                "switchLocked": {
                    "type": "boolean",
                    "description": "Enablement of the ZT client switch lock.\n"
                },
                "tunnelProtocol": {
                    "type": "string",
                    "description": "Determines which tunnel protocol to use. Available values: `\"\"`, `wireguard`, `masque`. Defaults to `wireguard`.\n"
                }
            },
            "required": [
                "accountId",
                "description",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowModeSwitch": {
                    "type": "boolean",
                    "description": "Whether to allow mode switch for this policy.\n"
                },
                "allowUpdates": {
                    "type": "boolean",
                    "description": "Whether to allow updates under this policy.\n"
                },
                "allowedToLeave": {
                    "type": "boolean",
                    "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                },
                "autoConnect": {
                    "type": "integer",
                    "description": "The amount of time in seconds to reconnect after having been disabled.\n"
                },
                "captivePortal": {
                    "type": "integer",
                    "description": "The captive portal value for this policy. Defaults to `180`.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Whether the policy refers to the default account policy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of Policy.\n"
                },
                "disableAutoFallback": {
                    "type": "boolean",
                    "description": "Whether to disable auto fallback for this policy.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                },
                "excludeOfficeIps": {
                    "type": "boolean",
                    "description": "Whether to add Microsoft IPs to split tunnel exclusions.\n"
                },
                "match": {
                    "type": "string",
                    "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                },
                "serviceModeV2Mode": {
                    "type": "string",
                    "description": "The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.\n"
                },
                "serviceModeV2Port": {
                    "type": "integer",
                    "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "The support URL that will be opened when sending feedback.\n"
                },
                "switchLocked": {
                    "type": "boolean",
                    "description": "Enablement of the ZT client switch lock.\n"
                },
                "tunnelProtocol": {
                    "type": "string",
                    "description": "Determines which tunnel protocol to use. Available values: `\"\"`, `wireguard`, `masque`. Defaults to `wireguard`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "description",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDeviceProfiles resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "allowModeSwitch": {
                        "type": "boolean",
                        "description": "Whether to allow mode switch for this policy.\n"
                    },
                    "allowUpdates": {
                        "type": "boolean",
                        "description": "Whether to allow updates under this policy.\n"
                    },
                    "allowedToLeave": {
                        "type": "boolean",
                        "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                    },
                    "autoConnect": {
                        "type": "integer",
                        "description": "The amount of time in seconds to reconnect after having been disabled.\n"
                    },
                    "captivePortal": {
                        "type": "integer",
                        "description": "The captive portal value for this policy. Defaults to `180`.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Whether the policy refers to the default account policy.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of Policy.\n"
                    },
                    "disableAutoFallback": {
                        "type": "boolean",
                        "description": "Whether to disable auto fallback for this policy.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                    },
                    "excludeOfficeIps": {
                        "type": "boolean",
                        "description": "Whether to add Microsoft IPs to split tunnel exclusions.\n"
                    },
                    "match": {
                        "type": "string",
                        "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the policy.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                    },
                    "serviceModeV2Mode": {
                        "type": "string",
                        "description": "The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.\n"
                    },
                    "serviceModeV2Port": {
                        "type": "integer",
                        "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                    },
                    "supportUrl": {
                        "type": "string",
                        "description": "The support URL that will be opened when sending feedback.\n"
                    },
                    "switchLocked": {
                        "type": "boolean",
                        "description": "Enablement of the ZT client switch lock.\n"
                    },
                    "tunnelProtocol": {
                        "type": "string",
                        "description": "Determines which tunnel protocol to use. Available values: `\"\"`, `wireguard`, `masque`. Defaults to `wireguard`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDexTest:ZeroTrustDexTest": {
            "description": "Provides a Cloudflare Device Dex Test resource. Device Dex Tests allow for building location-aware device settings policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustDexTest(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"GET homepage\",\n    description: \"Send a HTTP GET request to the home endpoint every half hour.\",\n    interval: \"0h30m0s\",\n    enabled: true,\n    data: {\n        host: \"https://example.com/home\",\n        kind: \"http\",\n        method: \"GET\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustDexTest(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"GET homepage\",\n    description=\"Send a HTTP GET request to the home endpoint every half hour.\",\n    interval=\"0h30m0s\",\n    enabled=True,\n    data={\n        \"host\": \"https://example.com/home\",\n        \"kind\": \"http\",\n        \"method\": \"GET\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustDexTest(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"GET homepage\",\n        Description = \"Send a HTTP GET request to the home endpoint every half hour.\",\n        Interval = \"0h30m0s\",\n        Enabled = true,\n        Data = new Cloudflare.Inputs.ZeroTrustDexTestDataArgs\n        {\n            Host = \"https://example.com/home\",\n            Kind = \"http\",\n            Method = \"GET\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDexTest(ctx, \"example\", \u0026cloudflare.ZeroTrustDexTestArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"GET homepage\"),\n\t\t\tDescription: pulumi.String(\"Send a HTTP GET request to the home endpoint every half hour.\"),\n\t\t\tInterval:    pulumi.String(\"0h30m0s\"),\n\t\t\tEnabled:     pulumi.Bool(true),\n\t\t\tData: \u0026cloudflare.ZeroTrustDexTestDataArgs{\n\t\t\t\tHost:   pulumi.String(\"https://example.com/home\"),\n\t\t\t\tKind:   pulumi.String(\"http\"),\n\t\t\t\tMethod: pulumi.String(\"GET\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDexTest;\nimport com.pulumi.cloudflare.ZeroTrustDexTestArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDexTestDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustDexTest(\"example\", ZeroTrustDexTestArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"GET homepage\")\n            .description(\"Send a HTTP GET request to the home endpoint every half hour.\")\n            .interval(\"0h30m0s\")\n            .enabled(true)\n            .data(ZeroTrustDexTestDataArgs.builder()\n                .host(\"https://example.com/home\")\n                .kind(\"http\")\n                .method(\"GET\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustDexTest\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: GET homepage\n      description: Send a HTTP GET request to the home endpoint every half hour.\n      interval: 0h30m0s\n      enabled: true\n      data:\n        host: https://example.com/home\n        kind: http\n        method: GET\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDexTest:ZeroTrustDexTest example \u003caccount_id\u003e/\u003cdevice_dex_test_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp of when the Dex Test was created.\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDexTestData:ZeroTrustDexTestData",
                    "description": "The configuration object which contains the details for the WARP client to conduct the test.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Additional details about the test.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines whether or not the test is active.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "How often the test will run.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Dex Test. Must be unique.\n"
                },
                "updated": {
                    "type": "string",
                    "description": "Timestamp of when the Dex Test was last updated.\n"
                }
            },
            "required": [
                "accountId",
                "created",
                "data",
                "description",
                "enabled",
                "interval",
                "name",
                "updated"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDexTestData:ZeroTrustDexTestData",
                    "description": "The configuration object which contains the details for the WARP client to conduct the test.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Additional details about the test.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines whether or not the test is active.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "How often the test will run.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Device Dex Test. Must be unique.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "data",
                "description",
                "enabled",
                "interval",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDexTest resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "created": {
                        "type": "string",
                        "description": "Timestamp of when the Dex Test was created.\n"
                    },
                    "data": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDexTestData:ZeroTrustDexTestData",
                        "description": "The configuration object which contains the details for the WARP client to conduct the test.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Additional details about the test.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines whether or not the test is active.\n"
                    },
                    "interval": {
                        "type": "string",
                        "description": "How often the test will run.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Device Dex Test. Must be unique.\n"
                    },
                    "updated": {
                        "type": "string",
                        "description": "Timestamp of when the Dex Test was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDlpProfile:ZeroTrustDlpProfile": {
            "description": "Provides a Cloudflare DLP Profile resource. Data Loss Prevention profiles\nare a set of entries that can be matched in HTTP bodies or files.\nThey are referenced in Zero Trust Gateway rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Predefined profile must be imported, cannot be created\nconst creds = new cloudflare.ZeroTrustDlpProfile(\"creds\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Credentials and Secrets\",\n    type: \"predefined\",\n    allowedMatchCount: 3,\n    entries: [\n        {\n            enabled: true,\n            name: \"Amazon AWS Access Key ID\",\n            id: \"d8fcfc9c-773c-405e-8426-21ecbb67ba93\",\n        },\n        {\n            enabled: false,\n            id: \"2c0e33e1-71da-40c8-aad3-32e674ad3d96\",\n            name: \"Amazon AWS Secret Access Key\",\n        },\n        {\n            enabled: true,\n            id: \"4e92c006-3802-4dff-bbe1-8e1513b1c92a\",\n            name: \"Microsoft Azure Client Secret\",\n        },\n        {\n            enabled: false,\n            id: \"5c713294-2375-4904-abcf-e4a15be4d592\",\n            name: \"SSH Private Key\",\n        },\n        {\n            enabled: true,\n            id: \"6c6579e4-d832-42d5-905c-8e53340930f2\",\n            name: \"Google GCP API Key\",\n        },\n    ],\n});\n// Custom profile\nconst exampleCustom = new cloudflare.ZeroTrustDlpProfile(\"example_custom\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Example Custom Profile\",\n    description: \"A profile with example entries\",\n    type: \"custom\",\n    allowedMatchCount: 0,\n    entries: [\n        {\n            name: \"Matches visa credit cards\",\n            enabled: true,\n            pattern: {\n                regex: \"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\",\n                validation: \"luhn\",\n            },\n        },\n        {\n            name: \"Matches diners club card\",\n            enabled: true,\n            pattern: {\n                regex: \"(?:0[0-5]|[68][0-9])[0-9]{11}\",\n                validation: \"luhn\",\n            },\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Predefined profile must be imported, cannot be created\ncreds = cloudflare.ZeroTrustDlpProfile(\"creds\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Credentials and Secrets\",\n    type=\"predefined\",\n    allowed_match_count=3,\n    entries=[\n        {\n            \"enabled\": True,\n            \"name\": \"Amazon AWS Access Key ID\",\n            \"id\": \"d8fcfc9c-773c-405e-8426-21ecbb67ba93\",\n        },\n        {\n            \"enabled\": False,\n            \"id\": \"2c0e33e1-71da-40c8-aad3-32e674ad3d96\",\n            \"name\": \"Amazon AWS Secret Access Key\",\n        },\n        {\n            \"enabled\": True,\n            \"id\": \"4e92c006-3802-4dff-bbe1-8e1513b1c92a\",\n            \"name\": \"Microsoft Azure Client Secret\",\n        },\n        {\n            \"enabled\": False,\n            \"id\": \"5c713294-2375-4904-abcf-e4a15be4d592\",\n            \"name\": \"SSH Private Key\",\n        },\n        {\n            \"enabled\": True,\n            \"id\": \"6c6579e4-d832-42d5-905c-8e53340930f2\",\n            \"name\": \"Google GCP API Key\",\n        },\n    ])\n# Custom profile\nexample_custom = cloudflare.ZeroTrustDlpProfile(\"example_custom\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Example Custom Profile\",\n    description=\"A profile with example entries\",\n    type=\"custom\",\n    allowed_match_count=0,\n    entries=[\n        {\n            \"name\": \"Matches visa credit cards\",\n            \"enabled\": True,\n            \"pattern\": {\n                \"regex\": \"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\",\n                \"validation\": \"luhn\",\n            },\n        },\n        {\n            \"name\": \"Matches diners club card\",\n            \"enabled\": True,\n            \"pattern\": {\n                \"regex\": \"(?:0[0-5]|[68][0-9])[0-9]{11}\",\n                \"validation\": \"luhn\",\n            },\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Predefined profile must be imported, cannot be created\n    var creds = new Cloudflare.ZeroTrustDlpProfile(\"creds\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Credentials and Secrets\",\n        Type = \"predefined\",\n        AllowedMatchCount = 3,\n        Entries = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Enabled = true,\n                Name = \"Amazon AWS Access Key ID\",\n                Id = \"d8fcfc9c-773c-405e-8426-21ecbb67ba93\",\n            },\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Enabled = false,\n                Id = \"2c0e33e1-71da-40c8-aad3-32e674ad3d96\",\n                Name = \"Amazon AWS Secret Access Key\",\n            },\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Enabled = true,\n                Id = \"4e92c006-3802-4dff-bbe1-8e1513b1c92a\",\n                Name = \"Microsoft Azure Client Secret\",\n            },\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Enabled = false,\n                Id = \"5c713294-2375-4904-abcf-e4a15be4d592\",\n                Name = \"SSH Private Key\",\n            },\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Enabled = true,\n                Id = \"6c6579e4-d832-42d5-905c-8e53340930f2\",\n                Name = \"Google GCP API Key\",\n            },\n        },\n    });\n\n    // Custom profile\n    var exampleCustom = new Cloudflare.ZeroTrustDlpProfile(\"example_custom\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Example Custom Profile\",\n        Description = \"A profile with example entries\",\n        Type = \"custom\",\n        AllowedMatchCount = 0,\n        Entries = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Name = \"Matches visa credit cards\",\n                Enabled = true,\n                Pattern = new Cloudflare.Inputs.ZeroTrustDlpProfileEntryPatternArgs\n                {\n                    Regex = \"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\",\n                    Validation = \"luhn\",\n                },\n            },\n            new Cloudflare.Inputs.ZeroTrustDlpProfileEntryArgs\n            {\n                Name = \"Matches diners club card\",\n                Enabled = true,\n                Pattern = new Cloudflare.Inputs.ZeroTrustDlpProfileEntryPatternArgs\n                {\n                    Regex = \"(?:0[0-5]|[68][0-9])[0-9]{11}\",\n                    Validation = \"luhn\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Predefined profile must be imported, cannot be created\n\t\t_, err := cloudflare.NewZeroTrustDlpProfile(ctx, \"creds\", \u0026cloudflare.ZeroTrustDlpProfileArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:              pulumi.String(\"Credentials and Secrets\"),\n\t\t\tType:              pulumi.String(\"predefined\"),\n\t\t\tAllowedMatchCount: pulumi.Int(3),\n\t\t\tEntries: cloudflare.ZeroTrustDlpProfileEntryArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tName:    pulumi.String(\"Amazon AWS Access Key ID\"),\n\t\t\t\t\tId:      pulumi.String(\"d8fcfc9c-773c-405e-8426-21ecbb67ba93\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tId:      pulumi.String(\"2c0e33e1-71da-40c8-aad3-32e674ad3d96\"),\n\t\t\t\t\tName:    pulumi.String(\"Amazon AWS Secret Access Key\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tId:      pulumi.String(\"4e92c006-3802-4dff-bbe1-8e1513b1c92a\"),\n\t\t\t\t\tName:    pulumi.String(\"Microsoft Azure Client Secret\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tId:      pulumi.String(\"5c713294-2375-4904-abcf-e4a15be4d592\"),\n\t\t\t\t\tName:    pulumi.String(\"SSH Private Key\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tId:      pulumi.String(\"6c6579e4-d832-42d5-905c-8e53340930f2\"),\n\t\t\t\t\tName:    pulumi.String(\"Google GCP API Key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Custom profile\n\t\t_, err = cloudflare.NewZeroTrustDlpProfile(ctx, \"example_custom\", \u0026cloudflare.ZeroTrustDlpProfileArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:              pulumi.String(\"Example Custom Profile\"),\n\t\t\tDescription:       pulumi.String(\"A profile with example entries\"),\n\t\t\tType:              pulumi.String(\"custom\"),\n\t\t\tAllowedMatchCount: pulumi.Int(0),\n\t\t\tEntries: cloudflare.ZeroTrustDlpProfileEntryArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tName:    pulumi.String(\"Matches visa credit cards\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tPattern: \u0026cloudflare.ZeroTrustDlpProfileEntryPatternArgs{\n\t\t\t\t\t\tRegex:      pulumi.String(\"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\"),\n\t\t\t\t\t\tValidation: pulumi.String(\"luhn\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.ZeroTrustDlpProfileEntryArgs{\n\t\t\t\t\tName:    pulumi.String(\"Matches diners club card\"),\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tPattern: \u0026cloudflare.ZeroTrustDlpProfileEntryPatternArgs{\n\t\t\t\t\t\tRegex:      pulumi.String(\"(?:0[0-5]|[68][0-9])[0-9]{11}\"),\n\t\t\t\t\t\tValidation: pulumi.String(\"luhn\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDlpProfile;\nimport com.pulumi.cloudflare.ZeroTrustDlpProfileArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDlpProfileEntryArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDlpProfileEntryPatternArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Predefined profile must be imported, cannot be created\n        var creds = new ZeroTrustDlpProfile(\"creds\", ZeroTrustDlpProfileArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Credentials and Secrets\")\n            .type(\"predefined\")\n            .allowedMatchCount(3)\n            .entries(            \n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .enabled(true)\n                    .name(\"Amazon AWS Access Key ID\")\n                    .id(\"d8fcfc9c-773c-405e-8426-21ecbb67ba93\")\n                    .build(),\n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .enabled(false)\n                    .id(\"2c0e33e1-71da-40c8-aad3-32e674ad3d96\")\n                    .name(\"Amazon AWS Secret Access Key\")\n                    .build(),\n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .enabled(true)\n                    .id(\"4e92c006-3802-4dff-bbe1-8e1513b1c92a\")\n                    .name(\"Microsoft Azure Client Secret\")\n                    .build(),\n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .enabled(false)\n                    .id(\"5c713294-2375-4904-abcf-e4a15be4d592\")\n                    .name(\"SSH Private Key\")\n                    .build(),\n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .enabled(true)\n                    .id(\"6c6579e4-d832-42d5-905c-8e53340930f2\")\n                    .name(\"Google GCP API Key\")\n                    .build())\n            .build());\n\n        // Custom profile\n        var exampleCustom = new ZeroTrustDlpProfile(\"exampleCustom\", ZeroTrustDlpProfileArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Example Custom Profile\")\n            .description(\"A profile with example entries\")\n            .type(\"custom\")\n            .allowedMatchCount(0)\n            .entries(            \n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .name(\"Matches visa credit cards\")\n                    .enabled(true)\n                    .pattern(ZeroTrustDlpProfileEntryPatternArgs.builder()\n                        .regex(\"4\\\\d{3}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}([-\\\\. ])?\\\\d{4}\")\n                        .validation(\"luhn\")\n                        .build())\n                    .build(),\n                ZeroTrustDlpProfileEntryArgs.builder()\n                    .name(\"Matches diners club card\")\n                    .enabled(true)\n                    .pattern(ZeroTrustDlpProfileEntryPatternArgs.builder()\n                        .regex(\"(?:0[0-5]|[68][0-9])[0-9]{11}\")\n                        .validation(\"luhn\")\n                        .build())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Predefined profile must be imported, cannot be created\n  creds:\n    type: cloudflare:ZeroTrustDlpProfile\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Credentials and Secrets\n      type: predefined\n      allowedMatchCount: 3\n      entries:\n        - enabled: true\n          name: Amazon AWS Access Key ID\n          id: d8fcfc9c-773c-405e-8426-21ecbb67ba93\n        - enabled: false\n          id: 2c0e33e1-71da-40c8-aad3-32e674ad3d96\n          name: Amazon AWS Secret Access Key\n        - enabled: true\n          id: 4e92c006-3802-4dff-bbe1-8e1513b1c92a\n          name: Microsoft Azure Client Secret\n        - enabled: false\n          id: 5c713294-2375-4904-abcf-e4a15be4d592\n          name: SSH Private Key\n        - enabled: true\n          id: 6c6579e4-d832-42d5-905c-8e53340930f2\n          name: Google GCP API Key\n  # Custom profile\n  exampleCustom:\n    type: cloudflare:ZeroTrustDlpProfile\n    name: example_custom\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Example Custom Profile\n      description: A profile with example entries\n      type: custom\n      allowedMatchCount: 0\n      entries:\n        - name: Matches visa credit cards\n          enabled: true\n          pattern:\n            regex: 4\\d{3}([-\\. ])?\\d{4}([-\\. ])?\\d{4}([-\\. ])?\\d{4}\n            validation: luhn\n        - name: Matches diners club card\n          enabled: true\n          pattern:\n            regex: (?:0[0-5]|[68][0-9])[0-9]{11}\n            validation: luhn\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDlpProfile:ZeroTrustDlpProfile example \u003caccount_id\u003e/\u003cdlp_profile_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "allowedMatchCount": {
                    "type": "integer",
                    "description": "Related DLP policies will trigger when the match count exceeds the number set.\n"
                },
                "contextAwareness": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileContextAwareness:ZeroTrustDlpProfileContextAwareness",
                    "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the profile and its intended use.\n"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileEntry:ZeroTrustDlpProfileEntry"
                    },
                    "description": "List of entries to apply to the profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ocrEnabled": {
                    "type": "boolean",
                    "description": "If true, scan images via OCR to determine if any text present matches filters.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "allowedMatchCount",
                "contextAwareness",
                "entries",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "allowedMatchCount": {
                    "type": "integer",
                    "description": "Related DLP policies will trigger when the match count exceeds the number set.\n"
                },
                "contextAwareness": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileContextAwareness:ZeroTrustDlpProfileContextAwareness",
                    "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the profile and its intended use.\n"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileEntry:ZeroTrustDlpProfileEntry"
                    },
                    "description": "List of entries to apply to the profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "ocrEnabled": {
                    "type": "boolean",
                    "description": "If true, scan images via OCR to determine if any text present matches filters.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "allowedMatchCount",
                "entries",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDlpProfile resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "allowedMatchCount": {
                        "type": "integer",
                        "description": "Related DLP policies will trigger when the match count exceeds the number set.\n"
                    },
                    "contextAwareness": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileContextAwareness:ZeroTrustDlpProfileContextAwareness",
                        "description": "Scan the context of predefined entries to only return matches surrounded by keywords.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Brief summary of the profile and its intended use.\n"
                    },
                    "entries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustDlpProfileEntry:ZeroTrustDlpProfileEntry"
                        },
                        "description": "List of entries to apply to the profile.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ocrEnabled": {
                        "type": "boolean",
                        "description": "If true, scan images via OCR to determine if any text present matches filters.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustDnsLocation:ZeroTrustDnsLocation": {
            "description": "Provides a Cloudflare Teams Location resource. Teams Locations are\nreferenced when creating secure web gateway policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustDnsLocation(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"office\",\n    clientDefault: true,\n    ecsSupport: false,\n    networks: [\n        {\n            network: \"203.0.113.1/32\",\n        },\n        {\n            network: \"203.0.113.2/32\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustDnsLocation(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"office\",\n    client_default=True,\n    ecs_support=False,\n    networks=[\n        {\n            \"network\": \"203.0.113.1/32\",\n        },\n        {\n            \"network\": \"203.0.113.2/32\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustDnsLocation(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"office\",\n        ClientDefault = true,\n        EcsSupport = false,\n        Networks = new[]\n        {\n            new Cloudflare.Inputs.ZeroTrustDnsLocationNetworkArgs\n            {\n                Network = \"203.0.113.1/32\",\n            },\n            new Cloudflare.Inputs.ZeroTrustDnsLocationNetworkArgs\n            {\n                Network = \"203.0.113.2/32\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustDnsLocation(ctx, \"example\", \u0026cloudflare.ZeroTrustDnsLocationArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:          pulumi.String(\"office\"),\n\t\t\tClientDefault: pulumi.Bool(true),\n\t\t\tEcsSupport:    pulumi.Bool(false),\n\t\t\tNetworks: cloudflare.ZeroTrustDnsLocationNetworkArray{\n\t\t\t\t\u0026cloudflare.ZeroTrustDnsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.1/32\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.ZeroTrustDnsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.2/32\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustDnsLocation;\nimport com.pulumi.cloudflare.ZeroTrustDnsLocationArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustDnsLocationNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustDnsLocation(\"example\", ZeroTrustDnsLocationArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"office\")\n            .clientDefault(true)\n            .ecsSupport(false)\n            .networks(            \n                ZeroTrustDnsLocationNetworkArgs.builder()\n                    .network(\"203.0.113.1/32\")\n                    .build(),\n                ZeroTrustDnsLocationNetworkArgs.builder()\n                    .network(\"203.0.113.2/32\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustDnsLocation\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: office\n      clientDefault: true\n      ecsSupport: false\n      networks:\n        - network: 203.0.113.1/32\n        - network: 203.0.113.2/32\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustDnsLocation:ZeroTrustDnsLocation example \u003caccount_id\u003e/\u003cteams_location_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "anonymizedLogsEnabled": {
                    "type": "boolean",
                    "description": "Indicator that anonymized logs are enabled.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "dohSubdomain": {
                    "type": "string",
                    "description": "The FQDN that DoH clients should be pointed at.\n"
                },
                "ecsSupport": {
                    "type": "boolean",
                    "description": "Indicator that this location needs to resolve EDNS queries.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Client IP address.\n"
                },
                "ipv4Destination": {
                    "type": "string",
                    "description": "IP to direct all IPv4 DNS queries to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDnsLocationNetwork:ZeroTrustDnsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                },
                "policyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "accountId",
                "anonymizedLogsEnabled",
                "dohSubdomain",
                "ip",
                "ipv4Destination",
                "name",
                "policyIds"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "ecsSupport": {
                    "type": "boolean",
                    "description": "Indicator that this location needs to resolve EDNS queries.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustDnsLocationNetwork:ZeroTrustDnsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustDnsLocation resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "anonymizedLogsEnabled": {
                        "type": "boolean",
                        "description": "Indicator that anonymized logs are enabled.\n"
                    },
                    "clientDefault": {
                        "type": "boolean",
                        "description": "Indicator that this is the default location.\n"
                    },
                    "dohSubdomain": {
                        "type": "string",
                        "description": "The FQDN that DoH clients should be pointed at.\n"
                    },
                    "ecsSupport": {
                        "type": "boolean",
                        "description": "Indicator that this location needs to resolve EDNS queries.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "Client IP address.\n"
                    },
                    "ipv4Destination": {
                        "type": "string",
                        "description": "IP to direct all IPv4 DNS queries to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams location.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustDnsLocationNetwork:ZeroTrustDnsLocationNetwork"
                        },
                        "description": "The networks CIDRs that comprise the location.\n"
                    },
                    "policyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustGatewayCertificate:ZeroTrustGatewayCertificate": {
            "description": "Provides a Cloudflare Teams Gateway Certificate resource. A Teams Certificate can\nbe specified for Gateway TLS interception and block pages.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "activate": {
                    "type": "boolean",
                    "description": "Whether or not to activate a certificate. A certificate must be activated to use in Gateway certificate settings. Defaults to `false`.\n"
                },
                "bindingStatus": {
                    "type": "string",
                    "description": "The deployment status of the certificate on the edge Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                },
                "createdAt": {
                    "type": "string"
                },
                "custom": {
                    "type": "boolean",
                    "description": "The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.\n"
                },
                "expiresOn": {
                    "type": "string"
                },
                "gatewayManaged": {
                    "type": "boolean",
                    "description": "The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.\n"
                },
                "inUse": {
                    "type": "boolean",
                    "description": "Whether the certificate is in use by Gateway for TLS interception and the block page.\n"
                },
                "qsPackId": {
                    "type": "string"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "validityPeriodDays": {
                    "type": "integer",
                    "description": "Number of days the generated certificate will be valid, minimum 1 day and maximum 30 years. Defaults to 5 years. Defaults to `1826`. Required when using `gateway_managed`. Conflicts with `custom`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "bindingStatus",
                "createdAt",
                "expiresOn",
                "inUse",
                "qsPackId",
                "uploadedOn"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "activate": {
                    "type": "boolean",
                    "description": "Whether or not to activate a certificate. A certificate must be activated to use in Gateway certificate settings. Defaults to `false`.\n"
                },
                "custom": {
                    "type": "boolean",
                    "description": "The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.\n"
                },
                "gatewayManaged": {
                    "type": "boolean",
                    "description": "The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.\n"
                },
                "validityPeriodDays": {
                    "type": "integer",
                    "description": "Number of days the generated certificate will be valid, minimum 1 day and maximum 30 years. Defaults to 5 years. Defaults to `1826`. Required when using `gateway_managed`. Conflicts with `custom`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustGatewayCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "activate": {
                        "type": "boolean",
                        "description": "Whether or not to activate a certificate. A certificate must be activated to use in Gateway certificate settings. Defaults to `false`.\n"
                    },
                    "bindingStatus": {
                        "type": "string",
                        "description": "The deployment status of the certificate on the edge Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                    },
                    "createdAt": {
                        "type": "string"
                    },
                    "custom": {
                        "type": "boolean",
                        "description": "The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.\n"
                    },
                    "expiresOn": {
                        "type": "string"
                    },
                    "gatewayManaged": {
                        "type": "boolean",
                        "description": "The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.\n"
                    },
                    "inUse": {
                        "type": "boolean",
                        "description": "Whether the certificate is in use by Gateway for TLS interception and the block page.\n"
                    },
                    "qsPackId": {
                        "type": "string"
                    },
                    "uploadedOn": {
                        "type": "string"
                    },
                    "validityPeriodDays": {
                        "type": "integer",
                        "description": "Number of days the generated certificate will be valid, minimum 1 day and maximum 30 years. Defaults to 5 years. Defaults to `1826`. Required when using `gateway_managed`. Conflicts with `custom`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy": {
            "description": "Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustGatewayPolicy(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"office\",\n    description: \"desc\",\n    precedence: 1,\n    action: \"block\",\n    filters: [\"http\"],\n    traffic: \"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n    ruleSettings: {\n        blockPageEnabled: true,\n        blockPageReason: \"access not permitted\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustGatewayPolicy(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"office\",\n    description=\"desc\",\n    precedence=1,\n    action=\"block\",\n    filters=[\"http\"],\n    traffic=\"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n    rule_settings={\n        \"block_page_enabled\": True,\n        \"block_page_reason\": \"access not permitted\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustGatewayPolicy(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"office\",\n        Description = \"desc\",\n        Precedence = 1,\n        Action = \"block\",\n        Filters = new[]\n        {\n            \"http\",\n        },\n        Traffic = \"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n        RuleSettings = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsArgs\n        {\n            BlockPageEnabled = true,\n            BlockPageReason = \"access not permitted\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustGatewayPolicy(ctx, \"example\", \u0026cloudflare.ZeroTrustGatewayPolicyArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"office\"),\n\t\t\tDescription: pulumi.String(\"desc\"),\n\t\t\tPrecedence:  pulumi.Int(1),\n\t\t\tAction:      pulumi.String(\"block\"),\n\t\t\tFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http\"),\n\t\t\t},\n\t\t\tTraffic: pulumi.String(\"http.request.uri == \\\"https://www.example.com/malicious\\\"\"),\n\t\t\tRuleSettings: \u0026cloudflare.ZeroTrustGatewayPolicyRuleSettingsArgs{\n\t\t\t\tBlockPageEnabled: pulumi.Bool(true),\n\t\t\t\tBlockPageReason:  pulumi.String(\"access not permitted\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustGatewayPolicy;\nimport com.pulumi.cloudflare.ZeroTrustGatewayPolicyArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewayPolicyRuleSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustGatewayPolicy(\"example\", ZeroTrustGatewayPolicyArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"office\")\n            .description(\"desc\")\n            .precedence(1)\n            .action(\"block\")\n            .filters(\"http\")\n            .traffic(\"http.request.uri == \\\"https://www.example.com/malicious\\\"\")\n            .ruleSettings(ZeroTrustGatewayPolicyRuleSettingsArgs.builder()\n                .blockPageEnabled(true)\n                .blockPageReason(\"access not permitted\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustGatewayPolicy\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: office\n      description: desc\n      precedence: 1\n      action: block\n      filters:\n        - http\n      traffic: http.request.uri == \"https://www.example.com/malicious\"\n      ruleSettings:\n        blockPageEnabled: true\n        blockPageReason: access not permitted\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy example \u003caccount_id\u003e/\u003cteams_rule_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettings:ZeroTrustGatewayPolicyRuleSettings",
                    "description": "Additional rule settings.\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                },
                "version": {
                    "type": "integer"
                }
            },
            "required": [
                "accountId",
                "action",
                "description",
                "devicePosture",
                "identity",
                "name",
                "precedence",
                "ruleSettings",
                "traffic",
                "version"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettings:ZeroTrustGatewayPolicyRuleSettings",
                    "description": "Additional rule settings.\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "action",
                "description",
                "name",
                "precedence"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustGatewayPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams rule.\n"
                    },
                    "devicePosture": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for device_posture check matching.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicator of rule enablement.\n"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for identity matching.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the teams rule.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The evaluation precedence of the teams rule.\n"
                    },
                    "ruleSettings": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewayPolicyRuleSettings:ZeroTrustGatewayPolicyRuleSettings",
                        "description": "Additional rule settings.\n"
                    },
                    "traffic": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for traffic matching.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustGatewayProxyEndpoint:ZeroTrustGatewayProxyEndpoint": {
            "description": "Provides a Cloudflare Teams Proxy Endpoint resource. Teams Proxy\nEndpoints are used for pointing proxy clients at Cloudflare Secure\nGateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustGatewayProxyEndpoint(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"office\",\n    ips: [\"192.0.2.0/24\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustGatewayProxyEndpoint(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"office\",\n    ips=[\"192.0.2.0/24\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustGatewayProxyEndpoint(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"office\",\n        Ips = new[]\n        {\n            \"192.0.2.0/24\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustGatewayProxyEndpoint(ctx, \"example\", \u0026cloudflare.ZeroTrustGatewayProxyEndpointArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"office\"),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.0.2.0/24\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustGatewayProxyEndpoint;\nimport com.pulumi.cloudflare.ZeroTrustGatewayProxyEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustGatewayProxyEndpoint(\"example\", ZeroTrustGatewayProxyEndpointArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"office\")\n            .ips(\"192.0.2.0/24\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustGatewayProxyEndpoint\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: office\n      ips:\n        - 192.0.2.0/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustGatewayProxyEndpoint:ZeroTrustGatewayProxyEndpoint example \u003caccount_id\u003e/\u003cproxy_endpoint_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams proxy endpoint.\n"
                },
                "subdomain": {
                    "type": "string",
                    "description": "The FQDN that proxy clients should be pointed at.\n"
                }
            },
            "required": [
                "accountId",
                "ips",
                "name",
                "subdomain"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams proxy endpoint.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "ips",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustGatewayProxyEndpoint resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams proxy endpoint.\n"
                    },
                    "subdomain": {
                        "type": "string",
                        "description": "The FQDN that proxy clients should be pointed at.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustGatewaySettings:ZeroTrustGatewaySettings": {
            "description": "Provides a Cloudflare Teams Account resource. The Teams Account\nresource defines configuration for secure web gateway.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustGatewaySettings(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tlsDecryptEnabled: true,\n    protocolDetectionEnabled: true,\n    blockPage: {\n        footerText: \"hello\",\n        headerText: \"hello\",\n        logoPath: \"https://example.com/logo.jpg\",\n        backgroundColor: \"#000000\",\n    },\n    bodyScanning: {\n        inspectionMode: \"deep\",\n    },\n    antivirus: {\n        enabledDownloadPhase: true,\n        enabledUploadPhase: false,\n        failClosed: true,\n        notificationSettings: {\n            enabled: true,\n            message: \"you are blocked\",\n            supportUrl: \"https://example.com/blocked\",\n        },\n    },\n    fips: {\n        tls: true,\n    },\n    proxy: {\n        tcp: true,\n        udp: true,\n        rootCa: true,\n        virtualIp: false,\n        disableForTime: 3600,\n    },\n    urlBrowserIsolationEnabled: true,\n    logging: {\n        redactPii: true,\n        settingsByRuleType: {\n            dns: {\n                logAll: false,\n                logBlocks: true,\n            },\n            http: {\n                logAll: true,\n                logBlocks: true,\n            },\n            l4: {\n                logAll: false,\n                logBlocks: true,\n            },\n        },\n    },\n    extendedEmailMatching: {\n        enabled: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustGatewaySettings(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tls_decrypt_enabled=True,\n    protocol_detection_enabled=True,\n    block_page={\n        \"footer_text\": \"hello\",\n        \"header_text\": \"hello\",\n        \"logo_path\": \"https://example.com/logo.jpg\",\n        \"background_color\": \"#000000\",\n    },\n    body_scanning={\n        \"inspection_mode\": \"deep\",\n    },\n    antivirus={\n        \"enabled_download_phase\": True,\n        \"enabled_upload_phase\": False,\n        \"fail_closed\": True,\n        \"notification_settings\": {\n            \"enabled\": True,\n            \"message\": \"you are blocked\",\n            \"support_url\": \"https://example.com/blocked\",\n        },\n    },\n    fips={\n        \"tls\": True,\n    },\n    proxy={\n        \"tcp\": True,\n        \"udp\": True,\n        \"root_ca\": True,\n        \"virtual_ip\": False,\n        \"disable_for_time\": 3600,\n    },\n    url_browser_isolation_enabled=True,\n    logging={\n        \"redact_pii\": True,\n        \"settings_by_rule_type\": {\n            \"dns\": {\n                \"log_all\": False,\n                \"log_blocks\": True,\n            },\n            \"http\": {\n                \"log_all\": True,\n                \"log_blocks\": True,\n            },\n            \"l4\": {\n                \"log_all\": False,\n                \"log_blocks\": True,\n            },\n        },\n    },\n    extended_email_matching={\n        \"enabled\": True,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustGatewaySettings(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TlsDecryptEnabled = true,\n        ProtocolDetectionEnabled = true,\n        BlockPage = new Cloudflare.Inputs.ZeroTrustGatewaySettingsBlockPageArgs\n        {\n            FooterText = \"hello\",\n            HeaderText = \"hello\",\n            LogoPath = \"https://example.com/logo.jpg\",\n            BackgroundColor = \"#000000\",\n        },\n        BodyScanning = new Cloudflare.Inputs.ZeroTrustGatewaySettingsBodyScanningArgs\n        {\n            InspectionMode = \"deep\",\n        },\n        Antivirus = new Cloudflare.Inputs.ZeroTrustGatewaySettingsAntivirusArgs\n        {\n            EnabledDownloadPhase = true,\n            EnabledUploadPhase = false,\n            FailClosed = true,\n            NotificationSettings = new Cloudflare.Inputs.ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs\n            {\n                Enabled = true,\n                Message = \"you are blocked\",\n                SupportUrl = \"https://example.com/blocked\",\n            },\n        },\n        Fips = new Cloudflare.Inputs.ZeroTrustGatewaySettingsFipsArgs\n        {\n            Tls = true,\n        },\n        Proxy = new Cloudflare.Inputs.ZeroTrustGatewaySettingsProxyArgs\n        {\n            Tcp = true,\n            Udp = true,\n            RootCa = true,\n            VirtualIp = false,\n            DisableForTime = 3600,\n        },\n        UrlBrowserIsolationEnabled = true,\n        Logging = new Cloudflare.Inputs.ZeroTrustGatewaySettingsLoggingArgs\n        {\n            RedactPii = true,\n            SettingsByRuleType = new Cloudflare.Inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs\n            {\n                Dns = new Cloudflare.Inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs\n                {\n                    LogAll = false,\n                    LogBlocks = true,\n                },\n                Http = new Cloudflare.Inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs\n                {\n                    LogAll = true,\n                    LogBlocks = true,\n                },\n                L4 = new Cloudflare.Inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args\n                {\n                    LogAll = false,\n                    LogBlocks = true,\n                },\n            },\n        },\n        ExtendedEmailMatching = new Cloudflare.Inputs.ZeroTrustGatewaySettingsExtendedEmailMatchingArgs\n        {\n            Enabled = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustGatewaySettings(ctx, \"example\", \u0026cloudflare.ZeroTrustGatewaySettingsArgs{\n\t\t\tAccountId:                pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTlsDecryptEnabled:        pulumi.Bool(true),\n\t\t\tProtocolDetectionEnabled: pulumi.Bool(true),\n\t\t\tBlockPage: \u0026cloudflare.ZeroTrustGatewaySettingsBlockPageArgs{\n\t\t\t\tFooterText:      pulumi.String(\"hello\"),\n\t\t\t\tHeaderText:      pulumi.String(\"hello\"),\n\t\t\t\tLogoPath:        pulumi.String(\"https://example.com/logo.jpg\"),\n\t\t\t\tBackgroundColor: pulumi.String(\"#000000\"),\n\t\t\t},\n\t\t\tBodyScanning: \u0026cloudflare.ZeroTrustGatewaySettingsBodyScanningArgs{\n\t\t\t\tInspectionMode: pulumi.String(\"deep\"),\n\t\t\t},\n\t\t\tAntivirus: \u0026cloudflare.ZeroTrustGatewaySettingsAntivirusArgs{\n\t\t\t\tEnabledDownloadPhase: pulumi.Bool(true),\n\t\t\t\tEnabledUploadPhase:   pulumi.Bool(false),\n\t\t\t\tFailClosed:           pulumi.Bool(true),\n\t\t\t\tNotificationSettings: \u0026cloudflare.ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs{\n\t\t\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\t\t\tMessage:    pulumi.String(\"you are blocked\"),\n\t\t\t\t\tSupportUrl: pulumi.String(\"https://example.com/blocked\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tFips: \u0026cloudflare.ZeroTrustGatewaySettingsFipsArgs{\n\t\t\t\tTls: pulumi.Bool(true),\n\t\t\t},\n\t\t\tProxy: \u0026cloudflare.ZeroTrustGatewaySettingsProxyArgs{\n\t\t\t\tTcp:            pulumi.Bool(true),\n\t\t\t\tUdp:            pulumi.Bool(true),\n\t\t\t\tRootCa:         pulumi.Bool(true),\n\t\t\t\tVirtualIp:      pulumi.Bool(false),\n\t\t\t\tDisableForTime: pulumi.Int(3600),\n\t\t\t},\n\t\t\tUrlBrowserIsolationEnabled: pulumi.Bool(true),\n\t\t\tLogging: \u0026cloudflare.ZeroTrustGatewaySettingsLoggingArgs{\n\t\t\t\tRedactPii: pulumi.Bool(true),\n\t\t\t\tSettingsByRuleType: \u0026cloudflare.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs{\n\t\t\t\t\tDns: \u0026cloudflare.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(false),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tHttp: \u0026cloudflare.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(true),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tL4: \u0026cloudflare.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(false),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tExtendedEmailMatching: \u0026cloudflare.ZeroTrustGatewaySettingsExtendedEmailMatchingArgs{\n\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustGatewaySettings;\nimport com.pulumi.cloudflare.ZeroTrustGatewaySettingsArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsBlockPageArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsBodyScanningArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsAntivirusArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsFipsArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsProxyArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsLoggingArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args;\nimport com.pulumi.cloudflare.inputs.ZeroTrustGatewaySettingsExtendedEmailMatchingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustGatewaySettings(\"example\", ZeroTrustGatewaySettingsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tlsDecryptEnabled(true)\n            .protocolDetectionEnabled(true)\n            .blockPage(ZeroTrustGatewaySettingsBlockPageArgs.builder()\n                .footerText(\"hello\")\n                .headerText(\"hello\")\n                .logoPath(\"https://example.com/logo.jpg\")\n                .backgroundColor(\"#000000\")\n                .build())\n            .bodyScanning(ZeroTrustGatewaySettingsBodyScanningArgs.builder()\n                .inspectionMode(\"deep\")\n                .build())\n            .antivirus(ZeroTrustGatewaySettingsAntivirusArgs.builder()\n                .enabledDownloadPhase(true)\n                .enabledUploadPhase(false)\n                .failClosed(true)\n                .notificationSettings(ZeroTrustGatewaySettingsAntivirusNotificationSettingsArgs.builder()\n                    .enabled(true)\n                    .message(\"you are blocked\")\n                    .supportUrl(\"https://example.com/blocked\")\n                    .build())\n                .build())\n            .fips(ZeroTrustGatewaySettingsFipsArgs.builder()\n                .tls(true)\n                .build())\n            .proxy(ZeroTrustGatewaySettingsProxyArgs.builder()\n                .tcp(true)\n                .udp(true)\n                .rootCa(true)\n                .virtualIp(false)\n                .disableForTime(3600)\n                .build())\n            .urlBrowserIsolationEnabled(true)\n            .logging(ZeroTrustGatewaySettingsLoggingArgs.builder()\n                .redactPii(true)\n                .settingsByRuleType(ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeArgs.builder()\n                    .dns(ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDnsArgs.builder()\n                        .logAll(false)\n                        .logBlocks(true)\n                        .build())\n                    .http(ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttpArgs.builder()\n                        .logAll(true)\n                        .logBlocks(true)\n                        .build())\n                    .l4(ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4Args.builder()\n                        .logAll(false)\n                        .logBlocks(true)\n                        .build())\n                    .build())\n                .build())\n            .extendedEmailMatching(ZeroTrustGatewaySettingsExtendedEmailMatchingArgs.builder()\n                .enabled(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustGatewaySettings\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tlsDecryptEnabled: true\n      protocolDetectionEnabled: true\n      blockPage:\n        footerText: hello\n        headerText: hello\n        logoPath: https://example.com/logo.jpg\n        backgroundColor: '#000000'\n      bodyScanning:\n        inspectionMode: deep\n      antivirus:\n        enabledDownloadPhase: true\n        enabledUploadPhase: false\n        failClosed: true\n        notificationSettings:\n          enabled: true\n          message: you are blocked\n          supportUrl: https://example.com/blocked\n      fips:\n        tls: true\n      proxy:\n        tcp: true\n        udp: true\n        rootCa: true\n        virtualIp: false\n        disableForTime: 3600\n      urlBrowserIsolationEnabled: true\n      logging:\n        redactPii: true\n        settingsByRuleType:\n          dns:\n            logAll: false\n            logBlocks: true\n          http:\n            logAll: true\n            logBlocks: true\n          l4:\n            logAll: false\n            logBlocks: true\n      extendedEmailMatching:\n        enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustGatewaySettings:ZeroTrustGatewaySettings example \u003caccount_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean",
                    "description": "Whether to enable the activity log.\n"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsAntivirus:ZeroTrustGatewaySettingsAntivirus",
                    "description": "Configuration block for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsBlockPage:ZeroTrustGatewaySettingsBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "bodyScanning": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsBodyScanning:ZeroTrustGatewaySettingsBodyScanning",
                    "description": "Configuration for body scanning.\n"
                },
                "certificate": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsCertificate:ZeroTrustGatewaySettingsCertificate",
                    "description": "Configuration for TLS interception certificate. This will be required starting Feb 2025.\n"
                },
                "customCertificate": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsCustomCertificate:ZeroTrustGatewaySettingsCustomCertificate",
                    "description": "Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.\n",
                    "deprecationMessage": "Use `certificate` instead. Continuing to use custom_certificate may result in inconsistent configuration."
                },
                "extendedEmailMatching": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsExtendedEmailMatching:ZeroTrustGatewaySettingsExtendedEmailMatching",
                    "description": "Configuration for extended e-mail matching.\n"
                },
                "fips": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsFips:ZeroTrustGatewaySettingsFips",
                    "description": "Configure compliance with Federal Information Processing Standards.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLogging:ZeroTrustGatewaySettingsLogging"
                },
                "nonIdentityBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Enable non-identity onramp for Browser Isolation. Defaults to `false`.\n"
                },
                "payloadLog": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsPayloadLog:ZeroTrustGatewaySettingsPayloadLog",
                    "description": "Configuration for DLP Payload Logging.\n"
                },
                "protocolDetectionEnabled": {
                    "type": "boolean",
                    "description": "Indicator that protocol detection is enabled.\n"
                },
                "proxy": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsProxy:ZeroTrustGatewaySettingsProxy",
                    "description": "Configuration block for specifying which protocols are proxied.\n"
                },
                "sshSessionLog": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsSshSessionLog:ZeroTrustGatewaySettingsSshSessionLog",
                    "description": "Configuration for SSH Session Logging.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                },
                "urlBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Safely browse websites in Browser Isolation through a URL. Defaults to `false`.\n"
                }
            },
            "required": [
                "accountId",
                "extendedEmailMatching"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean",
                    "description": "Whether to enable the activity log.\n"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsAntivirus:ZeroTrustGatewaySettingsAntivirus",
                    "description": "Configuration block for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsBlockPage:ZeroTrustGatewaySettingsBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "bodyScanning": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsBodyScanning:ZeroTrustGatewaySettingsBodyScanning",
                    "description": "Configuration for body scanning.\n"
                },
                "certificate": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsCertificate:ZeroTrustGatewaySettingsCertificate",
                    "description": "Configuration for TLS interception certificate. This will be required starting Feb 2025.\n"
                },
                "customCertificate": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsCustomCertificate:ZeroTrustGatewaySettingsCustomCertificate",
                    "description": "Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.\n",
                    "deprecationMessage": "Use `certificate` instead. Continuing to use custom_certificate may result in inconsistent configuration."
                },
                "extendedEmailMatching": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsExtendedEmailMatching:ZeroTrustGatewaySettingsExtendedEmailMatching",
                    "description": "Configuration for extended e-mail matching.\n"
                },
                "fips": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsFips:ZeroTrustGatewaySettingsFips",
                    "description": "Configure compliance with Federal Information Processing Standards.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLogging:ZeroTrustGatewaySettingsLogging"
                },
                "nonIdentityBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Enable non-identity onramp for Browser Isolation. Defaults to `false`.\n"
                },
                "payloadLog": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsPayloadLog:ZeroTrustGatewaySettingsPayloadLog",
                    "description": "Configuration for DLP Payload Logging.\n"
                },
                "protocolDetectionEnabled": {
                    "type": "boolean",
                    "description": "Indicator that protocol detection is enabled.\n"
                },
                "proxy": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsProxy:ZeroTrustGatewaySettingsProxy",
                    "description": "Configuration block for specifying which protocols are proxied.\n"
                },
                "sshSessionLog": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsSshSessionLog:ZeroTrustGatewaySettingsSshSessionLog",
                    "description": "Configuration for SSH Session Logging.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                },
                "urlBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Safely browse websites in Browser Isolation through a URL. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustGatewaySettings resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "activityLogEnabled": {
                        "type": "boolean",
                        "description": "Whether to enable the activity log.\n"
                    },
                    "antivirus": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsAntivirus:ZeroTrustGatewaySettingsAntivirus",
                        "description": "Configuration block for antivirus traffic scanning.\n"
                    },
                    "blockPage": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsBlockPage:ZeroTrustGatewaySettingsBlockPage",
                        "description": "Configuration for a custom block page.\n"
                    },
                    "bodyScanning": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsBodyScanning:ZeroTrustGatewaySettingsBodyScanning",
                        "description": "Configuration for body scanning.\n"
                    },
                    "certificate": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsCertificate:ZeroTrustGatewaySettingsCertificate",
                        "description": "Configuration for TLS interception certificate. This will be required starting Feb 2025.\n"
                    },
                    "customCertificate": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsCustomCertificate:ZeroTrustGatewaySettingsCustomCertificate",
                        "description": "Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.\n",
                        "deprecationMessage": "Use `certificate` instead. Continuing to use custom_certificate may result in inconsistent configuration."
                    },
                    "extendedEmailMatching": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsExtendedEmailMatching:ZeroTrustGatewaySettingsExtendedEmailMatching",
                        "description": "Configuration for extended e-mail matching.\n"
                    },
                    "fips": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsFips:ZeroTrustGatewaySettingsFips",
                        "description": "Configure compliance with Federal Information Processing Standards.\n"
                    },
                    "logging": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsLogging:ZeroTrustGatewaySettingsLogging"
                    },
                    "nonIdentityBrowserIsolationEnabled": {
                        "type": "boolean",
                        "description": "Enable non-identity onramp for Browser Isolation. Defaults to `false`.\n"
                    },
                    "payloadLog": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsPayloadLog:ZeroTrustGatewaySettingsPayloadLog",
                        "description": "Configuration for DLP Payload Logging.\n"
                    },
                    "protocolDetectionEnabled": {
                        "type": "boolean",
                        "description": "Indicator that protocol detection is enabled.\n"
                    },
                    "proxy": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsProxy:ZeroTrustGatewaySettingsProxy",
                        "description": "Configuration block for specifying which protocols are proxied.\n"
                    },
                    "sshSessionLog": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustGatewaySettingsSshSessionLog:ZeroTrustGatewaySettingsSshSessionLog",
                        "description": "Configuration for SSH Session Logging.\n"
                    },
                    "tlsDecryptEnabled": {
                        "type": "boolean",
                        "description": "Indicator that decryption of TLS traffic is enabled.\n"
                    },
                    "urlBrowserIsolationEnabled": {
                        "type": "boolean",
                        "description": "Safely browse websites in Browser Isolation through a URL. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustInfrastructureAccessTarget:ZeroTrustInfrastructureAccessTarget": {
            "description": "The [Infrastructure Access Target](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#4-add-a-target) resource allows you to configure Infrastructure Access Targets for an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustInfrastructureAccessTarget(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostname: \"example-target\",\n    ip: {\n        ipv4: {\n            ipAddr: \"198.51.100.1\",\n            virtualNetworkId: \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n        ipv6: {\n            ipAddr: \"2001:db8::\",\n            virtualNetworkId: \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    },\n});\nconst ipv4OnlyExample = new cloudflare.ZeroTrustInfrastructureAccessTarget(\"ipv4_only_example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostname: \"example-ipv4-only\",\n    ip: {\n        ipv4: {\n            ipAddr: \"198.51.100.1\",\n            virtualNetworkId: \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustInfrastructureAccessTarget(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname=\"example-target\",\n    ip={\n        \"ipv4\": {\n            \"ip_addr\": \"198.51.100.1\",\n            \"virtual_network_id\": \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n        \"ipv6\": {\n            \"ip_addr\": \"2001:db8::\",\n            \"virtual_network_id\": \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    })\nipv4_only_example = cloudflare.ZeroTrustInfrastructureAccessTarget(\"ipv4_only_example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname=\"example-ipv4-only\",\n    ip={\n        \"ipv4\": {\n            \"ip_addr\": \"198.51.100.1\",\n            \"virtual_network_id\": \"238dccd1-149b-463d-8228-560ab83a54fd\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustInfrastructureAccessTarget(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Hostname = \"example-target\",\n        Ip = new Cloudflare.Inputs.ZeroTrustInfrastructureAccessTargetIpArgs\n        {\n            Ipv4 = new Cloudflare.Inputs.ZeroTrustInfrastructureAccessTargetIpIpv4Args\n            {\n                IpAddr = \"198.51.100.1\",\n                VirtualNetworkId = \"238dccd1-149b-463d-8228-560ab83a54fd\",\n            },\n            Ipv6 = new Cloudflare.Inputs.ZeroTrustInfrastructureAccessTargetIpIpv6Args\n            {\n                IpAddr = \"2001:db8::\",\n                VirtualNetworkId = \"238dccd1-149b-463d-8228-560ab83a54fd\",\n            },\n        },\n    });\n\n    var ipv4OnlyExample = new Cloudflare.ZeroTrustInfrastructureAccessTarget(\"ipv4_only_example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Hostname = \"example-ipv4-only\",\n        Ip = new Cloudflare.Inputs.ZeroTrustInfrastructureAccessTargetIpArgs\n        {\n            Ipv4 = new Cloudflare.Inputs.ZeroTrustInfrastructureAccessTargetIpIpv4Args\n            {\n                IpAddr = \"198.51.100.1\",\n                VirtualNetworkId = \"238dccd1-149b-463d-8228-560ab83a54fd\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustInfrastructureAccessTarget(ctx, \"example\", \u0026cloudflare.ZeroTrustInfrastructureAccessTargetArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tHostname:  pulumi.String(\"example-target\"),\n\t\t\tIp: \u0026cloudflare.ZeroTrustInfrastructureAccessTargetIpArgs{\n\t\t\t\tIpv4: \u0026cloudflare.ZeroTrustInfrastructureAccessTargetIpIpv4Args{\n\t\t\t\t\tIpAddr:           pulumi.String(\"198.51.100.1\"),\n\t\t\t\t\tVirtualNetworkId: pulumi.String(\"238dccd1-149b-463d-8228-560ab83a54fd\"),\n\t\t\t\t},\n\t\t\t\tIpv6: \u0026cloudflare.ZeroTrustInfrastructureAccessTargetIpIpv6Args{\n\t\t\t\t\tIpAddr:           pulumi.String(\"2001:db8::\"),\n\t\t\t\t\tVirtualNetworkId: pulumi.String(\"238dccd1-149b-463d-8228-560ab83a54fd\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewZeroTrustInfrastructureAccessTarget(ctx, \"ipv4_only_example\", \u0026cloudflare.ZeroTrustInfrastructureAccessTargetArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tHostname:  pulumi.String(\"example-ipv4-only\"),\n\t\t\tIp: \u0026cloudflare.ZeroTrustInfrastructureAccessTargetIpArgs{\n\t\t\t\tIpv4: \u0026cloudflare.ZeroTrustInfrastructureAccessTargetIpIpv4Args{\n\t\t\t\t\tIpAddr:           pulumi.String(\"198.51.100.1\"),\n\t\t\t\t\tVirtualNetworkId: pulumi.String(\"238dccd1-149b-463d-8228-560ab83a54fd\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustInfrastructureAccessTarget;\nimport com.pulumi.cloudflare.ZeroTrustInfrastructureAccessTargetArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustInfrastructureAccessTargetIpArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustInfrastructureAccessTargetIpIpv4Args;\nimport com.pulumi.cloudflare.inputs.ZeroTrustInfrastructureAccessTargetIpIpv6Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustInfrastructureAccessTarget(\"example\", ZeroTrustInfrastructureAccessTargetArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostname(\"example-target\")\n            .ip(ZeroTrustInfrastructureAccessTargetIpArgs.builder()\n                .ipv4(ZeroTrustInfrastructureAccessTargetIpIpv4Args.builder()\n                    .ipAddr(\"198.51.100.1\")\n                    .virtualNetworkId(\"238dccd1-149b-463d-8228-560ab83a54fd\")\n                    .build())\n                .ipv6(ZeroTrustInfrastructureAccessTargetIpIpv6Args.builder()\n                    .ipAddr(\"2001:db8::\")\n                    .virtualNetworkId(\"238dccd1-149b-463d-8228-560ab83a54fd\")\n                    .build())\n                .build())\n            .build());\n\n        var ipv4OnlyExample = new ZeroTrustInfrastructureAccessTarget(\"ipv4OnlyExample\", ZeroTrustInfrastructureAccessTargetArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostname(\"example-ipv4-only\")\n            .ip(ZeroTrustInfrastructureAccessTargetIpArgs.builder()\n                .ipv4(ZeroTrustInfrastructureAccessTargetIpIpv4Args.builder()\n                    .ipAddr(\"198.51.100.1\")\n                    .virtualNetworkId(\"238dccd1-149b-463d-8228-560ab83a54fd\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustInfrastructureAccessTarget\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      hostname: example-target\n      ip:\n        ipv4:\n          ipAddr: 198.51.100.1\n          virtualNetworkId: 238dccd1-149b-463d-8228-560ab83a54fd\n        ipv6:\n          ipAddr: '2001:db8::'\n          virtualNetworkId: 238dccd1-149b-463d-8228-560ab83a54fd\n  ipv4OnlyExample:\n    type: cloudflare:ZeroTrustInfrastructureAccessTarget\n    name: ipv4_only_example\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      hostname: example-ipv4-only\n      ip:\n        ipv4:\n          ipAddr: 198.51.100.1\n          virtualNetworkId: 238dccd1-149b-463d-8228-560ab83a54fd\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustInfrastructureAccessTarget:ZeroTrustInfrastructureAccessTarget example \u003caccount_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The date and time at which the target was created.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A non-unique field that refers to a target.\n"
                },
                "ip": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustInfrastructureAccessTargetIp:ZeroTrustInfrastructureAccessTargetIp",
                    "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                },
                "modifiedAt": {
                    "type": "string",
                    "description": "The date and time at which the target was last modified.\n"
                }
            },
            "required": [
                "accountId",
                "createdAt",
                "hostname",
                "ip",
                "modifiedAt"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A non-unique field that refers to a target.\n"
                },
                "ip": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustInfrastructureAccessTargetIp:ZeroTrustInfrastructureAccessTargetIp",
                    "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "hostname",
                "ip"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustInfrastructureAccessTarget resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The date and time at which the target was created.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "A non-unique field that refers to a target.\n"
                    },
                    "ip": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustInfrastructureAccessTargetIp:ZeroTrustInfrastructureAccessTargetIp",
                        "description": "The IPv4/IPv6 address that identifies where to reach a target.\n"
                    },
                    "modifiedAt": {
                        "type": "string",
                        "description": "The date and time at which the target was last modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustKeyAccessKeyConfiguration:ZeroTrustKeyAccessKeyConfiguration": {
            "description": "Access Keys Configuration defines the rotation policy for the keys\nthat access will use to sign data.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "keyRotationIntervalDays": {
                    "type": "integer",
                    "description": "Number of days to trigger a rotation of the keys.\n"
                }
            },
            "required": [
                "accountId",
                "keyRotationIntervalDays"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "keyRotationIntervalDays": {
                    "type": "integer",
                    "description": "Number of days to trigger a rotation of the keys.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustKeyAccessKeyConfiguration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "keyRotationIntervalDays": {
                        "type": "integer",
                        "description": "Number of days to trigger a rotation of the keys.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustList:ZeroTrustList": {
            "description": "Provides a Cloudflare Teams List resource. Teams lists are\nreferenced when creating secure web gateway policies or device\nposture rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustList(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Corporate devices\",\n    type: \"SERIAL\",\n    description: \"Serial numbers for all corporate devices.\",\n    items: [\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustList(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Corporate devices\",\n    type=\"SERIAL\",\n    description=\"Serial numbers for all corporate devices.\",\n    items=[\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustList(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Corporate devices\",\n        Type = \"SERIAL\",\n        Description = \"Serial numbers for all corporate devices.\",\n        Items = new[]\n        {\n            \"8GE8721REF\",\n            \"5RE8543EGG\",\n            \"1YE2880LNP\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustList(ctx, \"example\", \u0026cloudflare.ZeroTrustListArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"Corporate devices\"),\n\t\t\tType:        pulumi.String(\"SERIAL\"),\n\t\t\tDescription: pulumi.String(\"Serial numbers for all corporate devices.\"),\n\t\t\tItems: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"8GE8721REF\"),\n\t\t\t\tpulumi.String(\"5RE8543EGG\"),\n\t\t\t\tpulumi.String(\"1YE2880LNP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustList;\nimport com.pulumi.cloudflare.ZeroTrustListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustList(\"example\", ZeroTrustListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Corporate devices\")\n            .type(\"SERIAL\")\n            .description(\"Serial numbers for all corporate devices.\")\n            .items(            \n                \"8GE8721REF\",\n                \"5RE8543EGG\",\n                \"1YE2880LNP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustList\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Corporate devices\n      type: SERIAL\n      description: Serial numbers for all corporate devices.\n      items:\n        - 8GE8721REF\n        - 5RE8543EGG\n        - 1YE2880LNP\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustList:ZeroTrustList example \u003caccount_id\u003e/\u003cteams_list_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "itemsWithDescriptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustListItemsWithDescription:ZeroTrustListItemsWithDescription"
                    },
                    "description": "The items of the teams list that has explicit description.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "itemsWithDescriptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustListItemsWithDescription:ZeroTrustListItemsWithDescription"
                    },
                    "description": "The items of the teams list that has explicit description.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustList resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams list.\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The items of the teams list.\n"
                    },
                    "itemsWithDescriptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustListItemsWithDescription:ZeroTrustListItemsWithDescription"
                        },
                        "description": "The items of the teams list that has explicit description.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams list.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustLocalFallbackDomain:ZeroTrustLocalFallbackDomain": {
            "description": "Provides a Cloudflare Fallback Domain resource. Fallback domains are\nused to ignore DNS requests to a given list of domains. These DNS\nrequests will be passed back to other DNS servers configured on\nexisting network interfaces on the device.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustLocalFallbackDomainDomain:ZeroTrustLocalFallbackDomainDomain"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this fallback domain policy.\n"
                }
            },
            "required": [
                "accountId",
                "domains"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustLocalFallbackDomainDomain:ZeroTrustLocalFallbackDomainDomain"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this fallback domain policy.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "domains"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustLocalFallbackDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "domains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustLocalFallbackDomainDomain:ZeroTrustLocalFallbackDomainDomain"
                        }
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The settings policy for which to configure this fallback domain policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustRiskBehavior:ZeroTrustRiskBehavior": {
            "description": "The [Risk Behavior](https://developers.cloudflare.com/cloudflare-one/insights/risk-score/) resource allows you to configure Cloudflare Risk Behaviors for an account.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "behaviors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustRiskBehaviorBehavior:ZeroTrustRiskBehaviorBehavior"
                    },
                    "description": "Zero Trust risk behaviors configured on this account\n"
                }
            },
            "required": [
                "accountId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "behaviors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustRiskBehaviorBehavior:ZeroTrustRiskBehaviorBehavior"
                    },
                    "description": "Zero Trust risk behaviors configured on this account\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustRiskBehavior resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "behaviors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustRiskBehaviorBehavior:ZeroTrustRiskBehaviorBehavior"
                        },
                        "description": "Zero Trust risk behaviors configured on this account\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustRiskScoreIntegration:ZeroTrustRiskScoreIntegration": {
            "description": "The [Risk Score Integration](https://developers.cloudflare.com/cloudflare-one/insights/risk-score/#send-risk-score-to-okta) resource allows you to transmit changes in User Risk Score to a specified vendor such as Okta.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.\n"
                },
                "integrationType": {
                    "type": "string",
                    "description": "The type of integration, e.g. 'Okta'. Full list of allowed values can be found here: https://developers.cloudflare.com/api/operations/dlp-zt-risk-score-integration-create#request-body\n"
                },
                "referenceId": {
                    "type": "string",
                    "description": "A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). If omitted, a random UUIDv4 is used. https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider\n"
                },
                "tenantUrl": {
                    "type": "string",
                    "description": "The base url of the tenant, e.g. 'https://tenant.okta.com'. Must be your Okta Tenant URL and not your custom domain.\n"
                },
                "wellKnownUrl": {
                    "type": "string",
                    "description": "The URL for the Shared Signals Framework configuration, e.g. '/.well-known/sse-configuration/{integration*uuid}/'. https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1\n"
                }
            },
            "required": [
                "accountId",
                "active",
                "integrationType",
                "referenceId",
                "tenantUrl",
                "wellKnownUrl"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.\n"
                },
                "integrationType": {
                    "type": "string",
                    "description": "The type of integration, e.g. 'Okta'. Full list of allowed values can be found here: https://developers.cloudflare.com/api/operations/dlp-zt-risk-score-integration-create#request-body\n"
                },
                "referenceId": {
                    "type": "string",
                    "description": "A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). If omitted, a random UUIDv4 is used. https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider\n"
                },
                "tenantUrl": {
                    "type": "string",
                    "description": "The base url of the tenant, e.g. 'https://tenant.okta.com'. Must be your Okta Tenant URL and not your custom domain.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "integrationType",
                "tenantUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustRiskScoreIntegration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "active": {
                        "type": "boolean",
                        "description": "Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.\n"
                    },
                    "integrationType": {
                        "type": "string",
                        "description": "The type of integration, e.g. 'Okta'. Full list of allowed values can be found here: https://developers.cloudflare.com/api/operations/dlp-zt-risk-score-integration-create#request-body\n"
                    },
                    "referenceId": {
                        "type": "string",
                        "description": "A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). If omitted, a random UUIDv4 is used. https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider\n"
                    },
                    "tenantUrl": {
                        "type": "string",
                        "description": "The base url of the tenant, e.g. 'https://tenant.okta.com'. Must be your Okta Tenant URL and not your custom domain.\n"
                    },
                    "wellKnownUrl": {
                        "type": "string",
                        "description": "The URL for the Shared Signals Framework configuration, e.g. '/.well-known/sse-configuration/{integration*uuid}/'. https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustSplitTunnel:ZeroTrustSplitTunnel": {
            "description": "Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either\ninclude or exclude lists of routes from the WARP client's tunnel.\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this split tunnel policy.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustSplitTunnelTunnel:ZeroTrustSplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes.\n"
                }
            },
            "required": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this split tunnel policy.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustSplitTunnelTunnel:ZeroTrustSplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustSplitTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The settings policy for which to configure this split tunnel policy.\n"
                    },
                    "tunnels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZeroTrustSplitTunnelTunnel:ZeroTrustSplitTunnelTunnel"
                        },
                        "description": "The value of the tunnel attributes.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustTunnelCloudflared:ZeroTrustTunnelCloudflared": {
            "description": "Tunnel exposes applications running on your local web server on any\nnetwork with an internet connection without manually adding DNS\nrecords or configuring a firewall or router.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustTunnelCloudflared(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"my-tunnel\",\n    secret: \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustTunnelCloudflared(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"my-tunnel\",\n    secret=\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustTunnelCloudflared(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"my-tunnel\",\n        Secret = \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustTunnelCloudflared(ctx, \"example\", \u0026cloudflare.ZeroTrustTunnelCloudflaredArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"my-tunnel\"),\n\t\t\tSecret:    pulumi.String(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflared;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflaredArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustTunnelCloudflared(\"example\", ZeroTrustTunnelCloudflaredArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"my-tunnel\")\n            .secret(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustTunnelCloudflared\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: my-tunnel\n      secret: AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustTunnelCloudflared:ZeroTrustTunnelCloudflared example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Usable CNAME for accessing the Tunnel.\n"
                },
                "configSrc": {
                    "type": "string",
                    "description": "Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                },
                "tunnelToken": {
                    "type": "string",
                    "description": "Token used by a connector to authenticate and run the tunnel.\n",
                    "secret": true
                }
            },
            "required": [
                "accountId",
                "cname",
                "name",
                "secret",
                "tunnelToken"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configSrc": {
                    "type": "string",
                    "description": "Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "secret"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustTunnelCloudflared resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "cname": {
                        "type": "string",
                        "description": "Usable CNAME for accessing the Tunnel.\n"
                    },
                    "configSrc": {
                        "type": "string",
                        "description": "Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "secret": {
                        "type": "string",
                        "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "tunnelToken": {
                        "type": "string",
                        "description": "Token used by a connector to authenticate and run the tunnel.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustTunnelCloudflaredConfig:ZeroTrustTunnelCloudflaredConfig": {
            "description": "Provides a Cloudflare Tunnel configuration resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleTunnel = new cloudflare.ZeroTrustTunnelCloudflared(\"example_tunnel\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_tunnel\",\n    secret: \"\u003c32 character secret\u003e\",\n});\nconst exampleConfig = new cloudflare.ZeroTrustTunnelCloudflaredConfig(\"example_config\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tunnelId: exampleTunnel.id,\n    config: {\n        warpRouting: {\n            enabled: true,\n        },\n        originRequest: {\n            connectTimeout: \"1m0s\",\n            tlsTimeout: \"1m0s\",\n            tcpKeepAlive: \"1m0s\",\n            noHappyEyeballs: false,\n            keepAliveConnections: 1024,\n            keepAliveTimeout: \"1m0s\",\n            httpHostHeader: \"baz\",\n            originServerName: \"foobar\",\n            caPool: \"/path/to/unsigned/ca/pool\",\n            noTlsVerify: false,\n            disableChunkedEncoding: false,\n            bastionMode: false,\n            proxyAddress: \"10.0.0.1\",\n            proxyPort: 8123,\n            proxyType: \"socks\",\n            ipRules: [{\n                prefix: \"/web\",\n                ports: [\n                    80,\n                    443,\n                ],\n                allow: false,\n            }],\n        },\n        ingressRules: [\n            {\n                hostname: \"foo\",\n                path: \"/bar\",\n                service: \"http://10.0.0.2:8080\",\n                originRequest: {\n                    connectTimeout: \"2m0s\",\n                    access: {\n                        required: true,\n                        teamName: \"terraform\",\n                        audTags: [\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"],\n                    },\n                },\n            },\n            {\n                service: \"https://10.0.0.3:8081\",\n            },\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_tunnel = cloudflare.ZeroTrustTunnelCloudflared(\"example_tunnel\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_tunnel\",\n    secret=\"\u003c32 character secret\u003e\")\nexample_config = cloudflare.ZeroTrustTunnelCloudflaredConfig(\"example_config\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tunnel_id=example_tunnel.id,\n    config={\n        \"warp_routing\": {\n            \"enabled\": True,\n        },\n        \"origin_request\": {\n            \"connect_timeout\": \"1m0s\",\n            \"tls_timeout\": \"1m0s\",\n            \"tcp_keep_alive\": \"1m0s\",\n            \"no_happy_eyeballs\": False,\n            \"keep_alive_connections\": 1024,\n            \"keep_alive_timeout\": \"1m0s\",\n            \"http_host_header\": \"baz\",\n            \"origin_server_name\": \"foobar\",\n            \"ca_pool\": \"/path/to/unsigned/ca/pool\",\n            \"no_tls_verify\": False,\n            \"disable_chunked_encoding\": False,\n            \"bastion_mode\": False,\n            \"proxy_address\": \"10.0.0.1\",\n            \"proxy_port\": 8123,\n            \"proxy_type\": \"socks\",\n            \"ip_rules\": [{\n                \"prefix\": \"/web\",\n                \"ports\": [\n                    80,\n                    443,\n                ],\n                \"allow\": False,\n            }],\n        },\n        \"ingress_rules\": [\n            {\n                \"hostname\": \"foo\",\n                \"path\": \"/bar\",\n                \"service\": \"http://10.0.0.2:8080\",\n                \"origin_request\": {\n                    \"connect_timeout\": \"2m0s\",\n                    \"access\": {\n                        \"required\": True,\n                        \"team_name\": \"terraform\",\n                        \"aud_tags\": [\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"],\n                    },\n                },\n            },\n            {\n                \"service\": \"https://10.0.0.3:8081\",\n            },\n        ],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleTunnel = new Cloudflare.ZeroTrustTunnelCloudflared(\"example_tunnel\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_tunnel\",\n        Secret = \"\u003c32 character secret\u003e\",\n    });\n\n    var exampleConfig = new Cloudflare.ZeroTrustTunnelCloudflaredConfig(\"example_config\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TunnelId = exampleTunnel.Id,\n        Config = new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigArgs\n        {\n            WarpRouting = new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs\n            {\n                Enabled = true,\n            },\n            OriginRequest = new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs\n            {\n                ConnectTimeout = \"1m0s\",\n                TlsTimeout = \"1m0s\",\n                TcpKeepAlive = \"1m0s\",\n                NoHappyEyeballs = false,\n                KeepAliveConnections = 1024,\n                KeepAliveTimeout = \"1m0s\",\n                HttpHostHeader = \"baz\",\n                OriginServerName = \"foobar\",\n                CaPool = \"/path/to/unsigned/ca/pool\",\n                NoTlsVerify = false,\n                DisableChunkedEncoding = false,\n                BastionMode = false,\n                ProxyAddress = \"10.0.0.1\",\n                ProxyPort = 8123,\n                ProxyType = \"socks\",\n                IpRules = new[]\n                {\n                    new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs\n                    {\n                        Prefix = \"/web\",\n                        Ports = new[]\n                        {\n                            80,\n                            443,\n                        },\n                        Allow = false,\n                    },\n                },\n            },\n            IngressRules = new[]\n            {\n                new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs\n                {\n                    Hostname = \"foo\",\n                    Path = \"/bar\",\n                    Service = \"http://10.0.0.2:8080\",\n                    OriginRequest = new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs\n                    {\n                        ConnectTimeout = \"2m0s\",\n                        Access = new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs\n                        {\n                            Required = true,\n                            TeamName = \"terraform\",\n                            AudTags = new[]\n                            {\n                                \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n                            },\n                        },\n                    },\n                },\n                new Cloudflare.Inputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs\n                {\n                    Service = \"https://10.0.0.3:8081\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleTunnel, err := cloudflare.NewZeroTrustTunnelCloudflared(ctx, \"example_tunnel\", \u0026cloudflare.ZeroTrustTunnelCloudflaredArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example_tunnel\"),\n\t\t\tSecret:    pulumi.String(\"\u003c32 character secret\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewZeroTrustTunnelCloudflaredConfig(ctx, \"example_config\", \u0026cloudflare.ZeroTrustTunnelCloudflaredConfigArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTunnelId:  exampleTunnel.ID(),\n\t\t\tConfig: \u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigArgs{\n\t\t\t\tWarpRouting: \u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\tOriginRequest: \u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs{\n\t\t\t\t\tConnectTimeout:         pulumi.String(\"1m0s\"),\n\t\t\t\t\tTlsTimeout:             pulumi.String(\"1m0s\"),\n\t\t\t\t\tTcpKeepAlive:           pulumi.String(\"1m0s\"),\n\t\t\t\t\tNoHappyEyeballs:        pulumi.Bool(false),\n\t\t\t\t\tKeepAliveConnections:   pulumi.Int(1024),\n\t\t\t\t\tKeepAliveTimeout:       pulumi.String(\"1m0s\"),\n\t\t\t\t\tHttpHostHeader:         pulumi.String(\"baz\"),\n\t\t\t\t\tOriginServerName:       pulumi.String(\"foobar\"),\n\t\t\t\t\tCaPool:                 pulumi.String(\"/path/to/unsigned/ca/pool\"),\n\t\t\t\t\tNoTlsVerify:            pulumi.Bool(false),\n\t\t\t\t\tDisableChunkedEncoding: pulumi.Bool(false),\n\t\t\t\t\tBastionMode:            pulumi.Bool(false),\n\t\t\t\t\tProxyAddress:           pulumi.String(\"10.0.0.1\"),\n\t\t\t\t\tProxyPort:              pulumi.Int(8123),\n\t\t\t\t\tProxyType:              pulumi.String(\"socks\"),\n\t\t\t\t\tIpRules: cloudflare.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArray{\n\t\t\t\t\t\t\u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs{\n\t\t\t\t\t\t\tPrefix: pulumi.String(\"/web\"),\n\t\t\t\t\t\t\tPorts: pulumi.IntArray{\n\t\t\t\t\t\t\t\tpulumi.Int(80),\n\t\t\t\t\t\t\t\tpulumi.Int(443),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAllow: pulumi.Bool(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tIngressRules: cloudflare.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArray{\n\t\t\t\t\t\u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs{\n\t\t\t\t\t\tHostname: pulumi.String(\"foo\"),\n\t\t\t\t\t\tPath:     pulumi.String(\"/bar\"),\n\t\t\t\t\t\tService:  pulumi.String(\"http://10.0.0.2:8080\"),\n\t\t\t\t\t\tOriginRequest: \u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs{\n\t\t\t\t\t\t\tConnectTimeout: pulumi.String(\"2m0s\"),\n\t\t\t\t\t\t\tAccess: \u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs{\n\t\t\t\t\t\t\t\tRequired: pulumi.Bool(true),\n\t\t\t\t\t\t\t\tTeamName: pulumi.String(\"terraform\"),\n\t\t\t\t\t\t\t\tAudTags: pulumi.StringArray{\n\t\t\t\t\t\t\t\t\tpulumi.String(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\u0026cloudflare.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs{\n\t\t\t\t\t\tService: pulumi.String(\"https://10.0.0.3:8081\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflared;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflaredArgs;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflaredConfig;\nimport com.pulumi.cloudflare.ZeroTrustTunnelCloudflaredConfigArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustTunnelCloudflaredConfigConfigArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs;\nimport com.pulumi.cloudflare.inputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleTunnel = new ZeroTrustTunnelCloudflared(\"exampleTunnel\", ZeroTrustTunnelCloudflaredArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_tunnel\")\n            .secret(\"\u003c32 character secret\u003e\")\n            .build());\n\n        var exampleConfig = new ZeroTrustTunnelCloudflaredConfig(\"exampleConfig\", ZeroTrustTunnelCloudflaredConfigArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tunnelId(exampleTunnel.id())\n            .config(ZeroTrustTunnelCloudflaredConfigConfigArgs.builder()\n                .warpRouting(ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs.builder()\n                    .enabled(true)\n                    .build())\n                .originRequest(ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs.builder()\n                    .connectTimeout(\"1m0s\")\n                    .tlsTimeout(\"1m0s\")\n                    .tcpKeepAlive(\"1m0s\")\n                    .noHappyEyeballs(false)\n                    .keepAliveConnections(1024)\n                    .keepAliveTimeout(\"1m0s\")\n                    .httpHostHeader(\"baz\")\n                    .originServerName(\"foobar\")\n                    .caPool(\"/path/to/unsigned/ca/pool\")\n                    .noTlsVerify(false)\n                    .disableChunkedEncoding(false)\n                    .bastionMode(false)\n                    .proxyAddress(\"10.0.0.1\")\n                    .proxyPort(\"8123\")\n                    .proxyType(\"socks\")\n                    .ipRules(ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRuleArgs.builder()\n                        .prefix(\"/web\")\n                        .ports(                        \n                            80,\n                            443)\n                        .allow(false)\n                        .build())\n                    .build())\n                .ingressRules(                \n                    ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs.builder()\n                        .hostname(\"foo\")\n                        .path(\"/bar\")\n                        .service(\"http://10.0.0.2:8080\")\n                        .originRequest(ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestArgs.builder()\n                            .connectTimeout(\"2m0s\")\n                            .access(ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccessArgs.builder()\n                                .required(true)\n                                .teamName(\"terraform\")\n                                .audTags(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")\n                                .build())\n                            .build())\n                        .build(),\n                    ZeroTrustTunnelCloudflaredConfigConfigIngressRuleArgs.builder()\n                        .service(\"https://10.0.0.3:8081\")\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleTunnel:\n    type: cloudflare:ZeroTrustTunnelCloudflared\n    name: example_tunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_tunnel\n      secret: \u003c32 character secret\u003e\n  exampleConfig:\n    type: cloudflare:ZeroTrustTunnelCloudflaredConfig\n    name: example_config\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tunnelId: ${exampleTunnel.id}\n      config:\n        warpRouting:\n          enabled: true\n        originRequest:\n          connectTimeout: 1m0s\n          tlsTimeout: 1m0s\n          tcpKeepAlive: 1m0s\n          noHappyEyeballs: false\n          keepAliveConnections: 1024\n          keepAliveTimeout: 1m0s\n          httpHostHeader: baz\n          originServerName: foobar\n          caPool: /path/to/unsigned/ca/pool\n          noTlsVerify: false\n          disableChunkedEncoding: false\n          bastionMode: false\n          proxyAddress: 10.0.0.1\n          proxyPort: '8123'\n          proxyType: socks\n          ipRules:\n            - prefix: /web\n              ports:\n                - 80\n                - 443\n              allow: false\n        ingressRules:\n          - hostname: foo\n            path: /bar\n            service: http://10.0.0.2:8080\n            originRequest:\n              connectTimeout: 2m0s\n              access:\n                required: true\n                teamName: terraform\n                audTags:\n                  - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n          - service: https://10.0.0.3:8081\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustTunnelCloudflaredConfig:ZeroTrustTunnelCloudflaredConfig example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfig:ZeroTrustTunnelCloudflaredConfigConfig",
                    "description": "Configuration block for Tunnel Configuration.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "Identifier of the Tunnel to target for this configuration.\n"
                }
            },
            "required": [
                "accountId",
                "config",
                "tunnelId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfig:ZeroTrustTunnelCloudflaredConfigConfig",
                    "description": "Configuration block for Tunnel Configuration.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "Identifier of the Tunnel to target for this configuration.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "config",
                "tunnelId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustTunnelCloudflaredConfig resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "config": {
                        "$ref": "#/types/cloudflare:index/ZeroTrustTunnelCloudflaredConfigConfig:ZeroTrustTunnelCloudflaredConfigConfig",
                        "description": "Configuration block for Tunnel Configuration.\n"
                    },
                    "tunnelId": {
                        "type": "string",
                        "description": "Identifier of the Tunnel to target for this configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustTunnelRoute:ZeroTrustTunnelRoute": {
            "description": "Provides a resource, that manages Cloudflare tunnel routes for Zero\nTrust. Tunnel routes are used to direct IP traffic through\nCloudflare Tunnels.\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustTunnelRoute:ZeroTrustTunnelRoute example \u003caccount_id\u003e/\u003cnetwork_cidr\u003e/\u003cvirtual_network_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "The ID of the tunnel that will service the tunnel route.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "network",
                "tunnelId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "The ID of the tunnel that will service the tunnel route.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "network",
                "tunnelId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustTunnelRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Description of the tunnel route.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                    },
                    "tunnelId": {
                        "type": "string",
                        "description": "The ID of the tunnel that will service the tunnel route.\n"
                    },
                    "virtualNetworkId": {
                        "type": "string",
                        "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zeroTrustTunnelVirtualNetwork:ZeroTrustTunnelVirtualNetwork": {
            "description": "Provides a resource, that manages Cloudflare tunnel virtual networks\nfor Zero Trust. Tunnel virtual networks are used for segregation of\nTunnel IP Routes via Virtualized Networks to handle overlapping\nprivate IPs in your origins.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZeroTrustTunnelVirtualNetwork(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"vnet-for-documentation\",\n    comment: \"New tunnel virtual network for documentation\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZeroTrustTunnelVirtualNetwork(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"vnet-for-documentation\",\n    comment=\"New tunnel virtual network for documentation\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZeroTrustTunnelVirtualNetwork(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"vnet-for-documentation\",\n        Comment = \"New tunnel virtual network for documentation\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZeroTrustTunnelVirtualNetwork(ctx, \"example\", \u0026cloudflare.ZeroTrustTunnelVirtualNetworkArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"vnet-for-documentation\"),\n\t\t\tComment:   pulumi.String(\"New tunnel virtual network for documentation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZeroTrustTunnelVirtualNetwork;\nimport com.pulumi.cloudflare.ZeroTrustTunnelVirtualNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZeroTrustTunnelVirtualNetwork(\"example\", ZeroTrustTunnelVirtualNetworkArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"vnet-for-documentation\")\n            .comment(\"New tunnel virtual network for documentation\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZeroTrustTunnelVirtualNetwork\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: vnet-for-documentation\n      comment: New tunnel virtual network for documentation\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zeroTrustTunnelVirtualNetwork:ZeroTrustTunnelVirtualNetwork example \u003caccount_id\u003e/\u003cvnet_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel virtual network.\n"
                },
                "isDefaultNetwork": {
                    "type": "boolean",
                    "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the virtual network is created.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel virtual network.\n"
                },
                "isDefaultNetwork": {
                    "type": "boolean",
                    "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the virtual network is created.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZeroTrustTunnelVirtualNetwork resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Description of the tunnel virtual network.\n"
                    },
                    "isDefaultNetwork": {
                        "type": "boolean",
                        "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the virtual network is created.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zone:Zone": {
            "description": "Provides a Cloudflare Zone resource. Zone is the basic resource for\nworking with Cloudflare and is roughly equivalent to a domain name\nthat the user purchases.\n\n\u003e If you are attempting to sign up a subdomain of a zone you must first have Subdomain Support entitlement for your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Zone(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    zone: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Zone(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    zone=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Zone(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ZoneName = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZone(ctx, \"example\", \u0026cloudflare.ZoneArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tZone:      pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Zone;\nimport com.pulumi.cloudflare.ZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Zone(\"example\", ZoneArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .zone(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Zone\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      zone: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zone:Zone example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to manage the zone resource in.\n"
                },
                "jumpStart": {
                    "type": "boolean",
                    "description": "Whether to scan for DNS records on creation. Ignored after zone is created.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    }
                },
                "nameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone. Available values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.\n"
                },
                "vanityNameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vanity Nameservers (if set).\n"
                },
                "verificationKey": {
                    "type": "string",
                    "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    }
                }
            },
            "required": [
                "accountId",
                "meta",
                "nameServers",
                "plan",
                "status",
                "vanityNameServers",
                "verificationKey",
                "zone"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to manage the zone resource in.\n"
                },
                "jumpStart": {
                    "type": "boolean",
                    "description": "Whether to scan for DNS records on creation. Ignored after zone is created.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.\n"
                },
                "vanityNameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vanity Nameservers (if set).\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Zone resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "Account ID to manage the zone resource in.\n"
                    },
                    "jumpStart": {
                        "type": "boolean",
                        "description": "Whether to scan for DNS records on creation. Ignored after zone is created.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "boolean"
                        }
                    },
                    "nameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the zone. Available values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.\n"
                    },
                    "vanityNameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vanity Nameservers (if set).\n"
                    },
                    "verificationKey": {
                        "type": "string",
                        "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**\n",
                        "language": {
                            "csharp": {
                                "name": "ZoneName"
                            }
                        },
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneCacheReserve:ZoneCacheReserve": {
            "description": "Provides a Cloudflare Cache Reserve resource. Cache Reserve can\nincrease cache lifetimes by automatically storing all cacheable\nfiles in Cloudflare's persistent object storage buckets.\n\nNote: Using Cache Reserve without Tiered Cache is not recommended.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZoneCacheReserve(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZoneCacheReserve(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZoneCacheReserve(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneCacheReserve(ctx, \"example\", \u0026cloudflare.ZoneCacheReserveArgs{\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneCacheReserve;\nimport com.pulumi.cloudflare.ZoneCacheReserveArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZoneCacheReserve(\"example\", ZoneCacheReserveArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZoneCacheReserve\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zoneCacheReserve:ZoneCacheReserve example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable or disable Cache Reserve support for a given zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable or disable Cache Reserve support for a given zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneCacheReserve resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable or disable Cache Reserve support for a given zone.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneCacheVariants:ZoneCacheVariants": {
            "description": "Provides a resource which customizes Cloudflare zone cache variants.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZoneCacheVariants(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    avifs: [\n        \"image/avif\",\n        \"image/webp\",\n    ],\n    bmps: [\n        \"image/bmp\",\n        \"image/webp\",\n    ],\n    gifs: [\n        \"image/gif\",\n        \"image/webp\",\n    ],\n    jpegs: [\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n    jpgs: [\n        \"image/jpg\",\n        \"image/webp\",\n    ],\n    jpg2s: [\n        \"image/jpg2\",\n        \"image/webp\",\n    ],\n    jp2s: [\n        \"image/jp2\",\n        \"image/webp\",\n    ],\n    pngs: [\n        \"image/png\",\n        \"image/webp\",\n    ],\n    tiffs: [\n        \"image/tiff\",\n        \"image/webp\",\n    ],\n    tifs: [\n        \"image/tif\",\n        \"image/webp\",\n    ],\n    webps: [\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZoneCacheVariants(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    avifs=[\n        \"image/avif\",\n        \"image/webp\",\n    ],\n    bmps=[\n        \"image/bmp\",\n        \"image/webp\",\n    ],\n    gifs=[\n        \"image/gif\",\n        \"image/webp\",\n    ],\n    jpegs=[\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n    jpgs=[\n        \"image/jpg\",\n        \"image/webp\",\n    ],\n    jpg2s=[\n        \"image/jpg2\",\n        \"image/webp\",\n    ],\n    jp2s=[\n        \"image/jp2\",\n        \"image/webp\",\n    ],\n    pngs=[\n        \"image/png\",\n        \"image/webp\",\n    ],\n    tiffs=[\n        \"image/tiff\",\n        \"image/webp\",\n    ],\n    tifs=[\n        \"image/tif\",\n        \"image/webp\",\n    ],\n    webps=[\n        \"image/jpeg\",\n        \"image/webp\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZoneCacheVariants(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Avifs = new[]\n        {\n            \"image/avif\",\n            \"image/webp\",\n        },\n        Bmps = new[]\n        {\n            \"image/bmp\",\n            \"image/webp\",\n        },\n        Gifs = new[]\n        {\n            \"image/gif\",\n            \"image/webp\",\n        },\n        Jpegs = new[]\n        {\n            \"image/jpeg\",\n            \"image/webp\",\n        },\n        Jpgs = new[]\n        {\n            \"image/jpg\",\n            \"image/webp\",\n        },\n        Jpg2s = new[]\n        {\n            \"image/jpg2\",\n            \"image/webp\",\n        },\n        Jp2s = new[]\n        {\n            \"image/jp2\",\n            \"image/webp\",\n        },\n        Pngs = new[]\n        {\n            \"image/png\",\n            \"image/webp\",\n        },\n        Tiffs = new[]\n        {\n            \"image/tiff\",\n            \"image/webp\",\n        },\n        Tifs = new[]\n        {\n            \"image/tif\",\n            \"image/webp\",\n        },\n        Webps = new[]\n        {\n            \"image/jpeg\",\n            \"image/webp\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneCacheVariants(ctx, \"example\", \u0026cloudflare.ZoneCacheVariantsArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tAvifs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/avif\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tBmps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/bmp\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tGifs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/gif\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJpegs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpeg\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJpgs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpg\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJpg2s: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpg2\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJp2s: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jp2\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tPngs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/png\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tTiffs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/tiff\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tTifs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/tif\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tWebps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpeg\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneCacheVariants;\nimport com.pulumi.cloudflare.ZoneCacheVariantsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZoneCacheVariants(\"example\", ZoneCacheVariantsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .avifs(            \n                \"image/avif\",\n                \"image/webp\")\n            .bmps(            \n                \"image/bmp\",\n                \"image/webp\")\n            .gifs(            \n                \"image/gif\",\n                \"image/webp\")\n            .jpegs(            \n                \"image/jpeg\",\n                \"image/webp\")\n            .jpgs(            \n                \"image/jpg\",\n                \"image/webp\")\n            .jpg2s(            \n                \"image/jpg2\",\n                \"image/webp\")\n            .jp2s(            \n                \"image/jp2\",\n                \"image/webp\")\n            .pngs(            \n                \"image/png\",\n                \"image/webp\")\n            .tiffs(            \n                \"image/tiff\",\n                \"image/webp\")\n            .tifs(            \n                \"image/tif\",\n                \"image/webp\")\n            .webps(            \n                \"image/jpeg\",\n                \"image/webp\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZoneCacheVariants\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      avifs:\n        - image/avif\n        - image/webp\n      bmps:\n        - image/bmp\n        - image/webp\n      gifs:\n        - image/gif\n        - image/webp\n      jpegs:\n        - image/jpeg\n        - image/webp\n      jpgs:\n        - image/jpg\n        - image/webp\n      jpg2s:\n        - image/jpg2\n        - image/webp\n      jp2s:\n        - image/jp2\n        - image/webp\n      pngs:\n        - image/png\n        - image/webp\n      tiffs:\n        - image/tiff\n        - image/webp\n      tifs:\n        - image/tif\n        - image/webp\n      webps:\n        - image/jpeg\n        - image/webp\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "avifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for avif.\n"
                },
                "bmps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for bmp.\n"
                },
                "gifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for gif.\n"
                },
                "jp2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jp2.\n"
                },
                "jpegs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpeg.\n"
                },
                "jpg2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg2.\n"
                },
                "jpgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg.\n"
                },
                "pngs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for png.\n"
                },
                "tiffs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tiff.\n"
                },
                "tifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tif.\n"
                },
                "webps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for webp.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "avifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for avif.\n"
                },
                "bmps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for bmp.\n"
                },
                "gifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for gif.\n"
                },
                "jp2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jp2.\n"
                },
                "jpegs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpeg.\n"
                },
                "jpg2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg2.\n"
                },
                "jpgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg.\n"
                },
                "pngs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for png.\n"
                },
                "tiffs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tiff.\n"
                },
                "tifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tif.\n"
                },
                "webps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for webp.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneCacheVariants resources.\n",
                "properties": {
                    "avifs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for avif.\n"
                    },
                    "bmps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for bmp.\n"
                    },
                    "gifs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for gif.\n"
                    },
                    "jp2s": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jp2.\n"
                    },
                    "jpegs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jpeg.\n"
                    },
                    "jpg2s": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jpg2.\n"
                    },
                    "jpgs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jpg.\n"
                    },
                    "pngs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for png.\n"
                    },
                    "tiffs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for tiff.\n"
                    },
                    "tifs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for tif.\n"
                    },
                    "webps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for webp.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneDnssec:ZoneDnssec": {
            "description": "Provides a Cloudflare resource to create and modify zone DNSSEC settings.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Zone(\"example\", {zone: \"example.com\"});\nconst exampleZoneDnssec = new cloudflare.ZoneDnssec(\"example\", {zoneId: example.id});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Zone(\"example\", zone=\"example.com\")\nexample_zone_dnssec = cloudflare.ZoneDnssec(\"example\", zone_id=example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Zone(\"example\", new()\n    {\n        ZoneName = \"example.com\",\n    });\n\n    var exampleZoneDnssec = new Cloudflare.ZoneDnssec(\"example\", new()\n    {\n        ZoneId = example.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.NewZone(ctx, \"example\", \u0026cloudflare.ZoneArgs{\n\t\t\tZone: pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewZoneDnssec(ctx, \"example\", \u0026cloudflare.ZoneDnssecArgs{\n\t\t\tZoneId: example.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Zone;\nimport com.pulumi.cloudflare.ZoneArgs;\nimport com.pulumi.cloudflare.ZoneDnssec;\nimport com.pulumi.cloudflare.ZoneDnssecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Zone(\"example\", ZoneArgs.builder()\n            .zone(\"example.com\")\n            .build());\n\n        var exampleZoneDnssec = new ZoneDnssec(\"exampleZoneDnssec\", ZoneDnssecArgs.builder()\n            .zoneId(example.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Zone\n    properties:\n      zone: example.com\n  exampleZoneDnssec:\n    type: cloudflare:ZoneDnssec\n    name: example\n    properties:\n      zoneId: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zoneDnssec:ZoneDnssec example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Zone DNSSEC algorithm.\n"
                },
                "digest": {
                    "type": "string",
                    "description": "Zone DNSSEC digest.\n"
                },
                "digestAlgorithm": {
                    "type": "string",
                    "description": "Digest algorithm use for Zone DNSSEC.\n"
                },
                "digestType": {
                    "type": "string",
                    "description": "Digest Type for Zone DNSSEC.\n"
                },
                "ds": {
                    "type": "string",
                    "description": "DS for the Zone DNSSEC.\n"
                },
                "flags": {
                    "type": "integer",
                    "description": "Zone DNSSEC flags.\n"
                },
                "keyTag": {
                    "type": "integer",
                    "description": "Key Tag for the Zone DNSSEC.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Key type used for Zone DNSSEC.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Zone DNSSEC updated time.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Public Key for the Zone DNSSEC.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the Zone DNSSEC.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "algorithm",
                "digest",
                "digestAlgorithm",
                "digestType",
                "ds",
                "flags",
                "keyTag",
                "keyType",
                "modifiedOn",
                "publicKey",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "modifiedOn": {
                    "type": "string",
                    "description": "Zone DNSSEC updated time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneDnssec resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Zone DNSSEC algorithm.\n"
                    },
                    "digest": {
                        "type": "string",
                        "description": "Zone DNSSEC digest.\n"
                    },
                    "digestAlgorithm": {
                        "type": "string",
                        "description": "Digest algorithm use for Zone DNSSEC.\n"
                    },
                    "digestType": {
                        "type": "string",
                        "description": "Digest Type for Zone DNSSEC.\n"
                    },
                    "ds": {
                        "type": "string",
                        "description": "DS for the Zone DNSSEC.\n"
                    },
                    "flags": {
                        "type": "integer",
                        "description": "Zone DNSSEC flags.\n"
                    },
                    "keyTag": {
                        "type": "integer",
                        "description": "Key Tag for the Zone DNSSEC.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Key type used for Zone DNSSEC.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Zone DNSSEC updated time.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public Key for the Zone DNSSEC.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the Zone DNSSEC.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneHold:ZoneHold": {
            "description": "Provides a Cloudflare Zone Hold resource that prevents adding\nthe hostname to another account for use.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZoneHold(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    hold: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZoneHold(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    hold=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZoneHold(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Hold = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneHold(ctx, \"example\", \u0026cloudflare.ZoneHoldArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tHold:   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneHold;\nimport com.pulumi.cloudflare.ZoneHoldArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZoneHold(\"example\", ZoneHoldArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .hold(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZoneHold\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      hold: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zoneHold:ZoneHold example \u003czone_id\u003e\n```\n\n",
            "properties": {
                "hold": {
                    "type": "boolean",
                    "description": "Enablement status of the zone hold.\n"
                },
                "holdAfter": {
                    "type": "string",
                    "description": "The RFC3339 compatible timestamp when to automatically re-enable the zone hold.\n"
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "Whether to extend to block any subdomain of the given zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "hold",
                "holdAfter",
                "zoneId"
            ],
            "inputProperties": {
                "hold": {
                    "type": "boolean",
                    "description": "Enablement status of the zone hold.\n"
                },
                "holdAfter": {
                    "type": "string",
                    "description": "The RFC3339 compatible timestamp when to automatically re-enable the zone hold.\n"
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "Whether to extend to block any subdomain of the given zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "hold",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneHold resources.\n",
                "properties": {
                    "hold": {
                        "type": "boolean",
                        "description": "Enablement status of the zone hold.\n"
                    },
                    "holdAfter": {
                        "type": "string",
                        "description": "The RFC3339 compatible timestamp when to automatically re-enable the zone hold.\n"
                    },
                    "includeSubdomains": {
                        "type": "boolean",
                        "description": "Whether to extend to block any subdomain of the given zone.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneLockdown:ZoneLockdown": {
            "description": "Provides a Cloudflare Zone Lockdown resource. Zone Lockdown allows\nyou to define one or more URLs (with wildcard matching on the domain\nor path) that will only permit access if the request originates\nfrom an IP address that matches a safelist of one or more IP\naddresses and/or IP ranges.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Restrict access to these endpoints to requests from a known IP address range.\nconst example = new cloudflare.ZoneLockdown(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    paused: false,\n    description: \"Restrict access to these endpoints to requests from a known IP address range\",\n    urls: [\"api.mysite.com/some/endpoint*\"],\n    configurations: [{\n        target: \"ip_range\",\n        value: \"192.0.2.0/24\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Restrict access to these endpoints to requests from a known IP address range.\nexample = cloudflare.ZoneLockdown(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    paused=False,\n    description=\"Restrict access to these endpoints to requests from a known IP address range\",\n    urls=[\"api.mysite.com/some/endpoint*\"],\n    configurations=[{\n        \"target\": \"ip_range\",\n        \"value\": \"192.0.2.0/24\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Restrict access to these endpoints to requests from a known IP address range.\n    var example = new Cloudflare.ZoneLockdown(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Paused = false,\n        Description = \"Restrict access to these endpoints to requests from a known IP address range\",\n        Urls = new[]\n        {\n            \"api.mysite.com/some/endpoint*\",\n        },\n        Configurations = new[]\n        {\n            new Cloudflare.Inputs.ZoneLockdownConfigurationArgs\n            {\n                Target = \"ip_range\",\n                Value = \"192.0.2.0/24\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Restrict access to these endpoints to requests from a known IP address range.\n\t\t_, err := cloudflare.NewZoneLockdown(ctx, \"example\", \u0026cloudflare.ZoneLockdownArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tPaused:      pulumi.Bool(false),\n\t\t\tDescription: pulumi.String(\"Restrict access to these endpoints to requests from a known IP address range\"),\n\t\t\tUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api.mysite.com/some/endpoint*\"),\n\t\t\t},\n\t\t\tConfigurations: cloudflare.ZoneLockdownConfigurationArray{\n\t\t\t\t\u0026cloudflare.ZoneLockdownConfigurationArgs{\n\t\t\t\t\tTarget: pulumi.String(\"ip_range\"),\n\t\t\t\t\tValue:  pulumi.String(\"192.0.2.0/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneLockdown;\nimport com.pulumi.cloudflare.ZoneLockdownArgs;\nimport com.pulumi.cloudflare.inputs.ZoneLockdownConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Restrict access to these endpoints to requests from a known IP address range.\n        var example = new ZoneLockdown(\"example\", ZoneLockdownArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .paused(\"false\")\n            .description(\"Restrict access to these endpoints to requests from a known IP address range\")\n            .urls(\"api.mysite.com/some/endpoint*\")\n            .configurations(ZoneLockdownConfigurationArgs.builder()\n                .target(\"ip_range\")\n                .value(\"192.0.2.0/24\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Restrict access to these endpoints to requests from a known IP address range.\n  example:\n    type: cloudflare:ZoneLockdown\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      paused: 'false'\n      description: Restrict access to these endpoints to requests from a known IP address range\n      urls:\n        - api.mysite.com/some/endpoint*\n      configurations:\n        - target: ip_range\n          value: 192.0.2.0/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import cloudflare:index/zoneLockdown:ZoneLockdown example \u003czone_id\u003e/\u003clockdown_id\u003e\n```\n\n",
            "properties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Defaults to `false`.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "inputProperties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Defaults to `false`.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneLockdown resources.\n",
                "properties": {
                    "configurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                        },
                        "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Boolean of whether this zone lockdown is currently paused. Defaults to `false`.\n"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneSettingsOverride:ZoneSettingsOverride": {
            "description": "Provides a resource which customizes Cloudflare zone settings.\n\n\u003e You **should not** use this resource to manage every zone setting. This\n  resource is only intended to override those which you do not want the default.\n  Attempting to manage all settings will result in problems with the resource\n  applying in a consistent manner.\n\n## Plan-Dependent Settings\n\nNote that some settings are only available on certain plans. Setting an argument\nfor a feature that is not available on the plan configured for the zone will\nresult in an error:\n\n```\nError: invalid zone setting \"\\\u003cargument\\\u003e\" (value: \\\u003cvalue\\\u003e) found - cannot be set as it is read only\n```\n\nThis is true even when setting the argument to its default value. These values\nshould either be omitted or set to `null` for zones with plans that don't\nsupport the feature. See the [plan feature matrices](https://www.cloudflare.com/plans/) for details on\nfeature support by plan.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = new cloudflare.ZoneSettingsOverride(\"test\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    settings: {\n        brotli: \"on\",\n        challengeTtl: 2700,\n        securityLevel: \"high\",\n        opportunisticEncryption: \"on\",\n        automaticHttpsRewrites: \"on\",\n        mirage: \"on\",\n        waf: \"on\",\n        minify: {\n            css: \"on\",\n            js: \"off\",\n            html: \"off\",\n        },\n        securityHeader: {\n            enabled: true,\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.ZoneSettingsOverride(\"test\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    settings={\n        \"brotli\": \"on\",\n        \"challenge_ttl\": 2700,\n        \"security_level\": \"high\",\n        \"opportunistic_encryption\": \"on\",\n        \"automatic_https_rewrites\": \"on\",\n        \"mirage\": \"on\",\n        \"waf\": \"on\",\n        \"minify\": {\n            \"css\": \"on\",\n            \"js\": \"off\",\n            \"html\": \"off\",\n        },\n        \"security_header\": {\n            \"enabled\": True,\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Cloudflare.ZoneSettingsOverride(\"test\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Settings = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsArgs\n        {\n            Brotli = \"on\",\n            ChallengeTtl = 2700,\n            SecurityLevel = \"high\",\n            OpportunisticEncryption = \"on\",\n            AutomaticHttpsRewrites = \"on\",\n            Mirage = \"on\",\n            Waf = \"on\",\n            Minify = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsMinifyArgs\n            {\n                Css = \"on\",\n                Js = \"off\",\n                Html = \"off\",\n            },\n            SecurityHeader = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs\n            {\n                Enabled = true,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneSettingsOverride(ctx, \"test\", \u0026cloudflare.ZoneSettingsOverrideArgs{\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tSettings: \u0026cloudflare.ZoneSettingsOverrideSettingsArgs{\n\t\t\t\tBrotli:                  pulumi.String(\"on\"),\n\t\t\t\tChallengeTtl:            pulumi.Int(2700),\n\t\t\t\tSecurityLevel:           pulumi.String(\"high\"),\n\t\t\t\tOpportunisticEncryption: pulumi.String(\"on\"),\n\t\t\t\tAutomaticHttpsRewrites:  pulumi.String(\"on\"),\n\t\t\t\tMirage:                  pulumi.String(\"on\"),\n\t\t\t\tWaf:                     pulumi.String(\"on\"),\n\t\t\t\tMinify: \u0026cloudflare.ZoneSettingsOverrideSettingsMinifyArgs{\n\t\t\t\t\tCss:  pulumi.String(\"on\"),\n\t\t\t\t\tJs:   pulumi.String(\"off\"),\n\t\t\t\t\tHtml: pulumi.String(\"off\"),\n\t\t\t\t},\n\t\t\t\tSecurityHeader: \u0026cloudflare.ZoneSettingsOverrideSettingsSecurityHeaderArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneSettingsOverride;\nimport com.pulumi.cloudflare.ZoneSettingsOverrideArgs;\nimport com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsArgs;\nimport com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsMinifyArgs;\nimport com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ZoneSettingsOverride(\"test\", ZoneSettingsOverrideArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .settings(ZoneSettingsOverrideSettingsArgs.builder()\n                .brotli(\"on\")\n                .challengeTtl(2700)\n                .securityLevel(\"high\")\n                .opportunisticEncryption(\"on\")\n                .automaticHttpsRewrites(\"on\")\n                .mirage(\"on\")\n                .waf(\"on\")\n                .minify(ZoneSettingsOverrideSettingsMinifyArgs.builder()\n                    .css(\"on\")\n                    .js(\"off\")\n                    .html(\"off\")\n                    .build())\n                .securityHeader(ZoneSettingsOverrideSettingsSecurityHeaderArgs.builder()\n                    .enabled(true)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: cloudflare:ZoneSettingsOverride\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      settings:\n        brotli: on\n        challengeTtl: 2700\n        securityLevel: high\n        opportunisticEncryption: on\n        automaticHttpsRewrites: on\n        mirage: on\n        waf: on\n        minify:\n          css: on\n          js: off\n          html: off\n        securityHeader:\n          enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "initialSettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting"
                    }
                },
                "initialSettingsReadAt": {
                    "type": "string"
                },
                "readonlySettings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "settings": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneStatus": {
                    "type": "string"
                },
                "zoneType": {
                    "type": "string"
                }
            },
            "required": [
                "initialSettings",
                "initialSettingsReadAt",
                "readonlySettings",
                "settings",
                "zoneId",
                "zoneStatus",
                "zoneType"
            ],
            "inputProperties": {
                "settings": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneSettingsOverride resources.\n",
                "properties": {
                    "initialSettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting"
                        }
                    },
                    "initialSettingsReadAt": {
                        "type": "string"
                    },
                    "readonlySettings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "settings": {
                        "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneStatus": {
                        "type": "string"
                    },
                    "zoneType": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "cloudflare:index/getAccessApplication:getAccessApplication": {
            "description": "Use this data source to lookup a single [Access Application](https://developers.cloudflare.com/cloudflare-one/applications/)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessApplication.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application. Must provide only one of `name`, `domain`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAccessApplication.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    },
                    "aud": {
                        "description": "Application Audience (AUD) Tag of the application.\n",
                        "type": "string"
                    },
                    "domain": {
                        "description": "The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Friendly name of the Access Application. Must provide only one of `name`, `domain`.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "aud",
                    "domain",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getAccessIdentityProvider:getAccessIdentityProvider": {
            "description": "Use this data source to lookup a single [Access Identity Provider](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration) by name.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getAccessIdentityProvider({\n    name: \"Google SSO\",\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\nconst exampleAccessApplication = new cloudflare.AccessApplication(\"example\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"name\",\n    domain: \"name.example.com\",\n    type: \"self_hosted\",\n    sessionDuration: \"24h\",\n    allowedIdps: [example.then(example =\u003e example.id)],\n    autoRedirectToIdentity: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_access_identity_provider(name=\"Google SSO\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\")\nexample_access_application = cloudflare.AccessApplication(\"example\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"name\",\n    domain=\"name.example.com\",\n    type=\"self_hosted\",\n    session_duration=\"24h\",\n    allowed_idps=[example.id],\n    auto_redirect_to_identity=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetAccessIdentityProvider.Invoke(new()\n    {\n        Name = \"Google SSO\",\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n    var exampleAccessApplication = new Cloudflare.AccessApplication(\"example\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"name\",\n        Domain = \"name.example.com\",\n        Type = \"self_hosted\",\n        SessionDuration = \"24h\",\n        AllowedIdps = new[]\n        {\n            example.Apply(getAccessIdentityProviderResult =\u003e getAccessIdentityProviderResult.Id),\n        },\n        AutoRedirectToIdentity = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.LookupAccessIdentityProvider(ctx, \u0026cloudflare.LookupAccessIdentityProviderArgs{\n\t\t\tName:      \"Google SSO\",\n\t\t\tAccountId: pulumi.StringRef(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessApplication(ctx, \"example\", \u0026cloudflare.AccessApplicationArgs{\n\t\t\tZoneId:          pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:            pulumi.String(\"name\"),\n\t\t\tDomain:          pulumi.String(\"name.example.com\"),\n\t\t\tType:            pulumi.String(\"self_hosted\"),\n\t\t\tSessionDuration: pulumi.String(\"24h\"),\n\t\t\tAllowedIdps: pulumi.StringArray{\n\t\t\t\tpulumi.String(example.Id),\n\t\t\t},\n\t\t\tAutoRedirectToIdentity: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetAccessIdentityProviderArgs;\nimport com.pulumi.cloudflare.AccessApplication;\nimport com.pulumi.cloudflare.AccessApplicationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getAccessIdentityProvider(GetAccessIdentityProviderArgs.builder()\n            .name(\"Google SSO\")\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .build());\n\n        var exampleAccessApplication = new AccessApplication(\"exampleAccessApplication\", AccessApplicationArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"name\")\n            .domain(\"name.example.com\")\n            .type(\"self_hosted\")\n            .sessionDuration(\"24h\")\n            .allowedIdps(example.applyValue(getAccessIdentityProviderResult -\u003e getAccessIdentityProviderResult.id()))\n            .autoRedirectToIdentity(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAccessApplication:\n    type: cloudflare:AccessApplication\n    name: example\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: name\n      domain: name.example.com\n      type: self_hosted\n      sessionDuration: 24h\n      allowedIdps:\n        - ${example.id}\n      autoRedirectToIdentity: true\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getAccessIdentityProvider\n      Arguments:\n        name: Google SSO\n        accountId: f037e56e89293a057740de681ac9abbe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Access Identity Provider name to search for.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Access Identity Provider name to search for.\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "Access Identity Provider Type.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getAccountRoles:getAccountRoles": {
            "description": "Use this data source to lookup [Account Roles](https://api.cloudflare.com/#account-roles-properties).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst accountRoles = cloudflare.getAccountRoles({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\nconst rolesByName = accountRoles.then(accountRoles =\u003e .reduce((__obj, role) =\u003e ({ ...__obj, [role.name]: role })));\nconst member = new cloudflare.AccountMember(\"member\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    emailAddress: \"user@example.com\",\n    roleIds: [rolesByName.Administrator?.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\naccount_roles = cloudflare.get_account_roles(account_id=\"f037e56e89293a057740de681ac9abbe\")\nroles_by_name = {role.name: role for role in account_roles.roles}\nmember = cloudflare.AccountMember(\"member\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    email_address=\"user@example.com\",\n    role_ids=[roles_by_name[\"Administrator\"]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var accountRoles = Cloudflare.GetAccountRoles.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n    var rolesByName = ;\n\n    var member = new Cloudflare.AccountMember(\"member\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        EmailAddress = \"user@example.com\",\n        RoleIds = new[]\n        {\n            rolesByName.Apply(rolesByName =\u003e rolesByName.Administrator.Id),\n        },\n    });\n\n});\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccountRoles.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccountRoles.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "roles": {
                        "description": "A list of roles object.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getAccountRolesRole:getAccountRolesRole"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accountId",
                    "roles",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getAccounts:getAccounts": {
            "description": "Data source for looking up Cloudflare Accounts.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getAccounts({\n    name: \"example account\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_accounts(name=\"example account\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetAccounts.Invoke(new()\n    {\n        Name = \"example account\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetAccounts(ctx, \u0026cloudflare.GetAccountsArgs{\n\t\t\tName: pulumi.StringRef(\"example account\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetAccountsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getAccounts(GetAccountsArgs.builder()\n            .name(\"example account\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getAccounts\n      Arguments:\n        name: example account\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccounts.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The account name to target for the resource.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAccounts.\n",
                "properties": {
                    "accounts": {
                        "items": {
                            "$ref": "#/types/cloudflare:index/getAccountsAccount:getAccountsAccount"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The account name to target for the resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accounts",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getApiTokenPermissionGroups:getApiTokenPermissionGroups": {
            "description": "Use this data source to look up [API Token Permission Groups](https://developers.cloudflare.com/api/tokens/create/permissions).\nCommonly used as references within [`cloudflare_token`](https://www.terraform.io/docs/providers/cloudflare/r/api_token.html) resources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst all = cloudflare.getApiTokenPermissionGroups({});\nexport const dnsReadPermissionId = all.then(all =\u003e all.zone?.[\"DNS Read\"]);\nexport const accountLbMonitorsAndReadId = all.then(all =\u003e all.account?.[\"Load Balancing: Monitors and Pools Read\"]);\nexport const userMembershipsReadId = all.then(all =\u003e all.user?.[\"Memberships Read\"]);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nall = cloudflare.get_api_token_permission_groups()\npulumi.export(\"dnsReadPermissionId\", all.zone[\"DNS Read\"])\npulumi.export(\"accountLbMonitorsAndReadId\", all.account[\"Load Balancing: Monitors and Pools Read\"])\npulumi.export(\"userMembershipsReadId\", all.user[\"Memberships Read\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = Cloudflare.GetApiTokenPermissionGroups.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dnsReadPermissionId\"] = all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.Zone?.DNS_Read),\n        [\"accountLbMonitorsAndReadId\"] = all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.Account?.Load_Balancing__Monitors_and_Pools_Read),\n        [\"userMembershipsReadId\"] = all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.User?.Memberships_Read),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\nall, err := cloudflare.GetApiTokenPermissionGroups(ctx, map[string]interface{}{\n}, nil);\nif err != nil {\nreturn err\n}\nctx.Export(\"dnsReadPermissionId\", all.Zone.DNS Read)\nctx.Export(\"accountLbMonitorsAndReadId\", all.Account.Load Balancing: Monitors and Pools Read)\nctx.Export(\"userMembershipsReadId\", all.User.Memberships Read)\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = CloudflareFunctions.getApiTokenPermissionGroups();\n\n        ctx.export(\"dnsReadPermissionId\", all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.zone().DNS Read()));\n        ctx.export(\"accountLbMonitorsAndReadId\", all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.account().Load Balancing: Monitors and Pools Read()));\n        ctx.export(\"userMembershipsReadId\", all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.user().Memberships Read()));\n    }\n}\n```\n```yaml\nvariables:\n  all:\n    fn::invoke:\n      Function: cloudflare:getApiTokenPermissionGroups\n      Arguments: {}\noutputs:\n  # Get zone level DNS read permission ID.\n  dnsReadPermissionId: ${all.zone\"DNS Read\"[%!s(MISSING)]}\n  # Get account level \"Load Balancing: Monitors and Pools Read\" permission ID.\n  accountLbMonitorsAndReadId: '${all.account\"Load Balancing: Monitors and Pools Read\"[%!s(MISSING)]}'\n  # Get user level \"Memberships Read\" permission ID.\n  userMembershipsReadId: ${all.user\"Memberships Read\"[%!s(MISSING)]}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getApiTokenPermissionGroups.\n",
                "properties": {
                    "account": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of permissions for account level resources.\n",
                        "type": "object"
                    },
                    "id": {
                        "description": "Checksum of permissions.\n",
                        "type": "string"
                    },
                    "permissions": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "Use specific account, zone or user attributes instead.",
                        "description": "Map of all permissions available. Should not be used as some permissions will overlap resource scope. Instead, use resource level specific attributes.\n",
                        "type": "object"
                    },
                    "r2": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of permissions for r2 level resources.\n",
                        "type": "object"
                    },
                    "user": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of permissions for user level resources.\n",
                        "type": "object"
                    },
                    "zone": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of permissions for zone level resources.\n",
                        "type": "object"
                    }
                },
                "required": [
                    "account",
                    "id",
                    "permissions",
                    "r2",
                    "user",
                    "zone"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getDcvDelegation:getDcvDelegation": {
            "description": "Use this data source to retrieve the DCV Delegation unique identifier for a zone.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDcvDelegation.\n",
                "properties": {
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDcvDelegation.\n",
                "properties": {
                    "hostname": {
                        "description": "The DCV Delegation hostname\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The DCV Delegation unique identifier\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "hostname",
                    "id",
                    "zoneId"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getDevicePostureRules:getDevicePostureRules": {
            "description": "Use this data source to lookup a list of [Device Posture Rule](https://developers.cloudflare.com/cloudflare-one/identity/devices)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getDevicePostureRules({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"check for /dev/random\",\n    type: \"file\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_device_posture_rules(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"check for /dev/random\",\n    type=\"file\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetDevicePostureRules.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"check for /dev/random\",\n        Type = \"file\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetDevicePostureRules(ctx, \u0026cloudflare.GetDevicePostureRulesArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tName:      pulumi.StringRef(\"check for /dev/random\"),\n\t\t\tType:      pulumi.StringRef(\"file\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetDevicePostureRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getDevicePostureRules(GetDevicePostureRulesArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"check for /dev/random\")\n            .type(\"file\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getDevicePostureRules\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        name: check for /dev/random\n        type: file\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDevicePostureRules.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Device Posture Rule.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDevicePostureRules.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Name of the Device Posture Rule.\n",
                        "type": "string"
                    },
                    "rules": {
                        "description": "A list of matching Device Posture Rules.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getDevicePostureRulesRule:getDevicePostureRulesRule"
                        },
                        "type": "array"
                    },
                    "type": {
                        "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "rules",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getDevices:getDevices": {
            "description": "Use this data source to lookup [Devices](https://api.cloudflare.com/#devices-list-devices).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getDevices({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_devices(account_id=\"f037e56e89293a057740de681ac9abbe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetDevices.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetDevices(ctx, \u0026cloudflare.GetDevicesArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetDevicesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getDevices(GetDevicesArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getDevices\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDevices.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDevices.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "devices": {
                        "items": {
                            "$ref": "#/types/cloudflare:index/getDevicesDevice:getDevicesDevice"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "devices",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getDlpDatasets:getDlpDatasets": {
            "description": "Use this data source to retrieve all DLP datasets for an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getDlpDatasets({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_dlp_datasets(account_id=\"f037e56e89293a057740de681ac9abbe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetDlpDatasets.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetDlpDatasets(ctx, \u0026cloudflare.GetDlpDatasetsArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetDlpDatasetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getDlpDatasets(GetDlpDatasetsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getDlpDatasets\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDlpDatasets.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID to fetch DLP Datasets from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDlpDatasets.\n",
                "properties": {
                    "accountId": {
                        "description": "The account ID to fetch DLP Datasets from.\n",
                        "type": "string"
                    },
                    "datasets": {
                        "description": "A list of DLP Datasets.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getDlpDatasetsDataset:getDlpDatasetsDataset"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "datasets",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getGatewayAppTypes:getGatewayAppTypes": {
            "description": "Use this data source to retrieve all Gateway application types for an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getGatewayAppTypes({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_gateway_app_types(account_id=\"f037e56e89293a057740de681ac9abbe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetGatewayAppTypes.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetGatewayAppTypes(ctx, \u0026cloudflare.GetGatewayAppTypesArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetGatewayAppTypesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getGatewayAppTypes(GetGatewayAppTypesArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getGatewayAppTypes\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGatewayAppTypes.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID to fetch Gateway App Types from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGatewayAppTypes.\n",
                "properties": {
                    "accountId": {
                        "description": "The account ID to fetch Gateway App Types from.\n",
                        "type": "string"
                    },
                    "appTypes": {
                        "description": "A list of Gateway App Types.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getGatewayAppTypesAppType:getGatewayAppTypesAppType"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "appTypes",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getGatewayCategories:getGatewayCategories": {
            "description": "Use this data source to retrieve all Gateway categories for an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getGatewayCategories({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_gateway_categories(account_id=\"f037e56e89293a057740de681ac9abbe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetGatewayCategories.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetGatewayCategories(ctx, \u0026cloudflare.GetGatewayCategoriesArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetGatewayCategoriesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getGatewayCategories(GetGatewayCategoriesArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getGatewayCategories\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGatewayCategories.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID to fetch Gateway Categories from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGatewayCategories.\n",
                "properties": {
                    "accountId": {
                        "description": "The account ID to fetch Gateway Categories from.\n",
                        "type": "string"
                    },
                    "categories": {
                        "description": "A list of Gateway Categories.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getGatewayCategoriesCategory:getGatewayCategoriesCategory"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "categories",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getInfrastructureAccessTargets:getInfrastructureAccessTargets": {
            "description": "Use this data source to retrieve all Infrastructure Access Targets.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getInfrastructureAccessTargets({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostnameContains: \"example\",\n    ipv4: \"198.51.100.1\",\n});\nexport const targets = example.then(example =\u003e example.targets);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_infrastructure_access_targets(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname_contains=\"example\",\n    ipv4=\"198.51.100.1\")\npulumi.export(\"targets\", example.targets)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetInfrastructureAccessTargets.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        HostnameContains = \"example\",\n        Ipv4 = \"198.51.100.1\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"targets\"] = example.Apply(getInfrastructureAccessTargetsResult =\u003e getInfrastructureAccessTargetsResult.Targets),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.GetInfrastructureAccessTargets(ctx, \u0026cloudflare.GetInfrastructureAccessTargetsArgs{\n\t\t\tAccountId:        \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tHostnameContains: pulumi.StringRef(\"example\"),\n\t\t\tIpv4:             pulumi.StringRef(\"198.51.100.1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"targets\", example.Targets)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetInfrastructureAccessTargetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getInfrastructureAccessTargets(GetInfrastructureAccessTargetsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostnameContains(\"example\")\n            .ipv4(\"198.51.100.1\")\n            .build());\n\n        ctx.export(\"targets\", example.applyValue(getInfrastructureAccessTargetsResult -\u003e getInfrastructureAccessTargetsResult.targets()));\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getInfrastructureAccessTargets\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        hostnameContains: example\n        ipv4: 198.51.100.1\noutputs:\n  # output the list of targets the data source contains\n  targets: ${example.targets}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getInfrastructureAccessTargets.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "A date and time after a target was created to filter on.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname of the target.\n"
                    },
                    "hostnameContains": {
                        "type": "string",
                        "description": "Partial match to the hostname of a target\n"
                    },
                    "ipv4": {
                        "type": "string",
                        "description": "The target's IPv4 address.\n"
                    },
                    "ipv6": {
                        "type": "string",
                        "description": "The target's IPv6 address.\n"
                    },
                    "modifiedAfter": {
                        "type": "string",
                        "description": "A date and time after a target was modified to filter on.\n"
                    },
                    "virtualNetworkId": {
                        "type": "string",
                        "description": "The private virtual network identifier for the target.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getInfrastructureAccessTargets.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "createdAfter": {
                        "description": "A date and time after a target was created to filter on.\n",
                        "type": "string"
                    },
                    "hostname": {
                        "description": "The hostname of the target.\n",
                        "type": "string"
                    },
                    "hostnameContains": {
                        "description": "Partial match to the hostname of a target\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipv4": {
                        "description": "The target's IPv4 address.\n",
                        "type": "string"
                    },
                    "ipv6": {
                        "description": "The target's IPv6 address.\n",
                        "type": "string"
                    },
                    "modifiedAfter": {
                        "description": "A date and time after a target was modified to filter on.\n",
                        "type": "string"
                    },
                    "targets": {
                        "items": {
                            "$ref": "#/types/cloudflare:index/getInfrastructureAccessTargetsTarget:getInfrastructureAccessTargetsTarget"
                        },
                        "type": "array"
                    },
                    "virtualNetworkId": {
                        "description": "The private virtual network identifier for the target.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "targets",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getIpRanges:getIpRanges": {
            "description": "Use this data source to get the [IP ranges](https://www.cloudflare.com/ips/) of Cloudflare network.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as example from \"@pulumi/example\";\n\nconst cloudflare = cloudflare.getIpRanges({});\nconst example = new example.index.FirewallResource(\"example\", {\n    name: \"from-cloudflare\",\n    network: \"default\",\n    sourceRanges: cloudflare.ipv4CidrBlocks,\n    allow: [{\n        ports: \"443\",\n        protocol: \"tcp\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_example as example\n\ncloudflare = cloudflare.get_ip_ranges()\nexample = example.index.FirewallResource(\"example\",\n    name=from-cloudflare,\n    network=default,\n    source_ranges=cloudflare.ipv4_cidr_blocks,\n    allow=[{\n        ports: 443,\n        protocol: tcp,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Example = Pulumi.Example;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cloudflare = Cloudflare.GetIpRanges.Invoke();\n\n    var example = new Example.Index.FirewallResource(\"example\", new()\n    {\n        Name = \"from-cloudflare\",\n        Network = \"default\",\n        SourceRanges = cloudflare.Apply(getIpRangesResult =\u003e getIpRangesResult.Ipv4CidrBlocks),\n        Allow = new[]\n        {\n            \n            {\n                { \"ports\", \"443\" },\n                { \"protocol\", \"tcp\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-example/sdk/go/example\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcloudflare, err := cloudflare.GetIpRanges(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = example.NewFirewallResource(ctx, \"example\", \u0026example.FirewallResourceArgs{\n\t\t\tName:         \"from-cloudflare\",\n\t\t\tNetwork:      \"default\",\n\t\t\tSourceRanges: cloudflare.Ipv4CidrBlocks,\n\t\t\tAllow: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"ports\":    \"443\",\n\t\t\t\t\t\"protocol\": \"tcp\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.example.firewallResource;\nimport com.pulumi.example.FirewallResourceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var cloudflare = CloudflareFunctions.getIpRanges();\n\n        var example = new FirewallResource(\"example\", FirewallResourceArgs.builder()\n            .name(\"from-cloudflare\")\n            .network(\"default\")\n            .sourceRanges(cloudflare.applyValue(getIpRangesResult -\u003e getIpRangesResult.ipv4CidrBlocks()))\n            .allow(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: example:firewallResource\n    properties:\n      name: from-cloudflare\n      network: default\n      sourceRanges: ${cloudflare.ipv4CidrBlocks}\n      allow:\n        - ports: '443'\n          protocol: tcp\nvariables:\n  cloudflare:\n    fn::invoke:\n      Function: cloudflare:getIpRanges\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getIpRanges.\n",
                "properties": {
                    "chinaIpv4CidrBlocks": {
                        "description": "The lexically ordered list of only the IPv4 China CIDR blocks.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "chinaIpv6CidrBlocks": {
                        "description": "The lexically ordered list of only the IPv6 China CIDR blocks.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "cidrBlocks": {
                        "description": "The lexically ordered list of all non-China CIDR blocks.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipv4CidrBlocks": {
                        "description": "The lexically ordered list of only the IPv4 CIDR blocks.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "ipv6CidrBlocks": {
                        "description": "The lexically ordered list of only the IPv6 CIDR blocks.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "chinaIpv4CidrBlocks",
                    "chinaIpv6CidrBlocks",
                    "cidrBlocks",
                    "ipv4CidrBlocks",
                    "ipv6CidrBlocks",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getList:getList": {
            "description": "Use this data source to lookup a [List](https://developers.cloudflare.com/api/operations/lists-get-lists).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getList({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"list_name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_list(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"list_name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetList.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"list_name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupList(ctx, \u0026cloudflare.LookupListArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tName:      \"list_name\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getList(GetListArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"list_name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getList\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        name: list_name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getList.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The list name to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getList.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "List description.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "kind": {
                        "description": "List kind.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The list name to target for the resource.\n",
                        "type": "string"
                    },
                    "numitems": {
                        "description": "Number of items in list.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "accountId",
                    "description",
                    "kind",
                    "name",
                    "numitems",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getLists:getLists": {
            "description": "Use this data source to lookup [Lists](https://developers.cloudflare.com/api/operations/lists-get-lists).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getLists({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_lists(account_id=\"f037e56e89293a057740de681ac9abbe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetLists.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetLists(ctx, \u0026cloudflare.GetListsArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetListsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getLists(GetListsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getLists\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLists.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLists.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lists": {
                        "items": {
                            "$ref": "#/types/cloudflare:index/getListsList:getListsList"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accountId",
                    "lists",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getLoadBalancerPools:getLoadBalancerPools": {
            "description": "A datasource to find Load Balancer Pools.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getLoadBalancerPools({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    filter: {\n        name: \"example-lb-pool\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_load_balancer_pools(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    filter={\n        \"name\": \"example-lb-pool\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetLoadBalancerPools.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Filter = new Cloudflare.Inputs.GetLoadBalancerPoolsFilterInputArgs\n        {\n            Name = \"example-lb-pool\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetLoadBalancerPools(ctx, \u0026cloudflare.GetLoadBalancerPoolsArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tFilter: cloudflare.GetLoadBalancerPoolsFilter{\n\t\t\t\tName: pulumi.StringRef(\"example-lb-pool\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetLoadBalancerPoolsArgs;\nimport com.pulumi.cloudflare.inputs.GetLoadBalancerPoolsFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getLoadBalancerPools(GetLoadBalancerPoolsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .filter(GetLoadBalancerPoolsFilterArgs.builder()\n                .name(\"example-lb-pool\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getLoadBalancerPools\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        filter:\n          name: example-lb-pool\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLoadBalancerPools.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the datasource lookups.\n"
                    },
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsFilter:getLoadBalancerPoolsFilter",
                        "description": "One or more values used to look up Load Balancer pools. If more than one value is given all values must match in order to be included.\n"
                    },
                    "pools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPool:getLoadBalancerPoolsPool"
                        },
                        "description": "A list of Load Balancer Pools details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLoadBalancerPools.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the datasource lookups.\n",
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsFilter:getLoadBalancerPoolsFilter",
                        "description": "One or more values used to look up Load Balancer pools. If more than one value is given all values must match in order to be included.\n"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "pools": {
                        "description": "A list of Load Balancer Pools details.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPool:getLoadBalancerPoolsPool"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accountId",
                    "pools",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getOriginCaCertificate:getOriginCaCertificate": {
            "description": "Use this data source to retrieve an existing origin ca certificate.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getOriginCaCertificate({\n    id: \"REPLACE_ME\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_origin_ca_certificate(id=\"REPLACE_ME\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetOriginCaCertificate.Invoke(new()\n    {\n        Id = \"REPLACE_ME\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupOriginCaCertificate(ctx, \u0026cloudflare.LookupOriginCaCertificateArgs{\n\t\t\tId: \"REPLACE_ME\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetOriginCaCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getOriginCaCertificate(GetOriginCaCertificateArgs.builder()\n            .id(\"REPLACE_ME\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getOriginCaCertificate\n      Arguments:\n        id: REPLACE_ME\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOriginCaCertificate.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The Origin CA Certificate unique identifier.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOriginCaCertificate.\n",
                "properties": {
                    "certificate": {
                        "description": "The Origin CA certificate.\n",
                        "type": "string"
                    },
                    "expiresOn": {
                        "description": "The timestamp when the certificate will expire.\n",
                        "type": "string"
                    },
                    "hostnames": {
                        "description": "A list of hostnames or wildcard names bound to the certificate.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The Origin CA Certificate unique identifier.\n",
                        "type": "string"
                    },
                    "requestType": {
                        "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`\n",
                        "type": "string"
                    },
                    "revokedAt": {
                        "description": "The timestamp when the certificate was revoked.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "certificate",
                    "expiresOn",
                    "hostnames",
                    "id",
                    "requestType",
                    "revokedAt"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getOriginCaRootCertificate:getOriginCaRootCertificate": {
            "description": "Use this data source to get the\n[Origin CA root certificate](https://developers.cloudflare.com/ssl/origin-configuration/origin-ca#4-required-for-some-add-cloudflare-origin-ca-root-certificates)\nfor a given algorithm.\"\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getOriginCaRootCertificate({\n    algorithm: \"rsa\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_origin_ca_root_certificate(algorithm=\"rsa\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetOriginCaRootCertificate.Invoke(new()\n    {\n        Algorithm = \"rsa\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetOriginCaRootCertificate(ctx, \u0026cloudflare.GetOriginCaRootCertificateArgs{\n\t\t\tAlgorithm: \"rsa\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetOriginCaRootCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getOriginCaRootCertificate(GetOriginCaRootCertificateArgs.builder()\n            .algorithm(\"rsa\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getOriginCaRootCertificate\n      Arguments:\n        algorithm: rsa\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOriginCaRootCertificate.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "The name of the algorithm used when creating an Origin CA certificate. Available values: `rsa`, `ecc`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOriginCaRootCertificate.\n",
                "properties": {
                    "algorithm": {
                        "description": "The name of the algorithm used when creating an Origin CA certificate. Available values: `rsa`, `ecc`.\n",
                        "type": "string"
                    },
                    "certPem": {
                        "description": "The Origin CA root certificate in PEM format.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "algorithm",
                    "certPem",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getRecord:getRecord": {
            "description": "Use this data source to lookup a single [DNS Record](https://api.cloudflare.com/#dns-records-for-a-zone-properties).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getRecord({\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_record(zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    hostname=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetRecord.Invoke(new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Hostname = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupRecord(ctx, \u0026cloudflare.LookupRecordArgs{\n\t\t\tZoneId:   \"0da42c8d2132a9ddaf714f9e7c920711\",\n\t\t\tHostname: \"example.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getRecord(GetRecordArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .hostname(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getRecord\n      Arguments:\n        zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n        hostname: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRecord.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "Content to filter record results on.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname to filter DNS record results on.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "DNS priority to filter record results on.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "DNS record type to filter record results on. Defaults to `A`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostname",
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRecord.\n",
                "properties": {
                    "content": {
                        "description": "Content to filter record results on.\n",
                        "type": "string"
                    },
                    "hostname": {
                        "description": "Hostname to filter DNS record results on.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "priority": {
                        "description": "DNS priority to filter record results on.\n",
                        "type": "integer"
                    },
                    "proxiable": {
                        "description": "Proxiable status of the found DNS record.\n",
                        "type": "boolean"
                    },
                    "proxied": {
                        "description": "Proxied status of the found DNS record.\n",
                        "type": "boolean"
                    },
                    "ttl": {
                        "description": "TTL of the found DNS record.\n",
                        "type": "integer"
                    },
                    "type": {
                        "description": "DNS record type to filter record results on. Defaults to `A`.\n",
                        "type": "string"
                    },
                    "value": {
                        "description": "Value of the found DNS record.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "hostname",
                    "proxiable",
                    "proxied",
                    "ttl",
                    "value",
                    "zoneId",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getRulesets:getRulesets": {
            "description": "Use this datasource to lookup Rulesets in an account or zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getRulesets({\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    filter: {\n        name: \".*OWASP.*\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_rulesets(zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    filter={\n        \"name\": \".*OWASP.*\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetRulesets.Invoke(new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Filter = new Cloudflare.Inputs.GetRulesetsFilterInputArgs\n        {\n            Name = \".*OWASP.*\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetRulesets(ctx, \u0026cloudflare.GetRulesetsArgs{\n\t\t\tZoneId: pulumi.StringRef(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tFilter: cloudflare.GetRulesetsFilter{\n\t\t\t\tName: pulumi.StringRef(\".*OWASP.*\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetRulesetsArgs;\nimport com.pulumi.cloudflare.inputs.GetRulesetsFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getRulesets(GetRulesetsArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .filter(GetRulesetsFilterArgs.builder()\n                .name(\".*OWASP.*\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getRulesets\n      Arguments:\n        zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n        filter:\n          name: .*OWASP.*\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRulesets.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    },
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getRulesetsFilter:getRulesetsFilter"
                    },
                    "includeRules": {
                        "type": "boolean",
                        "description": "Include rule data in response.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getRulesets.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    },
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getRulesetsFilter:getRulesetsFilter"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "includeRules": {
                        "description": "Include rule data in response.\n",
                        "type": "boolean"
                    },
                    "rulesets": {
                        "items": {
                            "$ref": "#/types/cloudflare:index/getRulesetsRuleset:getRulesetsRuleset"
                        },
                        "type": "array"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "rulesets",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getTunnel:getTunnel": {
            "description": "Use this datasource to lookup a tunnel in an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getTunnel({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"my-tunnel\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_tunnel(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"my-tunnel\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetTunnel.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"my-tunnel\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupTunnel(ctx, \u0026cloudflare.LookupTunnelArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tName:      \"my-tunnel\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getTunnel(GetTunnelArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"my-tunnel\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getTunnel\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        name: my-tunnel\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTunnel.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "isDeleted": {
                        "type": "boolean",
                        "description": "If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the tunnel. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTunnel.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "ID of the tunnel.\n",
                        "type": "string"
                    },
                    "isDeleted": {
                        "description": "If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "Name of the tunnel. **Modifying this attribute will force creation of a new resource.**\n",
                        "type": "string"
                    },
                    "remoteConfig": {
                        "description": "Whether the tunnel can be configured remotely from the Zero Trust dashboard.\n",
                        "type": "boolean"
                    },
                    "status": {
                        "description": "The status of the tunnel. Available values: `inactive`, `degraded`, `healthy`, `down`.\n",
                        "type": "string"
                    },
                    "tunnelType": {
                        "description": "The type of the tunnel. Available values: `cfd_tunnel`, `warp_connector`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "id",
                    "name",
                    "remoteConfig",
                    "status",
                    "tunnelType"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getTunnelVirtualNetwork:getTunnelVirtualNetwork": {
            "description": "Use this datasource to lookup a tunnel virtual network in an account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getTunnelVirtualNetwork({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_tunnel_virtual_network(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetTunnelVirtualNetwork.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupTunnelVirtualNetwork(ctx, \u0026cloudflare.LookupTunnelVirtualNetworkArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tName:      \"example\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetTunnelVirtualNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getTunnelVirtualNetwork(GetTunnelVirtualNetworkArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getTunnelVirtualNetwork\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        name: example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTunnelVirtualNetwork.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Virtual Network Name.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTunnelVirtualNetwork.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "comment": {
                        "description": "The Virtual Network Comment.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isDefault": {
                        "description": "If true, only include deleted virtual networks. If false, exclude deleted virtual networks. If empty, all virtual networks will be included.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "The Virtual Network Name.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "comment",
                    "isDefault",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getUser:getUser": {
            "description": "Use this data source to retrieve information about the currently authenticated user.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst me = cloudflare.getUser({});\nconst all = cloudflare.getApiTokenPermissionGroups({});\nconst example = new cloudflare.ApiToken(\"example\", {\n    name: \"Terraform Cloud (Terraform)\",\n    policies: [{\n        permissionGroups: [all.then(all =\u003e all.user?.[\"User Details Read\"])],\n        resources: me.then(me =\u003e {\n            [`com.cloudflare.api.user.${me.id}`]: \"*\",\n        }),\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nme = cloudflare.get_user()\nall = cloudflare.get_api_token_permission_groups()\nexample = cloudflare.ApiToken(\"example\",\n    name=\"Terraform Cloud (Terraform)\",\n    policies=[{\n        \"permission_groups\": [all.user[\"User Details Read\"]],\n        \"resources\": {\n            \"\": \"*\",\n        },\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var me = Cloudflare.GetUser.Invoke();\n\n    var all = Cloudflare.GetApiTokenPermissionGroups.Invoke();\n\n    var example = new Cloudflare.ApiToken(\"example\", new()\n    {\n        Name = \"Terraform Cloud (Terraform)\",\n        Policies = new[]\n        {\n            new Cloudflare.Inputs.ApiTokenPolicyArgs\n            {\n                PermissionGroups = new[]\n                {\n                    all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.User?.User_Details_Read),\n                },\n                Resources = \n                {\n                    { $\"com.cloudflare.api.user.{me.Apply(getUserResult =\u003e getUserResult.Id)}\", \"*\" },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\nme, err := cloudflare.GetUser(ctx, map[string]interface{}{\n}, nil);\nif err != nil {\nreturn err\n}\nall, err := cloudflare.GetApiTokenPermissionGroups(ctx, map[string]interface{}{\n}, nil);\nif err != nil {\nreturn err\n}\n_, err = cloudflare.NewApiToken(ctx, \"example\", \u0026cloudflare.ApiTokenArgs{\nName: pulumi.String(\"Terraform Cloud (Terraform)\"),\nPolicies: cloudflare.ApiTokenPolicyArray{\n\u0026cloudflare.ApiTokenPolicyArgs{\nPermissionGroups: pulumi.StringArray{\npulumi.String(all.User.User Details Read),\n},\nResources: pulumi.StringMap{\nfmt.Sprintf(\"com.cloudflare.api.user.%v\", me.Id): pulumi.String(\"*\"),\n},\n},\n},\n})\nif err != nil {\nreturn err\n}\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.ApiToken;\nimport com.pulumi.cloudflare.ApiTokenArgs;\nimport com.pulumi.cloudflare.inputs.ApiTokenPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var me = CloudflareFunctions.getUser();\n\n        final var all = CloudflareFunctions.getApiTokenPermissionGroups();\n\n        var example = new ApiToken(\"example\", ApiTokenArgs.builder()\n            .name(\"Terraform Cloud (Terraform)\")\n            .policies(ApiTokenPolicyArgs.builder()\n                .permissionGroups(all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.user().User Details Read()))\n                .resources(Map.of(String.format(\"com.cloudflare.api.user.%s\", me.applyValue(getUserResult -\u003e getUserResult.id())), \"*\"))\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ApiToken\n    properties:\n      name: Terraform Cloud (Terraform)\n      policies:\n        - permissionGroups:\n            - ${all.user\"User Details Read\"[%!s(MISSING)]}\n          resources:\n            com.cloudflare.api.user.${me.id}: '*'\nvariables:\n  me:\n    fn::invoke:\n      Function: cloudflare:getUser\n      Arguments: {}\n  all:\n    fn::invoke:\n      Function: cloudflare:getApiTokenPermissionGroups\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "email": {
                        "description": "The user's email address.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The user's unique identifier.\n",
                        "type": "string"
                    },
                    "username": {
                        "description": "The user's username.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "email",
                    "id",
                    "username"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZeroTrustAccessApplication:getZeroTrustAccessApplication": {
            "description": "Use this data source to lookup a single [Access Application](https://developers.cloudflare.com/cloudflare-one/applications/)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZeroTrustAccessApplication.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application. Must provide only one of `name`, `domain`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZeroTrustAccessApplication.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    },
                    "aud": {
                        "description": "Application Audience (AUD) Tag of the application.\n",
                        "type": "string"
                    },
                    "domain": {
                        "description": "The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Friendly name of the Access Application. Must provide only one of `name`, `domain`.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "aud",
                    "domain",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZeroTrustAccessIdentityProvider:getZeroTrustAccessIdentityProvider": {
            "description": "Use this data source to lookup a single [Access Identity Provider](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration) by name.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZeroTrustAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Access Identity Provider name to search for.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZeroTrustAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Access Identity Provider name to search for.\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "Access Identity Provider Type.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZeroTrustInfrastructureAccessTargets:getZeroTrustInfrastructureAccessTargets": {
            "description": "Use this data source to retrieve all Infrastructure Access Targets.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZeroTrustInfrastructureAccessTargets({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    hostnameContains: \"example\",\n    ipv4: \"198.51.100.1\",\n});\nexport const targets = example.then(example =\u003e example.targets);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zero_trust_infrastructure_access_targets(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    hostname_contains=\"example\",\n    ipv4=\"198.51.100.1\")\npulumi.export(\"targets\", example.targets)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZeroTrustInfrastructureAccessTargets.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        HostnameContains = \"example\",\n        Ipv4 = \"198.51.100.1\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"targets\"] = example.Apply(getZeroTrustInfrastructureAccessTargetsResult =\u003e getZeroTrustInfrastructureAccessTargetsResult.Targets),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.GetZeroTrustInfrastructureAccessTargets(ctx, \u0026cloudflare.GetZeroTrustInfrastructureAccessTargetsArgs{\n\t\t\tAccountId:        \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tHostnameContains: pulumi.StringRef(\"example\"),\n\t\t\tIpv4:             pulumi.StringRef(\"198.51.100.1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"targets\", example.Targets)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZeroTrustInfrastructureAccessTargetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZeroTrustInfrastructureAccessTargets(GetZeroTrustInfrastructureAccessTargetsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .hostnameContains(\"example\")\n            .ipv4(\"198.51.100.1\")\n            .build());\n\n        ctx.export(\"targets\", example.applyValue(getZeroTrustInfrastructureAccessTargetsResult -\u003e getZeroTrustInfrastructureAccessTargetsResult.targets()));\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZeroTrustInfrastructureAccessTargets\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        hostnameContains: example\n        ipv4: 198.51.100.1\noutputs:\n  # output the list of targets the data source contains\n  targets: ${example.targets}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZeroTrustInfrastructureAccessTargets.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "A date and time after a target was created to filter on.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname of the target.\n"
                    },
                    "hostnameContains": {
                        "type": "string",
                        "description": "Partial match to the hostname of a target\n"
                    },
                    "ipv4": {
                        "type": "string",
                        "description": "The target's IPv4 address.\n"
                    },
                    "ipv6": {
                        "type": "string",
                        "description": "The target's IPv6 address.\n"
                    },
                    "modifiedAfter": {
                        "type": "string",
                        "description": "A date and time after a target was modified to filter on.\n"
                    },
                    "virtualNetworkId": {
                        "type": "string",
                        "description": "The private virtual network identifier for the target.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZeroTrustInfrastructureAccessTargets.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "createdAfter": {
                        "description": "A date and time after a target was created to filter on.\n",
                        "type": "string"
                    },
                    "hostname": {
                        "description": "The hostname of the target.\n",
                        "type": "string"
                    },
                    "hostnameContains": {
                        "description": "Partial match to the hostname of a target\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipv4": {
                        "description": "The target's IPv4 address.\n",
                        "type": "string"
                    },
                    "ipv6": {
                        "description": "The target's IPv6 address.\n",
                        "type": "string"
                    },
                    "modifiedAfter": {
                        "description": "A date and time after a target was modified to filter on.\n",
                        "type": "string"
                    },
                    "targets": {
                        "items": {
                            "$ref": "#/types/cloudflare:index/getZeroTrustInfrastructureAccessTargetsTarget:getZeroTrustInfrastructureAccessTargetsTarget"
                        },
                        "type": "array"
                    },
                    "virtualNetworkId": {
                        "description": "The private virtual network identifier for the target.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "targets",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZeroTrustTunnelCloudflared:getZeroTrustTunnelCloudflared": {
            "description": "Use this datasource to lookup a tunnel in an account.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZeroTrustTunnelCloudflared.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "isDeleted": {
                        "type": "boolean",
                        "description": "If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the tunnel. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZeroTrustTunnelCloudflared.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "ID of the tunnel.\n",
                        "type": "string"
                    },
                    "isDeleted": {
                        "description": "If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "Name of the tunnel. **Modifying this attribute will force creation of a new resource.**\n",
                        "type": "string"
                    },
                    "remoteConfig": {
                        "description": "Whether the tunnel can be configured remotely from the Zero Trust dashboard.\n",
                        "type": "boolean"
                    },
                    "status": {
                        "description": "The status of the tunnel. Available values: `inactive`, `degraded`, `healthy`, `down`.\n",
                        "type": "string"
                    },
                    "tunnelType": {
                        "description": "The type of the tunnel. Available values: `cfd_tunnel`, `warp_connector`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "id",
                    "name",
                    "remoteConfig",
                    "status",
                    "tunnelType"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZeroTrustTunnelVirtualNetwork:getZeroTrustTunnelVirtualNetwork": {
            "description": "Use this datasource to lookup a tunnel virtual network in an account.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZeroTrustTunnelVirtualNetwork.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Virtual Network Name.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZeroTrustTunnelVirtualNetwork.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "comment": {
                        "description": "The Virtual Network Comment.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isDefault": {
                        "description": "If true, only include deleted virtual networks. If false, exclude deleted virtual networks. If empty, all virtual networks will be included.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "The Virtual Network Name.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "comment",
                    "isDefault",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZone:getZone": {
            "description": "Use this data source to look up [zone](https://api.cloudflare.com/#zone-properties)\ninfo. This is the singular alternative to `cloudflare.getZones`.\n\n\u003e **Note** Cloudflare zone names **are not unique**. It is possible for multiple\naccounts to have the same zone created but in different states. If you are\nusing this setup, it is advised to use the `account_id` attribute on this\nresource or swap to `cloudflare.getZones` to further filter the results.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZone({\n    name: \"example.com\",\n});\nconst exampleRecord = new cloudflare.Record(\"example\", {\n    zoneId: example.then(example =\u003e example.id),\n    name: \"www\",\n    content: \"203.0.113.1\",\n    type: \"A\",\n    proxied: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone(name=\"example.com\")\nexample_record = cloudflare.Record(\"example\",\n    zone_id=example.id,\n    name=\"www\",\n    content=\"203.0.113.1\",\n    type=\"A\",\n    proxied=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZone.Invoke(new()\n    {\n        Name = \"example.com\",\n    });\n\n    var exampleRecord = new Cloudflare.Record(\"example\", new()\n    {\n        ZoneId = example.Apply(getZoneResult =\u003e getZoneResult.Id),\n        Name = \"www\",\n        Content = \"203.0.113.1\",\n        Type = \"A\",\n        Proxied = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := cloudflare.LookupZone(ctx, \u0026cloudflare.LookupZoneArgs{\n\t\t\tName: pulumi.StringRef(\"example.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewRecord(ctx, \"example\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId:  pulumi.String(example.Id),\n\t\t\tName:    pulumi.String(\"www\"),\n\t\t\tContent: pulumi.String(\"203.0.113.1\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t\tProxied: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZoneArgs;\nimport com.pulumi.cloudflare.Record;\nimport com.pulumi.cloudflare.RecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZone(GetZoneArgs.builder()\n            .name(\"example.com\")\n            .build());\n\n        var exampleRecord = new Record(\"exampleRecord\", RecordArgs.builder()\n            .zoneId(example.applyValue(getZoneResult -\u003e getZoneResult.id()))\n            .name(\"www\")\n            .content(\"203.0.113.1\")\n            .type(\"A\")\n            .proxied(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleRecord:\n    type: cloudflare:Record\n    name: example\n    properties:\n      zoneId: ${example.id}\n      name: www\n      content: 203.0.113.1\n      type: A\n      proxied: true\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZone\n      Arguments:\n        name: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZone.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the zone. Must provide only one of `zone_id`, `name`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `name`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZone.\n",
                "properties": {
                    "accountId": {
                        "description": "The account identifier to target for the resource.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the zone. Must provide only one of `zone_id`, `name`.\n",
                        "type": "string"
                    },
                    "nameServers": {
                        "description": "Cloudflare assigned name servers. This is only populated for zones that use Cloudflare DNS.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "paused": {
                        "description": "Whether the zone is paused on Cloudflare.\n",
                        "type": "boolean"
                    },
                    "plan": {
                        "description": "The name of the plan associated with the zone.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "Status of the zone.\n",
                        "type": "string"
                    },
                    "vanityNameServers": {
                        "description": "List of Vanity Nameservers (if set).\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource. Must provide only one of `zone_id`, `name`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "name",
                    "nameServers",
                    "paused",
                    "plan",
                    "status",
                    "vanityNameServers",
                    "zoneId",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZoneCacheReserve:getZoneCacheReserve": {
            "description": "Provides a Cloudflare data source to look up Cache Reserve\nstatus for a given zone.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZoneCacheReserve({\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone_cache_reserve(zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZoneCacheReserve.Invoke(new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupZoneCacheReserve(ctx, \u0026cloudflare.LookupZoneCacheReserveArgs{\n\t\t\tZoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZoneCacheReserveArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZoneCacheReserve(GetZoneCacheReserveArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZoneCacheReserve\n      Arguments:\n        zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZoneCacheReserve.\n",
                "properties": {
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZoneCacheReserve.\n",
                "properties": {
                    "enabled": {
                        "description": "The status of Cache Reserve support.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "enabled",
                    "zoneId",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZoneDnssec:getZoneDnssec": {
            "description": "Use this data source to look up Zone DNSSEC settings.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZoneDnssec({\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone_dnssec(zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZoneDnssec.Invoke(new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupZoneDnssec(ctx, \u0026cloudflare.LookupZoneDnssecArgs{\n\t\t\tZoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZoneDnssecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZoneDnssec(GetZoneDnssecArgs.builder()\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZoneDnssec\n      Arguments:\n        zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZoneDnssec.\n",
                "properties": {
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZoneDnssec.\n",
                "properties": {
                    "algorithm": {
                        "description": "Zone DNSSEC algorithm.\n",
                        "type": "string"
                    },
                    "digest": {
                        "description": "Zone DNSSEC digest.\n",
                        "type": "string"
                    },
                    "digestAlgorithm": {
                        "description": "Digest algorithm use for Zone DNSSEC.\n",
                        "type": "string"
                    },
                    "digestType": {
                        "description": "Digest Type for Zone DNSSEC.\n",
                        "type": "string"
                    },
                    "ds": {
                        "description": "DS for the Zone DNSSEC.\n",
                        "type": "string"
                    },
                    "flags": {
                        "description": "Zone DNSSEC flags.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "keyTag": {
                        "description": "Key Tag for the Zone DNSSEC.\n",
                        "type": "integer"
                    },
                    "keyType": {
                        "description": "Key type used for Zone DNSSEC.\n",
                        "type": "string"
                    },
                    "publicKey": {
                        "description": "Public Key for the Zone DNSSEC.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "The status of the Zone DNSSEC.\n",
                        "type": "string"
                    },
                    "zoneId": {
                        "description": "The zone identifier to target for the resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "algorithm",
                    "digest",
                    "digestAlgorithm",
                    "digestType",
                    "ds",
                    "flags",
                    "keyTag",
                    "keyType",
                    "publicKey",
                    "status",
                    "zoneId",
                    "id"
                ],
                "type": "object"
            }
        },
        "cloudflare:index/getZones:getZones": {
            "description": "Use this data source to look up Zone results for use in other resources.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getZonesFilter:getZonesFilter",
                        "description": "One or more values used to look up zone records. If more than one value is given all values must match in order to be included.\n"
                    }
                },
                "type": "object",
                "required": [
                    "filter"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getZonesFilter:getZonesFilter",
                        "description": "One or more values used to look up zone records. If more than one value is given all values must match in order to be included.\n"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "zones": {
                        "description": "A list of zone objects.\n",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getZonesZone:getZonesZone"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "filter",
                    "zones",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}