{
    "name": "cloudflare",
    "description": "A Pulumi package for creating and managing Cloudflare cloud resources.",
    "keywords": [
        "pulumi",
        "cloudflare"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`cloudflare` Terraform Provider](https://github.com/terraform-providers/terraform-provider-cloudflare).",
    "repository": "https://github.com/pulumi/pulumi-cloudflare",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use that account.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_ACCOUNT_ID"
                    ]
                }
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger)\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_KEY"
                    ]
                }
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_TOKEN"
                    ]
                }
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_USER_SERVICE_KEY"
                    ]
                }
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_EMAIL"
                    ]
                }
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            }
        }
    },
    "types": {
        "cloudflare:/AccessGroupExclude:AccessGroupExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExcludeAzure:AccessGroupExcludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExcludeGithub:AccessGroupExcludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExcludeOkta:AccessGroupExcludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExcludeSaml:AccessGroupExcludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupExcludeAzure:AccessGroupExcludeAzure": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupExcludeGithub:AccessGroupExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite": {
            "properties": {
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupExcludeOkta:AccessGroupExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupExcludeSaml:AccessGroupExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupInclude:AccessGroupInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupIncludeAzure:AccessGroupIncludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupIncludeGithub:AccessGroupIncludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupIncludeOkta:AccessGroupIncludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupIncludeSaml:AccessGroupIncludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupIncludeAzure:AccessGroupIncludeAzure": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupIncludeGithub:AccessGroupIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite": {
            "properties": {
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupIncludeOkta:AccessGroupIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupIncludeSaml:AccessGroupIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupRequire:AccessGroupRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequireAzure:AccessGroupRequireAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequireGithub:AccessGroupRequireGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequireGsuite:AccessGroupRequireGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequireOkta:AccessGroupRequireOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequireSaml:AccessGroupRequireSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupRequireAzure:AccessGroupRequireAzure": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupRequireGithub:AccessGroupRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupRequireGsuite:AccessGroupRequireGsuite": {
            "properties": {
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupRequireOkta:AccessGroupRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessGroupRequireSaml:AccessGroupRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessIdentityProviderConfig:AccessIdentityProviderConfig": {
            "properties": {
                "appsDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "centrifyAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "centrifyAppId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certsUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directoryId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAttributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "idpPublicCert": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "issuerUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktaAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oneloginAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "redirectUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signRequest": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssoTargetUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportGroups": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "redirectUrl"
                    ]
                }
            }
        },
        "cloudflare:/AccessPolicyExclude:AccessPolicyExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite": {
            "properties": {
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyInclude:AccessPolicyInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite": {
            "properties": {
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyRequire:AccessPolicyRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequireAzure:AccessPolicyRequireAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequireGithub:AccessPolicyRequireGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequireOkta:AccessPolicyRequireOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequireSaml:AccessPolicyRequireSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyRequireAzure:AccessPolicyRequireAzure": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyRequireGithub:AccessPolicyRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite": {
            "properties": {
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyRequireOkta:AccessPolicyRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessPolicyRequireSaml:AccessPolicyRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/AccessRuleConfiguration:AccessRuleConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Allowed values: \"ip\", \"ip6\", \"ip_range\", \"asn\", \"country\"\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type.\n"
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:/CustomSslCustomSslOptions:CustomSslCustomSslOptions": {
            "properties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Certificate certificate and the intermediate(s)\n"
                },
                "geoRestrictions": {
                    "type": "string",
                    "description": "Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Certificate's private key\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.\n"
                }
            },
            "type": "object",
            "required": [
                "certificate",
                "privateKey"
            ]
        },
        "cloudflare:/CustomSslCustomSslPriority:CustomSslCustomSslPriority": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/HealthcheckHeader:HealthcheckHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Default: 1.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "name"
            ]
        },
        "cloudflare:/LoadBalancerPopPool:LoadBalancerPopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:/LoadBalancerRegionPool:LoadBalancerRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:/PageRuleActions:PageRuleActions": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "string",
                    "description": "The Time To Live for the browser cache. `0` means 'Respect Existing Headers'\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bypassCacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally bypass cache the page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheByDeviceType": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheDeceptionArmor": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheKeyFields": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields",
                    "description": "Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Whether to set the cache level to `\"bypass\"`, `\"basic\"`, `\"simplified\"`, `\"aggressive\"`, or `\"cache_everything\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally cache the page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableApps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disablePerformance": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableRailgun": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableSecurity": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeCacheTtl": {
                    "type": "integer",
                    "description": "The Time To Live for the edge cache.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "explicitCacheControl": {
                    "type": "string",
                    "description": "Whether origin Cache-Control action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardingUrl": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl",
                    "description": "The URL to forward to, and with what status. See below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeaderOverride": {
                    "type": "string",
                    "description": "Value of the Host header to send.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/PageRuleActionsMinify:PageRuleActionsMinify"
                    },
                    "description": "The configuration for HTML, CSS and JS minification. See below for full list of options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Whether this action is `\"off\"`, `\"lossless\"` or `\"lossy\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resolveOverride": {
                    "type": "string",
                    "description": "Overridden origin server name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "respectStrongEtag": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "description": "Whether to set the rocket loader to `\"on\"`, `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Whether to set the security level to `\"off\"`, `\"essentially_off\"`, `\"low\"`, `\"medium\"`, `\"high\"`, or `\"under_attack\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Whether to set the SSL mode to `\"off\"`, `\"flexible\"`, `\"full\"`, `\"strict\"`, or `\"origin_pull\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie",
                    "description": "Controls what cookies go into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "header": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader",
                    "description": "Controls what HTTP headers go into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost",
                    "description": "Controls which Host header goes into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString",
                    "description": "Controls which URL query string parameters go into the Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "user": {
                    "$ref": "#/types/cloudflare:/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser",
                    "description": "Controls which end user-related features go into the Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cookie",
                "header",
                "host",
                "queryString",
                "user"
            ]
        },
        "cloudflare:/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "excludes",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "description": "`false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "resolved"
                    ]
                }
            }
        },
        "cloudflare:/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignore": {
                    "type": "boolean",
                    "description": "`false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value is ignored if any of `exclude` or `include` is non-empty.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "excludes",
                        "ignore",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "description": "`true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geo": {
                    "type": "boolean",
                    "description": "`true` - includes the clients country, derived from the IP address; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lang": {
                    "type": "boolean",
                    "description": "`true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceType",
                        "geo",
                        "lang"
                    ]
                }
            }
        },
        "cloudflare:/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "description": "The status code to use for the redirection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL to which the page rule should forward.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "statusCode",
                "url"
            ]
        },
        "cloudflare:/PageRuleActionsMinify:PageRuleActionsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "Whether CSS should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "Whether HTML should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "Whether Javascript should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:/RateLimitAction:RateLimitAction": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The type of action to perform. Allowable values are 'simulate', 'ban', 'challenge' and 'js_challenge'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "response": {
                    "$ref": "#/types/cloudflare:/RateLimitActionResponse:RateLimitActionResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "description": "The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period (min: 1, max: 86400).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:/RateLimitActionResponse:RateLimitActionResponse": {
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The body to return, the content here should conform to the content_type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "The content-type of the body, must be one of: 'text/plain', 'text/xml', 'application/json'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "body",
                "contentType"
            ]
        },
        "cloudflare:/RateLimitCorrelate:RateLimitCorrelate": {
            "properties": {
                "by": {
                    "type": "string",
                    "description": "If set to 'nat', NAT support will be enabled for rate limiting.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/RateLimitMatch:RateLimitMatch": {
            "properties": {
                "request": {
                    "$ref": "#/types/cloudflare:/RateLimitMatchRequest:RateLimitMatchRequest",
                    "description": "Matches HTTP requests (from the client to Cloudflare). See definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "response": {
                    "$ref": "#/types/cloudflare:/RateLimitMatchResponse:RateLimitMatchResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "request",
                        "response"
                    ]
                }
            }
        },
        "cloudflare:/RateLimitMatchRequest:RateLimitMatchRequest": {
            "properties": {
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Methods, can be a subset ['POST','PUT'] or all ['\\_ALL\\_']. Default: ['\\_ALL\\_'].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schemes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Schemes, can be one ['HTTPS'], both ['HTTP','HTTPS'] or all ['\\_ALL\\_'].  Default: ['\\_ALL\\_'].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "urlPattern": {
                    "type": "string",
                    "description": "The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use * for all traffic to your zone. Default: '*'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "methods",
                        "schemes",
                        "urlPattern"
                    ]
                }
            }
        },
        "cloudflare:/RateLimitMatchResponse:RateLimitMatchResponse": {
            "properties": {
                "originTraffic": {
                    "type": "boolean",
                    "description": "Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting. Default: `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "HTTP Status codes, can be one [403], many [401,403] or indicate all by not providing this value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "originTraffic",
                        "statuses"
                    ]
                }
            }
        },
        "cloudflare:/RecordData:RecordData": {
            "properties": {
                "algorithm": {
                    "type": "integer"
                },
                "altitude": {
                    "type": "number"
                },
                "certificate": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "flags": {
                    "type": "string"
                },
                "keyTag": {
                    "type": "integer"
                },
                "latDegrees": {
                    "type": "integer"
                },
                "latDirection": {
                    "type": "string"
                },
                "latMinutes": {
                    "type": "integer"
                },
                "latSeconds": {
                    "type": "number"
                },
                "longDegrees": {
                    "type": "integer"
                },
                "longDirection": {
                    "type": "string"
                },
                "longMinutes": {
                    "type": "integer"
                },
                "longSeconds": {
                    "type": "number"
                },
                "matchingType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n"
                },
                "order": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "precisionHorz": {
                    "type": "number"
                },
                "precisionVert": {
                    "type": "number"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proto": {
                    "type": "string"
                },
                "protocol": {
                    "type": "integer"
                },
                "publicKey": {
                    "type": "string"
                },
                "regex": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                },
                "target": {
                    "type": "string"
                },
                "type": {
                    "type": "integer",
                    "description": "The type of the record\n"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "cloudflare:/SpectrumApplicationDns:SpectrumApplicationDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin e.g. origin-ssh.example.com.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of DNS record associated with the application. Valid values: `CNAME`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "cloudflare:/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin e.g. origin-ssh.example.com.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name for the binding.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespaceId": {
                    "type": "string",
                    "description": "ID of KV namespace.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "namespaceId"
            ]
        },
        "cloudflare:/ZoneLockdownConfiguration:ZoneLockdownConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Allowed values: \"ip\", \"ip_range\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `198.51.100.4` or `2001:db8::/32` and IP ranges in CIDR format i.e. `198.51.0.0/16`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:/ZoneMeta:ZoneMeta": {
            "properties": {
                "phishingDetected": {
                    "type": "boolean"
                },
                "wildcardProxiable": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "phishingDetected",
                "wildcardProxiable"
            ]
        },
        "cloudflare:/ZoneSettingsOverrideInitialSettings:ZoneSettingsOverrideInitialSettings": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "brotli": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "challengeTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFlattening": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "developmentMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "h2Prioritization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http3": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "imageResizing": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxUpload": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minify": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideInitialSettingsMinify:ZoneSettingsOverrideInitialSettingsMinify",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideInitialSettingsMobileRedirect:ZoneSettingsOverrideInitialSettingsMobileRedirect",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticOnion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefetchPreload": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privacyPass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pseudoIpv4": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideInitialSettingsSecurityHeader:ZoneSettingsOverrideInitialSettingsSecurityHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsClientAuth": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "universalSsl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webp": {
                    "type": "string",
                    "description": ". Note that the value specified will be ignored unless `polish` is turned on (i.e. is \"lossless\" or \"lossy\")\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "websockets": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zeroRtt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "cnameFlattening",
                        "developmentMode",
                        "emailObfuscation",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "originErrorPagePassThru",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "pseudoIpv4",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:/ZoneSettingsOverrideInitialSettingsMinify:ZoneSettingsOverrideInitialSettingsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:/ZoneSettingsOverrideInitialSettingsMobileRedirect:ZoneSettingsOverrideInitialSettingsMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string",
                    "description": "String value\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stripUri": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:/ZoneSettingsOverrideInitialSettingsSecurityHeader:ZoneSettingsOverrideInitialSettingsSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nosniff": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preload": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "brotli": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "challengeTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFlattening": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "developmentMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "h2Prioritization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http3": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "imageResizing": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxUpload": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minify": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticOnion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefetchPreload": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privacyPass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pseudoIpv4": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsClientAuth": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "universalSsl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webp": {
                    "type": "string",
                    "description": ". Note that the value specified will be ignored unless `polish` is turned on (i.e. is \"lossless\" or \"lossy\")\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "websockets": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zeroRtt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "cnameFlattening",
                        "developmentMode",
                        "emailObfuscation",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "originErrorPagePassThru",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "pseudoIpv4",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string",
                    "description": "String value\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stripUri": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nosniff": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preload": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:/getWafGroupsFilter:getWafGroupsFilter": {
            "properties": {
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getWafGroupsGroup:getWafGroupsGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "modifiedRulesCount": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packageId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rulesCount": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getWafPackagesFilter:getWafPackagesFilter": {
            "properties": {
                "actionMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detectionMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getWafPackagesPackage:getWafPackagesPackage": {
            "properties": {
                "actionMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detectionMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getWafRulesFilter:getWafRulesFilter": {
            "properties": {
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getWafRulesRule:getWafRulesRule": {
            "properties": {
                "allowedModes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packageId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getZonesFilter:getZonesFilter": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "paused": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:/getZonesZone:getZonesZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the cloudflare package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "inputProperties": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use that account.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_ACCOUNT_ID"
                    ]
                }
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger)\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_KEY"
                    ]
                }
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_TOKEN"
                    ]
                }
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_USER_SERVICE_KEY"
                    ]
                }
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address.\n",
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_EMAIL"
                    ]
                }
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            }
        }
    },
    "resources": {
        "cloudflare:index/accessApplication:AccessApplication": {
            "description": "Provides a Cloudflare Access Application resource. Access Applications\nare used to restrict access to a whole application using an\nauthorisation gateway managed by Cloudflare.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst stagingApp = new cloudflare.AccessApplication(\"staging_app\", {\n    domain: \"staging.example.com\",\n    name: \"staging application\",\n    sessionDuration: \"24h\",\n    zoneId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nstaging_app = cloudflare.AccessApplication(\"stagingApp\",\n    domain=\"staging.example.com\",\n    name=\"staging application\",\n    session_duration=\"24h\",\n    zone_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var stagingApp = new Cloudflare.AccessApplication(\"stagingApp\", new Cloudflare.AccessApplicationArgs\n        {\n            Domain = \"staging.example.com\",\n            Name = \"staging application\",\n            SessionDuration = \"24h\",\n            ZoneId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the application\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The complete URL of the asset you wish to put\nCloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to\nre-authorise. Must be one of `30m`, `6h`, `12h`, `24h`, `168h`, `730h`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added.\n"
                }
            },
            "required": [
                "aud",
                "domain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The complete URL of the asset you wish to put\nCloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to\nre-authorise. Must be one of `30m`, `6h`, `12h`, `24h`, `168h`, `730h`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessApplication resources.\n",
                "properties": {
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the application\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The complete URL of the asset you wish to put\nCloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to\nre-authorise. Must be one of `30m`, `6h`, `12h`, `24h`, `168h`, `730h`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the access rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessGroup:AccessGroup": {
            "description": "Provides a Cloudflare Access Group resource. Access Groups are used\nin conjunction with Access Policies to restrict access to a\nparticular resource based on group membership.\n\n{{% examples %}}\n{{% /examples %}}\n## Conditions\n\n`require`, `exclude` and `include` arguments share the available\nconditions which can be applied. The conditions are:\n\n* `ip` - (Optional) A list of IP addresses or ranges. Example:\n  `ip = [\"1.2.3.4\", \"10.0.0.0/2\"]`\n* `email` - (Optional) A list of email addresses. Example:\n  `email = [\"test@example.com\"]`\n* `email_domain` - (Optional) A list of email domains. Example:\n  `email_domain = [\"example.com\"]`\n* `service_token` - (Optional) A list of service token ids. Example:\n  `service_token = [cloudflare_access_service_token.demo.id]`\n* `any_valid_service_token` - (Optional) Boolean indicating if allow\n  all tokens to be granted. Example: `any_valid_service_token = true`\n* `group` - (Optional) A list of access group ids. Example:\n  `group = [cloudflare_access_group.demo.id]`\n* `everyone` - (Optional) Boolean indicating permitting access for all\n  requests. Example: `everyone = true`\n* `certificate` - (Optional) Whether to use mTLS certificate authentication.\n* `common_name` - (Optional) Use a certificate common name to authenticate with.\n* `gsuite` - (Optional) Use GSuite as the authentication mechanism. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    gsuite {\n      email = \"admins@example.com\"\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `github` - (Optional) Use a GitHub team as the `include` condition. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    github {\n      name = \"my-github-team-name\"\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `azure` - (Optional) Use Azure AD as the `include` condition. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    azure {\n      id = \"86773093-5feb-48dd-814b-7ccd3676ff50e\"\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `okta` - (Optional) Use Okta as the `include` condition. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    okta {\n      name = \"admins\"\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `saml` - (Optional) Use an external SAML setup as the `include` condition.\n  Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    saml {\n      attribute_name = \"group\"\n      attribute_value = \"admins\"\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account the group is\nassociated with.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExclude:AccessGroupExclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupInclude:AccessGroupInclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequire:AccessGroupRequire"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                }
            },
            "required": [
                "accountId",
                "includes",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account the group is\nassociated with.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupExclude:AccessGroupExclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupInclude:AccessGroupInclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessGroupRequire:AccessGroupRequire"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessGroup resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account the group is\nassociated with.\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessGroupExclude:AccessGroupExclude"
                        },
                        "description": "A series of access conditions, see below for\nfull list.\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessGroupInclude:AccessGroupInclude"
                        },
                        "description": "A series of access conditions, see below for\nfull list.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Group.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessGroupRequire:AccessGroupRequire"
                        },
                        "description": "A series of access conditions, see below for\nfull list.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessIdentityProvider:AccessIdentityProvider": {
            "description": "Provides a Cloudflare Access Identity Provider resource. Identity Providers are\nused as an authentication or authorisation source within Access.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// one time pin\nconst pinLogin = new cloudflare.AccessIdentityProvider(\"pin_login\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name: \"PIN login\",\n    type: \"onetimepin\",\n});\n// oauth\nconst githubOauth = new cloudflare.AccessIdentityProvider(\"github_oauth\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n    }],\n    name: \"GitHub OAuth\",\n    type: \"github\",\n});\n// saml\nconst jumpcloudSaml = new cloudflare.AccessIdentityProvider(\"jumpcloud_saml\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs: [{\n        attributes: [\n            \"email\",\n            \"username\",\n        ],\n        idpPublicCert: `MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o`,\n        issuerUrl: \"jumpcloud\",\n        signRequest: false,\n        ssoTargetUrl: \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n    }],\n    name: \"JumpCloud SAML\",\n    type: \"saml\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# one time pin\npin_login = cloudflare.AccessIdentityProvider(\"pinLogin\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name=\"PIN login\",\n    type=\"onetimepin\")\n# oauth\ngithub_oauth = cloudflare.AccessIdentityProvider(\"githubOauth\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs=[{\n        \"client_id\": \"example\",\n        \"client_secret\": \"secret_key\",\n    }],\n    name=\"GitHub OAuth\",\n    type=\"github\")\n# saml\njumpcloud_saml = cloudflare.AccessIdentityProvider(\"jumpcloudSaml\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs=[{\n        \"attributes\": [\n            \"email\",\n            \"username\",\n        ],\n        \"idpPublicCert\": \"\"\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n\"\"\",\n        \"issuerUrl\": \"jumpcloud\",\n        \"signRequest\": False,\n        \"ssoTargetUrl\": \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n    }],\n    name=\"JumpCloud SAML\",\n    type=\"saml\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // one time pin\n        var pinLogin = new Cloudflare.AccessIdentityProvider(\"pinLogin\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Name = \"PIN login\",\n            Type = \"onetimepin\",\n        });\n        // oauth\n        var githubOauth = new Cloudflare.AccessIdentityProvider(\"githubOauth\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Configs = \n            {\n                new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n                {\n                    ClientId = \"example\",\n                    ClientSecret = \"secret_key\",\n                },\n            },\n            Name = \"GitHub OAuth\",\n            Type = \"github\",\n        });\n        // saml\n        var jumpcloudSaml = new Cloudflare.AccessIdentityProvider(\"jumpcloudSaml\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Configs = \n            {\n                new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n                {\n                    Attributes = \n                    {\n                        \"email\",\n                        \"username\",\n                    },\n                    IdpPublicCert = @\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n\",\n                    IssuerUrl = \"jumpcloud\",\n                    SignRequest = false,\n                    SsoTargetUrl = \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n                },\n            },\n            Name = \"JumpCloud SAML\",\n            Type = \"saml\",\n        });\n    }\n\n}\n```\n\nPlease refer to the [developers.cloudflare.com Access documentation][access_identity_provider_guide]\nfor full reference on what is available and how to configure your provider.\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "accountId": {
                    "type": "string"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation][access_identity_provider_guide].\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Must be one of: `\"centrify\"`,\n`\"facebook\"`, `\"google-apps\"`, `\"oidc\"`, `\"github\"`, `\"google\"`, `\"saml\"`,\n`\"linkedin\"`, `\"azureAD\"`, `\"okta\"`, `\"onetimepin\"`, `\"onelogin\"`, `\"yandex\"`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation][access_identity_provider_guide].\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Must be one of: `\"centrify\"`,\n`\"facebook\"`, `\"google-apps\"`, `\"oidc\"`, `\"github\"`, `\"google\"`, `\"saml\"`,\n`\"linkedin\"`, `\"azureAD\"`, `\"okta\"`, `\"onetimepin\"`, `\"onelogin\"`, `\"yandex\"`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessIdentityProvider resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                        },
                        "description": "Provider configuration from the [developer documentation][access_identity_provider_guide].\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Identity Provider configuration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The provider type to use. Must be one of: `\"centrify\"`,\n`\"facebook\"`, `\"google-apps\"`, `\"oidc\"`, `\"github\"`, `\"google\"`, `\"saml\"`,\n`\"linkedin\"`, `\"azureAD\"`, `\"okta\"`, `\"onetimepin\"`, `\"onelogin\"`, `\"yandex\"`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessPolicy:AccessPolicy": {
            "description": "Provides a Cloudflare Access Policy resource. Access Policies are used\nin conjunction with Access Applications to restrict access to a\nparticular resource.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is\nassociated with.\n"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user.\nAllowed values: `allow`, `deny`, `non_identity`, `bypass`\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Integer.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be\nadded.\n"
                }
            },
            "required": [
                "applicationId",
                "decision",
                "includes",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is\nassociated with.\n"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user.\nAllowed values: `allow`, `deny`, `non_identity`, `bypass`\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Integer.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be\nadded.\n"
                }
            },
            "requiredInputs": [
                "applicationId",
                "decision",
                "includes",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessPolicy resources.\n",
                "properties": {
                    "applicationId": {
                        "type": "string",
                        "description": "The ID of the application the policy is\nassociated with.\n"
                    },
                    "decision": {
                        "type": "string",
                        "description": "Defines the action Access will take if the policy matches the user.\nAllowed values: `allow`, `deny`, `non_identity`, `bypass`\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessPolicyExclude:AccessPolicyExclude"
                        },
                        "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessPolicyInclude:AccessPolicyInclude"
                        },
                        "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The unique precedence for policies on a single application. Integer.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/AccessPolicyRequire:AccessPolicyRequire"
                        },
                        "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/docs/providers/cloudflare/r/access_group.html#conditions).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the access rule should be\nadded.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessRule:AccessRule": {
            "description": "Provides a Cloudflare IP Firewall Access Rule resource. Access control can be applied on basis of IP addresses, IP ranges, AS numbers or countries.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. It's a complex value. See description below.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"whitelist\", \"js_challenge\"\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added.\n"
                }
            },
            "required": [
                "configuration",
                "mode",
                "zoneId"
            ],
            "inputProperties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. It's a complex value. See description below.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"whitelist\", \"js_challenge\"\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added.\n"
                }
            },
            "requiredInputs": [
                "configuration",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessRule resources.\n",
                "properties": {
                    "configuration": {
                        "$ref": "#/types/cloudflare:/AccessRuleConfiguration:AccessRuleConfiguration",
                        "description": "Rule configuration to apply to a matched request. It's a complex value. See description below.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"whitelist\", \"js_challenge\"\n"
                    },
                    "notes": {
                        "type": "string",
                        "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the access rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessServiceToken:AccessServiceToken": {
            "description": "Access Service Tokens are used for service-to-service communication\nwhen an application is behind Cloudflare Access.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myApp = new cloudflare.AccessServiceToken(\"my_app\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"CI/CD app\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_app = cloudflare.AccessServiceToken(\"myApp\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"CI/CD app\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var myApp = new Cloudflare.AccessServiceToken(\"myApp\", new Cloudflare.AccessServiceTokenArgs\n        {\n            AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Name = \"CI/CD app\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the Access\nService is being created.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "UUID client ID associated with the Service Token.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "A secret for interacting with Access protocols.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                }
            },
            "required": [
                "accountId",
                "clientId",
                "clientSecret",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the Access\nService is being created.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessServiceToken resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the Access\nService is being created.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "UUID client ID associated with the Service Token.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "A secret for interacting with Access protocols.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the token's intent.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accountMember:AccountMember": {
            "description": "Provides a resource which manages Cloudflare account members.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleUser = new cloudflare.AccountMember(\"example_user\", {\n    emailAddress: \"user@example.com\",\n    roleIds: [\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_user = cloudflare.AccountMember(\"exampleUser\",\n    email_address=\"user@example.com\",\n    role_ids=[\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleUser = new Cloudflare.AccountMember(\"exampleUser\", new Cloudflare.AccountMemberArgs\n        {\n            EmailAddress = \"user@example.com\",\n            RoleIds = \n            {\n                \"68b329da9893e34099c7d8ad5cb9c940\",\n                \"d784fa8b6d98d27699781bd9a7cf19f0\",\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Note: Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of account role IDs that you want to assign to a member.\n"
                }
            },
            "required": [
                "emailAddress",
                "roleIds"
            ],
            "inputProperties": {
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Note: Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of account role IDs that you want to assign to a member.\n"
                }
            },
            "requiredInputs": [
                "emailAddress",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountMember resources.\n",
                "properties": {
                    "emailAddress": {
                        "type": "string",
                        "description": "The email address of the user who you wish to manage. Note: Following creation, this field becomes read only via the API and cannot be updated.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of account role IDs that you want to assign to a member.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/argo:Argo": {
            "description": "Cloudflare Argo controls the routing to your origin and tiered caching options to speed up your website browsing experience.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Argo(\"example\", {\n    smartRouting: \"on\",\n    tieredCaching: \"on\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Argo(\"example\",\n    smart_routing=\"on\",\n    tiered_caching=\"on\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.Argo(\"example\", new Cloudflare.ArgoArgs\n        {\n            SmartRouting = \"on\",\n            TieredCaching = \"on\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Valid values: `on` or `off`. Defaults to `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Valid values: `on` or `off`. Defaults to `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID that you wish to manage Argo on.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Valid values: `on` or `off`. Defaults to `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Valid values: `on` or `off`. Defaults to `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID that you wish to manage Argo on.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Argo resources.\n",
                "properties": {
                    "smartRouting": {
                        "type": "string",
                        "description": "Whether smart routing is enabled. Valid values: `on` or `off`. Defaults to `off`.\n"
                    },
                    "tieredCaching": {
                        "type": "string",
                        "description": "Whether tiered caching is enabled. Valid values: `on` or `off`. Defaults to `off`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID that you wish to manage Argo on.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/byoIpPrefix:ByoIpPrefix": {
            "description": "Provides the ability to manage Bring-Your-Own-IP prefixes (BYOIP) which are used with or without Magic Transit.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ByoIpPrefix(\"example\", {\n    advertisement: \"on\",\n    description: \"Example IP Prefix\",\n    prefixId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ByoIpPrefix(\"example\",\n    advertisement=\"on\",\n    description=\"Example IP Prefix\",\n    prefix_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.ByoIpPrefix(\"example\", new Cloudflare.ByoIpPrefixArgs\n        {\n            Advertisement = \"on\",\n            Description = \"Example IP Prefix\",\n            PrefixId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Valid values: `on` or `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID.\n"
                }
            },
            "required": [
                "advertisement",
                "description",
                "prefixId"
            ],
            "inputProperties": {
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Valid values: `on` or `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID.\n"
                }
            },
            "requiredInputs": [
                "prefixId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ByoIpPrefix resources.\n",
                "properties": {
                    "advertisement": {
                        "type": "string",
                        "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Valid values: `on` or `off`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the prefix.\n"
                    },
                    "prefixId": {
                        "type": "string",
                        "description": "The assigned Bring-Your-Own-IP prefix ID.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customPages:CustomPages": {
            "description": "Provides a resource which manages Cloudflare custom error pages.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst basicChallenge = new cloudflare.CustomPages(\"basic_challenge\", {\n    state: \"customized\",\n    type: \"basic_challenge\",\n    url: \"https://example.com/challenge.html\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nbasic_challenge = cloudflare.CustomPages(\"basicChallenge\",\n    state=\"customized\",\n    type=\"basic_challenge\",\n    url=\"https://example.com/challenge.html\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var basicChallenge = new Cloudflare.CustomPages(\"basicChallenge\", new Cloudflare.CustomPagesArgs\n        {\n            State = \"customized\",\n            Type = \"basic_challenge\",\n            Url = \"https://example.com/challenge.html\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                }
            },
            "required": [
                "type",
                "url"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                }
            },
            "requiredInputs": [
                "type",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomPages resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                    },
                    "state": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "URL of where the custom page source is located.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customSsl:CustomSsl": {
            "description": "Provides a Cloudflare custom ssl resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\nconst cloudflareZoneId = config.get(\"cloudflareZoneId\") || \"1d5fdc9e88c8a8c4518b068cd94331fe\";\n\n// Add a custom ssl certificate to the domain\nconst foossl = new cloudflare.CustomSsl(\"foossl\", {\n    customSslOptions: {\n        bundle_method: \"ubiquitous\",\n        certificate: \"-----INSERT CERTIFICATE-----\",\n        geo_restrictions: \"us\",\n        private_key: \"-----INSERT PRIVATE KEY-----\",\n        type: \"legacy_custom\",\n    },\n    zoneId: cloudflareZoneId,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nconfig = pulumi.Config()\ncloudflare_zone_id = config.get(\"cloudflareZoneId\")\nif cloudflare_zone_id is None:\n    cloudflare_zone_id = \"1d5fdc9e88c8a8c4518b068cd94331fe\"\n# Add a custom ssl certificate to the domain\nfoossl = cloudflare.CustomSsl(\"foossl\",\n    custom_ssl_options={\n        \"bundle_method\": \"ubiquitous\",\n        \"certificate\": \"-----INSERT CERTIFICATE-----\",\n        \"geo_restrictions\": \"us\",\n        \"private_key\": \"-----INSERT PRIVATE KEY-----\",\n        \"type\": \"legacy_custom\",\n    },\n    zone_id=cloudflare_zone_id)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var config = new Config();\n        var cloudflareZoneId = config.Get(\"cloudflareZoneId\") ?? \"1d5fdc9e88c8a8c4518b068cd94331fe\";\n        // Add a custom ssl certificate to the domain\n        var foossl = new Cloudflare.CustomSsl(\"foossl\", new Cloudflare.CustomSslArgs\n        {\n            CustomSslOptions = new Cloudflare.Inputs.CustomSslCustomSslOptionsArgs\n            {\n                Bundle_method = \"ubiquitous\",\n                Certificate = \"-----INSERT CERTIFICATE-----\",\n                Geo_restrictions = \"us\",\n                Private_key = \"-----INSERT PRIVATE KEY-----\",\n                Type = \"legacy_custom\",\n            },\n            ZoneId = cloudflareZoneId,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "expiresOn": {
                    "type": "string"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "issuer": {
                    "type": "string"
                },
                "modifiedOn": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "signature": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone id to the custom ssl cert should be added.\n"
                }
            },
            "required": [
                "expiresOn",
                "hosts",
                "issuer",
                "modifiedOn",
                "priority",
                "signature",
                "status",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone id to the custom ssl cert should be added.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomSsl resources.\n",
                "properties": {
                    "customSslOptions": {
                        "$ref": "#/types/cloudflare:/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                        "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                    },
                    "customSslPriorities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                        }
                    },
                    "expiresOn": {
                        "type": "string"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "modifiedOn": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    },
                    "uploadedOn": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone id to the custom ssl cert should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/filter:Filter": {
            "description": "Filter expressions that can be referenced across multiple features, e.g. Firewall Rule. The expression format is similar to [Wireshark Display Filter](https://www.wireshark.org/docs/man-pages/wireshark-filter.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpress = new cloudflare.Filter(\"wordpress\", {\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress = cloudflare.Filter(\"wordpress\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var wordpress = new Cloudflare.Filter(\"wordpress\", new Cloudflare.FilterArgs\n        {\n            Description = \"Wordpress break-in attempts that are outside of the office\",\n            Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused. Boolean value.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "required": [
                "expression",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused. Boolean value.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "requiredInputs": [
                "expression",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Filter resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the purpose of the filter.\n"
                    },
                    "expression": {
                        "type": "string",
                        "description": "The filter expression to be used.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter is currently paused. Boolean value.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "Short reference tag to quickly select related rules.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the Filter should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/firewallRule:FirewallRule": {
            "description": "Define Firewall rules using filter expressions for more control over how traffic is matched to the rule.\nA filter expression permits selecting traffic by multiple criteria allowing greater freedom in rule creation.\n\nFilter expressions needs to be created first before using Firewall Rule. See Filter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpressFilter = new cloudflare.Filter(\"wordpressFilter\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n});\nconst wordpressFirewallRule = new cloudflare.FirewallRule(\"wordpressFirewallRule\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Block wordpress break-in attempts\",\n    filterId: wordpressFilter.id,\n    action: \"block\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress_filter = cloudflare.Filter(\"wordpressFilter\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\nwordpress_firewall_rule = cloudflare.FirewallRule(\"wordpressFirewallRule\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Block wordpress break-in attempts\",\n    filter_id=wordpress_filter.id,\n    action=\"block\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var wordpressFilter = new Cloudflare.Filter(\"wordpressFilter\", new Cloudflare.FilterArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Description = \"Wordpress break-in attempts that are outside of the office\",\n            Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n        });\n        var wordpressFirewallRule = new Cloudflare.FirewallRule(\"wordpressFirewallRule\", new Cloudflare.FirewallRuleArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Description = \"Block wordpress break-in attempts\",\n            FilterId = wordpressFilter.Id,\n            Action = \"block\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"allow\", \"js_challenge\", \"bypass\". Enterprise plan also allows \"log\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused. Boolean value.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Allowed values: \"zoneLockdown\", \"uaBlock\", \"bic\", \"hot\", \"securityLevel\", \"rateLimit\", \"waf\".\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "required": [
                "action",
                "filterId",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"allow\", \"js_challenge\", \"bypass\". Enterprise plan also allows \"log\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused. Boolean value.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Allowed values: \"zoneLockdown\", \"uaBlock\", \"bic\", \"hot\", \"securityLevel\", \"rateLimit\", \"waf\".\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "requiredInputs": [
                "action",
                "filterId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallRule resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"allow\", \"js_challenge\", \"bypass\". Enterprise plan also allows \"log\".\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the rule to help identify it.\n"
                    },
                    "filterId": {
                        "type": "string"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter based firewall rule is currently paused. Boolean value.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                    },
                    "products": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of products to bypass for a request when the bypass action is used. Allowed values: \"zoneLockdown\", \"uaBlock\", \"bic\", \"hot\", \"securityLevel\", \"rateLimit\", \"waf\".\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the Filter should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/healthcheck:Healthcheck": {
            "description": "Standalone Health Checks provide a way to monitor origin servers without needing a Cloudflare Load Balancer. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe resource supports HTTP, HTTPS and TCP type health checks.\n\n{{% /example %}}\n{{% example %}}\n### TCP Monitor\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst tcpHealthCheck = new cloudflare.Healthcheck(\"tcpHealthCheck\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"tcp-health-check\",\n    description: \"example tcp health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    notificationSuspended: false,\n    notificationEmailAddresses: [\"hostmaster@example.com\"],\n    type: \"TCP\",\n    port: \"22\",\n    method: \"connection_established\",\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntcp_health_check = cloudflare.Healthcheck(\"tcpHealthCheck\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"tcp-health-check\",\n    description=\"example tcp health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    notification_suspended=False,\n    notification_email_addresses=[\"hostmaster@example.com\"],\n    type=\"TCP\",\n    port=\"22\",\n    method=\"connection_established\",\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var tcpHealthCheck = new Cloudflare.Healthcheck(\"tcpHealthCheck\", new Cloudflare.HealthcheckArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Name = \"tcp-health-check\",\n            Description = \"example tcp health check\",\n            Address = \"example.com\",\n            Suspended = false,\n            CheckRegions = \n            {\n                \"WEU\",\n                \"EEU\",\n            },\n            NotificationSuspended = false,\n            NotificationEmailAddresses = \n            {\n                \"hostmaster@example.com\",\n            },\n            Type = \"TCP\",\n            Port = 22,\n            Method = \"connection_established\",\n            Timeout = 10,\n            Retries = 2,\n            Interval = 60,\n            ConsecutiveFails = 3,\n            ConsecutiveSuccesses = 2,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set Cloudflare will pick a default region. Valid values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. (Default: `1`)\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. (Default: `1`)\n"
                },
                "createdOn": {
                    "type": "string"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. \"200\") or code ranges (e.g. \"2xx\" for all codes starting with 2) of the health check. (Default: `[\"200\"]`)\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. (Default: `60`)\n"
                },
                "method": {
                    "type": "string",
                    "description": "The TCP connection method to use for the health check. Valid values: `connection_established` (Default: `connection_established`).\n"
                },
                "modifiedOn": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.\n"
                },
                "notificationEmailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses we want to send the notifications to.\n"
                },
                "notificationSuspended": {
                    "type": "boolean",
                    "description": "Whether the notifications are suspended or not. Useful for maintenance periods. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. (Default: `/`)\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check.  Valid values are in the rage `0-65535` (Default: `80`).\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. (Default: `2`)\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. (Default: `5`)\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Valid values: `HTTP`, `HTTPS`, `TCP`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                }
            },
            "required": [
                "address",
                "checkRegions",
                "createdOn",
                "method",
                "modifiedOn",
                "name",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set Cloudflare will pick a default region. Valid values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. (Default: `1`)\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. (Default: `1`)\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. \"200\") or code ranges (e.g. \"2xx\" for all codes starting with 2) of the health check. (Default: `[\"200\"]`)\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. (Default: `60`)\n"
                },
                "method": {
                    "type": "string",
                    "description": "The TCP connection method to use for the health check. Valid values: `connection_established` (Default: `connection_established`).\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.\n"
                },
                "notificationEmailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses we want to send the notifications to.\n"
                },
                "notificationSuspended": {
                    "type": "boolean",
                    "description": "Whether the notifications are suspended or not. Useful for maintenance periods. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. (Default: `/`)\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check.  Valid values are in the rage `0-65535` (Default: `80`).\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. (Default: `2`)\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. (Default: `5`)\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Valid values: `HTTP`, `HTTPS`, `TCP`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                }
            },
            "requiredInputs": [
                "address",
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Healthcheck resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The hostname or IP address of the origin server to run health checks on.\n"
                    },
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when the health check uses HTTPS. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions from which to run health checks. If not set Cloudflare will pick a default region. Valid values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                    },
                    "consecutiveFails": {
                        "type": "integer",
                        "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. (Default: `1`)\n"
                    },
                    "consecutiveSuccesses": {
                        "type": "integer",
                        "description": "The number of consecutive successes required from a health check before changing the health to healthy. (Default: `1`)\n"
                    },
                    "createdOn": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-readable description of the health check.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.\n"
                    },
                    "expectedCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The expected HTTP response codes (e.g. \"200\") or code ranges (e.g. \"2xx\" for all codes starting with 2) of the health check. (Default: `[\"200\"]`)\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if the origin returns a 3xx status code. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/HealthcheckHeader:HealthcheckHeader"
                        },
                        "description": "The header name.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. (Default: `60`)\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The TCP connection method to use for the health check. Valid values: `connection_established` (Default: `connection_established`).\n"
                    },
                    "modifiedOn": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.\n"
                    },
                    "notificationEmailAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses we want to send the notifications to.\n"
                    },
                    "notificationSuspended": {
                        "type": "boolean",
                        "description": "Whether the notifications are suspended or not. Useful for maintenance periods. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. (Default: `/`)\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port number to connect to for the health check.  Valid values are in the rage `0-65535` (Default: `80`).\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. (Default: `2`)\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, no health checks are sent to the origin. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. (Default: `5`)\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the health check. Valid values: `HTTP`, `HTTPS`, `TCP`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which apply settings.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancer:LoadBalancer": {
            "description": "Provides a Cloudflare Load Balancer resource. This sits in front of a number of defined pools of origins and provides various options for geographically-aware load balancing. Note that the load balancing feature must be enabled in your Cloudflare account before you can use this resource.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever region/pop pools are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true` (enabled).\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name (FQDN, including the zone) to associate with the load balancer.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers. Fields documented below.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "A set containing mappings of region/country codes to a list of pool IDs (ordered by their failover priority) for the given region. Fields documented below.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Associates all requests coming from an end-user with a single origin. Cloudflare will set a cookie on the initial response to the client, such that consequent requests with the cookie in the request will go to the same origin, so long as it is available.  Valid values are: `\"\"`, `\"none\"`, `\"cookie\"`, and `\"ip_cookie\"`.  Default is `\"\"`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "Determine which method the load balancer uses to determine the fastest route to your origin. Valid values are: `\"off\"`, `\"geo\"`, `\"dynamic_latency\"`, `\"random\"` or `\"\"`. Default is `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of this load balancer's DNS `name`. Conflicts with `proxied` - this cannot be set for proxied load balancers. Default is `30`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to.\n"
                }
            },
            "required": [
                "createdOn",
                "defaultPoolIds",
                "fallbackPoolId",
                "modifiedOn",
                "name",
                "popPools",
                "regionPools",
                "steeringPolicy",
                "ttl",
                "zoneId"
            ],
            "inputProperties": {
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever region/pop pools are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true` (enabled).\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name (FQDN, including the zone) to associate with the load balancer.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers. Fields documented below.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "A set containing mappings of region/country codes to a list of pool IDs (ordered by their failover priority) for the given region. Fields documented below.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Associates all requests coming from an end-user with a single origin. Cloudflare will set a cookie on the initial response to the client, such that consequent requests with the cookie in the request will go to the same origin, so long as it is available.  Valid values are: `\"\"`, `\"none\"`, `\"cookie\"`, and `\"ip_cookie\"`.  Default is `\"\"`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "Determine which method the load balancer uses to determine the fastest route to your origin. Valid values are: `\"off\"`, `\"geo\"`, `\"dynamic_latency\"`, `\"random\"` or `\"\"`. Default is `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of this load balancer's DNS `name`. Conflicts with `proxied` - this cannot be set for proxied load balancers. Default is `30`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to.\n"
                }
            },
            "requiredInputs": [
                "defaultPoolIds",
                "fallbackPoolId",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancer resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "defaultPoolIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of pool IDs ordered by their failover priority. Used whenever region/pop pools are not defined.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable the load balancer. Defaults to `true` (enabled).\n"
                    },
                    "fallbackPoolId": {
                        "type": "string",
                        "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS name (FQDN, including the zone) to associate with the load balancer.\n"
                    },
                    "popPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/LoadBalancerPopPool:LoadBalancerPopPool"
                        },
                        "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers. Fields documented below.\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`.\n"
                    },
                    "regionPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/LoadBalancerRegionPool:LoadBalancerRegionPool"
                        },
                        "description": "A set containing mappings of region/country codes to a list of pool IDs (ordered by their failover priority) for the given region. Fields documented below.\n"
                    },
                    "sessionAffinity": {
                        "type": "string",
                        "description": "Associates all requests coming from an end-user with a single origin. Cloudflare will set a cookie on the initial response to the client, such that consequent requests with the cookie in the request will go to the same origin, so long as it is available.  Valid values are: `\"\"`, `\"none\"`, `\"cookie\"`, and `\"ip_cookie\"`.  Default is `\"\"`.\n"
                    },
                    "steeringPolicy": {
                        "type": "string",
                        "description": "Determine which method the load balancer uses to determine the fastest route to your origin. Valid values are: `\"off\"`, `\"geo\"`, `\"dynamic_latency\"`, `\"random\"` or `\"\"`. Default is `\"\"`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Time to live (TTL) of this load balancer's DNS `name`. Conflicts with `proxied` - this cannot be set for proxied load balancers. Default is `30`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to add the load balancer to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor": {
            "description": "If you're using Cloudflare's Load Balancing to load-balance across multiple origin servers or data centers, you configure one of these Monitors to actively check the availability of those servers over HTTP(S) or TCP.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### HTTP Monitor\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst httpMonitor = new cloudflare.LoadBalancerMonitor(\"http_monitor\", {\n    allowInsecure: false,\n    description: \"example http load balancer\",\n    expectedBody: \"alive\",\n    expectedCodes: \"2xx\",\n    followRedirects: true,\n    headers: [{\n        header: \"Host\",\n        values: [\"example.com\"],\n    }],\n    interval: 60,\n    method: \"GET\",\n    path: \"/health\",\n    retries: 5,\n    timeout: 7,\n    type: \"http\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhttp_monitor = cloudflare.LoadBalancerMonitor(\"httpMonitor\",\n    allow_insecure=False,\n    description=\"example http load balancer\",\n    expected_body=\"alive\",\n    expected_codes=\"2xx\",\n    follow_redirects=True,\n    headers=[{\n        \"header\": \"Host\",\n        \"values\": [\"example.com\"],\n    }],\n    interval=60,\n    method=\"GET\",\n    path=\"/health\",\n    retries=5,\n    timeout=7,\n    type=\"http\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var httpMonitor = new Cloudflare.LoadBalancerMonitor(\"httpMonitor\", new Cloudflare.LoadBalancerMonitorArgs\n        {\n            AllowInsecure = false,\n            Description = \"example http load balancer\",\n            ExpectedBody = \"alive\",\n            ExpectedCodes = \"2xx\",\n            FollowRedirects = true,\n            Headers = \n            {\n                new Cloudflare.Inputs.LoadBalancerMonitorHeaderArgs\n                {\n                    Header = \"Host\",\n                    Values = \n                    {\n                        \"example.com\",\n                    },\n                },\n            },\n            Interval = 60,\n            Method = \"GET\",\n            Path = \"/health\",\n            Retries = 5,\n            Timeout = 7,\n            Type = \"http\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### TCP Monitor\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst tcpMonitor = new cloudflare.LoadBalancerMonitor(\"tcp_monitor\", {\n    description: \"example tcp load balancer\",\n    interval: 60,\n    method: \"connection_established\",\n    retries: 5,\n    timeout: 7,\n    type: \"tcp\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntcp_monitor = cloudflare.LoadBalancerMonitor(\"tcpMonitor\",\n    description=\"example tcp load balancer\",\n    interval=60,\n    method=\"connection_established\",\n    retries=5,\n    timeout=7,\n    type=\"tcp\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var tcpMonitor = new Cloudflare.LoadBalancerMonitor(\"tcpMonitor\", new Cloudflare.LoadBalancerMonitorArgs\n        {\n            Description = \"example tcp load balancer\",\n            Interval = 60,\n            Method = \"connection_established\",\n            Retries = 5,\n            Timeout = 7,\n            Type = \"tcp\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", or \"connection_established\" if `type` is \"tcp\" .\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                },
                "port": {
                    "type": "integer"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. Default: \"http\".\n"
                }
            },
            "required": [
                "createdOn",
                "method",
                "modifiedOn",
                "path"
            ],
            "inputProperties": {
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", or \"connection_established\" if `type` is \"tcp\" .\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                },
                "port": {
                    "type": "integer"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. Default: \"http\".\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerMonitor resources.\n",
                "properties": {
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                    },
                    "expectedCodes": {
                        "type": "string",
                        "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                        },
                        "description": "The header name.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", or \"connection_established\" if `type` is \"tcp\" .\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. Default: \"http\".\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerPool:LoadBalancerPool": {
            "description": "Provides a Cloudflare Load Balancer pool resource. This provides a pool of origins that can be used by a Cloudflare Load Balancer. Note that the load balancing feature must be enabled in your Cloudflare account before you can use this resource.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst foo = new cloudflare.LoadBalancerPool(\"foo\", {\n    description: \"example load balancer pool\",\n    enabled: false,\n    minimumOrigins: 1,\n    name: \"example-pool\",\n    notificationEmail: \"someone@example.com\",\n    origins: [\n        {\n            address: \"192.0.2.1\",\n            enabled: false,\n            name: \"example-1\",\n        },\n        {\n            address: \"192.0.2.2\",\n            name: \"example-2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nfoo = cloudflare.LoadBalancerPool(\"foo\",\n    description=\"example load balancer pool\",\n    enabled=False,\n    minimum_origins=1,\n    name=\"example-pool\",\n    notification_email=\"someone@example.com\",\n    origins=[\n        {\n            \"address\": \"192.0.2.1\",\n            \"enabled\": False,\n            \"name\": \"example-1\",\n        },\n        {\n            \"address\": \"192.0.2.2\",\n            \"name\": \"example-2\",\n        },\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var foo = new Cloudflare.LoadBalancerPool(\"foo\", new Cloudflare.LoadBalancerPoolArgs\n        {\n            Description = \"example load balancer pool\",\n            Enabled = false,\n            MinimumOrigins = 1,\n            Name = \"example-pool\",\n            NotificationEmail = \"someone@example.com\",\n            Origins = \n            {\n                new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n                {\n                    Address = \"192.0.2.1\",\n                    Enabled = false,\n                    Name = \"example-1\",\n                },\n                new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n                {\n                    Address = \"192.0.2.2\",\n                    Name = \"example-2\",\n                },\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                }
            },
            "required": [
                "checkRegions",
                "createdOn",
                "modifiedOn",
                "name",
                "origins"
            ],
            "inputProperties": {
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                }
            },
            "requiredInputs": [
                "name",
                "origins"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerPool resources.\n",
                "properties": {
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                    },
                    "minimumOrigins": {
                        "type": "integer",
                        "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "monitor": {
                        "type": "string",
                        "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-identifiable name for the origin.\n"
                    },
                    "notificationEmail": {
                        "type": "string",
                        "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                        },
                        "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpullRetention:LogpullRetention": {
            "description": "Allows management of the Logpull Retention settings used to control whether or not to retain HTTP request logs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpullRetention(\"example\", {\n    enabled: true,\n    zoneId: \"fb54f084ca7f7b732d3d3ecbd8ef7bf2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpullRetention(\"example\",\n    enabled=\"true\",\n    zone_id=\"fb54f084ca7f7b732d3d3ecbd8ef7bf2\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.LogpullRetention(\"example\", new Cloudflare.LogpullRetentionArgs\n        {\n            Enabled = true,\n            ZoneId = \"fb54f084ca7f7b732d3d3ecbd8ef7bf2\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to apply the log retention to.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to apply the log retention to.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpullRetention resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether you wish to retain logs or not.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to apply the log retention to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpushJob:LogpushJob": {
            "properties": {
                "dataset": {
                    "type": "string",
                    "description": "Which type of dataset resource to use. Available values are `\"firewall_events\"`, `\"http_requests\"`, and `\"spectrum_events\"`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create. Must match the regular expression `^[a-zA-Z0-9\\-\\.]*$`.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush job should be created.\n"
                }
            },
            "required": [
                "dataset",
                "destinationConf",
                "ownershipChallenge",
                "zoneId"
            ],
            "inputProperties": {
                "dataset": {
                    "type": "string",
                    "description": "Which type of dataset resource to use. Available values are `\"firewall_events\"`, `\"http_requests\"`, and `\"spectrum_events\"`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create. Must match the regular expression `^[a-zA-Z0-9\\-\\.]*$`.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush job should be created.\n"
                }
            },
            "requiredInputs": [
                "dataset",
                "destinationConf",
                "ownershipChallenge",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpushJob resources.\n",
                "properties": {
                    "dataset": {
                        "type": "string",
                        "description": "Which type of dataset resource to use. Available values are `\"firewall_events\"`, `\"http_requests\"`, and `\"spectrum_events\"`.\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "logpullOptions": {
                        "type": "string",
                        "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the logpush job to create. Must match the regular expression `^[a-zA-Z0-9\\-\\.]*$`.\n"
                    },
                    "ownershipChallenge": {
                        "type": "string",
                        "description": "Ownership challenge token to prove destination ownership. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the logpush job should be created.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/originCaCertificate:OriginCaCertificate": {
            "description": "Provides a Cloudflare Origin CA certificate used to protect traffic to your origin without involving a third party Certificate Authority.\n\n**This resource requires you use your Origin CA Key as the `api_user_service_key`.**\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The Origin CA certificate\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded.\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The datetime when the certificate will expire.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of hostnames or wildcard names bound to the certificate.\n"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate.\n"
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid.\n"
                }
            },
            "required": [
                "certificate",
                "csr",
                "expiresOn",
                "hostnames",
                "requestType"
            ],
            "inputProperties": {
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of hostnames or wildcard names bound to the certificate.\n"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate.\n"
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid.\n"
                }
            },
            "requiredInputs": [
                "csr",
                "hostnames",
                "requestType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OriginCaCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The Origin CA certificate\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The Certificate Signing Request. Must be newline-encoded.\n"
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "The datetime when the certificate will expire.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of hostnames or wildcard names bound to the certificate.\n"
                    },
                    "requestType": {
                        "type": "string",
                        "description": "The signature type desired on the certificate.\n"
                    },
                    "requestedValidity": {
                        "type": "integer",
                        "description": "The number of days for which the certificate should be valid.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pageRule:PageRule": {
            "description": "Provides a Cloudflare page rule resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a page rule to the domain\nconst foobar = new cloudflare.PageRule(\"foobar\", {\n    zoneId: _var.cloudflare_zone_id,\n    target: `sub.${_var.cloudflare_zone}/page`,\n    priority: 1,\n    actions: {\n        ssl: \"flexible\",\n        emailObfuscation: \"on\",\n        minify: [{\n            html: \"off\",\n            css: \"on\",\n            js: \"on\",\n        }],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a page rule to the domain\nfoobar = cloudflare.PageRule(\"foobar\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    target=f\"sub.{var['cloudflare_zone']}/page\",\n    priority=1,\n    actions={\n        \"ssl\": \"flexible\",\n        \"emailObfuscation\": \"on\",\n        \"minify\": [{\n            \"html\": \"off\",\n            \"css\": \"on\",\n            \"js\": \"on\",\n        }],\n    })\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Add a page rule to the domain\n        var foobar = new Cloudflare.PageRule(\"foobar\", new Cloudflare.PageRuleArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Target = $\"sub.{@var.Cloudflare_zone}/page\",\n            Priority = 1,\n            Actions = new Cloudflare.Inputs.PageRuleActionsArgs\n            {\n                Ssl = \"flexible\",\n                EmailObfuscation = \"on\",\n                Minify = \n                {\n                    \n                    {\n                        { \"html\", \"off\" },\n                        { \"css\", \"on\" },\n                        { \"js\", \"on\" },\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "actions": {
                    "$ref": "#/types/cloudflare:/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n"
                }
            },
            "required": [
                "actions",
                "target",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "$ref": "#/types/cloudflare:/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n"
                }
            },
            "requiredInputs": [
                "actions",
                "target",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PageRule resources.\n",
                "properties": {
                    "actions": {
                        "$ref": "#/types/cloudflare:/PageRuleActions:PageRuleActions",
                        "description": "The actions taken by the page rule, options given below.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Whether the page rule is active or disabled.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The URL pattern to target with the page rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the page rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/rateLimit:RateLimit": {
            "description": "Provides a Cloudflare rate limit resource for a given zone. This can be used to limit the traffic you receive zone-wide, or matching more specific types of requests/responses.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.RateLimit(\"example\", {\n    zoneId: _var.cloudflare_zone_id,\n    threshold: 2000,\n    period: 2,\n    match: {\n        request: {\n            urlPattern: `${_var.cloudflare_zone}/*`,\n            schemes: [\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            methods: [\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        },\n        response: {\n            statuses: [\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            originTraffic: false,\n        },\n    },\n    action: {\n        mode: \"simulate\",\n        timeout: 43200,\n        response: {\n            contentType: \"text/plain\",\n            body: \"custom response body\",\n        },\n    },\n    correlate: {\n        by: \"nat\",\n    },\n    disabled: false,\n    description: \"example rate limit for a zone\",\n    bypassUrlPatterns: [\n        `${_var.cloudflare_zone}/bypass1`,\n        `${_var.cloudflare_zone}/bypass2`,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.RateLimit(\"example\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    threshold=2000,\n    period=2,\n    match={\n        \"request\": {\n            \"urlPattern\": f\"{var['cloudflare_zone']}/*\",\n            \"schemes\": [\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            \"methods\": [\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        },\n        \"response\": {\n            \"statuses\": [\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            \"originTraffic\": False,\n        },\n    },\n    action={\n        \"mode\": \"simulate\",\n        \"timeout\": 43200,\n        \"response\": {\n            \"contentType\": \"text/plain\",\n            \"body\": \"custom response body\",\n        },\n    },\n    correlate={\n        \"by\": \"nat\",\n    },\n    disabled=False,\n    description=\"example rate limit for a zone\",\n    bypass_url_patterns=[\n        f\"{var['cloudflare_zone']}/bypass1\",\n        f\"{var['cloudflare_zone']}/bypass2\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.RateLimit(\"example\", new Cloudflare.RateLimitArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Threshold = 2000,\n            Period = 2,\n            Match = new Cloudflare.Inputs.RateLimitMatchArgs\n            {\n                Request = new Cloudflare.Inputs.RateLimitMatchRequestArgs\n                {\n                    UrlPattern = $\"{@var.Cloudflare_zone}/*\",\n                    Schemes = \n                    {\n                        \"HTTP\",\n                        \"HTTPS\",\n                    },\n                    Methods = \n                    {\n                        \"GET\",\n                        \"POST\",\n                        \"PUT\",\n                        \"DELETE\",\n                        \"PATCH\",\n                        \"HEAD\",\n                    },\n                },\n                Response = new Cloudflare.Inputs.RateLimitMatchResponseArgs\n                {\n                    Statuses = \n                    {\n                        200,\n                        201,\n                        202,\n                        301,\n                        429,\n                    },\n                    OriginTraffic = false,\n                },\n            },\n            Action = new Cloudflare.Inputs.RateLimitActionArgs\n            {\n                Mode = \"simulate\",\n                Timeout = 43200,\n                Response = new Cloudflare.Inputs.RateLimitActionResponseArgs\n                {\n                    ContentType = \"text/plain\",\n                    Body = \"custom response body\",\n                },\n            },\n            Correlate = new Cloudflare.Inputs.RateLimitCorrelateArgs\n            {\n                By = \"nat\",\n            },\n            Disabled = false,\n            Description = \"example rate limit for a zone\",\n            BypassUrlPatterns = \n            {\n                $\"{@var.Cloudflare_zone}/bypass1\",\n                $\"{@var.Cloudflare_zone}/bypass2\",\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "action": {
                    "$ref": "#/types/cloudflare:/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply rate limiting to.\n"
                }
            },
            "required": [
                "action",
                "match",
                "period",
                "threshold",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "$ref": "#/types/cloudflare:/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply rate limiting to.\n"
                }
            },
            "requiredInputs": [
                "action",
                "period",
                "threshold",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RateLimit resources.\n",
                "properties": {
                    "action": {
                        "$ref": "#/types/cloudflare:/RateLimitAction:RateLimitAction",
                        "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                    },
                    "bypassUrlPatterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                    },
                    "correlate": {
                        "$ref": "#/types/cloudflare:/RateLimitCorrelate:RateLimitCorrelate",
                        "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                    },
                    "match": {
                        "$ref": "#/types/cloudflare:/RateLimitMatch:RateLimitMatch",
                        "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                    },
                    "threshold": {
                        "type": "integer",
                        "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply rate limiting to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/record:Record": {
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was created\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The FQDN of the record\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A key-value map of string metadata Cloudflare associates with the record\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was last modified\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proxiable": {
                    "type": "boolean",
                    "description": "Shows whether this record can be proxied, must be true if setting `proxied=true`\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record\n"
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the record to\n"
                }
            },
            "required": [
                "createdOn",
                "hostname",
                "metadata",
                "modifiedOn",
                "name",
                "proxiable",
                "ttl",
                "type",
                "value",
                "zoneId"
            ],
            "inputProperties": {
                "data": {
                    "$ref": "#/types/cloudflare:/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record\n"
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the record to\n"
                }
            },
            "requiredInputs": [
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Record resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was created\n"
                    },
                    "data": {
                        "$ref": "#/types/cloudflare:/RecordData:RecordData",
                        "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The FQDN of the record\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A key-value map of string metadata Cloudflare associates with the record\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was last modified\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the record\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the record\n"
                    },
                    "proxiable": {
                        "type": "boolean",
                        "description": "Shows whether this record can be proxied, must be true if setting `proxied=true`\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the record\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The (string) value of the record. Either this or `data` must be specified\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to add the record to\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/spectrumApplication:SpectrumApplication": {
            "description": "Provides a Cloudflare Spectrum Application. You can extend the power of Cloudflare's DDoS, TLS, and IP Firewall to your other TCP-based services.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Define a spectrum application proxies ssh traffic\nconst sshProxy = new cloudflare.SpectrumApplication(\"sshProxy\", {\n    zoneId: _var.cloudflare_zone_id,\n    protocol: \"tcp/22\",\n    trafficType: \"direct\",\n    dns: {\n        type: \"CNAME\",\n        name: \"ssh.example.com\",\n    },\n    originDirects: [\"tcp://109.151.40.129:22\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Define a spectrum application proxies ssh traffic\nssh_proxy = cloudflare.SpectrumApplication(\"sshProxy\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    protocol=\"tcp/22\",\n    traffic_type=\"direct\",\n    dns={\n        \"type\": \"CNAME\",\n        \"name\": \"ssh.example.com\",\n    },\n    origin_directs=[\"tcp://109.151.40.129:22\"])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Define a spectrum application proxies ssh traffic\n        var sshProxy = new Cloudflare.SpectrumApplication(\"sshProxy\", new Cloudflare.SpectrumApplicationArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Protocol = \"tcp/22\",\n            TrafficType = \"direct\",\n            Dns = new Cloudflare.Inputs.SpectrumApplicationDnsArgs\n            {\n                Type = \"CNAME\",\n                Name = \"ssh.example.com\",\n            },\n            OriginDirects = \n            {\n                \"tcp://109.151.40.129:22\",\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                },
                "edgeIpConnectivity": {
                    "type": "string",
                    "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                },
                "edgeIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "If using `origin_dns` this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflares edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Valid values are: `direct`, `http`, `https`.  Defaults to `direct`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the application to\n"
                }
            },
            "required": [
                "dns",
                "protocol",
                "zoneId"
            ],
            "inputProperties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                },
                "edgeIpConnectivity": {
                    "type": "string",
                    "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                },
                "edgeIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "If using `origin_dns` this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflares edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Valid values are: `direct`, `http`, `https`.  Defaults to `direct`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the application to\n"
                }
            },
            "requiredInputs": [
                "dns",
                "protocol",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SpectrumApplication resources.\n",
                "properties": {
                    "argoSmartRouting": {
                        "type": "boolean",
                        "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                    },
                    "dns": {
                        "$ref": "#/types/cloudflare:/SpectrumApplicationDns:SpectrumApplicationDns",
                        "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                    },
                    "edgeIpConnectivity": {
                        "type": "string",
                        "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                    },
                    "edgeIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                    },
                    "ipFirewall": {
                        "type": "boolean",
                        "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                    },
                    "originDirects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                    },
                    "originDns": {
                        "$ref": "#/types/cloudflare:/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                        "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                    },
                    "originPort": {
                        "type": "integer",
                        "description": "If using `origin_dns` this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The port configuration at Cloudflares edge. e.g. `tcp/22`.\n"
                    },
                    "proxyProtocol": {
                        "type": "string",
                        "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                    },
                    "tls": {
                        "type": "string",
                        "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                    },
                    "trafficType": {
                        "type": "string",
                        "description": "Sets application type. Valid values are: `direct`, `http`, `https`.  Defaults to `direct`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to add the application to\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafGroup:WafGroup": {
            "description": "Provides a Cloudflare WAF rule group resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall groups.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst honeyPot = new cloudflare.WafGroup(\"honey_pot\", {\n    groupId: \"de677e5818985db1285d0e80225f06e5\",\n    mode: \"on\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhoney_pot = cloudflare.WafGroup(\"honeyPot\",\n    group_id=\"de677e5818985db1285d0e80225f06e5\",\n    mode=\"on\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var honeyPot = new Cloudflare.WafGroup(\"honeyPot\", new Cloudflare.WafGroupArgs\n        {\n            GroupId = \"de677e5818985db1285d0e80225f06e5\",\n            Mode = \"on\",\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The WAF Rule Group ID.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the group.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "groupId",
                "packageId",
                "zoneId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "description": "The WAF Rule Group ID.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the group.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafGroup resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The WAF Rule Group ID.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the group.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafPackage:WafPackage": {
            "description": "Provides a Cloudflare WAF rule package resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall packages.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst owasp = new cloudflare.WafPackage(\"owasp\", {\n    actionMode: \"simulate\",\n    packageId: \"a25a9a7e9c00afc1fb2e0245519d725b\",\n    sensitivity: \"medium\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nowasp = cloudflare.WafPackage(\"owasp\",\n    action_mode=\"simulate\",\n    package_id=\"a25a9a7e9c00afc1fb2e0245519d725b\",\n    sensitivity=\"medium\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var owasp = new Cloudflare.WafPackage(\"owasp\", new Cloudflare.WafPackageArgs\n        {\n            ActionMode = \"simulate\",\n            PackageId = \"a25a9a7e9c00afc1fb2e0245519d725b\",\n            Sensitivity = \"medium\",\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The WAF Package ID.\n"
                },
                "sensitivity": {
                    "type": "string",
                    "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "packageId",
                "zoneId"
            ],
            "inputProperties": {
                "actionMode": {
                    "type": "string",
                    "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The WAF Package ID.\n"
                },
                "sensitivity": {
                    "type": "string",
                    "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "packageId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafPackage resources.\n",
                "properties": {
                    "actionMode": {
                        "type": "string",
                        "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The WAF Package ID.\n"
                    },
                    "sensitivity": {
                        "type": "string",
                        "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafRule:WafRule": {
            "description": "Provides a Cloudflare WAF rule resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst _100000 = new cloudflare.WafRule(\"100000\", {\n    mode: \"simulate\",\n    ruleId: \"100000\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n_100000 = cloudflare.WafRule(\"100000\",\n    mode=\"simulate\",\n    rule_id=\"100000\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var _00000 = new Cloudflare.WafRule(\"100000\", new Cloudflare.WafRuleArgs\n        {\n            Mode = \"simulate\",\n            RuleId = \"100000\",\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group that contains the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the rule.\n"
                },
                "ruleId": {
                    "type": "string",
                    "description": "The WAF Rule ID.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "groupId",
                "mode",
                "packageId",
                "ruleId",
                "zoneId"
            ],
            "inputProperties": {
                "mode": {
                    "type": "string",
                    "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the rule.\n"
                },
                "ruleId": {
                    "type": "string",
                    "description": "The WAF Rule ID.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "mode",
                "ruleId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafRule resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Group that contains the rule.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the rule.\n"
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "The WAF Rule ID.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerRoute:WorkerRoute": {
            "description": "Provides a Cloudflare worker route resource. A route will also require a `cloudflare..WorkerScript`. *NOTE:*  This resource uses the Cloudflare account APIs. This requires setting the `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myScript = new cloudflare.WorkerScript(\"myScript\", {});\n// see \"cloudflare..WorkerScript\" documentation ...\n// Runs the specified worker script for all URLs that match `example.com/*`\nconst myRoute = new cloudflare.WorkerRoute(\"myRoute\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    pattern: \"example.com/*\",\n    scriptName: myScript.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_script = cloudflare.WorkerScript(\"myScript\")\n# see \"cloudflare..WorkerScript\" documentation ...\n# Runs the specified worker script for all URLs that match `example.com/*`\nmy_route = cloudflare.WorkerRoute(\"myRoute\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    pattern=\"example.com/*\",\n    script_name=my_script.name)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var myScript = new Cloudflare.WorkerScript(\"myScript\", new Cloudflare.WorkerScriptArgs\n        {\n        });\n        // see \"cloudflare..WorkerScript\" documentation ...\n        // Runs the specified worker script for all URLs that match `example.com/*`\n        var myRoute = new Cloudflare.WorkerRoute(\"myRoute\", new Cloudflare.WorkerRouteArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Pattern = \"example.com/*\",\n            ScriptName = myScript.Name,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/)\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Which worker script to run for requests that match the route pattern. If `script_name` is empty, workers will be skipped for matching requests.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the route to.\n"
                }
            },
            "required": [
                "pattern",
                "zoneId"
            ],
            "inputProperties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/)\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Which worker script to run for requests that match the route pattern. If `script_name` is empty, workers will be skipped for matching requests.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the route to.\n"
                }
            },
            "requiredInputs": [
                "pattern",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerRoute resources.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/)\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Which worker script to run for requests that match the route pattern. If `script_name` is empty, workers will be skipped for matching requests.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to add the route to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerScript:WorkerScript": {
            "description": "Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare..WorkerRoute`. *NOTE:*  This resource uses the Cloudflare account APIs. This requires setting the `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name for the binding.\n"
                }
            },
            "required": [
                "content",
                "name"
            ],
            "inputProperties": {
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name for the binding.\n"
                }
            },
            "requiredInputs": [
                "content",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerScript resources.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "The script content.\n"
                    },
                    "kvNamespaceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for the binding.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKv:WorkersKv": {
            "description": "Provides a Workers KV Pair.  *NOTE:*  This resource uses the Cloudflare account APIs.  This requires setting the `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleNs = new cloudflare.WorkersKvNamespace(\"exampleNs\", {title: \"test-namespace\"});\nconst example = new cloudflare.WorkersKv(\"example\", {\n    namespaceId: exampleNs.id,\n    key: \"test-key\",\n    value: \"test value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_ns = cloudflare.WorkersKvNamespace(\"exampleNs\", title=\"test-namespace\")\nexample = cloudflare.WorkersKv(\"example\",\n    namespace_id=example_ns.id,\n    key=\"test-key\",\n    value=\"test value\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleNs = new Cloudflare.WorkersKvNamespace(\"exampleNs\", new Cloudflare.WorkersKvNamespaceArgs\n        {\n            Title = \"test-namespace\",\n        });\n        var example = new Cloudflare.WorkersKv(\"example\", new Cloudflare.WorkersKvArgs\n        {\n            NamespaceId = exampleNs.Id,\n            Key = \"test-key\",\n            Value = \"test value\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key name\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair\n"
                },
                "value": {
                    "type": "string",
                    "description": "The string value to be stored in the key\n"
                }
            },
            "required": [
                "key",
                "namespaceId",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "The key name\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair\n"
                },
                "value": {
                    "type": "string",
                    "description": "The string value to be stored in the key\n"
                }
            },
            "requiredInputs": [
                "key",
                "namespaceId",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKv resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "The key name\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "The ID of the Workers KV namespace in which you want to create the KV pair\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The string value to be stored in the key\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKvNamespace:WorkersKvNamespace": {
            "description": "Provides a Workers KV Namespace\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WorkersKvNamespace(\"example\", {\n    title: \"test-namespace\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WorkersKvNamespace(\"example\", title=\"test-namespace\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.WorkersKvNamespace(\"example\", new Cloudflare.WorkersKvNamespaceArgs\n        {\n            Title = \"test-namespace\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "title": {
                    "type": "string",
                    "description": "The name of the namespace you wish to create.\n"
                }
            },
            "required": [
                "title"
            ],
            "inputProperties": {
                "title": {
                    "type": "string",
                    "description": "The name of the namespace you wish to create.\n"
                }
            },
            "requiredInputs": [
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKvNamespace resources.\n",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "The name of the namespace you wish to create.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zone:Zone": {
            "description": "Provides a Cloudflare Zone resource. Zone is the basic resource for working with Cloudflare and is roughly equivalent to a domain name that the user purchases.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Zone(\"example\", {\n    zone: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Zone(\"example\", zone=\"example.com\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.Zone(\"example\", new Cloudflare.ZoneArgs\n        {\n            Zone = \"example.com\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "jumpStart": {
                    "type": "boolean",
                    "description": "Boolean of whether to scan for DNS records on creation. Ignored after zone is created. Default: false.\n"
                },
                "meta": {
                    "$ref": "#/types/cloudflare:/ZoneMeta:ZoneMeta"
                },
                "nameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone is paused (traffic bypasses Cloudflare). Default: false.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone, can be updated once the one is created; one of `free`, `pro`, `business`, `enterprise`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone. Valid values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Valid values: `full`, `partial`. Default is `full`.\n"
                },
                "vanityNameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vanity Nameservers (if set).\n* `meta.wildcard_proxiable` - Indicates whether wildcard DNS records can receive Cloudflare security and performance features.\n* `meta.phishing_detected` - Indicates if URLs on the zone have been identified as hosting phishing content.\n"
                },
                "verificationKey": {
                    "type": "string",
                    "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`. \n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added.\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    }
                }
            },
            "required": [
                "meta",
                "nameServers",
                "plan",
                "status",
                "vanityNameServers",
                "verificationKey",
                "zone"
            ],
            "inputProperties": {
                "jumpStart": {
                    "type": "boolean",
                    "description": "Boolean of whether to scan for DNS records on creation. Ignored after zone is created. Default: false.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone is paused (traffic bypasses Cloudflare). Default: false.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone, can be updated once the one is created; one of `free`, `pro`, `business`, `enterprise`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Valid values: `full`, `partial`. Default is `full`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added.\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    }
                }
            },
            "requiredInputs": [
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Zone resources.\n",
                "properties": {
                    "jumpStart": {
                        "type": "boolean",
                        "description": "Boolean of whether to scan for DNS records on creation. Ignored after zone is created. Default: false.\n"
                    },
                    "meta": {
                        "$ref": "#/types/cloudflare:/ZoneMeta:ZoneMeta"
                    },
                    "nameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Boolean of whether this zone is paused (traffic bypasses Cloudflare). Default: false.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The name of the commercial plan to apply to the zone, can be updated once the one is created; one of `free`, `pro`, `business`, `enterprise`.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the zone. Valid values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Valid values: `full`, `partial`. Default is `full`.\n"
                    },
                    "vanityNameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vanity Nameservers (if set).\n* `meta.wildcard_proxiable` - Indicates whether wildcard DNS records can receive Cloudflare security and performance features.\n* `meta.phishing_detected` - Indicates if URLs on the zone have been identified as hosting phishing content.\n"
                    },
                    "verificationKey": {
                        "type": "string",
                        "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`. \n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The DNS zone name which will be added.\n",
                        "language": {
                            "csharp": {
                                "name": "ZoneName"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneLockdown:ZoneLockdown": {
            "description": "Provides a Cloudflare Zone Lockdown resource. Zone Lockdown allows you to define one or more URLs (with wildcard matching on the domain or path) that will only permit access if the request originates from an IP address that matches a safelist of one or more IP addresses and/or IP ranges.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Restrict access to these endpoints to requests from a known IP address.\nconst endpointLockdown = new cloudflare.ZoneLockdown(\"endpoint_lockdown\", {\n    configurations: [{\n        target: \"ip\",\n        value: \"198.51.100.4\",\n    }],\n    description: \"Restrict access to these endpoints to requests from a known IP address\",\n    paused: false,\n    urls: [\"api.mysite.com/some/endpoint*\"],\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Restrict access to these endpoints to requests from a known IP address.\nendpoint_lockdown = cloudflare.ZoneLockdown(\"endpointLockdown\",\n    configurations=[{\n        \"target\": \"ip\",\n        \"value\": \"198.51.100.4\",\n    }],\n    description=\"Restrict access to these endpoints to requests from a known IP address\",\n    paused=\"false\",\n    urls=[\"api.mysite.com/some/endpoint*\"],\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Restrict access to these endpoints to requests from a known IP address.\n        var endpointLockdown = new Cloudflare.ZoneLockdown(\"endpointLockdown\", new Cloudflare.ZoneLockdownArgs\n        {\n            Configurations = \n            {\n                new Cloudflare.Inputs.ZoneLockdownConfigurationArgs\n                {\n                    Target = \"ip\",\n                    Value = \"198.51.100.4\",\n                },\n            },\n            Description = \"Restrict access to these endpoints to requests from a known IP address\",\n            Paused = false,\n            Urls = \n            {\n                \"api.mysite.com/some/endpoint*\",\n            },\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.  It's a complex value. See description below.   The order of the configuration entries is unimportant.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the access rule should be added.\n"
                }
            },
            "required": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "inputProperties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.  It's a complex value. See description below.   The order of the configuration entries is unimportant.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the access rule should be added.\n"
                }
            },
            "requiredInputs": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneLockdown resources.\n",
                "properties": {
                    "configurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                        },
                        "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.  It's a complex value. See description below.   The order of the configuration entries is unimportant.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the access rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneSettingsOverride:ZoneSettingsOverride": {
            "description": "Provides a resource which customizes Cloudflare zone settings. Note that after destroying this resource Zone Settings will be reset to their initial values.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = new cloudflare.ZoneSettingsOverride(\"test\", {\n    zoneId: _var.cloudflare_zone_id,\n    settings: {\n        brotli: \"on\",\n        challengeTtl: 2700,\n        securityLevel: \"high\",\n        opportunisticEncryption: \"on\",\n        automaticHttpsRewrites: \"on\",\n        mirage: \"on\",\n        waf: \"on\",\n        minify: {\n            css: \"on\",\n            js: \"off\",\n            html: \"off\",\n        },\n        security_header: {\n            enabled: true,\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.ZoneSettingsOverride(\"test\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    settings={\n        \"brotli\": \"on\",\n        \"challengeTtl\": 2700,\n        \"securityLevel\": \"high\",\n        \"opportunisticEncryption\": \"on\",\n        \"automaticHttpsRewrites\": \"on\",\n        \"mirage\": \"on\",\n        \"waf\": \"on\",\n        \"minify\": {\n            \"css\": \"on\",\n            \"js\": \"off\",\n            \"html\": \"off\",\n        },\n        \"security_header\": {\n            \"enabled\": True,\n        },\n    })\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Cloudflare.ZoneSettingsOverride(\"test\", new Cloudflare.ZoneSettingsOverrideArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Settings = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsArgs\n            {\n                Brotli = \"on\",\n                ChallengeTtl = 2700,\n                SecurityLevel = \"high\",\n                OpportunisticEncryption = \"on\",\n                AutomaticHttpsRewrites = \"on\",\n                Mirage = \"on\",\n                Waf = \"on\",\n                Minify = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsMinifyArgs\n                {\n                    Css = \"on\",\n                    Js = \"off\",\n                    Html = \"off\",\n                },\n                Security_header = \n                {\n                    { \"enabled\", true },\n                },\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "initialSettings": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideInitialSettings:ZoneSettingsOverrideInitialSettings",
                    "description": "Settings present in the zone at the time the resource is created. This will be used to restore the original settings when this resource is destroyed. Shares the same schema as the `settings` attribute (Above).\n"
                },
                "initialSettingsReadAt": {
                    "type": "string"
                },
                "readonlySettings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Which of the current `settings` are not able to be set by the user. Which settings these are is determined by plan level and user permissions.\n* `zone_status`. A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup.\n* `zone_type`. Status of the zone. Valid values: active, pending, initializing, moved, deleted, deactivated.\n"
                },
                "settings": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                    "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                },
                "zoneStatus": {
                    "type": "string"
                },
                "zoneType": {
                    "type": "string"
                }
            },
            "required": [
                "initialSettings",
                "initialSettingsReadAt",
                "readonlySettings",
                "settings",
                "zoneId",
                "zoneStatus",
                "zoneType"
            ],
            "inputProperties": {
                "settings": {
                    "$ref": "#/types/cloudflare:/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                    "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneSettingsOverride resources.\n",
                "properties": {
                    "initialSettings": {
                        "$ref": "#/types/cloudflare:/ZoneSettingsOverrideInitialSettings:ZoneSettingsOverrideInitialSettings",
                        "description": "Settings present in the zone at the time the resource is created. This will be used to restore the original settings when this resource is destroyed. Shares the same schema as the `settings` attribute (Above).\n"
                    },
                    "initialSettingsReadAt": {
                        "type": "string"
                    },
                    "readonlySettings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Which of the current `settings` are not able to be set by the user. Which settings these are is determined by plan level and user permissions.\n* `zone_status`. A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup.\n* `zone_type`. Status of the zone. Valid values: active, pending, initializing, moved, deleted, deactivated.\n"
                    },
                    "settings": {
                        "$ref": "#/types/cloudflare:/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                        "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which apply settings.\n"
                    },
                    "zoneStatus": {
                        "type": "string"
                    },
                    "zoneType": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "cloudflare:index/getIpRanges:getIpRanges": {
            "description": "Use this data source to get the [IP ranges](https://www.cloudflare.com/ips/) of Cloudflare edge nodes.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "outputs": {
                "description": "A collection of values returned by getIpRanges.\n",
                "properties": {
                    "cidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipv4CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ipv6CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "cidrBlocks",
                    "ipv4CidrBlocks",
                    "ipv6CidrBlocks",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafGroups:getWafGroups": {
            "description": "Use this data source to look up [WAF Rule Groups](https://api.cloudflare.com/#waf-rule-groups-properties).\n\n{{% examples %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getWafGroups.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getWafGroupsFilter:getWafGroupsFilter"
                    },
                    "packageId": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafGroups.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getWafGroupsFilter:getWafGroupsFilter"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/getWafGroupsGroup:getWafGroupsGroup"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packageId": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "groups",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafPackages:getWafPackages": {
            "description": "Use this data source to look up [WAF Rule Packages](https://api.cloudflare.com/#waf-rule-packages-properties).\n\n{{% examples %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getWafPackages.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getWafPackagesFilter:getWafPackagesFilter"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafPackages.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getWafPackagesFilter:getWafPackagesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/getWafPackagesPackage:getWafPackagesPackage"
                        }
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "packages",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafRules:getWafRules": {
            "description": "Use this data source to look up [WAF Rules](https://api.cloudflare.com/#waf-rule-groups-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all WAF Rules that are in the group of ID `de677e5818985db1285d0e80225f06e5`, contain `example` in their description, and are currently `on`. The matched WAF Rules are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafRules({\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n    packageId: \"a25a9a7e9c00afc1fb2e0245519d725b\",\n    filter: {\n        description: \".*example.*\",\n        mode: \"on\",\n        groupId: \"de677e5818985db1285d0e80225f06e5\",\n    },\n});\nexport const wafRules = test.then(test =\u003e test.rules);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_rules(zone_id=\"ae36f999674d196762efcc5abb06b345\",\n    package_id=\"a25a9a7e9c00afc1fb2e0245519d725b\",\n    filter={\n        \"description\": \".*example.*\",\n        \"mode\": \"on\",\n        \"group_id\": \"de677e5818985db1285d0e80225f06e5\",\n    })\npulumi.export(\"wafRules\", test.rules)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Cloudflare.GetWafRules.InvokeAsync(new Cloudflare.GetWafRulesArgs\n        {\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n            PackageId = \"a25a9a7e9c00afc1fb2e0245519d725b\",\n            Filter = new Cloudflare.Inputs.GetWafRulesFilterArgs\n            {\n                Description = \".*example.*\",\n                Mode = \"on\",\n                GroupId = \"de677e5818985db1285d0e80225f06e5\",\n            },\n        }));\n        this.WafRules = test.Apply(test =\u003e test.Rules);\n    }\n\n    [Output(\"wafRules\")]\n    public Output\u003cstring\u003e WafRules { get; set; }\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getWafRules.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getWafRulesFilter:getWafRulesFilter"
                    },
                    "packageId": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafRules.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getWafRulesFilter:getWafRulesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packageId": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/getWafRulesRule:getWafRulesRule"
                        }
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "rules",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZones:getZones": {
            "description": "Use this data source to look up [Zone](https://api.cloudflare.com/#zone-properties) records.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getZonesFilter:getZonesFilter"
                    }
                },
                "type": "object",
                "required": [
                    "filter"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:/getZonesFilter:getZonesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "zones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:/getZonesZone:getZonesZone"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "filter",
                    "zones",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "cloudflare": "Cloudflare"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^8.0.25"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing Cloudflare cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-cloudflare` repo](https://github.com/terraform-providers/terraform-provider-cloudflare/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=2.0.0,\u003c3.0.0"
            }
        }
    }
}