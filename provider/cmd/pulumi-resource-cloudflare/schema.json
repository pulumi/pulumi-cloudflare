{
    "name": "cloudflare",
    "description": "A Pulumi package for creating and managing Cloudflare cloud resources.",
    "keywords": [
        "pulumi",
        "cloudflare"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`cloudflare` Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare).",
    "repository": "https://github.com/pulumi/pulumi-cloudflare",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use that account\n"
            },
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger)\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            }
        }
    },
    "types": {
        "cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader": {
            "properties": {
                "allowAllHeaders": {
                    "type": "boolean",
                    "description": "Boolean value to determine whether all\nHTTP headers are exposed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowAllMethods": {
                    "type": "boolean",
                    "description": "Boolean value to determine whether all\nmethods are exposed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowAllOrigins": {
                    "type": "boolean",
                    "description": "Boolean value to determine whether all\norigins are permitted to make CORS requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowCredentials": {
                    "type": "boolean",
                    "description": "Boolean value to determine if credentials\n(cookies, authorization headers, or TLS client certificates) are included with\nrequests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowedHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of HTTP headers to expose via CORS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowedMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of methods to expose via CORS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowedOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of origins permitted to make CORS requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer representing the maximum time a preflight\nrequest will be cached.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExclude:AccessGroupExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeAzure:AccessGroupExcludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeGithub:AccessGroupExcludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeOkta:AccessGroupExcludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeSaml:AccessGroupExcludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeAzure:AccessGroupExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeGithub:AccessGroupExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeOkta:AccessGroupExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeSaml:AccessGroupExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupInclude:AccessGroupInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeAzure:AccessGroupIncludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeGithub:AccessGroupIncludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeOkta:AccessGroupIncludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeSaml:AccessGroupIncludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeAzure:AccessGroupIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeGithub:AccessGroupIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeOkta:AccessGroupIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeSaml:AccessGroupIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequire:AccessGroupRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireAzure:AccessGroupRequireAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireGithub:AccessGroupRequireGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireGsuite:AccessGroupRequireGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireOkta:AccessGroupRequireOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireSaml:AccessGroupRequireSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireAzure:AccessGroupRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireGithub:AccessGroupRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireGsuite:AccessGroupRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireOkta:AccessGroupRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireSaml:AccessGroupRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "appsDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "centrifyAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "centrifyAppId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certsUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directoryId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAttributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "idpPublicCert": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "issuerUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktaAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oneloginAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "redirectUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signRequest": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssoTargetUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportGroups": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "redirectUrl"
                    ]
                }
            }
        },
        "cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup": {
            "properties": {
                "approvalsNeeded": {
                    "type": "integer",
                    "description": "Number of approvals needed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of emails to request approval from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailListUuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "approvalsNeeded"
            ]
        },
        "cloudflare:index/AccessPolicyExclude:AccessPolicyExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyInclude:AccessPolicyInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequire:AccessPolicyRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireAzure:AccessPolicyRequireAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireGithub:AccessPolicyRequireGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireOkta:AccessPolicyRequireOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireSaml:AccessPolicyRequireSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireAzure:AccessPolicyRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireGithub:AccessPolicyRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireOkta:AccessPolicyRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireSaml:AccessPolicyRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Allowed values: \"ip\", \"ip6\", \"ip_range\", \"asn\", \"country\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/ApiTokenCondition:ApiTokenCondition": {
            "properties": {
                "requestIp": {
                    "$ref": "#/types/cloudflare:index/ApiTokenConditionRequestIp:ApiTokenConditionRequestIp",
                    "description": "Request IP related conditions. See the definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenConditionRequestIp:ApiTokenConditionRequestIp": {
            "properties": {
                "ins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv4/IPv6 CIDR addresses where\nthe Token can be used from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notIns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv4/IPv6 CIDR addresses where\nthe Token cannot be used from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenPolicy:ApiTokenPolicy": {
            "properties": {
                "effect": {
                    "type": "string",
                    "description": "Policy effect. Valid values are `allow` or `deny`. `allow`\nis set as default.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permissionGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of permissions groups\nids ([see official docs](https://developers.cloudflare.com/api/tokens/create/permissions)).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map describes what operations against which resources\nare allowed or denied.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "permissionGroups",
                "resources"
            ]
        },
        "cloudflare:index/CustomHostnameSsl:CustomHostnameSsl": {
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTarget": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customCertificate": {
                    "type": "string",
                    "description": "If a custom uploaded certificate is used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customKey": {
                    "type": "string",
                    "description": "The key for a custom uploaded certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "method": {
                    "type": "string",
                    "description": "Domain control validation (DCV) method used for this\nhostname. Valid values are `\"txt\"`, `\"http\"` and `\"email\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslSetting:CustomHostnameSslSetting"
                    },
                    "description": "SSL/TLS settings for the certificate. See further notes below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Level of validation to be used for this hostname. Domain validation (\"dv\") must be used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "wildcard": {
                    "type": "boolean",
                    "description": "Indicates whether the certificate covers a wildcard.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "settings",
                        "status"
                    ]
                }
            }
        },
        "cloudflare:index/CustomHostnameSslSetting:CustomHostnameSslSetting": {
            "properties": {
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of SSL/TLS ciphers to associate with this certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "earlyHints": {
                    "type": "string",
                    "description": "Whether or not early hints should be supported. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "description": "Whether or not HTTP2 should be supported. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "description": "Lowest version of TLS this certificate should\nsupport. Valid values are `\"1.0\"`, `\"1.1\"`, `\"1.2\"` and `\"1.3\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "description": "Whether or not TLSv1.3 should be supported. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions": {
            "properties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "description": "Certificate certificate and the intermediate(s)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geoRestrictions": {
                    "type": "string",
                    "description": "Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateKey": {
                    "type": "string",
                    "description": "Certificate's private key\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput": {
            "properties": {
                "complianceStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domain": {
                    "type": "string",
                    "description": "= (Required) The domain that the client must join.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "= (Required) True if the firewall must be enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exists": {
                    "type": "boolean",
                    "description": "Checks if the file should exist.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The Teams List id.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "description": "= (Required) The version comparison operator in (\u003e,\u003e=,\u003c,\u003c=,==)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the application.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireAll": {
                    "type": "boolean",
                    "description": "= (Required) True if all drives must be encrypted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "running": {
                    "type": "boolean",
                    "description": "Checks if the application should be running.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sha256": {
                    "type": "string",
                    "description": "The sha256 hash of the file.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thumbprint": {
                    "type": "string",
                    "description": "The thumbprint of the application certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "description": "= (Required) The operating system semantic version.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "exists",
                        "requireAll",
                        "running"
                    ]
                }
            }
        },
        "cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch": {
            "properties": {
                "platform": {
                    "type": "string",
                    "description": "The platform of the device. Valid values are `windows`, `mac`, `linux`, `android`, and `ios`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/HealthcheckHeader:HealthcheckHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/IpListItem:IpListItem": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "A note that can be used to annotate the item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The IPv4 address, IPv4 CIDR or IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding": {
            "properties": {
                "defaultPercent": {
                    "type": "number",
                    "description": "Percent of traffic to shed 0 - 100.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultPolicy": {
                    "type": "string",
                    "description": "Method of shedding traffic \"\", \"hash\" or \"random\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionPercent": {
                    "type": "number",
                    "description": "Percent of session traffic to shed 0 - 100.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionPolicy": {
                    "type": "string",
                    "description": "Method of shedding session traffic \"\" or \"hash\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginHeader:LoadBalancerPoolOriginHeader"
                    },
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Default: 1.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "name"
            ]
        },
        "cloudflare:index/LoadBalancerPoolOriginHeader:LoadBalancerPoolOriginHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering": {
            "properties": {
                "policy": {
                    "type": "string",
                    "description": "Either \"random\" (default) or \"hash\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:index/LoadBalancerRule:LoadBalancerRule": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "The statement to evaluate to determine if this rules effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A disabled rule will be be executed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fixedResponse": {
                    "$ref": "#/types/cloudflare:index/LoadBalancerRuleFixedResponse:LoadBalancerRuleFixedResponse",
                    "description": "Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: overrides or fixed_response must be set. See the field documentation below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Human readable name for this rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrides": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverride:LoadBalancerRuleOverride"
                    },
                    "description": "The Load Balancer settings to alter if this rules condition is true. Note: overrides or fixed_response must be set. See the field documentation below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority used when determining the order of rule execution. Lower values are executed first. If not provided list order will be used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "terminates": {
                    "type": "boolean",
                    "description": "Terminates indicates that if this rule is true no further rules should be executed. Note: setting a fixed_response forces this field to true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "priority",
                        "terminates"
                    ]
                }
            }
        },
        "cloudflare:index/LoadBalancerRuleFixedResponse:LoadBalancerRuleFixedResponse": {
            "properties": {
                "contentType": {
                    "type": "string",
                    "description": "The value of the HTTP context-type header for this fixed response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "location": {
                    "type": "string",
                    "description": "The value of the HTTP location header for this fixed response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "messageBody": {
                    "type": "string",
                    "description": "The text used as the html body for this fixed response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "description": "The HTTP status code used for this fixed response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverride:LoadBalancerRuleOverride": {
            "properties": {
                "defaultPools": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "See default_pool_ids above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fallbackPool": {
                    "type": "string",
                    "description": "See fallback_pool_id above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverridePopPool:LoadBalancerRuleOverridePopPool"
                    },
                    "description": "See pop_pools above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideRegionPool:LoadBalancerRuleOverrideRegionPool"
                    },
                    "description": "See region_pools above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "See field above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionAffinityAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "See field above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "See field above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "See field above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "See field above.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverridePopPool:LoadBalancerRuleOverridePopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:index/LoadBalancerRuleOverrideRegionPool:LoadBalancerRuleOverrideRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions). Multiple entries should not be specified with the same region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/PageRuleActions:PageRuleActions": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "string",
                    "description": "The Time To Live for the browser cache. `0` means 'Respect Existing Headers'\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bypassCacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally bypass cache the page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheByDeviceType": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheDeceptionArmor": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheKeyFields": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields",
                    "description": "Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Whether to set the cache level to `\"bypass\"`, `\"basic\"`, `\"simplified\"`, `\"aggressive\"`, or `\"cache_everything\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally cache the page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheTtlByStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PageRuleActionsCacheTtlByStatus:PageRuleActionsCacheTtlByStatus"
                    },
                    "description": "Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableApps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disablePerformance": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableRailgun": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableSecurity": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeCacheTtl": {
                    "type": "integer",
                    "description": "The Time To Live for the edge cache.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "explicitCacheControl": {
                    "type": "string",
                    "description": "Whether origin Cache-Control action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardingUrl": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl",
                    "description": "The URL to forward to, and with what status. See below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeaderOverride": {
                    "type": "string",
                    "description": "Value of the Host header to send.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PageRuleActionsMinify:PageRuleActionsMinify"
                    },
                    "description": "The configuration for HTML, CSS and JS minification. See below for full list of options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Whether this action is `\"off\"`, `\"lossless\"` or `\"lossy\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resolveOverride": {
                    "type": "string",
                    "description": "Overridden origin server name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "respectStrongEtag": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "description": "Whether to set the rocket loader to `\"on\"`, `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Whether to set the security level to `\"off\"`, `\"essentially_off\"`, `\"low\"`, `\"medium\"`, `\"high\"`, or `\"under_attack\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Whether to set the SSL mode to `\"off\"`, `\"flexible\"`, `\"full\"`, `\"strict\"`, or `\"origin_pull\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie",
                    "description": "Controls what cookies go into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "header": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader",
                    "description": "Controls what HTTP headers go into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost",
                    "description": "Controls which Host header goes into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString",
                    "description": "Controls which URL query string parameters go into the Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "user": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser",
                    "description": "Controls which end user-related features go into the Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cookie",
                "header",
                "host",
                "queryString",
                "user"
            ]
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "excludes",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "description": "`false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignore": {
                    "type": "boolean",
                    "description": "`false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value is ignored if any of `exclude` or `include` is non-empty.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "excludes",
                        "ignore",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "description": "`true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geo": {
                    "type": "boolean",
                    "description": "`true` - includes the client’s country, derived from the IP address; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lang": {
                    "type": "boolean",
                    "description": "`true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceType",
                        "geo",
                        "lang"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheTtlByStatus:PageRuleActionsCacheTtlByStatus": {
            "properties": {
                "codes": {
                    "type": "string",
                    "description": "A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "Duration a resource lives in the Cloudflare cache.\n* positive number - cache for specified duration in seconds\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "codes",
                "ttl"
            ]
        },
        "cloudflare:index/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "description": "The status code to use for the redirection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL to which the page rule should forward.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "statusCode",
                "url"
            ]
        },
        "cloudflare:index/PageRuleActionsMinify:PageRuleActionsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "Whether CSS should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "Whether HTML should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "Whether Javascript should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/RateLimitAction:RateLimitAction": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The type of action to perform. Allowable values are 'simulate', 'ban', 'challenge' and 'js_challenge'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "response": {
                    "$ref": "#/types/cloudflare:index/RateLimitActionResponse:RateLimitActionResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "description": "The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period (min: 1, max: 86400).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RateLimitActionResponse:RateLimitActionResponse": {
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The body to return, the content here should conform to the content_type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "The content-type of the body, must be one of: 'text/plain', 'text/xml', 'application/json'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "body",
                "contentType"
            ]
        },
        "cloudflare:index/RateLimitCorrelate:RateLimitCorrelate": {
            "properties": {
                "by": {
                    "type": "string",
                    "description": "If set to 'nat', NAT support will be enabled for rate limiting.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RateLimitMatch:RateLimitMatch": {
            "properties": {
                "request": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatchRequest:RateLimitMatchRequest",
                    "description": "Matches HTTP requests (from the client to Cloudflare). See definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "response": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatchResponse:RateLimitMatchResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "request",
                        "response"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitMatchRequest:RateLimitMatchRequest": {
            "properties": {
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Methods, can be a subset ['POST','PUT'] or all ['\\_ALL\\_']. Default: ['\\_ALL\\_'].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schemes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Schemes, can be one ['HTTPS'], both ['HTTP','HTTPS'] or all ['\\_ALL\\_'].  Default: ['\\_ALL\\_'].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "urlPattern": {
                    "type": "string",
                    "description": "The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use * for all traffic to your zone. Default: '*'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "methods",
                        "schemes",
                        "urlPattern"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitMatchResponse:RateLimitMatchResponse": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "description": "block is a list of maps with the following attributes:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originTraffic": {
                    "type": "boolean",
                    "description": "Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting. Default: `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "HTTP Status codes, can be one [403], many [401,403] or indicate all by not providing this value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "originTraffic",
                        "statuses"
                    ]
                }
            }
        },
        "cloudflare:index/RecordData:RecordData": {
            "properties": {
                "algorithm": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "altitude": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "content": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "digest": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "digestType": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fingerprint": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flags": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyTag": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latDegrees": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latDirection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latMinutes": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latSeconds": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longDegrees": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longDirection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longMinutes": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longSeconds": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchingType": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "order": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "precisionHorz": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "precisionVert": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preference": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proto": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regex": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replacement": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "selector": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tag": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "integer",
                    "description": "The type of the record\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usage": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRule:RulesetRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Valid values are `\"block\"`, `\"challenge\"`, `\"ddos_dynamic\"`, `\"execute\"`, `\"force_connection_close\"`, `\"js_challenge\"`, `\"log\"`, `\"rewrite\"`, `\"score\"`, or  `\"skip\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "actionParameters": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParameters:RulesetRuleActionParameters",
                    "description": "List of parameters that configure the behavior of the ruleset rule action (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset rule and its intended use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current rule-level override enables or disables the rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exposedCredentialCheck": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleExposedCredentialCheck:RulesetRuleExposedCredentialCheck",
                    "description": "List of parameters that configure exposed credential checks (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Rule ID to apply the override to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ratelimit": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleRatelimit:RulesetRuleRatelimit",
                    "description": "List of parameters that configure HTTP rate limiting behaviour (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ref": {
                    "type": "string",
                    "description": "Rule reference.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "description",
                "expression"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "description",
                        "expression",
                        "id",
                        "ref",
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParameters:RulesetRuleActionParameters": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersHeader:RulesetRuleActionParametersHeader"
                    },
                    "description": "List of HTTP header modifications to perform in the ruleset rule (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Rule ID to apply the override to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "increment": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchedData": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersMatchedData:RulesetRuleActionParametersMatchedData",
                    "description": "List of properties to configure WAF payload logging (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrides": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverrides:RulesetRuleActionParametersOverrides",
                    "description": "List of override configurations to apply to the ruleset (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Products to target with the actions. Valid values are `\"bic\"`, `\"hot\"`, `\"ratelimit\"`, `\"securityLevel\"`, `\"uablock\"`, `\"waf\"` or `\"zonelockdown\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "List of rule-based overrides (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ruleset": {
                    "type": "string",
                    "description": "Which ruleset ID to target.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rulesets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of managed WAF rule IDs to target. Only valid when the \"action\" is set to skip.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uri": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUri:RulesetRuleActionParametersUri",
                    "description": "List of URI properties to configure for the ruleset rule when performing URL rewrite transformations (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParametersHeader:RulesetRuleActionParametersHeader": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP request header to target.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operation": {
                    "type": "string",
                    "description": "Action to perform on the HTTP request header. Valid values are `\"set\"` or `\"remove\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component. Conflicts with `expression`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersMatchedData:RulesetRuleActionParametersMatchedData": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "description": "Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverrides:RulesetRuleActionParametersOverrides": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Valid values are `\"block\"`, `\"challenge\"`, `\"ddos_dynamic\"`, `\"execute\"`, `\"force_connection_close\"`, `\"js_challenge\"`, `\"log\"`, `\"rewrite\"`, `\"score\"`, or  `\"skip\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "categories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverridesCategory:RulesetRuleActionParametersOverridesCategory"
                    },
                    "description": "List of tag-based overrides (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current rule-level override enables or disables the rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverridesRule:RulesetRuleActionParametersOverridesRule"
                    },
                    "description": "List of rule-based overrides (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverridesCategory:RulesetRuleActionParametersOverridesCategory": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Valid values are `\"block\"`, `\"challenge\"`, `\"ddos_dynamic\"`, `\"execute\"`, `\"force_connection_close\"`, `\"js_challenge\"`, `\"log\"`, `\"rewrite\"`, `\"score\"`, or  `\"skip\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "category": {
                    "type": "string",
                    "description": "Tag name to apply the ruleset rule override to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current rule-level override enables or disables the rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverridesRule:RulesetRuleActionParametersOverridesRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the rule-level override. Valid values are `\"block\"`, `\"challenge\"`, `\"ddos_dynamic\"`, `\"execute\"`, `\"force_connection_close\"`, `\"js_challenge\"`, `\"log\"`, `\"rewrite\"`, `\"score\"`, or  `\"skip\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines if the current rule-level override enables or disables the rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Rule ID to apply the override to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scoreThreshold": {
                    "type": "integer",
                    "description": "Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivityLevel": {
                    "type": "string",
                    "description": "Sensitivity level for a ruleset rule override.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUri:RulesetRuleActionParametersUri": {
            "properties": {
                "origin": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUriPath:RulesetRuleActionParametersUriPath",
                    "description": "URI path configuration when performing a URL rewrite (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUriQuery:RulesetRuleActionParametersUriQuery",
                    "description": "Query string configuration when performing a URL rewrite (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUriPath:RulesetRuleActionParametersUriPath": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component. Conflicts with `expression`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUriQuery:RulesetRuleActionParametersUriQuery": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expression that defines the updated (dynamic) value of the URI path or query string component. Conflicts with `value`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Static string value of the updated URI path or query string component. Conflicts with `expression`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleExposedCredentialCheck:RulesetRuleExposedCredentialCheck": {
            "properties": {
                "passwordExpression": {
                    "type": "string",
                    "description": "Firewall Rules expression language based on Wireshark display filters for where to check for the \"password\" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameExpression": {
                    "type": "string",
                    "description": "Firewall Rules expression language based on Wireshark display filters for where to check for the \"username\" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleRatelimit:RulesetRuleRatelimit": {
            "properties": {
                "characteristics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of parameters that define how Cloudflare tracks the request rate for this rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mitigationExpression": {
                    "type": "string",
                    "description": "Scope of the mitigation action. Allows you to specify an action scope different from the rule scope. Refer to the [rate limiting parameters documentation](https://developers.cloudflare.com/firewall/cf-rulesets/custom-rules/rate-limiting/parameters) for full details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mitigationTimeout": {
                    "type": "integer",
                    "description": "Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "period": {
                    "type": "integer",
                    "description": "The period of time to consider (in seconds) when evaluating the request rate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestsPerPeriod": {
                    "type": "integer",
                    "description": "The number of requests over the period of time that will trigger the Rate Limiting rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin e.g. origin-ssh.example.com.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of DNS record associated with the application. Valid values: `CNAME`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin e.g. origin-ssh.example.com.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange": {
            "properties": {
                "end": {
                    "type": "integer",
                    "description": "Upper bound of the origin port range, e.g. `2000`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "Lower bound of the origin port range, e.g. `1000`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "end",
                "start"
            ]
        },
        "cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address in CIDR format to include in the tunnel configuration. Conflicts with `\"host\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "The description of the tunnel.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The domain name to include in the tunnel configuration. Conflicts with `\"address\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus": {
            "properties": {
                "enabledDownloadPhase": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabledUploadPhase": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failClosed": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabledDownloadPhase",
                "enabledUploadPhase",
                "failClosed"
            ]
        },
        "cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "Hex code of block page background color.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of enablement.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "footerText": {
                    "type": "string",
                    "description": "Block page header text.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headerText": {
                    "type": "string",
                    "description": "Block page footer text.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logoPath": {
                    "type": "string",
                    "description": "URL of block page logo.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of block page configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the teams location.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "network": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "network"
                    ]
                }
            }
        },
        "cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings": {
            "properties": {
                "bisoAdminControls": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsBisoAdminControls:TeamsRuleRuleSettingsBisoAdminControls",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "blockPageEnabled": {
                    "type": "boolean",
                    "description": "Indicator of block page enablement.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "blockPageReason": {
                    "type": "string",
                    "description": "The displayed reason for a user being blocked.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "l4override": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsL4override:TeamsRuleRuleSettingsL4override",
                    "description": "Settings to forward layer 4 traffic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrideHost": {
                    "type": "string",
                    "description": "The host to override matching DNS queries with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrideIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IPs to override matching DNS queries with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsBisoAdminControls:TeamsRuleRuleSettingsBisoAdminControls": {
            "properties": {
                "disableCopyPaste": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disablePrinting": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsL4override:TeamsRuleRuleSettingsL4override": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Override IP to forward traffic to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "Override Port to forward traffic to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "ip",
                "port"
            ]
        },
        "cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespaceId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "namespaceId"
            ]
        },
        "cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "text": {
                    "type": "string",
                    "description": "The secret text you want to store.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "text": {
                    "type": "string",
                    "description": "The secret text you want to store.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding": {
            "properties": {
                "module": {
                    "type": "string",
                    "description": "The base64 encoded wasm module you want to store.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "module",
                "name"
            ]
        },
        "cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Allowed values: \"ip\", \"ip_range\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `198.51.100.4` or `2001:db8::/32` and IP ranges in CIDR format i.e. `198.51.0.0/16`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "binaryAst": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "brotli": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Allowed values: \"aggressive\" (default) - delivers a different resource each time the query string changes, \"basic\" - delivers resources from cache when there is no query string, \"simplified\" - delivers the same resource to everyone independent of the query string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "challengeTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFlattening": {
                    "type": "string",
                    "description": "Allowed values: \"flatten_at_root\" (default), \"flatten_all\", \"flatten_none\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "developmentMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "earlyHints": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "filterLogsToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "h2Prioritization": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"custom\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http3": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "imageResizing": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"open\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxUpload": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "description": "Allowed values: \"1.0\" (default), \"1.1\", \"1.2\", \"1.3\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minify": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingMinify:ZoneSettingsOverrideInitialSettingMinify",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingMobileRedirect:ZoneSettingsOverrideInitialSettingMobileRedirect",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticOnion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orangeToOrange": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"lossless\", \"lossy\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefetchPreload": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privacyPass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyReadTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pseudoIpv4": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"add_header\", \"overwrite_header\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingSecurityHeader:ZoneSettingsOverrideInitialSettingSecurityHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (Enterprise only), \"essentially_off\", \"low\", \"medium\" (default), \"high\", \"under_attack\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"flexible\", \"full\", \"strict\", \"origin_pull\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"on\", \"zrt\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsClientAuth": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "universalSsl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "visitorIp": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webp": {
                    "type": "string",
                    "description": ". Note that the value specified will be ignored unless `polish` is turned on (i.e. is \"lossless\" or \"lossy\")\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "websockets": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zeroRtt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "binaryAst",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "ciphers",
                        "cnameFlattening",
                        "developmentMode",
                        "earlyHints",
                        "emailObfuscation",
                        "filterLogsToCloudflare",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "logToCloudflare",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "orangeToOrange",
                        "originErrorPagePassThru",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "proxyReadTimeout",
                        "pseudoIpv4",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "visitorIp",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingMinify:ZoneSettingsOverrideInitialSettingMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingMobileRedirect:ZoneSettingsOverrideInitialSettingMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string",
                    "description": "String value\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stripUri": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingSecurityHeader:ZoneSettingsOverrideInitialSettingSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nosniff": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preload": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "binaryAst": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "brotli": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Allowed values: \"aggressive\" (default) - delivers a different resource each time the query string changes, \"basic\" - delivers resources from cache when there is no query string, \"simplified\" - delivers the same resource to everyone independent of the query string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "challengeTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFlattening": {
                    "type": "string",
                    "description": "Allowed values: \"flatten_at_root\" (default), \"flatten_all\", \"flatten_none\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "developmentMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "earlyHints": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "filterLogsToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "h2Prioritization": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"custom\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http3": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "imageResizing": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"open\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxUpload": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "description": "Allowed values: \"1.0\" (default), \"1.1\", \"1.2\", \"1.3\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minify": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticOnion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orangeToOrange": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"lossless\", \"lossy\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefetchPreload": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privacyPass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyReadTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pseudoIpv4": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"add_header\", \"overwrite_header\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (Enterprise only), \"essentially_off\", \"low\", \"medium\" (default), \"high\", \"under_attack\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"flexible\", \"full\", \"strict\", \"origin_pull\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"on\", \"zrt\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsClientAuth": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "universalSsl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "visitorIp": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webp": {
                    "type": "string",
                    "description": ". Note that the value specified will be ignored unless `polish` is turned on (i.e. is \"lossless\" or \"lossy\")\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "websockets": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zeroRtt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "binaryAst",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "ciphers",
                        "cnameFlattening",
                        "developmentMode",
                        "earlyHints",
                        "emailObfuscation",
                        "filterLogsToCloudflare",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "logToCloudflare",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "orangeToOrange",
                        "originErrorPagePassThru",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "proxyReadTimeout",
                        "pseudoIpv4",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "visitorIp",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string",
                    "description": "String value\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stripUri": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nosniff": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preload": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:index/getAccountRolesRole:getAccountRolesRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of role's permissions\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Role identifier tag\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Role Name\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafGroupsFilter:getWafGroupsFilter": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rule Groups to lookup. Valid values: on and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Groups to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafGroupsGroup:getWafGroupsGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The WAF Rule Group description\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The WAF Rule Group ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rule Groups to lookup. Valid values: on and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "modifiedRulesCount": {
                    "type": "integer",
                    "description": "The number of modified rules in the WAF Rule Group\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Groups to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package in which to search for the WAF Rule Groups.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rulesCount": {
                    "type": "integer",
                    "description": "The number of rules in the WAF Rule Group\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafPackagesFilter:getWafPackagesFilter": {
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detectionMode": {
                    "type": "string",
                    "description": "Detection mode of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivity": {
                    "type": "string",
                    "description": "Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafPackagesPackage:getWafPackagesPackage": {
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "The WAF Rule Package description\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detectionMode": {
                    "type": "string",
                    "description": "Detection mode of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The WAF Rule Package ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivity": {
                    "type": "string",
                    "description": "Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafRulesFilter:getWafRulesFilter": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A regular expression matching the description of the WAF Rules to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rules to lookup. Valid values: one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafRulesRule:getWafRulesRule": {
            "properties": {
                "allowedModes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed `mode` values for the WAF Rule\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultMode": {
                    "type": "string",
                    "description": "The default `mode` value for the WAF Rule\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "A regular expression matching the description of the WAF Rules to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupName": {
                    "type": "string",
                    "description": "The Name of the WAF Rule Group that contains the WAF Rule\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The WAF Rule ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rules to lookup. Valid values: one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package in which to search for the WAF Rules.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "string",
                    "description": "The WAF Rule priority\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZonesFilter:getZonesFilter": {
            "properties": {
                "lookupType": {
                    "type": "string",
                    "description": "The type of search to perform for the `name` value\nwhen querying the zone API. Valid values: `\"exact\"` and `\"contains\"`. Defaults\nto `\"exact\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "match": {
                    "type": "string",
                    "description": "A RE2 compatible regular expression to filter the\nresults. This is performed client side whereas the `name` and `lookup_type`\nare performed on the Cloudflare server side.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A string value to search for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "paused": {
                    "type": "boolean",
                    "description": "Paused status of the zone to lookup. Valid values are\n`true` or `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone to lookup. Valid values: `\"active\"`,\n`\"pending\"`, `\"initializing\"`, `\"moved\"`, `\"deleted\"`, `\"deactivated\"` and\n`\"read only\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZonesZone:getZonesZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The zone ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A string value to search for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the cloudflare package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use that account\n"
            },
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger)\n"
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls\n"
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls\n"
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails\n"
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API\n"
            }
        },
        "inputProperties": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use that account\n"
            },
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger)\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            }
        }
    },
    "resources": {
        "cloudflare:index/accessApplication:AccessApplication": {
            "description": "Provides a Cloudflare Access Application resource. Access Applications\nare used to restrict access to a whole application using an\nauthorisation gateway managed by Cloudflare.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// With CORS configuration\nconst stagingApp = new cloudflare.AccessApplication(\"staging_app\", {\n    corsHeaders: [{\n        allowCredentials: true,\n        allowedMethods: [\n            \"GET\",\n            \"POST\",\n            \"OPTIONS\",\n        ],\n        allowedOrigins: [\"https://example.com\"],\n        maxAge: 10,\n    }],\n    domain: \"staging.example.com\",\n    name: \"staging application\",\n    sessionDuration: \"24h\",\n    type: \"self_hosted\",\n    zoneId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# With CORS configuration\nstaging_app = cloudflare.AccessApplication(\"stagingApp\",\n    cors_headers=[cloudflare.AccessApplicationCorsHeaderArgs(\n        allow_credentials=True,\n        allowed_methods=[\n            \"GET\",\n            \"POST\",\n            \"OPTIONS\",\n        ],\n        allowed_origins=[\"https://example.com\"],\n        max_age=10,\n    )],\n    domain=\"staging.example.com\",\n    name=\"staging application\",\n    session_duration=\"24h\",\n    type=\"self_hosted\",\n    zone_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // With CORS configuration\n        var stagingApp = new Cloudflare.AccessApplication(\"stagingApp\", new Cloudflare.AccessApplicationArgs\n        {\n            CorsHeaders = \n            {\n                new Cloudflare.Inputs.AccessApplicationCorsHeaderArgs\n                {\n                    AllowCredentials = true,\n                    AllowedMethods = \n                    {\n                        \"GET\",\n                        \"POST\",\n                        \"OPTIONS\",\n                    },\n                    AllowedOrigins = \n                    {\n                        \"https://example.com\",\n                    },\n                    MaxAge = 10,\n                },\n            },\n            Domain = \"staging.example.com\",\n            Name = \"staging application\",\n            SessionDuration = \"24h\",\n            Type = \"self_hosted\",\n            ZoneId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessApplication(ctx, \"stagingApp\", \u0026cloudflare.AccessApplicationArgs{\n\t\t\tCorsHeaders: AccessApplicationCorsHeaderArray{\n\t\t\t\t\u0026AccessApplicationCorsHeaderArgs{\n\t\t\t\t\tAllowCredentials: pulumi.Bool(true),\n\t\t\t\t\tAllowedMethods: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GET\"),\n\t\t\t\t\t\tpulumi.String(\"POST\"),\n\t\t\t\t\t\tpulumi.String(\"OPTIONS\"),\n\t\t\t\t\t},\n\t\t\t\t\tAllowedOrigins: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"https://example.com\"),\n\t\t\t\t\t},\n\t\t\t\t\tMaxAge: pulumi.Int(10),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDomain:          pulumi.String(\"staging.example.com\"),\n\t\t\tName:            pulumi.String(\"staging application\"),\n\t\t\tSessionDuration: pulumi.String(\"24h\"),\n\t\t\tType:            pulumi.String(\"self_hosted\"),\n\t\t\tZoneId:          pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccess Applications can be imported using a composite ID formed of account ID and application ID.\n\n```sh\n $ pulumi import cloudflare:index/accessApplication:AccessApplication staging cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the access application should be added. Conflicts with `zone_id`.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the application\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider\nselection if only one is configured in allowed_idps. Defaults to `false`\n(disabled).\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See\nbelow for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The complete URL of the asset you wish to put\nCloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean"
                },
                "logoUrl": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to\nre-authorise. Must be in the format `\"48h\"` or `\"2h45m\"`.\nValid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`. Defaults to `24h`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Defaults to `self_hosted`. Valid\nvalues are `self_hosted`, `ssh`, `vnc`, `file` or `bookmark`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access application should be added. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "aud",
                "domain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the access application should be added. Conflicts with `zone_id`.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider\nselection if only one is configured in allowed_idps. Defaults to `false`\n(disabled).\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See\nbelow for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The complete URL of the asset you wish to put\nCloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean"
                },
                "logoUrl": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to\nre-authorise. Must be in the format `\"48h\"` or `\"2h45m\"`.\nValid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`. Defaults to `24h`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Defaults to `self_hosted`. Valid\nvalues are `self_hosted`, `ssh`, `vnc`, `file` or `bookmark`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access application should be added. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessApplication resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the access application should be added. Conflicts with `zone_id`.\n"
                    },
                    "allowedIdps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identity providers selected for the application.\n"
                    },
                    "appLauncherVisible": {
                        "type": "boolean",
                        "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the application\n"
                    },
                    "autoRedirectToIdentity": {
                        "type": "boolean",
                        "description": "Option to skip identity provider\nselection if only one is configured in allowed_idps. Defaults to `false`\n(disabled).\n"
                    },
                    "corsHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                        },
                        "description": "CORS configuration for the Access Application. See\nbelow for reference structure.\n"
                    },
                    "customDenyMessage": {
                        "type": "string",
                        "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                    },
                    "customDenyUrl": {
                        "type": "string",
                        "description": "Option that redirects to a custom URL when a user is denied access to the application.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The complete URL of the asset you wish to put\nCloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                    },
                    "enableBindingCookie": {
                        "type": "boolean",
                        "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                    },
                    "httpOnlyCookieAttribute": {
                        "type": "boolean"
                    },
                    "logoUrl": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "sameSiteCookieAttribute": {
                        "type": "string"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to\nre-authorise. Must be in the format `\"48h\"` or `\"2h45m\"`.\nValid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`. Defaults to `24h`.\n"
                    },
                    "skipInterstitial": {
                        "type": "boolean"
                    },
                    "type": {
                        "type": "string",
                        "description": "The application type. Defaults to `self_hosted`. Valid\nvalues are `self_hosted`, `ssh`, `vnc`, `file` or `bookmark`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the access application should be added. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessCaCertificate:AccessCaCertificate": {
            "description": "Cloudflare Access can replace traditional SSH key models with short-lived\ncertificates issued to your users based on the token generated by their Access\nlogin.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// account level\nconst example = new cloudflare.AccessCaCertificate(\"example\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    applicationId: \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n});\n// zone level\nconst anotherExample = new cloudflare.AccessCaCertificate(\"another_example\", {\n    applicationId: \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n    zoneId: \"b6bc7eb6027c792a6bca3dc91fd2d7e0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# account level\nexample = cloudflare.AccessCaCertificate(\"example\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    application_id=\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n# zone level\nanother_example = cloudflare.AccessCaCertificate(\"anotherExample\",\n    application_id=\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n    zone_id=\"b6bc7eb6027c792a6bca3dc91fd2d7e0\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // account level\n        var example = new Cloudflare.AccessCaCertificate(\"example\", new Cloudflare.AccessCaCertificateArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            ApplicationId = \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n        });\n        // zone level\n        var anotherExample = new Cloudflare.AccessCaCertificate(\"anotherExample\", new Cloudflare.AccessCaCertificateArgs\n        {\n            ApplicationId = \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n            ZoneId = \"b6bc7eb6027c792a6bca3dc91fd2d7e0\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessCaCertificate(ctx, \"example\", \u0026cloudflare.AccessCaCertificateArgs{\n\t\t\tAccountId:     pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tApplicationId: pulumi.String(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessCaCertificate(ctx, \"anotherExample\", \u0026cloudflare.AccessCaCertificateArgs{\n\t\t\tApplicationId: pulumi.String(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\"),\n\t\t\tZoneId:        pulumi.String(\"b6bc7eb6027c792a6bca3dc91fd2d7e0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccess CA certificates can be imported using a composite ID formed of identifer (\"account\" or \"zone\"), identifier ID and the CA certificate ID.\n\n```sh\n $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/1d5fdc9e88c8a8c4518b068cd94331fe/edc1e4e24567217764b4322669c44df985dddffdf03ac781\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the Access CA certificate should be added. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the CA certificate\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Cryptographic public key of the generated CA certificate\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Access CA certificate should be added. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "applicationId",
                "aud",
                "publicKey",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the Access CA certificate should be added. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Access CA certificate should be added. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "applicationId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessCaCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the Access CA certificate should be added. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The Access Application ID to associate with the CA certificate.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the CA certificate\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Cryptographic public key of the generated CA certificate\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the Access CA certificate should be added. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessGroup:AccessGroup": {
            "description": "Provides a Cloudflare Access Group resource. Access Groups are used\nin conjunction with Access Policies to restrict access to a\nparticular resource based on group membership.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Allowing access to `test@example.com` email address only\nconst testGroupAccessGroup = new cloudflare.AccessGroup(\"testGroupAccessGroup\", {\n    accountId: \"975ecf5a45e3bcb680dba0722a420ad9\",\n    name: \"staging group\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n});\n// Allowing `test@example.com` to access but only when coming from a\n// specific IP.\nconst testGroupIndex_accessGroupAccessGroup = new cloudflare.AccessGroup(\"testGroupIndex/accessGroupAccessGroup\", {\n    accountId: \"975ecf5a45e3bcb680dba0722a420ad9\",\n    name: \"staging group\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n    requires: {\n        ips: [_var.office_ip],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Allowing access to `test@example.com` email address only\ntest_group_access_group = cloudflare.AccessGroup(\"testGroupAccessGroup\",\n    account_id=\"975ecf5a45e3bcb680dba0722a420ad9\",\n    name=\"staging group\",\n    includes=[cloudflare.AccessGroupIncludeArgs(\n        emails=[\"test@example.com\"],\n    )])\n# Allowing `test@example.com` to access but only when coming from a\n# specific IP.\ntest_group_index_access_group_access_group = cloudflare.AccessGroup(\"testGroupIndex/accessGroupAccessGroup\",\n    account_id=\"975ecf5a45e3bcb680dba0722a420ad9\",\n    name=\"staging group\",\n    includes=[cloudflare.AccessGroupIncludeArgs(\n        emails=[\"test@example.com\"],\n    )],\n    requires={\n        \"ips\": [var[\"office_ip\"]],\n    })\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Allowing access to `test@example.com` email address only\n        var testGroupAccessGroup = new Cloudflare.AccessGroup(\"testGroupAccessGroup\", new Cloudflare.AccessGroupArgs\n        {\n            AccountId = \"975ecf5a45e3bcb680dba0722a420ad9\",\n            Name = \"staging group\",\n            Includes = \n            {\n                new Cloudflare.Inputs.AccessGroupIncludeArgs\n                {\n                    Emails = \n                    {\n                        \"test@example.com\",\n                    },\n                },\n            },\n        });\n        // Allowing `test@example.com` to access but only when coming from a\n        // specific IP.\n        var testGroupIndex_accessGroupAccessGroup = new Cloudflare.AccessGroup(\"testGroupIndex/accessGroupAccessGroup\", new Cloudflare.AccessGroupArgs\n        {\n            AccountId = \"975ecf5a45e3bcb680dba0722a420ad9\",\n            Name = \"staging group\",\n            Includes = \n            {\n                new Cloudflare.Inputs.AccessGroupIncludeArgs\n                {\n                    Emails = \n                    {\n                        \"test@example.com\",\n                    },\n                },\n            },\n            Requires = \n            {\n                { \"ips\", \n                {\n                    @var.Office_ip,\n                } },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessGroup(ctx, \"testGroupAccessGroup\", \u0026cloudflare.AccessGroupArgs{\n\t\t\tAccountId: pulumi.String(\"975ecf5a45e3bcb680dba0722a420ad9\"),\n\t\t\tName:      pulumi.String(\"staging group\"),\n\t\t\tIncludes: AccessGroupIncludeArray{\n\t\t\t\t\u0026AccessGroupIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessGroup(ctx, \"testGroupIndex_accessGroupAccessGroup\", \u0026cloudflare.AccessGroupArgs{\n\t\t\tAccountId: pulumi.String(\"975ecf5a45e3bcb680dba0722a420ad9\"),\n\t\t\tName:      pulumi.String(\"staging group\"),\n\t\t\tIncludes: AccessGroupIncludeArray{\n\t\t\t\t\u0026AccessGroupIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequires: AccessGroupRequireArray{\n\t\t\t\tIps: AccessGroupRequireArgs{\n\t\t\t\t\t_var.Office_ip,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Conditions\n\n`require`, `exclude` and `include` arguments share the available\nconditions which can be applied. The conditions are:\n\n* `ip` - (Optional) A list of IP addresses or ranges. Example:\n  `ip = [\"1.2.3.4\", \"10.0.0.0/2\"]`\n* `email` - (Optional) A list of email addresses. Example:\n  `email = [\"test@example.com\"]`\n* `email_domain` - (Optional) A list of email domains. Example:\n  `email_domain = [\"example.com\"]`\n* `service_token` - (Optional) A list of service token ids. Example:\n  `service_token = [cloudflare_access_service_token.demo.id]`\n* `any_valid_service_token` - (Optional) Boolean indicating if allow\n  all tokens to be granted. Example: `any_valid_service_token = true`\n* `group` - (Optional) A list of access group ids. Example:\n  `group = [cloudflare_access_group.demo.id]`\n* `everyone` - (Optional) Boolean indicating permitting access for all\n  requests. Example: `everyone = true`\n* `certificate` - (Optional) Whether to use mTLS certificate authentication.\n* `common_name` - (Optional) Use a certificate common name to authenticate with.\n* `auth_method` - (Optional) A string identifying the authentication\n  method code. The list of codes are listed here: https://tools.ietf.org/html/rfc8176#section-2.\n  Custom values are also supported. Example: `auth_method = [\"swk\"]`\n* `geo` - (Optional) A list of country codes. Example: `geo = [\"US\"]`\n* `login_method` - (Optional) A list of identity provider ids. Example: `login_method = [cloudflare_access_identity_provider.my_idp.id]`\n* `device_posture` - (Optional) A list of device_posture integration_uids. Example: `device_posture = [cloudflare_device_posture_rule.my_posture_rule.id]`\n* `gsuite` - (Optional) Use GSuite as the authentication mechanism. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    gsuite {\n      email = [\"admins@example.com\"]\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `github` - (Optional) Use a GitHub organization as the `include` condition. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    github {\n      name = \"my-github-org-name\" # (Required) GitHub organization name\n      teams = [\"my-github-team-name\"] # (Optional) GitHub teams\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `azure` - (Optional) Use Azure AD as the `include` condition. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    azure {\n      id = [\"86773093-5feb-48dd-814b-7ccd3676ff50e\"]\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `okta` - (Optional) Use Okta as the `include` condition. Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    okta {\n      name = [\"admins\"]\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n* `saml` - (Optional) Use an external SAML setup as the `include` condition.\n  Example:\n\n  ```hcl\n  # ... other configuration\n  include {\n    saml {\n      attribute_name = \"group\"\n      attribute_value = \"admins\"\n      identity_provider_id = \"ca298b82-93b5-41bf-bc2d-10493f09b761\"\n    }\n  }\n  ```\n\n\n## Import\n\nAccess Groups can be imported using a composite ID formed of account ID and group ID.\n\n```sh\n $ pulumi import cloudflare:index/accessGroup:AccessGroup staging 975ecf5a45e3bcb680dba0722a420ad9/67ea780ce4982c1cfbe6b7293afc765d\n```\n\n where * `975ecf5a45e3bcb680dba0722a420ad9` - Account ID * `67ea780ce4982c1cfbe6b7293afc765d` - Access Group ID ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account the group is associated with. Conflicts with `zone_id`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the zone the group is associated with. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "includes",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account the group is associated with. Conflicts with `zone_id`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Group.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                    },
                    "description": "A series of access conditions, see below for\nfull list.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the zone the group is associated with. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessGroup resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account the group is associated with. Conflicts with `zone_id`.\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                        },
                        "description": "A series of access conditions, see below for\nfull list.\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                        },
                        "description": "A series of access conditions, see below for\nfull list.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Group.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                        },
                        "description": "A series of access conditions, see below for\nfull list.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the zone the group is associated with. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessIdentityProvider:AccessIdentityProvider": {
            "description": "Provides a Cloudflare Access Identity Provider resource. Identity Providers are\nused as an authentication or authorisation source within Access.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// one time pin\nconst pinLogin = new cloudflare.AccessIdentityProvider(\"pin_login\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name: \"PIN login\",\n    type: \"onetimepin\",\n});\n// oauth\nconst githubOauth = new cloudflare.AccessIdentityProvider(\"github_oauth\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n    }],\n    name: \"GitHub OAuth\",\n    type: \"github\",\n});\n// saml\nconst jumpcloudSaml = new cloudflare.AccessIdentityProvider(\"jumpcloud_saml\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs: [{\n        attributes: [\n            \"email\",\n            \"username\",\n        ],\n        idpPublicCert: `MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o`,\n        issuerUrl: \"jumpcloud\",\n        signRequest: false,\n        ssoTargetUrl: \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n    }],\n    name: \"JumpCloud SAML\",\n    type: \"saml\",\n});\n// okta\nconst okta = new cloudflare.AccessIdentityProvider(\"okta\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs: [{\n        apiToken: \"okta_api_token\",\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n    }],\n    name: \"Okta\",\n    type: \"okta\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# one time pin\npin_login = cloudflare.AccessIdentityProvider(\"pinLogin\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name=\"PIN login\",\n    type=\"onetimepin\")\n# oauth\ngithub_oauth = cloudflare.AccessIdentityProvider(\"githubOauth\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs=[cloudflare.AccessIdentityProviderConfigArgs(\n        client_id=\"example\",\n        client_secret=\"secret_key\",\n    )],\n    name=\"GitHub OAuth\",\n    type=\"github\")\n# saml\njumpcloud_saml = cloudflare.AccessIdentityProvider(\"jumpcloudSaml\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs=[cloudflare.AccessIdentityProviderConfigArgs(\n        attributes=[\n            \"email\",\n            \"username\",\n        ],\n        idp_public_cert=\"\"\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n\"\"\",\n        issuer_url=\"jumpcloud\",\n        sign_request=False,\n        sso_target_url=\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n    )],\n    name=\"JumpCloud SAML\",\n    type=\"saml\")\n# okta\nokta = cloudflare.AccessIdentityProvider(\"okta\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs=[cloudflare.AccessIdentityProviderConfigArgs(\n        api_token=\"okta_api_token\",\n        client_id=\"example\",\n        client_secret=\"secret_key\",\n    )],\n    name=\"Okta\",\n    type=\"okta\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // one time pin\n        var pinLogin = new Cloudflare.AccessIdentityProvider(\"pinLogin\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Name = \"PIN login\",\n            Type = \"onetimepin\",\n        });\n        // oauth\n        var githubOauth = new Cloudflare.AccessIdentityProvider(\"githubOauth\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Configs = \n            {\n                new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n                {\n                    ClientId = \"example\",\n                    ClientSecret = \"secret_key\",\n                },\n            },\n            Name = \"GitHub OAuth\",\n            Type = \"github\",\n        });\n        // saml\n        var jumpcloudSaml = new Cloudflare.AccessIdentityProvider(\"jumpcloudSaml\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Configs = \n            {\n                new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n                {\n                    Attributes = \n                    {\n                        \"email\",\n                        \"username\",\n                    },\n                    IdpPublicCert = @\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n\",\n                    IssuerUrl = \"jumpcloud\",\n                    SignRequest = false,\n                    SsoTargetUrl = \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n                },\n            },\n            Name = \"JumpCloud SAML\",\n            Type = \"saml\",\n        });\n        // okta\n        var okta = new Cloudflare.AccessIdentityProvider(\"okta\", new Cloudflare.AccessIdentityProviderArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Configs = \n            {\n                new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n                {\n                    ApiToken = \"okta_api_token\",\n                    ClientId = \"example\",\n                    ClientSecret = \"secret_key\",\n                },\n            },\n            Name = \"Okta\",\n            Type = \"okta\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessIdentityProvider(ctx, \"pinLogin\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tName:      pulumi.String(\"PIN login\"),\n\t\t\tType:      pulumi.String(\"onetimepin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"githubOauth\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tConfigs: AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026AccessIdentityProviderConfigArgs{\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"GitHub OAuth\"),\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"jumpcloudSaml\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tConfigs: AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026AccessIdentityProviderConfigArgs{\n\t\t\t\t\tAttributes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"email\"),\n\t\t\t\t\t\tpulumi.String(\"username\"),\n\t\t\t\t\t},\n\t\t\t\t\tIdpPublicCert: pulumi.String(fmt.Sprintf(\"%v%v\", \"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\\n\", \"uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\\n\")),\n\t\t\t\t\tIssuerUrl:     pulumi.String(\"jumpcloud\"),\n\t\t\t\t\tSignRequest:   pulumi.Bool(false),\n\t\t\t\t\tSsoTargetUrl:  pulumi.String(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"JumpCloud SAML\"),\n\t\t\tType: pulumi.String(\"saml\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"okta\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tConfigs: AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026AccessIdentityProviderConfigArgs{\n\t\t\t\t\tApiToken:     pulumi.String(\"okta_api_token\"),\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"Okta\"),\n\t\t\tType: pulumi.String(\"okta\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nPlease refer to the [developers.cloudflare.com Access documentation][access_identity_provider_guide]\nfor full reference on what is available and how to configure your provider.\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccess Identity Providers can be imported using a composite ID formed of account ID and Access Identity Provider ID.\n\n```sh\n $ pulumi import cloudflare:index/accessIdentityProvider:AccessIdentityProvider my_idp cb029e245cfdd66dc8d2e570d5dd3322/e00e1c13-e350-44fe-96c5-fb75c954871c\n```\n\n [access_identity_provider_guide]https://developers.cloudflare.com/access/configuring-identity-providers/ ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID the provider should be associated with. Conflicts with `zone_id`.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation][access_identity_provider_guide].\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Must be one of: `\"centrify\"`,\n`\"facebook\"`, `\"google-apps\"`, `\"oidc\"`, `\"github\"`, `\"google\"`, `\"saml\"`,\n`\"linkedin\"`, `\"azureAD\"`, `\"okta\"`, `\"onetimepin\"`, `\"onelogin\"`, `\"yandex\"`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID the provider should be associated with. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID the provider should be associated with. Conflicts with `zone_id`.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation][access_identity_provider_guide].\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Must be one of: `\"centrify\"`,\n`\"facebook\"`, `\"google-apps\"`, `\"oidc\"`, `\"github\"`, `\"google\"`, `\"saml\"`,\n`\"linkedin\"`, `\"azureAD\"`, `\"okta\"`, `\"onetimepin\"`, `\"onelogin\"`, `\"yandex\"`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID the provider should be associated with. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessIdentityProvider resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID the provider should be associated with. Conflicts with `zone_id`.\n"
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                        },
                        "description": "Provider configuration from the [developer documentation][access_identity_provider_guide].\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Identity Provider configuration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The provider type to use. Must be one of: `\"centrify\"`,\n`\"facebook\"`, `\"google-apps\"`, `\"oidc\"`, `\"github\"`, `\"google\"`, `\"saml\"`,\n`\"linkedin\"`, `\"azureAD\"`, `\"okta\"`, `\"onetimepin\"`, `\"onelogin\"`, `\"yandex\"`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID the provider should be associated with. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessKeysConfiguration:AccessKeysConfiguration": {
            "properties": {
                "accountId": {
                    "type": "string"
                },
                "keyRotationIntervalDays": {
                    "type": "integer"
                }
            },
            "required": [
                "accountId",
                "keyRotationIntervalDays"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string"
                },
                "keyRotationIntervalDays": {
                    "type": "integer"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessKeysConfiguration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "keyRotationIntervalDays": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate": {
            "description": "Provides a Cloudflare Access Mutual TLS Certificate resource. Mutual TLS authentication ensures that the traffic is secure and trusted in both directions between a client and server and can be used with Access to only allows requests from devices with a corresponding client certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myCert = new cloudflare.AccessMutualTlsCertificate(\"myCert\", {\n    zoneId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name: \"My Root Cert\",\n    certificate: _var.ca_pem,\n    associatedHostnames: [\"staging.example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_cert = cloudflare.AccessMutualTlsCertificate(\"myCert\",\n    zone_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name=\"My Root Cert\",\n    certificate=var[\"ca_pem\"],\n    associated_hostnames=[\"staging.example.com\"])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var myCert = new Cloudflare.AccessMutualTlsCertificate(\"myCert\", new Cloudflare.AccessMutualTlsCertificateArgs\n        {\n            ZoneId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Name = \"My Root Cert\",\n            Certificate = @var.Ca_pem,\n            AssociatedHostnames = \n            {\n                \"staging.example.com\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessMutualTlsCertificate(ctx, \"myCert\", \u0026cloudflare.AccessMutualTlsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tName:        pulumi.String(\"My Root Cert\"),\n\t\t\tCertificate: pulumi.Any(_var.Ca_pem),\n\t\t\tAssociatedHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"staging.example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccess Mutual TLS Certificate can be imported using a composite ID composed of the account or zone and the mutual TLS certificate ID in the form of`account/ACCOUNT_ID/MUTUAL_TLS_CERTIFICATE_ID` or `zone/ZONE_ID/MUTUAL_TLS_CERTIFICATE_ID`.\n\n```sh\n $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate staging account/cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the certificate should be added. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "fingerprint": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the certificate should be added. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "fingerprint",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the certificate should be added. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the certificate should be added. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessMutualTlsCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the certificate should be added. Conflicts with `zone_id`.\n"
                    },
                    "associatedHostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames that will be prompted for this certificate.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The Root CA for your certificates.\n"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the certificate should be added. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessPolicy:AccessPolicy": {
            "description": "Provides a Cloudflare Access Policy resource. Access Policies are used\nin conjunction with Access Applications to restrict access to a\nparticular resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Allowing access to `test@example.com` email address only\nconst testPolicyAccessPolicy = new cloudflare.AccessPolicy(\"testPolicyAccessPolicy\", {\n    applicationId: \"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"staging policy\",\n    precedence: \"1\",\n    decision: \"allow\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n    requires: [{\n        emails: [\"test@example.com\"],\n    }],\n});\n// Allowing `test@example.com` to access but only when coming from a\n// specific IP.\nconst testPolicyIndex_accessPolicyAccessPolicy = new cloudflare.AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\", {\n    applicationId: \"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"staging policy\",\n    precedence: \"1\",\n    decision: \"allow\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n    requires: [{\n        ips: [_var.office_ip],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Allowing access to `test@example.com` email address only\ntest_policy_access_policy = cloudflare.AccessPolicy(\"testPolicyAccessPolicy\",\n    application_id=\"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"staging policy\",\n    precedence=1,\n    decision=\"allow\",\n    includes=[cloudflare.AccessPolicyIncludeArgs(\n        emails=[\"test@example.com\"],\n    )],\n    requires=[cloudflare.AccessPolicyRequireArgs(\n        emails=[\"test@example.com\"],\n    )])\n# Allowing `test@example.com` to access but only when coming from a\n# specific IP.\ntest_policy_index_access_policy_access_policy = cloudflare.AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\",\n    application_id=\"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"staging policy\",\n    precedence=1,\n    decision=\"allow\",\n    includes=[cloudflare.AccessPolicyIncludeArgs(\n        emails=[\"test@example.com\"],\n    )],\n    requires=[cloudflare.AccessPolicyRequireArgs(\n        ips=[var[\"office_ip\"]],\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Allowing access to `test@example.com` email address only\n        var testPolicyAccessPolicy = new Cloudflare.AccessPolicy(\"testPolicyAccessPolicy\", new Cloudflare.AccessPolicyArgs\n        {\n            ApplicationId = \"cb029e245cfdd66dc8d2e570d5dd3322\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Name = \"staging policy\",\n            Precedence = 1,\n            Decision = \"allow\",\n            Includes = \n            {\n                new Cloudflare.Inputs.AccessPolicyIncludeArgs\n                {\n                    Emails = \n                    {\n                        \"test@example.com\",\n                    },\n                },\n            },\n            Requires = \n            {\n                new Cloudflare.Inputs.AccessPolicyRequireArgs\n                {\n                    Emails = \n                    {\n                        \"test@example.com\",\n                    },\n                },\n            },\n        });\n        // Allowing `test@example.com` to access but only when coming from a\n        // specific IP.\n        var testPolicyIndex_accessPolicyAccessPolicy = new Cloudflare.AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\", new Cloudflare.AccessPolicyArgs\n        {\n            ApplicationId = \"cb029e245cfdd66dc8d2e570d5dd3322\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Name = \"staging policy\",\n            Precedence = 1,\n            Decision = \"allow\",\n            Includes = \n            {\n                new Cloudflare.Inputs.AccessPolicyIncludeArgs\n                {\n                    Emails = \n                    {\n                        \"test@example.com\",\n                    },\n                },\n            },\n            Requires = \n            {\n                new Cloudflare.Inputs.AccessPolicyRequireArgs\n                {\n                    Ips = \n                    {\n                        @var.Office_ip,\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessPolicy(ctx, \"testPolicyAccessPolicy\", \u0026cloudflare.AccessPolicyArgs{\n\t\t\tApplicationId: pulumi.String(\"cb029e245cfdd66dc8d2e570d5dd3322\"),\n\t\t\tZoneId:        pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:          pulumi.String(\"staging policy\"),\n\t\t\tPrecedence:    pulumi.Int(1),\n\t\t\tDecision:      pulumi.String(\"allow\"),\n\t\t\tIncludes: AccessPolicyIncludeArray{\n\t\t\t\t\u0026AccessPolicyIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequires: AccessPolicyRequireArray{\n\t\t\t\t\u0026AccessPolicyRequireArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessPolicy(ctx, \"testPolicyIndex_accessPolicyAccessPolicy\", \u0026cloudflare.AccessPolicyArgs{\n\t\t\tApplicationId: pulumi.String(\"cb029e245cfdd66dc8d2e570d5dd3322\"),\n\t\t\tZoneId:        pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:          pulumi.String(\"staging policy\"),\n\t\t\tPrecedence:    pulumi.Int(1),\n\t\t\tDecision:      pulumi.String(\"allow\"),\n\t\t\tIncludes: AccessPolicyIncludeArray{\n\t\t\t\t\u0026AccessPolicyIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequires: AccessPolicyRequireArray{\n\t\t\t\t\u0026AccessPolicyRequireArgs{\n\t\t\t\t\tIps: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.Any(_var.Office_ip),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccess Policies can be imported using a composite ID formed of identifier type (`zone` or `account`), identifier ID (`zone_id` or `account_id`), application ID and policy ID. # import a zone level Access policy\n\n```sh\n $ pulumi import cloudflare:index/accessPolicy:AccessPolicy staging zone/cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e/67ea780ce4982c1cfbe6b7293afc765d\n```\n\n # import an account level Access policy\n\n```sh\n $ pulumi import cloudflare:index/accessPolicy:AccessPolicy production account/0d599f0ec05c3bda8c3b8a68c32a1b47/d41d8cd98f00b204e9800998ecf8427e/67ea780ce4982c1cfbe6b7293afc765d\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the access rule should be added. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with.\n"
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                    },
                    "description": "List of approval group blocks for configuring additional approvals (refer to the nested schema).\n"
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user.\nAllowed values: `allow`, `deny`, `non_identity`, `bypass`\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Integer.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "String to present to the user when purpose justification is enabled.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Boolean of whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "applicationId",
                "decision",
                "includes",
                "name",
                "precedence",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the access rule should be added. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with.\n"
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                    },
                    "description": "List of approval group blocks for configuring additional approvals (refer to the nested schema).\n"
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user.\nAllowed values: `allow`, `deny`, `non_identity`, `bypass`\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application. Integer.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "String to present to the user when purpose justification is enabled.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Boolean of whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "applicationId",
                "decision",
                "includes",
                "name",
                "precedence"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the access rule should be added. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The ID of the application the policy is associated with.\n"
                    },
                    "approvalGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                        },
                        "description": "List of approval group blocks for configuring additional approvals (refer to the nested schema).\n"
                    },
                    "approvalRequired": {
                        "type": "boolean"
                    },
                    "decision": {
                        "type": "string",
                        "description": "Defines the action Access will take if the policy matches the user.\nAllowed values: `allow`, `deny`, `non_identity`, `bypass`\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                        },
                        "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                        },
                        "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The unique precedence for policies on a single application. Integer.\n"
                    },
                    "purposeJustificationPrompt": {
                        "type": "string",
                        "description": "String to present to the user when purpose justification is enabled.\n"
                    },
                    "purposeJustificationRequired": {
                        "type": "boolean",
                        "description": "Boolean of whether to prompt the user for a justification for accessing the resource.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                        },
                        "description": "A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the access rule should be added. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessRule:AccessRule": {
            "description": "Provides a Cloudflare IP Firewall Access Rule resource. Access control can be applied on basis of IP addresses, IP ranges, AS numbers or countries.\n\n\n## Import\n\nRecords can be imported using a composite ID formed of access rule type, access rule type identifier and identifer value, e.g.\n\n```sh\n $ pulumi import cloudflare:index/accessRule:AccessRule default zone/cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n where* `zone` - access rule type (`account`, `zone` or `user`) * `cb029e245cfdd66dc8d2e570d5dd3322` - access rule type ID (i.e the zone ID\n\n or account ID you wish to target) * `d41d8cd98f00b204e9800998ecf8427e` - access rule ID as returned by\n\n respective API endpoint for the type you are attempting to import. ",
            "properties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. It's a complex value. See description below.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"whitelist\", \"js_challenge\"\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added.\n"
                }
            },
            "required": [
                "configuration",
                "mode",
                "zoneId"
            ],
            "inputProperties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. It's a complex value. See description below.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"whitelist\", \"js_challenge\"\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the access rule should be added.\n"
                }
            },
            "requiredInputs": [
                "configuration",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessRule resources.\n",
                "properties": {
                    "configuration": {
                        "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                        "description": "Rule configuration to apply to a matched request. It's a complex value. See description below.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"whitelist\", \"js_challenge\"\n"
                    },
                    "notes": {
                        "type": "string",
                        "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the access rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessServiceToken:AccessServiceToken": {
            "description": "Access Service Tokens are used for service-to-service communication\nwhen an application is behind Cloudflare Access.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Generate a service token that will renew if terraform is ran within 30 days of expiration\nconst myApp = new cloudflare.AccessServiceToken(\"my_app\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    minDaysForRenewal: 30,\n    name: \"CI/CD app renewed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Generate a service token that will renew if terraform is ran within 30 days of expiration\nmy_app = cloudflare.AccessServiceToken(\"myApp\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    min_days_for_renewal=30,\n    name=\"CI/CD app renewed\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Generate a service token that will renew if terraform is ran within 30 days of expiration\n        var myApp = new Cloudflare.AccessServiceToken(\"myApp\", new Cloudflare.AccessServiceTokenArgs\n        {\n            AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            MinDaysForRenewal = 30,\n            Name = \"CI/CD app renewed\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessServiceToken(ctx, \"myApp\", \u0026cloudflare.AccessServiceTokenArgs{\n\t\t\tAccountId:         pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tMinDaysForRenewal: pulumi.Int(30),\n\t\t\tName:              pulumi.String(\"CI/CD app renewed\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n~\u003e **Important:** If you are importing an Access Service Token you will not have the `client_secret` available in the state for use. The `client_secret` is only available once, at creation. In most cases, it is better to just create a new resource should you need to reference it in other resources. Access Service Tokens can be imported using a composite ID formed of account ID and Service Token ID.\n\n```sh\n $ pulumi import cloudflare:index/accessServiceToken:AccessServiceToken my_app cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n where * `cb029e245cfdd66dc8d2e570d5dd3322` - Account ID * `d41d8cd98f00b204e9800998ecf8427e` - Access Service Token ID ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the Access Service is being created. Conflicts with `zone_id`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "UUID client ID associated with the Service Token.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "A secret for interacting with Access protocols.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Date when the token expires\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the zone where the Access Service is being created. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "clientId",
                "clientSecret",
                "expiresAt",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the Access Service is being created. Conflicts with `zone_id`.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the zone where the Access Service is being created. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessServiceToken resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the Access Service is being created. Conflicts with `zone_id`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "UUID client ID associated with the Service Token.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "A secret for interacting with Access protocols.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Date when the token expires\n"
                    },
                    "minDaysForRenewal": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the token's intent.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the zone where the Access Service is being created. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accountMember:AccountMember": {
            "description": "Provides a resource which manages Cloudflare account members.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleUser = new cloudflare.AccountMember(\"example_user\", {\n    emailAddress: \"user@example.com\",\n    roleIds: [\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_user = cloudflare.AccountMember(\"exampleUser\",\n    email_address=\"user@example.com\",\n    role_ids=[\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleUser = new Cloudflare.AccountMember(\"exampleUser\", new Cloudflare.AccountMemberArgs\n        {\n            EmailAddress = \"user@example.com\",\n            RoleIds = \n            {\n                \"68b329da9893e34099c7d8ad5cb9c940\",\n                \"d784fa8b6d98d27699781bd9a7cf19f0\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccountMember(ctx, \"exampleUser\", \u0026cloudflare.AccountMemberArgs{\n\t\t\tEmailAddress: pulumi.String(\"user@example.com\"),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"68b329da9893e34099c7d8ad5cb9c940\"),\n\t\t\t\tpulumi.String(\"d784fa8b6d98d27699781bd9a7cf19f0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccount members can be imported using a composite ID formed of account ID and account member ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/accountMember:AccountMember example_user d41d8cd98f00b204e9800998ecf8427e/b58c6f14d292556214bd64909bcdb118\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - account ID as returned by the [API](https://api.cloudflare.com/#accounts-account-details) * `b58c6f14d292556214bd64909bcdb118` - account member ID as returned by the [API](https://api.cloudflare.com/#account-members-member-details) ",
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Note: Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of account role IDs that you want to assign to a member.\n"
                }
            },
            "required": [
                "emailAddress",
                "roleIds"
            ],
            "inputProperties": {
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Note: Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of account role IDs that you want to assign to a member.\n"
                }
            },
            "requiredInputs": [
                "emailAddress",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountMember resources.\n",
                "properties": {
                    "emailAddress": {
                        "type": "string",
                        "description": "The email address of the user who you wish to manage. Note: Following creation, this field becomes read only via the API and cannot be updated.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of account role IDs that you want to assign to a member.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiToken:ApiToken": {
            "description": "Provides a resource which manages Cloudflare API tokens.\n\nRead more about permission groups and their applicable scopes in\n[the official documentation](https://developers.cloudflare.com/api/tokens/create/permissions).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### User Permissions\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst all = cloudflare.getApiTokenPermissionGroups({});\n// Token allowed to create new tokens.\n// Can only be used from specific ip range.\nconst apiTokenCreate = new cloudflare.ApiToken(\"apiTokenCreate\", {\n    name: \"api_token_create\",\n    policies: [{\n        permissionGroups: [all.then(all =\u003e all.permissions?[\"API Tokens Write\"])],\n        resources: {\n            `com.cloudflare.api.user.${_var.user_id}`: \"*\",\n        },\n    }],\n    condition: {\n        requestIp: {\n            ins: [\"192.0.2.1/32\"],\n            notIns: [\"198.51.100.1/32\"],\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nall = cloudflare.get_api_token_permission_groups()\n# Token allowed to create new tokens.\n# Can only be used from specific ip range.\napi_token_create = cloudflare.ApiToken(\"apiTokenCreate\",\n    name=\"api_token_create\",\n    policies=[cloudflare.ApiTokenPolicyArgs(\n        permission_groups=[all.permissions[\"API Tokens Write\"]],\n        resources={\n            f\"com.cloudflare.api.user.{var['user_id']}\": \"*\",\n        },\n    )],\n    condition=cloudflare.ApiTokenConditionArgs(\n        request_ip=cloudflare.ApiTokenConditionRequestIpArgs(\n            ins=[\"192.0.2.1/32\"],\n            not_ins=[\"198.51.100.1/32\"],\n        ),\n    ))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var all = Output.Create(Cloudflare.GetApiTokenPermissionGroups.InvokeAsync());\n        // Token allowed to create new tokens.\n        // Can only be used from specific ip range.\n        var apiTokenCreate = new Cloudflare.ApiToken(\"apiTokenCreate\", new Cloudflare.ApiTokenArgs\n        {\n            Name = \"api_token_create\",\n            Policies = \n            {\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.API_Tokens_Write),\n                    },\n                    Resources = \n                    {\n                        { $\"com.cloudflare.api.user.{@var.User_id}\", \"*\" },\n                    },\n                },\n            },\n            Condition = new Cloudflare.Inputs.ApiTokenConditionArgs\n            {\n                RequestIp = new Cloudflare.Inputs.ApiTokenConditionRequestIpArgs\n                {\n                    Ins = \n                    {\n                        \"192.0.2.1/32\",\n                    },\n                    NotIns = \n                    {\n                        \"198.51.100.1/32\",\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% example %}}\n### Account permissions\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst all = cloudflare.getApiTokenPermissionGroups({});\n// Token allowed to read audit logs from all accounts.\nconst logsAccountAll = new cloudflare.ApiToken(\"logsAccountAll\", {\n    name: \"logs_account_all\",\n    policies: [{\n        permissionGroups: [all.then(all =\u003e all.permissions?[\"Access: Audit Logs Read\"])],\n        resources: {\n            \"com.cloudflare.api.account.*\": \"*\",\n        },\n    }],\n});\n// Token allowed to read audit logs from specific account.\nconst logsAccount = new cloudflare.ApiToken(\"logsAccount\", {\n    name: \"logs_account\",\n    policies: [{\n        permissionGroups: [all.then(all =\u003e all.permissions?[\"Access: Audit Logs Read\"])],\n        resources: {\n            `com.cloudflare.api.account.${_var.account_id}`: \"*\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nall = cloudflare.get_api_token_permission_groups()\n# Token allowed to read audit logs from all accounts.\nlogs_account_all = cloudflare.ApiToken(\"logsAccountAll\",\n    name=\"logs_account_all\",\n    policies=[cloudflare.ApiTokenPolicyArgs(\n        permission_groups=[all.permissions[\"Access: Audit Logs Read\"]],\n        resources={\n            \"com.cloudflare.api.account.*\": \"*\",\n        },\n    )])\n# Token allowed to read audit logs from specific account.\nlogs_account = cloudflare.ApiToken(\"logsAccount\",\n    name=\"logs_account\",\n    policies=[cloudflare.ApiTokenPolicyArgs(\n        permission_groups=[all.permissions[\"Access: Audit Logs Read\"]],\n        resources={\n            f\"com.cloudflare.api.account.{var['account_id']}\": \"*\",\n        },\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var all = Output.Create(Cloudflare.GetApiTokenPermissionGroups.InvokeAsync());\n        // Token allowed to read audit logs from all accounts.\n        var logsAccountAll = new Cloudflare.ApiToken(\"logsAccountAll\", new Cloudflare.ApiTokenArgs\n        {\n            Name = \"logs_account_all\",\n            Policies = \n            {\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.Access__Audit_Logs_Read),\n                    },\n                    Resources = \n                    {\n                        { \"com.cloudflare.api.account.*\", \"*\" },\n                    },\n                },\n            },\n        });\n        // Token allowed to read audit logs from specific account.\n        var logsAccount = new Cloudflare.ApiToken(\"logsAccount\", new Cloudflare.ApiTokenArgs\n        {\n            Name = \"logs_account\",\n            Policies = \n            {\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.Access__Audit_Logs_Read),\n                    },\n                    Resources = \n                    {\n                        { $\"com.cloudflare.api.account.{@var.Account_id}\", \"*\" },\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% example %}}\n### Zone Permissions\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst all = cloudflare.getApiTokenPermissionGroups({});\n// Token allowed to edit DNS entries and TLS certs for specific zone.\nconst dnsTlsEdit = new cloudflare.ApiToken(\"dnsTlsEdit\", {\n    name: \"dns_tls_edit\",\n    policies: [{\n        permissionGroups: [\n            all.then(all =\u003e all.permissions?[\"DNS Write\"]),\n            all.then(all =\u003e all.permissions?[\"SSL and Certificates Write\"]),\n        ],\n        resources: {\n            `com.cloudflare.api.account.zone.${_var.zone_id}`: \"*\",\n        },\n    }],\n});\n// Token allowed to edit DNS entries for all zones except one.\nconst dnsTlsEditAllExceptOne = new cloudflare.ApiToken(\"dnsTlsEditAllExceptOne\", {\n    name: \"dns_tls_edit_all_except_one\",\n    policies: [\n        {\n            permissionGroups: [all.then(all =\u003e all.permissions?[\"DNS Write\"])],\n            resources: {\n                \"com.cloudflare.api.account.zone.*\": \"*\",\n            },\n        },\n        {\n            permissionGroups: [all.then(all =\u003e all.permissions?[\"DNS Write\"])],\n            resources: {\n                `com.cloudflare.api.account.zone.${_var.zone_id}`: \"*\",\n            },\n            effect: \"deny\",\n        },\n    ],\n});\n// Token allowed to edit DNS entries for all zones from specific account.\nconst dnsEditAllAccount = new cloudflare.ApiToken(\"dnsEditAllAccount\", {\n    name: \"dns_edit_all_account\",\n    policies: [{\n        permissionGroups: [all.then(all =\u003e all.permissions?[\"DNS Write\"])],\n        resources: {\n            `com.cloudflare.api.account.${_var.account_id}`: JSON.stringify({\n                \"com.cloudflare.api.account.zone.*\": \"*\",\n            }),\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_cloudflare as cloudflare\n\nall = cloudflare.get_api_token_permission_groups()\n# Token allowed to edit DNS entries and TLS certs for specific zone.\ndns_tls_edit = cloudflare.ApiToken(\"dnsTlsEdit\",\n    name=\"dns_tls_edit\",\n    policies=[cloudflare.ApiTokenPolicyArgs(\n        permission_groups=[\n            all.permissions[\"DNS Write\"],\n            all.permissions[\"SSL and Certificates Write\"],\n        ],\n        resources={\n            f\"com.cloudflare.api.account.zone.{var['zone_id']}\": \"*\",\n        },\n    )])\n# Token allowed to edit DNS entries for all zones except one.\ndns_tls_edit_all_except_one = cloudflare.ApiToken(\"dnsTlsEditAllExceptOne\",\n    name=\"dns_tls_edit_all_except_one\",\n    policies=[\n        cloudflare.ApiTokenPolicyArgs(\n            permission_groups=[all.permissions[\"DNS Write\"]],\n            resources={\n                \"com.cloudflare.api.account.zone.*\": \"*\",\n            },\n        ),\n        cloudflare.ApiTokenPolicyArgs(\n            permission_groups=[all.permissions[\"DNS Write\"]],\n            resources={\n                f\"com.cloudflare.api.account.zone.{var['zone_id']}\": \"*\",\n            },\n            effect=\"deny\",\n        ),\n    ])\n# Token allowed to edit DNS entries for all zones from specific account.\ndns_edit_all_account = cloudflare.ApiToken(\"dnsEditAllAccount\",\n    name=\"dns_edit_all_account\",\n    policies=[cloudflare.ApiTokenPolicyArgs(\n        permission_groups=[all.permissions[\"DNS Write\"]],\n        resources={\n            f\"com.cloudflare.api.account.{var['account_id']}\": json.dumps({\n                \"com.cloudflare.api.account.zone.*\": \"*\",\n            }),\n        },\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var all = Output.Create(Cloudflare.GetApiTokenPermissionGroups.InvokeAsync());\n        // Token allowed to edit DNS entries and TLS certs for specific zone.\n        var dnsTlsEdit = new Cloudflare.ApiToken(\"dnsTlsEdit\", new Cloudflare.ApiTokenArgs\n        {\n            Name = \"dns_tls_edit\",\n            Policies = \n            {\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.DNS_Write),\n                        all.Apply(all =\u003e all.Permissions?.SSL_and_Certificates_Write),\n                    },\n                    Resources = \n                    {\n                        { $\"com.cloudflare.api.account.zone.{@var.Zone_id}\", \"*\" },\n                    },\n                },\n            },\n        });\n        // Token allowed to edit DNS entries for all zones except one.\n        var dnsTlsEditAllExceptOne = new Cloudflare.ApiToken(\"dnsTlsEditAllExceptOne\", new Cloudflare.ApiTokenArgs\n        {\n            Name = \"dns_tls_edit_all_except_one\",\n            Policies = \n            {\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.DNS_Write),\n                    },\n                    Resources = \n                    {\n                        { \"com.cloudflare.api.account.zone.*\", \"*\" },\n                    },\n                },\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.DNS_Write),\n                    },\n                    Resources = \n                    {\n                        { $\"com.cloudflare.api.account.zone.{@var.Zone_id}\", \"*\" },\n                    },\n                    Effect = \"deny\",\n                },\n            },\n        });\n        // Token allowed to edit DNS entries for all zones from specific account.\n        var dnsEditAllAccount = new Cloudflare.ApiToken(\"dnsEditAllAccount\", new Cloudflare.ApiTokenArgs\n        {\n            Name = \"dns_edit_all_account\",\n            Policies = \n            {\n                new Cloudflare.Inputs.ApiTokenPolicyArgs\n                {\n                    PermissionGroups = \n                    {\n                        all.Apply(all =\u003e all.Permissions?.DNS_Write),\n                    },\n                    Resources = \n                    {\n                        { $\"com.cloudflare.api.account.{@var.Account_id}\", JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n                        {\n                            { \"com.cloudflare.api.account.zone.*\", \"*\" },\n                        }) },\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "condition": {
                    "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                    "description": "Condition block. See the definition below.\n"
                },
                "issuedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the API Token was issued.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the API Token was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the APIToken.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                    },
                    "description": "Permissions policy. Multiple policy blocks can be defined.\nSee the definition below.\n"
                },
                "status": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the API Token.\n"
                }
            },
            "required": [
                "issuedOn",
                "modifiedOn",
                "name",
                "policies",
                "status",
                "value"
            ],
            "inputProperties": {
                "condition": {
                    "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                    "description": "Condition block. See the definition below.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the APIToken.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                    },
                    "description": "Permissions policy. Multiple policy blocks can be defined.\nSee the definition below.\n"
                }
            },
            "requiredInputs": [
                "name",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiToken resources.\n",
                "properties": {
                    "condition": {
                        "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                        "description": "Condition block. See the definition below.\n"
                    },
                    "issuedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the API Token was issued.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the API Token was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the APIToken.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                        },
                        "description": "Permissions policy. Multiple policy blocks can be defined.\nSee the definition below.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the API Token.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/argo:Argo": {
            "description": "Cloudflare Argo controls the routing to your origin and tiered caching options to speed up your website browsing experience.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Argo(\"example\", {\n    smartRouting: \"on\",\n    tieredCaching: \"on\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Argo(\"example\",\n    smart_routing=\"on\",\n    tiered_caching=\"on\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.Argo(\"example\", new Cloudflare.ArgoArgs\n        {\n            SmartRouting = \"on\",\n            TieredCaching = \"on\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewArgo(ctx, \"example\", \u0026cloudflare.ArgoArgs{\n\t\t\tSmartRouting:  pulumi.String(\"on\"),\n\t\t\tTieredCaching: pulumi.String(\"on\"),\n\t\t\tZoneId:        pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nArgo settings can be imported the zone ID.\n\n```sh\n $ pulumi import cloudflare:index/argo:Argo example d41d8cd98f00b204e9800998ecf8427e\n```\n\n where `d41d8cd98f00b204e9800998ecf8427e` is the zone ID. ",
            "properties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Valid values: `on` or `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Valid values: `on` or `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID that you wish to manage Argo on.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Valid values: `on` or `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Valid values: `on` or `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID that you wish to manage Argo on.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Argo resources.\n",
                "properties": {
                    "smartRouting": {
                        "type": "string",
                        "description": "Whether smart routing is enabled. Valid values: `on` or `off`.\n"
                    },
                    "tieredCaching": {
                        "type": "string",
                        "description": "Whether tiered caching is enabled. Valid values: `on` or `off`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID that you wish to manage Argo on.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/argoTunnel:ArgoTunnel": {
            "description": "Argo Tunnel exposes applications running on your local web server on any network with an internet connection without manually adding DNS records or configuring a firewall or router.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ArgoTunnel(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"my-tunnel\",\n    secret: \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ArgoTunnel(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"my-tunnel\",\n    secret=\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.ArgoTunnel(\"example\", new Cloudflare.ArgoTunnelArgs\n        {\n            AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Name = \"my-tunnel\",\n            Secret = \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewArgoTunnel(ctx, \"example\", \u0026cloudflare.ArgoTunnelArgs{\n\t\t\tAccountId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:      pulumi.String(\"my-tunnel\"),\n\t\t\tSecret:    pulumi.String(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nArgo Tunnels can be imported a composite ID of the account ID and tunnel UUID.\n\n```sh\n $ pulumi import cloudflare:index/argoTunnel:ArgoTunnel example d41d8cd98f00b204e9800998ecf8427e/fd2455cb-5fcc-4c13-8738-8d8d2605237f\n```\n\n where - `d41d8cd98f00b204e9800998ecf8427e` is the account ID - `fd2455cb-5fcc-4c13-8738-8d8d2605237f` is the Argo Tunnel UUID ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The Cloudflare account ID that you wish to manage the Argo Tunnel on.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Usable CNAME for accessing the Argo Tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. Cannot be empty.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password.\n"
                }
            },
            "required": [
                "accountId",
                "cname",
                "name",
                "secret"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The Cloudflare account ID that you wish to manage the Argo Tunnel on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. Cannot be empty.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "secret"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ArgoTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The Cloudflare account ID that you wish to manage the Argo Tunnel on.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Usable CNAME for accessing the Argo Tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the tunnel is created. Cannot be empty.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls": {
            "description": "Provides a Cloudflare Authenticated Origin Pulls resource. An `cloudflare.AuthenticatedOriginPulls` resource is required to use Per-Zone or Per-Hostname Authenticated Origin Pulls.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe arguments that you provide determine which form of Authenticated Origin Pulls to use:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Authenticated Origin Pulls\nconst myAop = new cloudflare.AuthenticatedOriginPulls(\"myAop\", {\n    zoneId: _var.cloudflare_zone_id,\n    enabled: true,\n});\n// Per-Zone Authenticated Origin Pulls\nconst myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", {\n    zoneId: _var.cloudflare_zone_id,\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-zone\",\n});\nconst myPerZoneAop = new cloudflare.AuthenticatedOriginPulls(\"myPerZoneAop\", {\n    zoneId: _var.cloudflare_zone_id,\n    authenticatedOriginPullsCertificate: myPerZoneAopCert.id,\n    enabled: true,\n});\n// Per-Hostname Authenticated Origin Pulls\nconst myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", {\n    zoneId: _var.cloudflare_zone_id,\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-hostname\",\n});\nconst myPerHostnameAop = new cloudflare.AuthenticatedOriginPulls(\"myPerHostnameAop\", {\n    zoneId: _var.cloudflare_zone_id,\n    authenticatedOriginPullsCertificate: myPerHostnameAopCert.id,\n    hostname: \"aop.example.com\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Authenticated Origin Pulls\nmy_aop = cloudflare.AuthenticatedOriginPulls(\"myAop\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    enabled=True)\n# Per-Zone Authenticated Origin Pulls\nmy_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-zone\")\nmy_per_zone_aop = cloudflare.AuthenticatedOriginPulls(\"myPerZoneAop\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    authenticated_origin_pulls_certificate=my_per_zone_aop_cert.id,\n    enabled=True)\n# Per-Hostname Authenticated Origin Pulls\nmy_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-hostname\")\nmy_per_hostname_aop = cloudflare.AuthenticatedOriginPulls(\"myPerHostnameAop\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    authenticated_origin_pulls_certificate=my_per_hostname_aop_cert.id,\n    hostname=\"aop.example.com\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Authenticated Origin Pulls\n        var myAop = new Cloudflare.AuthenticatedOriginPulls(\"myAop\", new Cloudflare.AuthenticatedOriginPullsArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Enabled = true,\n        });\n        // Per-Zone Authenticated Origin Pulls\n        var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", new Cloudflare.AuthenticatedOriginPullsCertificateArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Certificate = \"-----INSERT CERTIFICATE-----\",\n            PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n            Type = \"per-zone\",\n        });\n        var myPerZoneAop = new Cloudflare.AuthenticatedOriginPulls(\"myPerZoneAop\", new Cloudflare.AuthenticatedOriginPullsArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            AuthenticatedOriginPullsCertificate = myPerZoneAopCert.Id,\n            Enabled = true,\n        });\n        // Per-Hostname Authenticated Origin Pulls\n        var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", new Cloudflare.AuthenticatedOriginPullsCertificateArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Certificate = \"-----INSERT CERTIFICATE-----\",\n            PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n            Type = \"per-hostname\",\n        });\n        var myPerHostnameAop = new Cloudflare.AuthenticatedOriginPulls(\"myPerHostnameAop\", new Cloudflare.AuthenticatedOriginPullsArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            AuthenticatedOriginPullsCertificate = myPerHostnameAopCert.Id,\n            Hostname = \"aop.example.com\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAuthenticatedOriginPulls(ctx, \"myAop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:  pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyPerZoneAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerZoneAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-zone\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, \"myPerZoneAop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:                              pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tAuthenticatedOriginPullsCertificate: myPerZoneAopCert.ID(),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyPerHostnameAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerHostnameAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-hostname\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, \"myPerHostnameAop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:                              pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tAuthenticatedOriginPullsCertificate: myPerHostnameAopCert.ID(),\n\t\t\tHostname:                            pulumi.String(\"aop.example.com\"),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuthenticated Origin Pull configuration can be imported using a composite ID formed of the zone ID, the form of Authenticated Origin Pulls, and the certificate ID, with each section filled or left blank e.g. # Import Authenticated Origin Pull configuration\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls my_aop 023e105f4ecef8ad9ca31a8372d0c353//\n```\n\n # Import Per-Zone Authenticated Origin Pull configuration\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls my_per_zone_aop 023e105f4ecef8ad9ca31a8372d0c353/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60/\n```\n\n # Import Per-Hostname Authenticated Origin Pull configuration\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls my_per_hostname_aop 023e105f4ecef8ad9ca31a8372d0c353/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60/aop.example.com\n```\n\n ",
            "properties": {
                "authenticatedOriginPullsCertificate": {
                    "type": "string",
                    "description": "The id of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "authenticatedOriginPullsCertificate": {
                    "type": "string",
                    "description": "The id of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthenticatedOriginPulls resources.\n",
                "properties": {
                    "authenticatedOriginPullsCertificate": {
                        "type": "string",
                        "description": "The id of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to upload the certificate to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate": {
            "description": "Provides a Cloudflare Authenticated Origin Pulls certificate resource. An uploaded client certificate is required to use Per-Zone or Per-Hostname Authenticated Origin Pulls.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Per-Zone Authenticated Origin Pulls certificate\nconst myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_zone_aop_cert\", {\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-zone\",\n    zoneId: var_cloudflare_zone_id,\n});\n// Per-Hostname Authenticated Origin Pulls certificate\nconst myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"my_per_hostname_aop_cert\", {\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-hostname\",\n    zoneId: var_cloudflare_zone_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Per-Zone Authenticated Origin Pulls certificate\nmy_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-zone\",\n    zone_id=var[\"cloudflare_zone_id\"])\n# Per-Hostname Authenticated Origin Pulls certificate\nmy_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-hostname\",\n    zone_id=var[\"cloudflare_zone_id\"])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Per-Zone Authenticated Origin Pulls certificate\n        var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", new Cloudflare.AuthenticatedOriginPullsCertificateArgs\n        {\n            Certificate = \"-----INSERT CERTIFICATE-----\",\n            PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n            Type = \"per-zone\",\n            ZoneId = @var.Cloudflare_zone_id,\n        });\n        // Per-Hostname Authenticated Origin Pulls certificate\n        var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", new Cloudflare.AuthenticatedOriginPullsCertificateArgs\n        {\n            Certificate = \"-----INSERT CERTIFICATE-----\",\n            PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n            Type = \"per-hostname\",\n            ZoneId = @var.Cloudflare_zone_id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerZoneAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-zone\"),\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerHostnameAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-hostname\"),\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuthenticated Origin Pull certificates can be imported using a composite ID formed of the zone ID, the form of Authenticated Origin Pulls, and the certificate ID, e.g. # Import Per-Zone Authenticated Origin Pull certificate\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate 2458ce5a-0c35-4c7f-82c7-8e9487d3ff60 023e105f4ecef8ad9ca31a8372d0c353/per-zone/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60\n```\n\n # Import Per-Hostname Authenticated Origin Pull certificate\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate 2458ce5a-0c35-4c7f-82c7-8e9487d3ff60 023e105f4ecef8ad9ca31a8372d0c353/per-hostname/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The public client certificate.\n"
                },
                "expiresOn": {
                    "type": "string"
                },
                "issuer": {
                    "type": "string"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key of the client certificate.\n"
                },
                "serialNumber": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The form of Authenticated Origin Pulls to upload the certificate to.\n"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n"
                }
            },
            "required": [
                "certificate",
                "expiresOn",
                "issuer",
                "privateKey",
                "serialNumber",
                "signature",
                "status",
                "type",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "The public client certificate.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key of the client certificate.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The form of Authenticated Origin Pulls to upload the certificate to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n"
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthenticatedOriginPullsCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The public client certificate.\n"
                    },
                    "expiresOn": {
                        "type": "string"
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key of the client certificate.\n"
                    },
                    "serialNumber": {
                        "type": "string"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The form of Authenticated Origin Pulls to upload the certificate to.\n"
                    },
                    "uploadedOn": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to upload the certificate to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/byoIpPrefix:ByoIpPrefix": {
            "description": "Provides the ability to manage Bring-Your-Own-IP prefixes (BYOIP) which are used with or without Magic Transit.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ByoIpPrefix(\"example\", {\n    advertisement: \"on\",\n    description: \"Example IP Prefix\",\n    prefixId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ByoIpPrefix(\"example\",\n    advertisement=\"on\",\n    description=\"Example IP Prefix\",\n    prefix_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.ByoIpPrefix(\"example\", new Cloudflare.ByoIpPrefixArgs\n        {\n            Advertisement = \"on\",\n            Description = \"Example IP Prefix\",\n            PrefixId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewByoIpPrefix(ctx, \"example\", \u0026cloudflare.ByoIpPrefixArgs{\n\t\t\tAdvertisement: pulumi.String(\"on\"),\n\t\t\tDescription:   pulumi.String(\"Example IP Prefix\"),\n\t\t\tPrefixId:      pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThe current settings for Bring-Your-Own-IP prefixes can be imported using the prefix ID.\n\n```sh\n $ pulumi import cloudflare:index/byoIpPrefix:ByoIpPrefix example d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Valid values: `on` or `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID.\n"
                }
            },
            "required": [
                "advertisement",
                "description",
                "prefixId"
            ],
            "inputProperties": {
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Valid values: `on` or `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID.\n"
                }
            },
            "requiredInputs": [
                "prefixId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ByoIpPrefix resources.\n",
                "properties": {
                    "advertisement": {
                        "type": "string",
                        "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Valid values: `on` or `off`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the prefix.\n"
                    },
                    "prefixId": {
                        "type": "string",
                        "description": "The assigned Bring-Your-Own-IP prefix ID.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/certificatePack:CertificatePack": {
            "description": "\n\n\n## Import\n\nCertificate packs can be imported using a composite ID of the zone ID and certificate pack ID. This isn't recommended and it is advised to replace the certificate entirely instead.\n\n```sh\n $ pulumi import cloudflare:index/certificatePack:CertificatePack example cb029e245cfdd66dc8d2e570d5dd3322/8fda82e2-6af9-4eb2-992a-5ab65b792ef1\n```\n\n ",
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "Which certificate\nauthority to issue the certificate pack. Allowed values: `\"digicert\"`,\n`\"lets_encrypt\"`.\n"
                },
                "cloudflareBranding": {
                    "type": "boolean",
                    "description": "Whether or not to include\nCloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name\nif set to `true`.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to provision the certificate pack for.\nNote: If using Let's Encrypt, you cannot use individual subdomains and only a\nwildcard for subdomain is available.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Certificate pack configuration type.\nAllowed values: `\"custom\"`, `\"dedicated_custom\"`, `\"advanced\"`.\n"
                },
                "validationMethod": {
                    "type": "string",
                    "description": "Which validation method to\nuse in order to prove domain ownership. Allowed values: `\"txt\"`, `\"http\"`, `\"email\"`.\n"
                },
                "validityDays": {
                    "type": "integer",
                    "description": "How long the certificate is valid\nfor. Note: If using Let's Encrypt, this value can only be 90 days.\nAllowed values: 14, 30, 90, 365.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the certificate pack should be added.\n"
                }
            },
            "required": [
                "hosts",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "Which certificate\nauthority to issue the certificate pack. Allowed values: `\"digicert\"`,\n`\"lets_encrypt\"`.\n"
                },
                "cloudflareBranding": {
                    "type": "boolean",
                    "description": "Whether or not to include\nCloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name\nif set to `true`.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to provision the certificate pack for.\nNote: If using Let's Encrypt, you cannot use individual subdomains and only a\nwildcard for subdomain is available.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Certificate pack configuration type.\nAllowed values: `\"custom\"`, `\"dedicated_custom\"`, `\"advanced\"`.\n"
                },
                "validationMethod": {
                    "type": "string",
                    "description": "Which validation method to\nuse in order to prove domain ownership. Allowed values: `\"txt\"`, `\"http\"`, `\"email\"`.\n"
                },
                "validityDays": {
                    "type": "integer",
                    "description": "How long the certificate is valid\nfor. Note: If using Let's Encrypt, this value can only be 90 days.\nAllowed values: 14, 30, 90, 365.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the certificate pack should be added.\n"
                }
            },
            "requiredInputs": [
                "hosts",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertificatePack resources.\n",
                "properties": {
                    "certificateAuthority": {
                        "type": "string",
                        "description": "Which certificate\nauthority to issue the certificate pack. Allowed values: `\"digicert\"`,\n`\"lets_encrypt\"`.\n"
                    },
                    "cloudflareBranding": {
                        "type": "boolean",
                        "description": "Whether or not to include\nCloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name\nif set to `true`.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of hostnames to provision the certificate pack for.\nNote: If using Let's Encrypt, you cannot use individual subdomains and only a\nwildcard for subdomain is available.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Certificate pack configuration type.\nAllowed values: `\"custom\"`, `\"dedicated_custom\"`, `\"advanced\"`.\n"
                    },
                    "validationMethod": {
                        "type": "string",
                        "description": "Which validation method to\nuse in order to prove domain ownership. Allowed values: `\"txt\"`, `\"http\"`, `\"email\"`.\n"
                    },
                    "validityDays": {
                        "type": "integer",
                        "description": "How long the certificate is valid\nfor. Note: If using Let's Encrypt, this value can only be 90 days.\nAllowed values: 14, 30, 90, 365.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the certificate pack should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customHostname:CustomHostname": {
            "description": "Provides a Cloudflare custom hostname (also known as SSL for SaaS) resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleHostname = new cloudflare.CustomHostname(\"example_hostname\", {\n    hostname: \"hostname.example.com\",\n    ssls: [{\n        method: \"txt\",\n    }],\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_hostname = cloudflare.CustomHostname(\"exampleHostname\",\n    hostname=\"hostname.example.com\",\n    ssls=[cloudflare.CustomHostnameSslArgs(\n        method=\"txt\",\n    )],\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleHostname = new Cloudflare.CustomHostname(\"exampleHostname\", new Cloudflare.CustomHostnameArgs\n        {\n            Hostname = \"hostname.example.com\",\n            Ssls = \n            {\n                new Cloudflare.Inputs.CustomHostnameSslArgs\n                {\n                    Method = \"txt\",\n                },\n            },\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomHostname(ctx, \"exampleHostname\", \u0026cloudflare.CustomHostnameArgs{\n\t\t\tHostname: pulumi.String(\"hostname.example.com\"),\n\t\t\tSsls: CustomHostnameSslArray{\n\t\t\t\t\u0026CustomHostnameSslArgs{\n\t\t\t\t\tMethod: pulumi.String(\"txt\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom hostname certificates can be imported using a composite ID formed of the zone ID and [hostname ID](https://api.cloudflare.com/#custom-hostname-for-a-zone-properties), separated by a \"/\" e.g.\n\n```sh\n $ pulumi import cloudflare:index/customHostname:CustomHostname example d41d8cd98f00b204e9800998ecf8427e/0d89c70d-ad9f-4843-b99f-6cc0252067e9\n```\n\n ",
            "properties": {
                "customOriginServer": {
                    "type": "string",
                    "description": "The custom origin server used for certificates.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname you intend to request a certificate for.\n"
                },
                "ownershipVerification": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ownershipVerificationHttp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ssls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                    },
                    "description": "SSL configuration of the certificate. See further notes below.\n"
                },
                "status": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                }
            },
            "required": [
                "hostname",
                "ownershipVerification",
                "ownershipVerificationHttp",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "customOriginServer": {
                    "type": "string",
                    "description": "The custom origin server used for certificates.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname you intend to request a certificate for.\n"
                },
                "ssls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                    },
                    "description": "SSL configuration of the certificate. See further notes below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomHostname resources.\n",
                "properties": {
                    "customOriginServer": {
                        "type": "string",
                        "description": "The custom origin server used for certificates.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname you intend to request a certificate for.\n"
                    },
                    "ownershipVerification": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "ownershipVerificationHttp": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "ssls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                        },
                        "description": "SSL configuration of the certificate. See further notes below.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin": {
            "description": "Provides a Cloudflare custom hostname fallback origin resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst fallbackOrigin = new cloudflare.CustomHostnameFallbackOrigin(\"fallback_origin\", {\n    origin: \"fallback.example.com\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nfallback_origin = cloudflare.CustomHostnameFallbackOrigin(\"fallbackOrigin\",\n    origin=\"fallback.example.com\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var fallbackOrigin = new Cloudflare.CustomHostnameFallbackOrigin(\"fallbackOrigin\", new Cloudflare.CustomHostnameFallbackOriginArgs\n        {\n            Origin = \"fallback.example.com\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomHostnameFallbackOrigin(ctx, \"fallbackOrigin\", \u0026cloudflare.CustomHostnameFallbackOriginArgs{\n\t\t\tOrigin: pulumi.String(\"fallback.example.com\"),\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom hostname fallback origins can be imported using a composite ID formed of the zone ID and [fallback origin](https://api.cloudflare.com/#custom-hostname-fallback-origin-for-a-zone-properties), separated by a \"/\" e.g.\n\n```sh\n $ pulumi import cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin example d41d8cd98f00b204e9800998ecf8427e/fallback.example.com\n```\n\n ",
            "properties": {
                "origin": {
                    "type": "string",
                    "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the fallback origin's activation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                }
            },
            "required": [
                "origin",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "origin": {
                    "type": "string",
                    "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                }
            },
            "requiredInputs": [
                "origin",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomHostnameFallbackOrigin resources.\n",
                "properties": {
                    "origin": {
                        "type": "string",
                        "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the fallback origin's activation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customPages:CustomPages": {
            "description": "Provides a resource which manages Cloudflare custom error pages.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst basicChallenge = new cloudflare.CustomPages(\"basic_challenge\", {\n    state: \"customized\",\n    type: \"basic_challenge\",\n    url: \"https://example.com/challenge.html\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nbasic_challenge = cloudflare.CustomPages(\"basicChallenge\",\n    state=\"customized\",\n    type=\"basic_challenge\",\n    url=\"https://example.com/challenge.html\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var basicChallenge = new Cloudflare.CustomPages(\"basicChallenge\", new Cloudflare.CustomPagesArgs\n        {\n            State = \"customized\",\n            Type = \"basic_challenge\",\n            Url = \"https://example.com/challenge.html\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomPages(ctx, \"basicChallenge\", \u0026cloudflare.CustomPagesArgs{\n\t\t\tState:  pulumi.String(\"customized\"),\n\t\t\tType:   pulumi.String(\"basic_challenge\"),\n\t\t\tUrl:    pulumi.String(\"https://example.com/challenge.html\"),\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom pages can be imported using a composite ID formed of* `customPageLevel` - Either `account` or `zone`. * `identifier` - The ID of the account or zone you intend to manage. * `pageType` - The value from the `type` argument. Example for a zone\n\n```sh\n $ pulumi import cloudflare:index/customPages:CustomPages basic_challenge zone/d41d8cd98f00b204e9800998ecf8427e/basic_challenge\n```\n\n Example for an account\n\n```sh\n $ pulumi import cloudflare:index/customPages:CustomPages basic_challenge account/e268443e43d93dab7ebef303bbe9642f/basic_challenge\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                }
            },
            "required": [
                "type",
                "url"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                }
            },
            "requiredInputs": [
                "type",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomPages resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                    },
                    "state": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "URL of where the custom page source is located.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customSsl:CustomSsl": {
            "description": "Provides a Cloudflare custom ssl resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\nconst cloudflareZoneId = config.get(\"cloudflareZoneId\") || \"1d5fdc9e88c8a8c4518b068cd94331fe\";\n\n// Add a custom ssl certificate to the domain\nconst foossl = new cloudflare.CustomSsl(\"foossl\", {\n    customSslOptions: {\n        bundleMethod: \"ubiquitous\",\n        certificate: \"-----INSERT CERTIFICATE-----\",\n        geoRestrictions: \"us\",\n        privateKey: \"-----INSERT PRIVATE KEY-----\",\n        type: \"legacy_custom\",\n    },\n    zoneId: cloudflareZoneId,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nconfig = pulumi.Config()\ncloudflare_zone_id = config.get(\"cloudflareZoneId\")\nif cloudflare_zone_id is None:\n    cloudflare_zone_id = \"1d5fdc9e88c8a8c4518b068cd94331fe\"\n# Add a custom ssl certificate to the domain\nfoossl = cloudflare.CustomSsl(\"foossl\",\n    custom_ssl_options=cloudflare.CustomSslCustomSslOptionsArgs(\n        bundle_method=\"ubiquitous\",\n        certificate=\"-----INSERT CERTIFICATE-----\",\n        geo_restrictions=\"us\",\n        private_key=\"-----INSERT PRIVATE KEY-----\",\n        type=\"legacy_custom\",\n    ),\n    zone_id=cloudflare_zone_id)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var config = new Config();\n        var cloudflareZoneId = config.Get(\"cloudflareZoneId\") ?? \"1d5fdc9e88c8a8c4518b068cd94331fe\";\n        // Add a custom ssl certificate to the domain\n        var foossl = new Cloudflare.CustomSsl(\"foossl\", new Cloudflare.CustomSslArgs\n        {\n            CustomSslOptions = new Cloudflare.Inputs.CustomSslCustomSslOptionsArgs\n            {\n                BundleMethod = \"ubiquitous\",\n                Certificate = \"-----INSERT CERTIFICATE-----\",\n                GeoRestrictions = \"us\",\n                PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n                Type = \"legacy_custom\",\n            },\n            ZoneId = cloudflareZoneId,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tcloudflareZoneId := \"1d5fdc9e88c8a8c4518b068cd94331fe\"\n\t\tif param := cfg.Get(\"cloudflareZoneId\"); param != \"\" {\n\t\t\tcloudflareZoneId = param\n\t\t}\n\t\t_, err := cloudflare.NewCustomSsl(ctx, \"foossl\", \u0026cloudflare.CustomSslArgs{\n\t\t\tCustomSslOptions: \u0026CustomSslCustomSslOptionsArgs{\n\t\t\t\tBundleMethod:    pulumi.String(\"ubiquitous\"),\n\t\t\t\tCertificate:     pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\t\tGeoRestrictions: pulumi.String(\"us\"),\n\t\t\t\tPrivateKey:      pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\t\tType:            pulumi.String(\"legacy_custom\"),\n\t\t\t},\n\t\t\tZoneId: pulumi.String(cloudflareZoneId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom SSL Certs can be imported using a composite ID formed of the zone ID and [certificate ID](https://api.cloudflare.com/#custom-ssl-for-a-zone-properties), separated by a \"/\" e.g.\n\n```sh\n $ pulumi import cloudflare:index/customSsl:CustomSsl default 1d5fdc9e88c8a8c4518b068cd94331fe/0123f0ab-9cde-45b2-80bd-4da3010f1337\n```\n\n ",
            "properties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "expiresOn": {
                    "type": "string"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "issuer": {
                    "type": "string"
                },
                "modifiedOn": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "signature": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone id to the custom ssl cert should be added.\n"
                }
            },
            "required": [
                "expiresOn",
                "hosts",
                "issuer",
                "modifiedOn",
                "priority",
                "signature",
                "status",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone id to the custom ssl cert should be added.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomSsl resources.\n",
                "properties": {
                    "customSslOptions": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                        "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                    },
                    "customSslPriorities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                        }
                    },
                    "expiresOn": {
                        "type": "string"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "modifiedOn": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    },
                    "uploadedOn": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone id to the custom ssl cert should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePostureRule:DevicePostureRule": {
            "description": "Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst corporateDevicesPostureRule = new cloudflare.DevicePostureRule(\"corporateDevicesPostureRule\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name: \"Corporate devices posture rule\",\n    type: \"serial_number\",\n    description: \"Device posture rule for corporate devices.\",\n    schedule: \"24h\",\n    matches: [{\n        platform: \"mac\",\n    }],\n    inputs: [{\n        id: cloudflare_teams_list.corporate_devices.id,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ncorporate_devices_posture_rule = cloudflare.DevicePostureRule(\"corporateDevicesPostureRule\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    name=\"Corporate devices posture rule\",\n    type=\"serial_number\",\n    description=\"Device posture rule for corporate devices.\",\n    schedule=\"24h\",\n    matches=[cloudflare.DevicePostureRuleMatchArgs(\n        platform=\"mac\",\n    )],\n    inputs=[cloudflare.DevicePostureRuleInputArgs(\n        id=cloudflare_teams_list[\"corporate_devices\"][\"id\"],\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var corporateDevicesPostureRule = new Cloudflare.DevicePostureRule(\"corporateDevicesPostureRule\", new Cloudflare.DevicePostureRuleArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Name = \"Corporate devices posture rule\",\n            Type = \"serial_number\",\n            Description = \"Device posture rule for corporate devices.\",\n            Schedule = \"24h\",\n            Matches = \n            {\n                new Cloudflare.Inputs.DevicePostureRuleMatchArgs\n                {\n                    Platform = \"mac\",\n                },\n            },\n            Inputs = \n            {\n                new Cloudflare.Inputs.DevicePostureRuleInputArgs\n                {\n                    Id = cloudflare_teams_list.Corporate_devices.Id,\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePostureRule(ctx, \"corporateDevicesPostureRule\", \u0026cloudflare.DevicePostureRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tName:        pulumi.String(\"Corporate devices posture rule\"),\n\t\t\tType:        pulumi.String(\"serial_number\"),\n\t\t\tDescription: pulumi.String(\"Device posture rule for corporate devices.\"),\n\t\t\tSchedule:    pulumi.String(\"24h\"),\n\t\t\tMatches: DevicePostureRuleMatchArray{\n\t\t\t\t\u0026DevicePostureRuleMatchArgs{\n\t\t\t\t\tPlatform: pulumi.String(\"mac\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tInputs: DevicePostureRuleInputArray{\n\t\t\t\t\u0026DevicePostureRuleInputArgs{\n\t\t\t\t\tId: pulumi.Any(cloudflare_teams_list.Corporate_devices.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDevice posture rules can be imported using a composite ID formed of account ID and device posture rule ID.\n\n```sh\n $ pulumi import cloudflare:index/devicePostureRule:DevicePostureRule corporate_devices cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the device posture rule should be added.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the device posture rule.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                    },
                    "description": "The value to be checked against. See below for reference\nstructure.\n"
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule. See below for reference structure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check.\nMust be in the format `\"1h\"` or `\"30m\"`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Valid values are `file`, `application`, and `serial_number`.\n"
                }
            },
            "required": [
                "accountId",
                "inputs",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the device posture rule should be added.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the device posture rule.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                    },
                    "description": "The value to be checked against. See below for reference\nstructure.\n"
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule. See below for reference structure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check.\nMust be in the format `\"1h\"` or `\"30m\"`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Valid values are `file`, `application`, and `serial_number`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePostureRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the device posture rule should be added.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the device posture rule.\n"
                    },
                    "inputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                        },
                        "description": "The value to be checked against. See below for reference\nstructure.\n"
                    },
                    "matches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                        },
                        "description": "The conditions that the client must match to run the rule. See below for reference structure.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture rule.\n"
                    },
                    "schedule": {
                        "type": "string",
                        "description": "Tells the client when to run the device posture check.\nMust be in the format `\"1h\"` or `\"30m\"`. Valid units are `h` and `m`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture rule type. Valid values are `file`, `application`, and `serial_number`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/filter:Filter": {
            "description": "Filter expressions that can be referenced across multiple features, e.g. Firewall Rule. The expression format is similar to [Wireshark Display Filter](https://www.wireshark.org/docs/man-pages/wireshark-filter.html).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpress = new cloudflare.Filter(\"wordpress\", {\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress = cloudflare.Filter(\"wordpress\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var wordpress = new Cloudflare.Filter(\"wordpress\", new Cloudflare.FilterArgs\n        {\n            Description = \"Wordpress break-in attempts that are outside of the office\",\n            Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewFilter(ctx, \"wordpress\", \u0026cloudflare.FilterArgs{\n\t\t\tDescription: pulumi.String(\"Wordpress break-in attempts that are outside of the office\"),\n\t\t\tExpression:  pulumi.String(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\"),\n\t\t\tZoneId:      pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nFilter can be imported using a composite ID formed of zone ID and filter ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/filter:Filter default d41d8cd98f00b204e9800998ecf8427e/9e107d9d372bb6826bd81d3542a419d6\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID * `9e107d9d372bb6826bd81d3542a419d6` - filter ID as returned by [API](https://api.cloudflare.com/#zone-firewall-filters) ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused. Boolean value.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "required": [
                "expression",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused. Boolean value.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "requiredInputs": [
                "expression",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Filter resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the purpose of the filter.\n"
                    },
                    "expression": {
                        "type": "string",
                        "description": "The filter expression to be used.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter is currently paused. Boolean value.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "Short reference tag to quickly select related rules.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the Filter should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/firewallRule:FirewallRule": {
            "description": "Define Firewall rules using filter expressions for more control over how traffic is matched to the rule.\nA filter expression permits selecting traffic by multiple criteria allowing greater freedom in rule creation.\n\nFilter expressions needs to be created first before using Firewall Rule. See Filter.\n\nIf you want to configure Custom Firewall rules, you need to use cloudflare_ruleset, because Custom Rules are built upon the\n[Cloudflare Ruleset Engine](https://developers.cloudflare.com/ruleset-engine/).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpressFilter = new cloudflare.Filter(\"wordpressFilter\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n});\nconst wordpressFirewallRule = new cloudflare.FirewallRule(\"wordpressFirewallRule\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Block wordpress break-in attempts\",\n    filterId: wordpressFilter.id,\n    action: \"block\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress_filter = cloudflare.Filter(\"wordpressFilter\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\nwordpress_firewall_rule = cloudflare.FirewallRule(\"wordpressFirewallRule\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Block wordpress break-in attempts\",\n    filter_id=wordpress_filter.id,\n    action=\"block\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var wordpressFilter = new Cloudflare.Filter(\"wordpressFilter\", new Cloudflare.FilterArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Description = \"Wordpress break-in attempts that are outside of the office\",\n            Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n        });\n        var wordpressFirewallRule = new Cloudflare.FirewallRule(\"wordpressFirewallRule\", new Cloudflare.FirewallRuleArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Description = \"Block wordpress break-in attempts\",\n            FilterId = wordpressFilter.Id,\n            Action = \"block\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\twordpressFilter, err := cloudflare.NewFilter(ctx, \"wordpressFilter\", \u0026cloudflare.FilterArgs{\n\t\t\tZoneId:      pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription: pulumi.String(\"Wordpress break-in attempts that are outside of the office\"),\n\t\t\tExpression:  pulumi.String(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewFirewallRule(ctx, \"wordpressFirewallRule\", \u0026cloudflare.FirewallRuleArgs{\n\t\t\tZoneId:      pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription: pulumi.String(\"Block wordpress break-in attempts\"),\n\t\t\tFilterId:    wordpressFilter.ID(),\n\t\t\tAction:      pulumi.String(\"block\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nFirewall Rule can be imported using a composite ID formed of zone ID and rule ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/firewallRule:FirewallRule default d41d8cd98f00b204e9800998ecf8427e/9e107d9d372bb6826bd81d3542a419d6\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID * `9e107d9d372bb6826bd81d3542a419d6` - rule ID as returned by [API](https://api.cloudflare.com/#zone-firewall-filter-rules) ",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"allow\", \"js_challenge\", \"managed_challenge\", \"bypass\". Enterprise plan also allows \"log\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused. Boolean value.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Allowed values: \"zoneLockdown\", \"uaBlock\", \"bic\", \"hot\", \"securityLevel\", \"rateLimit\", \"waf\".\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "required": [
                "action",
                "filterId",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"allow\", \"js_challenge\", \"managed_challenge\", \"bypass\". Enterprise plan also allows \"log\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused. Boolean value.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Allowed values: \"zoneLockdown\", \"uaBlock\", \"bic\", \"hot\", \"securityLevel\", \"rateLimit\", \"waf\".\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the Filter should be added.\n"
                }
            },
            "requiredInputs": [
                "action",
                "filterId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallRule resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Allowed values: \"block\", \"challenge\", \"allow\", \"js_challenge\", \"managed_challenge\", \"bypass\". Enterprise plan also allows \"log\".\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the rule to help identify it.\n"
                    },
                    "filterId": {
                        "type": "string"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter based firewall rule is currently paused. Boolean value.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                    },
                    "products": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of products to bypass for a request when the bypass action is used. Allowed values: \"zoneLockdown\", \"uaBlock\", \"bic\", \"hot\", \"securityLevel\", \"rateLimit\", \"waf\".\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the Filter should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/healthcheck:Healthcheck": {
            "description": "Standalone Health Checks provide a way to monitor origin servers without needing a Cloudflare Load Balancer. \n\n{{% examples %}}\n## Example Usage\n\nThe resource supports HTTP, HTTPS and TCP type health checks.\n{{% example %}}\n### HTTPS Health Check\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst httpHealthCheck = new cloudflare.Healthcheck(\"httpHealthCheck\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"http-health-check\",\n    description: \"example http health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    notificationSuspended: false,\n    notificationEmailAddresses: [\"hostmaster@example.com\"],\n    type: \"HTTPS\",\n    port: \"443\",\n    method: \"GET\",\n    path: \"/health\",\n    expectedBody: \"alive\",\n    expectedCodes: [\n        \"2xx\",\n        \"301\",\n    ],\n    followRedirects: true,\n    allowInsecure: false,\n    headers: [{\n        header: \"Host\",\n        values: [\"example.com\"],\n    }],\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhttp_health_check = cloudflare.Healthcheck(\"httpHealthCheck\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"http-health-check\",\n    description=\"example http health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    notification_suspended=False,\n    notification_email_addresses=[\"hostmaster@example.com\"],\n    type=\"HTTPS\",\n    port=443,\n    method=\"GET\",\n    path=\"/health\",\n    expected_body=\"alive\",\n    expected_codes=[\n        \"2xx\",\n        \"301\",\n    ],\n    follow_redirects=True,\n    allow_insecure=False,\n    headers=[cloudflare.HealthcheckHeaderArgs(\n        header=\"Host\",\n        values=[\"example.com\"],\n    )],\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var httpHealthCheck = new Cloudflare.Healthcheck(\"httpHealthCheck\", new Cloudflare.HealthcheckArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Name = \"http-health-check\",\n            Description = \"example http health check\",\n            Address = \"example.com\",\n            Suspended = false,\n            CheckRegions = \n            {\n                \"WEU\",\n                \"EEU\",\n            },\n            NotificationSuspended = false,\n            NotificationEmailAddresses = \n            {\n                \"hostmaster@example.com\",\n            },\n            Type = \"HTTPS\",\n            Port = 443,\n            Method = \"GET\",\n            Path = \"/health\",\n            ExpectedBody = \"alive\",\n            ExpectedCodes = \n            {\n                \"2xx\",\n                \"301\",\n            },\n            FollowRedirects = true,\n            AllowInsecure = false,\n            Headers = \n            {\n                new Cloudflare.Inputs.HealthcheckHeaderArgs\n                {\n                    Header = \"Host\",\n                    Values = \n                    {\n                        \"example.com\",\n                    },\n                },\n            },\n            Timeout = 10,\n            Retries = 2,\n            Interval = 60,\n            ConsecutiveFails = 3,\n            ConsecutiveSuccesses = 2,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewHealthcheck(ctx, \"httpHealthCheck\", \u0026cloudflare.HealthcheckArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:        pulumi.String(\"http-health-check\"),\n\t\t\tDescription: pulumi.String(\"example http health check\"),\n\t\t\tAddress:     pulumi.String(\"example.com\"),\n\t\t\tSuspended:   pulumi.Bool(false),\n\t\t\tCheckRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WEU\"),\n\t\t\t\tpulumi.String(\"EEU\"),\n\t\t\t},\n\t\t\tNotificationSuspended: pulumi.Bool(false),\n\t\t\tNotificationEmailAddresses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"hostmaster@example.com\"),\n\t\t\t},\n\t\t\tType:         pulumi.String(\"HTTPS\"),\n\t\t\tPort:         pulumi.Int(443),\n\t\t\tMethod:       pulumi.String(\"GET\"),\n\t\t\tPath:         pulumi.String(\"/health\"),\n\t\t\tExpectedBody: pulumi.String(\"alive\"),\n\t\t\tExpectedCodes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"2xx\"),\n\t\t\t\tpulumi.String(\"301\"),\n\t\t\t},\n\t\t\tFollowRedirects: pulumi.Bool(true),\n\t\t\tAllowInsecure:   pulumi.Bool(false),\n\t\t\tHeaders: HealthcheckHeaderArray{\n\t\t\t\t\u0026HealthcheckHeaderArgs{\n\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTimeout:              pulumi.Int(10),\n\t\t\tRetries:              pulumi.Int(2),\n\t\t\tInterval:             pulumi.Int(60),\n\t\t\tConsecutiveFails:     pulumi.Int(3),\n\t\t\tConsecutiveSuccesses: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### TCP Monitor\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst tcpHealthCheck = new cloudflare.Healthcheck(\"tcpHealthCheck\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"tcp-health-check\",\n    description: \"example tcp health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    notificationSuspended: false,\n    notificationEmailAddresses: [\"hostmaster@example.com\"],\n    type: \"TCP\",\n    port: \"22\",\n    method: \"connection_established\",\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntcp_health_check = cloudflare.Healthcheck(\"tcpHealthCheck\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"tcp-health-check\",\n    description=\"example tcp health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    notification_suspended=False,\n    notification_email_addresses=[\"hostmaster@example.com\"],\n    type=\"TCP\",\n    port=22,\n    method=\"connection_established\",\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var tcpHealthCheck = new Cloudflare.Healthcheck(\"tcpHealthCheck\", new Cloudflare.HealthcheckArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Name = \"tcp-health-check\",\n            Description = \"example tcp health check\",\n            Address = \"example.com\",\n            Suspended = false,\n            CheckRegions = \n            {\n                \"WEU\",\n                \"EEU\",\n            },\n            NotificationSuspended = false,\n            NotificationEmailAddresses = \n            {\n                \"hostmaster@example.com\",\n            },\n            Type = \"TCP\",\n            Port = 22,\n            Method = \"connection_established\",\n            Timeout = 10,\n            Retries = 2,\n            Interval = 60,\n            ConsecutiveFails = 3,\n            ConsecutiveSuccesses = 2,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewHealthcheck(ctx, \"tcpHealthCheck\", \u0026cloudflare.HealthcheckArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:        pulumi.String(\"tcp-health-check\"),\n\t\t\tDescription: pulumi.String(\"example tcp health check\"),\n\t\t\tAddress:     pulumi.String(\"example.com\"),\n\t\t\tSuspended:   pulumi.Bool(false),\n\t\t\tCheckRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WEU\"),\n\t\t\t\tpulumi.String(\"EEU\"),\n\t\t\t},\n\t\t\tNotificationSuspended: pulumi.Bool(false),\n\t\t\tNotificationEmailAddresses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"hostmaster@example.com\"),\n\t\t\t},\n\t\t\tType:                 pulumi.String(\"TCP\"),\n\t\t\tPort:                 pulumi.Int(22),\n\t\t\tMethod:               pulumi.String(\"connection_established\"),\n\t\t\tTimeout:              pulumi.Int(10),\n\t\t\tRetries:              pulumi.Int(2),\n\t\t\tInterval:             pulumi.Int(60),\n\t\t\tConsecutiveFails:     pulumi.Int(3),\n\t\t\tConsecutiveSuccesses: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set Cloudflare will pick a default region. Valid values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. (Default: `1`)\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. (Default: `1`)\n"
                },
                "createdOn": {
                    "type": "string"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. \"200\") or code ranges (e.g. \"2xx\" for all codes starting with 2) of the health check. (Default: `[\"200\"]`)\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. (Default: `60`)\n"
                },
                "method": {
                    "type": "string",
                    "description": "The TCP connection method to use for the health check. Valid values: `connection_established` (Default: `connection_established`).\n"
                },
                "modifiedOn": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.\n"
                },
                "notificationEmailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses we want to send the notifications to.\n"
                },
                "notificationSuspended": {
                    "type": "boolean",
                    "description": "Whether the notifications are suspended or not. Useful for maintenance periods. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. (Default: `/`)\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check.  Valid values are in the range `0-65535` (Default: `80`).\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. (Default: `2`)\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. (Default: `5`)\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Valid values: `HTTP`, `HTTPS`, `TCP`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                }
            },
            "required": [
                "address",
                "checkRegions",
                "createdOn",
                "method",
                "modifiedOn",
                "name",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set Cloudflare will pick a default region. Valid values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. (Default: `1`)\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. (Default: `1`)\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. \"200\") or code ranges (e.g. \"2xx\" for all codes starting with 2) of the health check. (Default: `[\"200\"]`)\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. (Default: `60`)\n"
                },
                "method": {
                    "type": "string",
                    "description": "The TCP connection method to use for the health check. Valid values: `connection_established` (Default: `connection_established`).\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.\n"
                },
                "notificationEmailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses we want to send the notifications to.\n"
                },
                "notificationSuspended": {
                    "type": "boolean",
                    "description": "Whether the notifications are suspended or not. Useful for maintenance periods. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. (Default: `/`)\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check.  Valid values are in the range `0-65535` (Default: `80`).\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. (Default: `2`)\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Valid values: `true` or `false` (Default: `false`).\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. (Default: `5`)\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Valid values: `HTTP`, `HTTPS`, `TCP`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                }
            },
            "requiredInputs": [
                "address",
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Healthcheck resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The hostname or IP address of the origin server to run health checks on.\n"
                    },
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when the health check uses HTTPS. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions from which to run health checks. If not set Cloudflare will pick a default region. Valid values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                    },
                    "consecutiveFails": {
                        "type": "integer",
                        "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. (Default: `1`)\n"
                    },
                    "consecutiveSuccesses": {
                        "type": "integer",
                        "description": "The number of consecutive successes required from a health check before changing the health to healthy. (Default: `1`)\n"
                    },
                    "createdOn": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-readable description of the health check.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.\n"
                    },
                    "expectedCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The expected HTTP response codes (e.g. \"200\") or code ranges (e.g. \"2xx\" for all codes starting with 2) of the health check. (Default: `[\"200\"]`)\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if the origin returns a 3xx status code. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                        },
                        "description": "The header name.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. (Default: `60`)\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The TCP connection method to use for the health check. Valid values: `connection_established` (Default: `connection_established`).\n"
                    },
                    "modifiedOn": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.\n"
                    },
                    "notificationEmailAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses we want to send the notifications to.\n"
                    },
                    "notificationSuspended": {
                        "type": "boolean",
                        "description": "Whether the notifications are suspended or not. Useful for maintenance periods. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. (Default: `/`)\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port number to connect to for the health check.  Valid values are in the range `0-65535` (Default: `80`).\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. (Default: `2`)\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, no health checks are sent to the origin. Valid values: `true` or `false` (Default: `false`).\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. (Default: `5`)\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the health check. Valid values: `HTTP`, `HTTPS`, `TCP`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which apply settings.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ipList:IpList": {
            "description": "IP Lists are a set of IP addresses or CIDR ranges that are configured on the account level. Once created, IP Lists can be \nused in Firewall Rules across all zones within the same account.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.IpList(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"list description\",\n    items: [\n        {\n            comment: \"Office IP\",\n            value: \"192.0.2.1\",\n        },\n        {\n            comment: \"Datacenter range\",\n            value: \"203.0.113.0/24\",\n        },\n    ],\n    kind: \"ip\",\n    name: \"example_list\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.IpList(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"list description\",\n    items=[\n        cloudflare.IpListItemArgs(\n            comment=\"Office IP\",\n            value=\"192.0.2.1\",\n        ),\n        cloudflare.IpListItemArgs(\n            comment=\"Datacenter range\",\n            value=\"203.0.113.0/24\",\n        ),\n    ],\n    kind=\"ip\",\n    name=\"example_list\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.IpList(\"example\", new Cloudflare.IpListArgs\n        {\n            AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Description = \"list description\",\n            Items = \n            {\n                new Cloudflare.Inputs.IpListItemArgs\n                {\n                    Comment = \"Office IP\",\n                    Value = \"192.0.2.1\",\n                },\n                new Cloudflare.Inputs.IpListItemArgs\n                {\n                    Comment = \"Datacenter range\",\n                    Value = \"203.0.113.0/24\",\n                },\n            },\n            Kind = \"ip\",\n            Name = \"example_list\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewIpList(ctx, \"example\", \u0026cloudflare.IpListArgs{\n\t\t\tAccountId:   pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription: pulumi.String(\"list description\"),\n\t\t\tItems: IpListItemArray{\n\t\t\t\t\u0026IpListItemArgs{\n\t\t\t\t\tComment: pulumi.String(\"Office IP\"),\n\t\t\t\t\tValue:   pulumi.String(\"192.0.2.1\"),\n\t\t\t\t},\n\t\t\t\t\u0026IpListItemArgs{\n\t\t\t\t\tComment: pulumi.String(\"Datacenter range\"),\n\t\t\t\t\tValue:   pulumi.String(\"203.0.113.0/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tKind: pulumi.String(\"ip\"),\n\t\t\tName: pulumi.String(\"example_list\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing IP List can be imported using the account ID and list ID\n\n```sh\n $ pulumi import cloudflare:index/ipList:IpList example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the IP List is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the List. Maximum Length: 500\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/IpListItem:IpListItem"
                    }
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of values in the List. Valid values: `ip`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list (used in filter expressions). Valid pattern: `^[a-zA-Z0-9_]+$`. Maximum Length: 50\n"
                }
            },
            "required": [
                "accountId",
                "kind",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the IP List is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the List. Maximum Length: 500\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/IpListItem:IpListItem"
                    }
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of values in the List. Valid values: `ip`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list (used in filter expressions). Valid pattern: `^[a-zA-Z0-9_]+$`. Maximum Length: 50\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "kind",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpList resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the IP List is being created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that can be used to annotate the List. Maximum Length: 500\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/IpListItem:IpListItem"
                        }
                    },
                    "kind": {
                        "type": "string",
                        "description": "The kind of values in the List. Valid values: `ip`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the list (used in filter expressions). Valid pattern: `^[a-zA-Z0-9_]+$`. Maximum Length: 50\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancer:LoadBalancer": {
            "description": "Provides a Cloudflare Load Balancer resource. This sits in front of a number of defined pools of origins and provides various options for geographically-aware load balancing. Note that the load balancing feature must be enabled in your Cloudflare account before you can use this resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst foo = new cloudflare.LoadBalancerPool(\"foo\", {\n    name: \"example-lb-pool\",\n    origins: [{\n        name: \"example-1\",\n        address: \"192.0.2.1\",\n        enabled: false,\n    }],\n});\n// Define a load balancer which always points to a pool we define below\n// In normal usage, would have different pools set for different pops (cloudflare points-of-presence) and/or for different regions\n// Within each pop or region we can define multiple pools in failover order\nconst bar = new cloudflare.LoadBalancer(\"bar\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"example-load-balancer.example.com\",\n    fallbackPoolId: foo.id,\n    defaultPoolIds: [foo.id],\n    description: \"example load balancer using geo-balancing\",\n    proxied: true,\n    steeringPolicy: \"geo\",\n    popPools: [{\n        pop: \"LAX\",\n        poolIds: [foo.id],\n    }],\n    regionPools: [{\n        region: \"WNAM\",\n        poolIds: [foo.id],\n    }],\n    rules: [{\n        name: \"example rule\",\n        condition: \"http.request.uri.path contains \\\"testing\\\"\",\n        fixedResponse: {\n            messageBody: \"hello\",\n            statusCode: 200,\n            contentType: \"html\",\n            location: \"www.example.com\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nfoo = cloudflare.LoadBalancerPool(\"foo\",\n    name=\"example-lb-pool\",\n    origins=[cloudflare.LoadBalancerPoolOriginArgs(\n        name=\"example-1\",\n        address=\"192.0.2.1\",\n        enabled=False,\n    )])\n# Define a load balancer which always points to a pool we define below\n# In normal usage, would have different pools set for different pops (cloudflare points-of-presence) and/or for different regions\n# Within each pop or region we can define multiple pools in failover order\nbar = cloudflare.LoadBalancer(\"bar\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"example-load-balancer.example.com\",\n    fallback_pool_id=foo.id,\n    default_pool_ids=[foo.id],\n    description=\"example load balancer using geo-balancing\",\n    proxied=True,\n    steering_policy=\"geo\",\n    pop_pools=[cloudflare.LoadBalancerPopPoolArgs(\n        pop=\"LAX\",\n        pool_ids=[foo.id],\n    )],\n    region_pools=[cloudflare.LoadBalancerRegionPoolArgs(\n        region=\"WNAM\",\n        pool_ids=[foo.id],\n    )],\n    rules=[cloudflare.LoadBalancerRuleArgs(\n        name=\"example rule\",\n        condition=\"http.request.uri.path contains \\\"testing\\\"\",\n        fixed_response=cloudflare.LoadBalancerRuleFixedResponseArgs(\n            message_body=\"hello\",\n            status_code=200,\n            content_type=\"html\",\n            location=\"www.example.com\",\n        ),\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var foo = new Cloudflare.LoadBalancerPool(\"foo\", new Cloudflare.LoadBalancerPoolArgs\n        {\n            Name = \"example-lb-pool\",\n            Origins = \n            {\n                new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n                {\n                    Name = \"example-1\",\n                    Address = \"192.0.2.1\",\n                    Enabled = false,\n                },\n            },\n        });\n        // Define a load balancer which always points to a pool we define below\n        // In normal usage, would have different pools set for different pops (cloudflare points-of-presence) and/or for different regions\n        // Within each pop or region we can define multiple pools in failover order\n        var bar = new Cloudflare.LoadBalancer(\"bar\", new Cloudflare.LoadBalancerArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Name = \"example-load-balancer.example.com\",\n            FallbackPoolId = foo.Id,\n            DefaultPoolIds = \n            {\n                foo.Id,\n            },\n            Description = \"example load balancer using geo-balancing\",\n            Proxied = true,\n            SteeringPolicy = \"geo\",\n            PopPools = \n            {\n                new Cloudflare.Inputs.LoadBalancerPopPoolArgs\n                {\n                    Pop = \"LAX\",\n                    PoolIds = \n                    {\n                        foo.Id,\n                    },\n                },\n            },\n            RegionPools = \n            {\n                new Cloudflare.Inputs.LoadBalancerRegionPoolArgs\n                {\n                    Region = \"WNAM\",\n                    PoolIds = \n                    {\n                        foo.Id,\n                    },\n                },\n            },\n            Rules = \n            {\n                new Cloudflare.Inputs.LoadBalancerRuleArgs\n                {\n                    Name = \"example rule\",\n                    Condition = \"http.request.uri.path contains \\\"testing\\\"\",\n                    FixedResponse = new Cloudflare.Inputs.LoadBalancerRuleFixedResponseArgs\n                    {\n                        MessageBody = \"hello\",\n                        StatusCode = 200,\n                        ContentType = \"html\",\n                        Location = \"www.example.com\",\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := cloudflare.NewLoadBalancerPool(ctx, \"foo\", \u0026cloudflare.LoadBalancerPoolArgs{\n\t\t\tName: pulumi.String(\"example-lb-pool\"),\n\t\t\tOrigins: LoadBalancerPoolOriginArray{\n\t\t\t\t\u0026LoadBalancerPoolOriginArgs{\n\t\t\t\t\tName:    pulumi.String(\"example-1\"),\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewLoadBalancer(ctx, \"bar\", \u0026cloudflare.LoadBalancerArgs{\n\t\t\tZoneId:         pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:           pulumi.String(\"example-load-balancer.example.com\"),\n\t\t\tFallbackPoolId: foo.ID(),\n\t\t\tDefaultPoolIds: pulumi.StringArray{\n\t\t\t\tfoo.ID(),\n\t\t\t},\n\t\t\tDescription:    pulumi.String(\"example load balancer using geo-balancing\"),\n\t\t\tProxied:        pulumi.Bool(true),\n\t\t\tSteeringPolicy: pulumi.String(\"geo\"),\n\t\t\tPopPools: LoadBalancerPopPoolArray{\n\t\t\t\t\u0026LoadBalancerPopPoolArgs{\n\t\t\t\t\tPop: pulumi.String(\"LAX\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\tfoo.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRegionPools: LoadBalancerRegionPoolArray{\n\t\t\t\t\u0026LoadBalancerRegionPoolArgs{\n\t\t\t\t\tRegion: pulumi.String(\"WNAM\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\tfoo.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRules: LoadBalancerRuleArray{\n\t\t\t\t\u0026LoadBalancerRuleArgs{\n\t\t\t\t\tName:      pulumi.String(\"example rule\"),\n\t\t\t\t\tCondition: pulumi.String(\"http.request.uri.path contains \\\"testing\\\"\"),\n\t\t\t\t\tFixedResponse: \u0026LoadBalancerRuleFixedResponseArgs{\n\t\t\t\t\t\tMessageBody: pulumi.String(\"hello\"),\n\t\t\t\t\t\tStatusCode:  pulumi.Int(200),\n\t\t\t\t\t\tContentType: pulumi.String(\"html\"),\n\t\t\t\t\t\tLocation:    pulumi.String(\"www.example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever region/pop pools are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true` (enabled).\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human readable name for this rule.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "See pop_pools above.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "See region_pools above.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                    },
                    "description": "A list of conditions and overrides for each load balancer operation. See the field documentation below.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "See field above.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "See field above.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "See field above.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "See field above.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "See field above.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to.\n"
                }
            },
            "required": [
                "createdOn",
                "defaultPoolIds",
                "fallbackPoolId",
                "modifiedOn",
                "name",
                "popPools",
                "regionPools",
                "steeringPolicy",
                "ttl",
                "zoneId"
            ],
            "inputProperties": {
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever region/pop pools are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true` (enabled).\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human readable name for this rule.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "See pop_pools above.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "See region_pools above.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                    },
                    "description": "A list of conditions and overrides for each load balancer operation. See the field documentation below.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "See field above.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "See field above.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "See field above.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "See field above.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "See field above.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to.\n"
                }
            },
            "requiredInputs": [
                "defaultPoolIds",
                "fallbackPoolId",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancer resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "defaultPoolIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of pool IDs ordered by their failover priority. Used whenever region/pop pools are not defined.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable the load balancer. Defaults to `true` (enabled).\n"
                    },
                    "fallbackPoolId": {
                        "type": "string",
                        "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human readable name for this rule.\n"
                    },
                    "popPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                        },
                        "description": "See pop_pools above.\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`.\n"
                    },
                    "regionPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                        },
                        "description": "See region_pools above.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                        },
                        "description": "A list of conditions and overrides for each load balancer operation. See the field documentation below.\n"
                    },
                    "sessionAffinity": {
                        "type": "string",
                        "description": "See field above.\n"
                    },
                    "sessionAffinityAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "See field above.\n"
                    },
                    "sessionAffinityTtl": {
                        "type": "integer",
                        "description": "See field above.\n"
                    },
                    "steeringPolicy": {
                        "type": "string",
                        "description": "See field above.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "See field above.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to add the load balancer to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor": {
            "description": "If you're using Cloudflare's Load Balancing to load-balance across multiple origin servers or data centers, you configure one of these Monitors to actively check the availability of those servers over HTTP(S) or TCP.\n\n\u003e **Note:** When creating a monitor, you have to pass `account_id` to the provider configuration in order to create account level resources. Otherwise, by default, it will be a user level resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### HTTP Monitor\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst httpMonitor = new cloudflare.LoadBalancerMonitor(\"http_monitor\", {\n    allowInsecure: false,\n    description: \"example http load balancer\",\n    expectedBody: \"alive\",\n    expectedCodes: \"2xx\",\n    followRedirects: true,\n    headers: [{\n        header: \"Host\",\n        values: [\"example.com\"],\n    }],\n    interval: 60,\n    method: \"GET\",\n    path: \"/health\",\n    probeZone: \"example.com\",\n    retries: 5,\n    timeout: 7,\n    type: \"http\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhttp_monitor = cloudflare.LoadBalancerMonitor(\"httpMonitor\",\n    allow_insecure=False,\n    description=\"example http load balancer\",\n    expected_body=\"alive\",\n    expected_codes=\"2xx\",\n    follow_redirects=True,\n    headers=[cloudflare.LoadBalancerMonitorHeaderArgs(\n        header=\"Host\",\n        values=[\"example.com\"],\n    )],\n    interval=60,\n    method=\"GET\",\n    path=\"/health\",\n    probe_zone=\"example.com\",\n    retries=5,\n    timeout=7,\n    type=\"http\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var httpMonitor = new Cloudflare.LoadBalancerMonitor(\"httpMonitor\", new Cloudflare.LoadBalancerMonitorArgs\n        {\n            AllowInsecure = false,\n            Description = \"example http load balancer\",\n            ExpectedBody = \"alive\",\n            ExpectedCodes = \"2xx\",\n            FollowRedirects = true,\n            Headers = \n            {\n                new Cloudflare.Inputs.LoadBalancerMonitorHeaderArgs\n                {\n                    Header = \"Host\",\n                    Values = \n                    {\n                        \"example.com\",\n                    },\n                },\n            },\n            Interval = 60,\n            Method = \"GET\",\n            Path = \"/health\",\n            ProbeZone = \"example.com\",\n            Retries = 5,\n            Timeout = 7,\n            Type = \"http\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerMonitor(ctx, \"httpMonitor\", \u0026cloudflare.LoadBalancerMonitorArgs{\n\t\t\tAllowInsecure:   pulumi.Bool(false),\n\t\t\tDescription:     pulumi.String(\"example http load balancer\"),\n\t\t\tExpectedBody:    pulumi.String(\"alive\"),\n\t\t\tExpectedCodes:   pulumi.String(\"2xx\"),\n\t\t\tFollowRedirects: pulumi.Bool(true),\n\t\t\tHeaders: LoadBalancerMonitorHeaderArray{\n\t\t\t\t\u0026LoadBalancerMonitorHeaderArgs{\n\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tInterval:  pulumi.Int(60),\n\t\t\tMethod:    pulumi.String(\"GET\"),\n\t\t\tPath:      pulumi.String(\"/health\"),\n\t\t\tProbeZone: pulumi.String(\"example.com\"),\n\t\t\tRetries:   pulumi.Int(5),\n\t\t\tTimeout:   pulumi.Int(7),\n\t\t\tType:      pulumi.String(\"http\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### TCP Monitor\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst tcpMonitor = new cloudflare.LoadBalancerMonitor(\"tcp_monitor\", {\n    description: \"example tcp load balancer\",\n    interval: 60,\n    method: \"connection_established\",\n    port: 8080,\n    retries: 5,\n    timeout: 7,\n    type: \"tcp\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntcp_monitor = cloudflare.LoadBalancerMonitor(\"tcpMonitor\",\n    description=\"example tcp load balancer\",\n    interval=60,\n    method=\"connection_established\",\n    port=8080,\n    retries=5,\n    timeout=7,\n    type=\"tcp\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var tcpMonitor = new Cloudflare.LoadBalancerMonitor(\"tcpMonitor\", new Cloudflare.LoadBalancerMonitorArgs\n        {\n            Description = \"example tcp load balancer\",\n            Interval = 60,\n            Method = \"connection_established\",\n            Port = 8080,\n            Retries = 5,\n            Timeout = 7,\n            Type = \"tcp\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerMonitor(ctx, \"tcpMonitor\", \u0026cloudflare.LoadBalancerMonitorArgs{\n\t\t\tDescription: pulumi.String(\"example tcp load balancer\"),\n\t\t\tInterval:    pulumi.Int(60),\n\t\t\tMethod:      pulumi.String(\"connection_established\"),\n\t\t\tPort:        pulumi.Int(8080),\n\t\t\tRetries:     pulumi.Int(5),\n\t\t\tTimeout:     pulumi.Int(7),\n\t\t\tType:        pulumi.String(\"tcp\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", \"connection_established\" if `type` is \"tcp\", and empty otherwise.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number to use for the healthcheck, required when creating a TCP monitor. Valid values are in the range `0-65535`.\n"
                },
                "probeZone": {
                    "type": "string",
                    "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS', 'TCP', 'UDP-ICMP', 'ICMP-PING', and 'SMTP'. Default: \"http\".\n"
                }
            },
            "required": [
                "createdOn",
                "method",
                "modifiedOn",
                "path"
            ],
            "inputProperties": {
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", \"connection_established\" if `type` is \"tcp\", and empty otherwise.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number to use for the healthcheck, required when creating a TCP monitor. Valid values are in the range `0-65535`.\n"
                },
                "probeZone": {
                    "type": "string",
                    "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS', 'TCP', 'UDP-ICMP', 'ICMP-PING', and 'SMTP'. Default: \"http\".\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerMonitor resources.\n",
                "properties": {
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                    },
                    "expectedCodes": {
                        "type": "string",
                        "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                        },
                        "description": "The header name.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", \"connection_established\" if `type` is \"tcp\", and empty otherwise.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port number to use for the healthcheck, required when creating a TCP monitor. Valid values are in the range `0-65535`.\n"
                    },
                    "probeZone": {
                        "type": "string",
                        "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS', 'TCP', 'UDP-ICMP', 'ICMP-PING', and 'SMTP'. Default: \"http\".\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerPool:LoadBalancerPool": {
            "description": "Provides a Cloudflare Load Balancer pool resource. This provides a pool of origins that can be used by a Cloudflare Load Balancer. Note that the load balancing feature must be enabled in your Cloudflare account before you can use this resource.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst foo = new cloudflare.LoadBalancerPool(\"foo\", {\n    description: \"example load balancer pool\",\n    enabled: false,\n    latitude: 55,\n    loadSheddings: [{\n        defaultPercent: 55,\n        defaultPolicy: \"random\",\n        sessionPercent: 12,\n        sessionPolicy: \"hash\",\n    }],\n    longitude: -12,\n    minimumOrigins: 1,\n    name: \"example-pool\",\n    notificationEmail: \"someone@example.com\",\n    originSteerings: [{\n        policy: \"random\",\n    }],\n    origins: [\n        {\n            address: \"192.0.2.1\",\n            enabled: false,\n            headers: [{\n                header: \"Host\",\n                values: [\"example-1\"],\n            }],\n            name: \"example-1\",\n        },\n        {\n            address: \"192.0.2.2\",\n            headers: [{\n                header: \"Host\",\n                values: [\"example-2\"],\n            }],\n            name: \"example-2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nfoo = cloudflare.LoadBalancerPool(\"foo\",\n    description=\"example load balancer pool\",\n    enabled=False,\n    latitude=55,\n    load_sheddings=[cloudflare.LoadBalancerPoolLoadSheddingArgs(\n        default_percent=55,\n        default_policy=\"random\",\n        session_percent=12,\n        session_policy=\"hash\",\n    )],\n    longitude=-12,\n    minimum_origins=1,\n    name=\"example-pool\",\n    notification_email=\"someone@example.com\",\n    origin_steerings=[cloudflare.LoadBalancerPoolOriginSteeringArgs(\n        policy=\"random\",\n    )],\n    origins=[\n        cloudflare.LoadBalancerPoolOriginArgs(\n            address=\"192.0.2.1\",\n            enabled=False,\n            headers=[cloudflare.LoadBalancerPoolOriginHeaderArgs(\n                header=\"Host\",\n                values=[\"example-1\"],\n            )],\n            name=\"example-1\",\n        ),\n        cloudflare.LoadBalancerPoolOriginArgs(\n            address=\"192.0.2.2\",\n            headers=[cloudflare.LoadBalancerPoolOriginHeaderArgs(\n                header=\"Host\",\n                values=[\"example-2\"],\n            )],\n            name=\"example-2\",\n        ),\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var foo = new Cloudflare.LoadBalancerPool(\"foo\", new Cloudflare.LoadBalancerPoolArgs\n        {\n            Description = \"example load balancer pool\",\n            Enabled = false,\n            Latitude = 55,\n            LoadSheddings = \n            {\n                new Cloudflare.Inputs.LoadBalancerPoolLoadSheddingArgs\n                {\n                    DefaultPercent = 55,\n                    DefaultPolicy = \"random\",\n                    SessionPercent = 12,\n                    SessionPolicy = \"hash\",\n                },\n            },\n            Longitude = -12,\n            MinimumOrigins = 1,\n            Name = \"example-pool\",\n            NotificationEmail = \"someone@example.com\",\n            OriginSteerings = \n            {\n                new Cloudflare.Inputs.LoadBalancerPoolOriginSteeringArgs\n                {\n                    Policy = \"random\",\n                },\n            },\n            Origins = \n            {\n                new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n                {\n                    Address = \"192.0.2.1\",\n                    Enabled = false,\n                    Headers = \n                    {\n                        new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs\n                        {\n                            Header = \"Host\",\n                            Values = \n                            {\n                                \"example-1\",\n                            },\n                        },\n                    },\n                    Name = \"example-1\",\n                },\n                new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n                {\n                    Address = \"192.0.2.2\",\n                    Headers = \n                    {\n                        new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs\n                        {\n                            Header = \"Host\",\n                            Values = \n                            {\n                                \"example-2\",\n                            },\n                        },\n                    },\n                    Name = \"example-2\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerPool(ctx, \"foo\", \u0026cloudflare.LoadBalancerPoolArgs{\n\t\t\tDescription: pulumi.String(\"example load balancer pool\"),\n\t\t\tEnabled:     pulumi.Bool(false),\n\t\t\tLatitude:    pulumi.Float64(55),\n\t\t\tLoadSheddings: LoadBalancerPoolLoadSheddingArray{\n\t\t\t\t\u0026LoadBalancerPoolLoadSheddingArgs{\n\t\t\t\t\tDefaultPercent: pulumi.Float64(55),\n\t\t\t\t\tDefaultPolicy:  pulumi.String(\"random\"),\n\t\t\t\t\tSessionPercent: pulumi.Float64(12),\n\t\t\t\t\tSessionPolicy:  pulumi.String(\"hash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLongitude:         -12,\n\t\t\tMinimumOrigins:    pulumi.Int(1),\n\t\t\tName:              pulumi.String(\"example-pool\"),\n\t\t\tNotificationEmail: pulumi.String(\"someone@example.com\"),\n\t\t\tOriginSteerings: LoadBalancerPoolOriginSteeringArray{\n\t\t\t\t\u0026LoadBalancerPoolOriginSteeringArgs{\n\t\t\t\t\tPolicy: pulumi.String(\"random\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tOrigins: LoadBalancerPoolOriginArray{\n\t\t\t\t\u0026LoadBalancerPoolOriginArgs{\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tHeaders: LoadBalancerPoolOriginHeaderArray{\n\t\t\t\t\t\t\u0026LoadBalancerPoolOriginHeaderArgs{\n\t\t\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"example-1\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.String(\"example-1\"),\n\t\t\t\t},\n\t\t\t\t\u0026LoadBalancerPoolOriginArgs{\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.2\"),\n\t\t\t\t\tHeaders: LoadBalancerPoolOriginHeaderArray{\n\t\t\t\t\t\t\u0026LoadBalancerPoolOriginHeaderArgs{\n\t\t\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"example-2\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.String(\"example-2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude this pool is physically located at; used for proximity steering. Values should be between -90 and 90.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude this pool is physically located at; used for proximity steering. Values should be between -180 and 180.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "originSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                    },
                    "description": "Set an origin steering policy to control origin selection within a pool.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                }
            },
            "required": [
                "checkRegions",
                "createdOn",
                "modifiedOn",
                "name",
                "origins"
            ],
            "inputProperties": {
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude this pool is physically located at; used for proximity steering. Values should be between -90 and 90.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude this pool is physically located at; used for proximity steering. Values should be between -180 and 180.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "originSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                    },
                    "description": "Set an origin steering policy to control origin selection within a pool.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                }
            },
            "requiredInputs": [
                "name",
                "origins"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerPool resources.\n",
                "properties": {
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "The latitude this pool is physically located at; used for proximity steering. Values should be between -90 and 90.\n"
                    },
                    "loadSheddings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                        },
                        "description": "Setting for controlling load shedding for this pool.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "The longitude this pool is physically located at; used for proximity steering. Values should be between -180 and 180.\n"
                    },
                    "minimumOrigins": {
                        "type": "integer",
                        "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "monitor": {
                        "type": "string",
                        "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-identifiable name for the origin.\n"
                    },
                    "notificationEmail": {
                        "type": "string",
                        "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                    },
                    "originSteerings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                        },
                        "description": "Set an origin steering policy to control origin selection within a pool.\n"
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                        },
                        "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logPushOwnershipChallenge:LogPushOwnershipChallenge": {
            "description": "Provides a resource which manages Cloudflare Logpush ownership challenges to use\nin a Logpush Job. On it's own, doesn't do much however this resource should\nbe used in conjunction to create Logpush jobs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogPushOwnershipChallenge(\"example\", {\n    destinationConf: \"s3://my-bucket-path?region=us-west-2\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogPushOwnershipChallenge(\"example\",\n    destination_conf=\"s3://my-bucket-path?region=us-west-2\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.LogPushOwnershipChallenge(\"example\", new Cloudflare.LogPushOwnershipChallengeArgs\n        {\n            DestinationConf = \"s3://my-bucket-path?region=us-west-2\",\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogPushOwnershipChallenge(ctx, \"example\", \u0026cloudflare.LogPushOwnershipChallengeArgs{\n\t\t\tDestinationConf: pulumi.String(\"s3://my-bucket-path?region=us-west-2\"),\n\t\t\tZoneId:          pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogPushOwnershipChallenge(\"example\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    destinationConf: \"s3://my-bucket-path?region=us-west-2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogPushOwnershipChallenge(\"example\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    destination_conf=\"s3://my-bucket-path?region=us-west-2\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.LogPushOwnershipChallenge(\"example\", new Cloudflare.LogPushOwnershipChallengeArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            DestinationConf = \"s3://my-bucket-path?region=us-west-2\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogPushOwnershipChallenge(ctx, \"example\", \u0026cloudflare.LogPushOwnershipChallengeArgs{\n\t\t\tAccountId:       pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tDestinationConf: pulumi.String(\"s3://my-bucket-path?region=us-west-2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                },
                "ownershipChallengeFilename": {
                    "type": "string",
                    "description": "The filename of the ownership challenge which\ncontains the contents required for Logpush Job creation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                }
            },
            "required": [
                "destinationConf",
                "ownershipChallengeFilename"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                }
            },
            "requiredInputs": [
                "destinationConf"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogPushOwnershipChallenge resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                    },
                    "ownershipChallengeFilename": {
                        "type": "string",
                        "description": "The filename of the ownership challenge which\ncontains the contents required for Logpush Job creation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpullRetention:LogpullRetention": {
            "description": "Allows management of the Logpull Retention settings used to control whether or not to retain HTTP request logs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpullRetention(\"example\", {\n    enabled: true,\n    zoneId: \"fb54f084ca7f7b732d3d3ecbd8ef7bf2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpullRetention(\"example\",\n    enabled=True,\n    zone_id=\"fb54f084ca7f7b732d3d3ecbd8ef7bf2\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.LogpullRetention(\"example\", new Cloudflare.LogpullRetentionArgs\n        {\n            Enabled = true,\n            ZoneId = \"fb54f084ca7f7b732d3d3ecbd8ef7bf2\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogpullRetention(ctx, \"example\", \u0026cloudflare.LogpullRetentionArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tZoneId:  pulumi.String(\"fb54f084ca7f7b732d3d3ecbd8ef7bf2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import existing Logpull Retention using the zone ID as the identifier.\n\n```sh\n $ pulumi import cloudflare:index/logpullRetention:LogpullRetention example fb54f084ca7f7b732d3d3ecbd8ef7bf2\n```\n\n ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to apply the log retention to.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to apply the log retention to.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpullRetention resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether you wish to retain logs or not.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to apply the log retention to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpushJob:LogpushJob": {
            "description": "\n\n\n## Import\n\nLogpush jobs can be imported using a composite ID formed of* `identifierType` - Either `account` or `zone`. * `identifierID` - The ID of the account or zone. * `jobID` - The Logpush Job ID to import. Import an account-scoped job using `account/:accountID/:jobID`\n\n```sh\n $ pulumi import cloudflare:index/logpushJob:LogpushJob example account/1d5fdc9e88c8a8c4518b068cd94331fe/54321\n```\n\n Import a zone-scoped job using `zone/:zoneID/:jobID`\n\n```sh\n $ pulumi import cloudflare:index/logpushJob:LogpushJob example zone/d41d8cd98f00b204e9800998ecf8427e/54321\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the logpush job should be created. Either `account_id` or `zone_id` are required.\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "Which type of dataset resource to use. Available values are\n- [account-scoped](https://developers.cloudflare.com/logs/reference/log-fields/account): `\"audit_logs\"`, `\"gateway_dns\"`, `\"gateway_http\"`, `\"gateway_network\"`\n- [zone-scoped](https://developers.cloudflare.com/logs/reference/log-fields/zone): `\"firewall_events\"`, `\"http_requests\"`, `\"spectrum_events\"`, `\"nel_reports\"`\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable the job.\n"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create. Must match the regular expression `^[a-zA-Z0-9\\-\\.]*$`.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage,\nMicrosoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush job should be created. Either `account_id` or `zone_id` are required.\n"
                }
            },
            "required": [
                "dataset",
                "destinationConf"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the logpush job should be created. Either `account_id` or `zone_id` are required.\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "Which type of dataset resource to use. Available values are\n- [account-scoped](https://developers.cloudflare.com/logs/reference/log-fields/account): `\"audit_logs\"`, `\"gateway_dns\"`, `\"gateway_http\"`, `\"gateway_network\"`\n- [zone-scoped](https://developers.cloudflare.com/logs/reference/log-fields/zone): `\"firewall_events\"`, `\"http_requests\"`, `\"spectrum_events\"`, `\"nel_reports\"`\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable the job.\n"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create. Must match the regular expression `^[a-zA-Z0-9\\-\\.]*$`.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage,\nMicrosoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush job should be created. Either `account_id` or `zone_id` are required.\n"
                }
            },
            "requiredInputs": [
                "dataset",
                "destinationConf"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpushJob resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID where the logpush job should be created. Either `account_id` or `zone_id` are required.\n"
                    },
                    "dataset": {
                        "type": "string",
                        "description": "Which type of dataset resource to use. Available values are\n- [account-scoped](https://developers.cloudflare.com/logs/reference/log-fields/account): `\"audit_logs\"`, `\"gateway_dns\"`, `\"gateway_http\"`, `\"gateway_network\"`\n- [zone-scoped](https://developers.cloudflare.com/logs/reference/log-fields/zone): `\"firewall_events\"`, `\"http_requests\"`, `\"spectrum_events\"`, `\"nel_reports\"`\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable the job.\n"
                    },
                    "logpullOptions": {
                        "type": "string",
                        "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the logpush job to create. Must match the regular expression `^[a-zA-Z0-9\\-\\.]*$`.\n"
                    },
                    "ownershipChallenge": {
                        "type": "string",
                        "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage,\nMicrosoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the logpush job should be created. Either `account_id` or `zone_id` are required.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset": {
            "description": "Magic Firewall is a network-level firewall to protect networks that are onboarded to Cloudflare's Magic Transit. This resource\ncreates a root ruleset on the account level and contains one or more rules. Rules can be crafted in Wireshark syntax and\nare evaluated in order, with the first rule having the highest priority. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MagicFirewallRuleset(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Global mitigations\",\n    name: \"Magic Transit Ruleset\",\n    rules: [\n        {\n            action: \"allow\",\n            description: \"Allow TCP Ephemeral Ports\",\n            enabled: \"true\",\n            expression: \"tcp.dstport in { 32768..65535 }\",\n        },\n        {\n            action: \"block\",\n            description: \"Block all\",\n            enabled: \"true\",\n            expression: \"ip.len \u003e= 0\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MagicFirewallRuleset(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Global mitigations\",\n    name=\"Magic Transit Ruleset\",\n    rules=[\n        {\n            \"action\": \"allow\",\n            \"description\": \"Allow TCP Ephemeral Ports\",\n            \"enabled\": \"true\",\n            \"expression\": \"tcp.dstport in { 32768..65535 }\",\n        },\n        {\n            \"action\": \"block\",\n            \"description\": \"Block all\",\n            \"enabled\": \"true\",\n            \"expression\": \"ip.len \u003e= 0\",\n        },\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.MagicFirewallRuleset(\"example\", new Cloudflare.MagicFirewallRulesetArgs\n        {\n            AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Description = \"Global mitigations\",\n            Name = \"Magic Transit Ruleset\",\n            Rules = \n            {\n                \n                {\n                    { \"action\", \"allow\" },\n                    { \"description\", \"Allow TCP Ephemeral Ports\" },\n                    { \"enabled\", \"true\" },\n                    { \"expression\", \"tcp.dstport in { 32768..65535 }\" },\n                },\n                \n                {\n                    { \"action\", \"block\" },\n                    { \"description\", \"Block all\" },\n                    { \"enabled\", \"true\" },\n                    { \"expression\", \"ip.len \u003e= 0\" },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMagicFirewallRuleset(ctx, \"example\", \u0026cloudflare.MagicFirewallRulesetArgs{\n\t\t\tAccountId:   pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription: pulumi.String(\"Global mitigations\"),\n\t\t\tName:        pulumi.String(\"Magic Transit Ruleset\"),\n\t\t\tRules: pulumi.StringMapArray{\n\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\"action\":      pulumi.String(\"allow\"),\n\t\t\t\t\t\"description\": pulumi.String(\"Allow TCP Ephemeral Ports\"),\n\t\t\t\t\t\"enabled\":     pulumi.String(\"true\"),\n\t\t\t\t\t\"expression\":  pulumi.String(\"tcp.dstport in { 32768..65535 }\"),\n\t\t\t\t},\n\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\"action\":      pulumi.String(\"block\"),\n\t\t\t\t\t\"description\": pulumi.String(\"Block all\"),\n\t\t\t\t\t\"enabled\":     pulumi.String(\"true\"),\n\t\t\t\t\t\"expression\":  pulumi.String(\"ip.len \u003e= 0\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing Magic Firewall Ruleset can be imported using the account ID and ruleset ID\n\n```sh\n $ pulumi import cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ruleset.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ruleset.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MagicFirewallRuleset resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the ruleset is being created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that can be used to annotate the rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ruleset.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/notificationPolicy:NotificationPolicy": {
            "description": "Provides a resource, that manages a notification policy for Cloudflare's products. The delivery\nmechanisms supported are email, webhooks, and PagerDuty.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.NotificationPolicy(\"example\", {\n    accountId: \"c4a7362d577a6c3019a474fd6f485821\",\n    alertType: \"universal_ssl_event_type\",\n    description: \"Notification policy to alert when my SSL certificates are modified\",\n    emailIntegrations: [{\n        id: \"myemail@example.com\",\n    }],\n    enabled: true,\n    name: \"Policy for SSL notification events\",\n    pagerdutyIntegrations: [{\n        id: \"850129d136459401860572c5d964d27k\",\n    }],\n    webhooksIntegrations: [{\n        id: \"1860572c5d964d27aa0f379d13645940\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.NotificationPolicy(\"example\",\n    account_id=\"c4a7362d577a6c3019a474fd6f485821\",\n    alert_type=\"universal_ssl_event_type\",\n    description=\"Notification policy to alert when my SSL certificates are modified\",\n    email_integrations=[cloudflare.NotificationPolicyEmailIntegrationArgs(\n        id=\"myemail@example.com\",\n    )],\n    enabled=True,\n    name=\"Policy for SSL notification events\",\n    pagerduty_integrations=[cloudflare.NotificationPolicyPagerdutyIntegrationArgs(\n        id=\"850129d136459401860572c5d964d27k\",\n    )],\n    webhooks_integrations=[cloudflare.NotificationPolicyWebhooksIntegrationArgs(\n        id=\"1860572c5d964d27aa0f379d13645940\",\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.NotificationPolicy(\"example\", new Cloudflare.NotificationPolicyArgs\n        {\n            AccountId = \"c4a7362d577a6c3019a474fd6f485821\",\n            AlertType = \"universal_ssl_event_type\",\n            Description = \"Notification policy to alert when my SSL certificates are modified\",\n            EmailIntegrations = \n            {\n                new Cloudflare.Inputs.NotificationPolicyEmailIntegrationArgs\n                {\n                    Id = \"myemail@example.com\",\n                },\n            },\n            Enabled = true,\n            Name = \"Policy for SSL notification events\",\n            PagerdutyIntegrations = \n            {\n                new Cloudflare.Inputs.NotificationPolicyPagerdutyIntegrationArgs\n                {\n                    Id = \"850129d136459401860572c5d964d27k\",\n                },\n            },\n            WebhooksIntegrations = \n            {\n                new Cloudflare.Inputs.NotificationPolicyWebhooksIntegrationArgs\n                {\n                    Id = \"1860572c5d964d27aa0f379d13645940\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewNotificationPolicy(ctx, \"example\", \u0026cloudflare.NotificationPolicyArgs{\n\t\t\tAccountId:   pulumi.String(\"c4a7362d577a6c3019a474fd6f485821\"),\n\t\t\tAlertType:   pulumi.String(\"universal_ssl_event_type\"),\n\t\t\tDescription: pulumi.String(\"Notification policy to alert when my SSL certificates are modified\"),\n\t\t\tEmailIntegrations: NotificationPolicyEmailIntegrationArray{\n\t\t\t\t\u0026NotificationPolicyEmailIntegrationArgs{\n\t\t\t\t\tId: pulumi.String(\"myemail@example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tName:    pulumi.String(\"Policy for SSL notification events\"),\n\t\t\tPagerdutyIntegrations: NotificationPolicyPagerdutyIntegrationArray{\n\t\t\t\t\u0026NotificationPolicyPagerdutyIntegrationArgs{\n\t\t\t\t\tId: pulumi.String(\"850129d136459401860572c5d964d27k\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWebhooksIntegrations: NotificationPolicyWebhooksIntegrationArray{\n\t\t\t\t\u0026NotificationPolicyWebhooksIntegrationArgs{\n\t\t\t\t\tId: pulumi.String(\"1860572c5d964d27aa0f379d13645940\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing notification policy can be imported using the account ID and the policy ID\n\n```sh\n $ pulumi import cloudflare:index/notificationPolicy:NotificationPolicy example 72c379d136459405d964d27aa0f18605/c4a7362d577a6c3019a474fd6f485821\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account for which the notification policy has to be created.\n"
                },
                "alertType": {
                    "type": "string",
                    "description": "The event type that will trigger the dispatch of a notification.\n"
                },
                "conditions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "created": {
                    "type": "string"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the notification policy.\n"
                },
                "emailIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                    },
                    "description": "The email id to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "The status of the notification policy, a boolean value.\n"
                },
                "filters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "Optional filterable items for a policy.\n"
                },
                "modified": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n"
                },
                "pagerdutyIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                    },
                    "description": "The unique id of a configured pagerduty endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "webhooksIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                    },
                    "description": "The unique id of a configured webhooks endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                }
            },
            "required": [
                "accountId",
                "alertType",
                "created",
                "enabled",
                "modified",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account for which the notification policy has to be created.\n"
                },
                "alertType": {
                    "type": "string",
                    "description": "The event type that will trigger the dispatch of a notification.\n"
                },
                "conditions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of the notification policy.\n"
                },
                "emailIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                    },
                    "description": "The email id to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "The status of the notification policy, a boolean value.\n"
                },
                "filters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "Optional filterable items for a policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n"
                },
                "pagerdutyIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                    },
                    "description": "The unique id of a configured pagerduty endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "webhooksIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                    },
                    "description": "The unique id of a configured webhooks endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "alertType",
                "enabled",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account for which the notification policy has to be created.\n"
                    },
                    "alertType": {
                        "type": "string",
                        "description": "The event type that will trigger the dispatch of a notification.\n"
                    },
                    "conditions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "created": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the notification policy.\n"
                    },
                    "emailIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                        },
                        "description": "The email id to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "The status of the notification policy, a boolean value.\n"
                    },
                    "filters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "array",
                            "items": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "Optional filterable items for a policy.\n"
                    },
                    "modified": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the notification policy.\n"
                    },
                    "pagerdutyIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                        },
                        "description": "The unique id of a configured pagerduty endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                    },
                    "webhooksIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                        },
                        "description": "The unique id of a configured webhooks endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks": {
            "description": "Provides a resource, that manages a webhook destination. These destinations can be tied to the notification policies created for Cloudflare's products.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.NotificationPolicyWebhooks(\"example\", {\n    accountId: \"c4a7362d577a6c3019a474fd6f485821\",\n    name: \"Webhooks destination\",\n    secret: \"my-secret\",\n    url: \"https://example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.NotificationPolicyWebhooks(\"example\",\n    account_id=\"c4a7362d577a6c3019a474fd6f485821\",\n    name=\"Webhooks destination\",\n    secret=\"my-secret\",\n    url=\"https://example.com\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.NotificationPolicyWebhooks(\"example\", new Cloudflare.NotificationPolicyWebhooksArgs\n        {\n            AccountId = \"c4a7362d577a6c3019a474fd6f485821\",\n            Name = \"Webhooks destination\",\n            Secret = \"my-secret\",\n            Url = \"https://example.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewNotificationPolicyWebhooks(ctx, \"example\", \u0026cloudflare.NotificationPolicyWebhooksArgs{\n\t\t\tAccountId: pulumi.String(\"c4a7362d577a6c3019a474fd6f485821\"),\n\t\t\tName:      pulumi.String(\"Webhooks destination\"),\n\t\t\tSecret:    pulumi.String(\"my-secret\"),\n\t\t\tUrl:       pulumi.String(\"https://example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing notification policy can be imported using the account ID and the webhook ID\n\n```sh\n $ pulumi import cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks example 72c379d136459405d964d27aa0f18605/c4a7362d577a6c3019a474fd6f485821\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account for which the webhook destination has to be connected.\n"
                },
                "createdAt": {
                    "type": "string"
                },
                "lastFailure": {
                    "type": "string"
                },
                "lastSuccess": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the webhook destination.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. \nSecrets are not returned in any API response body.\nRefer to the documentation for more details - https://api.cloudflare.com/#notification-webhooks-create-webhook.\n"
                },
                "type": {
                    "type": "string"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the webhook destinations.\n"
                }
            },
            "required": [
                "accountId",
                "createdAt",
                "lastFailure",
                "lastSuccess",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account for which the webhook destination has to be connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the webhook destination.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. \nSecrets are not returned in any API response body.\nRefer to the documentation for more details - https://api.cloudflare.com/#notification-webhooks-create-webhook.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the webhook destinations.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationPolicyWebhooks resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account for which the webhook destination has to be connected.\n"
                    },
                    "createdAt": {
                        "type": "string"
                    },
                    "lastFailure": {
                        "type": "string"
                    },
                    "lastSuccess": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the webhook destination.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. \nSecrets are not returned in any API response body.\nRefer to the documentation for more details - https://api.cloudflare.com/#notification-webhooks-create-webhook.\n"
                    },
                    "type": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the webhook destinations.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/originCaCertificate:OriginCaCertificate": {
            "description": "Provides a Cloudflare Origin CA certificate used to protect traffic to your origin without involving a third party Certificate Authority.\n\n**This resource requires you use your Origin CA Key as the `api_user_service_key`, in conjunction with an `api_token` or `email` and `api_key`.**\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as tls from \"@pulumi/tls\";\n\n// Create a CSR and generate a CA certificate\nconst examplePrivateKey = new tls.PrivateKey(\"examplePrivateKey\", {algorithm: \"RSA\"});\nconst exampleCertRequest = new tls.CertRequest(\"exampleCertRequest\", {\n    keyAlgorithm: examplePrivateKey.algorithm,\n    privateKeyPem: examplePrivateKey.privateKeyPem,\n    subjects: [{\n        commonName: \"\",\n        organization: \"Terraform Test\",\n    }],\n});\nconst exampleOriginCaCertificate = new cloudflare.OriginCaCertificate(\"exampleOriginCaCertificate\", {\n    csr: exampleCertRequest.certRequestPem,\n    hostnames: [\"example.com\"],\n    requestType: \"origin-rsa\",\n    requestedValidity: 7,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_tls as tls\n\n# Create a CSR and generate a CA certificate\nexample_private_key = tls.PrivateKey(\"examplePrivateKey\", algorithm=\"RSA\")\nexample_cert_request = tls.CertRequest(\"exampleCertRequest\",\n    key_algorithm=example_private_key.algorithm,\n    private_key_pem=example_private_key.private_key_pem,\n    subjects=[tls.CertRequestSubjectArgs(\n        common_name=\"\",\n        organization=\"Terraform Test\",\n    )])\nexample_origin_ca_certificate = cloudflare.OriginCaCertificate(\"exampleOriginCaCertificate\",\n    csr=example_cert_request.cert_request_pem,\n    hostnames=[\"example.com\"],\n    request_type=\"origin-rsa\",\n    requested_validity=7)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Tls = Pulumi.Tls;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a CSR and generate a CA certificate\n        var examplePrivateKey = new Tls.PrivateKey(\"examplePrivateKey\", new Tls.PrivateKeyArgs\n        {\n            Algorithm = \"RSA\",\n        });\n        var exampleCertRequest = new Tls.CertRequest(\"exampleCertRequest\", new Tls.CertRequestArgs\n        {\n            KeyAlgorithm = examplePrivateKey.Algorithm,\n            PrivateKeyPem = examplePrivateKey.PrivateKeyPem,\n            Subjects = \n            {\n                new Tls.Inputs.CertRequestSubjectArgs\n                {\n                    CommonName = \"\",\n                    Organization = \"Terraform Test\",\n                },\n            },\n        });\n        var exampleOriginCaCertificate = new Cloudflare.OriginCaCertificate(\"exampleOriginCaCertificate\", new Cloudflare.OriginCaCertificateArgs\n        {\n            Csr = exampleCertRequest.CertRequestPem,\n            Hostnames = \n            {\n                \"example.com\",\n            },\n            RequestType = \"origin-rsa\",\n            RequestedValidity = 7,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-tls/sdk/v4/go/tls\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePrivateKey, err := tls.NewPrivateKey(ctx, \"examplePrivateKey\", \u0026tls.PrivateKeyArgs{\n\t\t\tAlgorithm: pulumi.String(\"RSA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCertRequest, err := tls.NewCertRequest(ctx, \"exampleCertRequest\", \u0026tls.CertRequestArgs{\n\t\t\tKeyAlgorithm:  examplePrivateKey.Algorithm,\n\t\t\tPrivateKeyPem: examplePrivateKey.PrivateKeyPem,\n\t\t\tSubjects: CertRequestSubjectArray{\n\t\t\t\t\u0026CertRequestSubjectArgs{\n\t\t\t\t\tCommonName:   pulumi.String(\"\"),\n\t\t\t\t\tOrganization: pulumi.String(\"Terraform Test\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewOriginCaCertificate(ctx, \"exampleOriginCaCertificate\", \u0026cloudflare.OriginCaCertificateArgs{\n\t\t\tCsr: exampleCertRequest.CertRequestPem,\n\t\t\tHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t},\n\t\t\tRequestType:       pulumi.String(\"origin-rsa\"),\n\t\t\tRequestedValidity: pulumi.Int(7),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nOrigin CA certificate resource can be imported using an ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/originCaCertificate:OriginCaCertificate example 276266538771611802607153687288146423901027769273\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The Origin CA certificate\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded.\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The datetime when the certificate will expire.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of hostnames or wildcard names bound to the certificate.\n"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate.\n"
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid.\n"
                }
            },
            "required": [
                "certificate",
                "expiresOn",
                "hostnames",
                "requestType",
                "requestedValidity"
            ],
            "inputProperties": {
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of hostnames or wildcard names bound to the certificate.\n"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate.\n"
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid.\n"
                }
            },
            "requiredInputs": [
                "hostnames",
                "requestType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OriginCaCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The Origin CA certificate\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The Certificate Signing Request. Must be newline-encoded.\n"
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "The datetime when the certificate will expire.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of hostnames or wildcard names bound to the certificate.\n"
                    },
                    "requestType": {
                        "type": "string",
                        "description": "The signature type desired on the certificate.\n"
                    },
                    "requestedValidity": {
                        "type": "integer",
                        "description": "The number of days for which the certificate should be valid.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pageRule:PageRule": {
            "description": "Provides a Cloudflare page rule resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a page rule to the domain\nconst foobar = new cloudflare.PageRule(\"foobar\", {\n    zoneId: _var.cloudflare_zone_id,\n    target: `sub.${_var.cloudflare_zone}/page`,\n    priority: 1,\n    actions: {\n        ssl: \"flexible\",\n        emailObfuscation: \"on\",\n        minifies: [{\n            html: \"off\",\n            css: \"on\",\n            js: \"on\",\n        }],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a page rule to the domain\nfoobar = cloudflare.PageRule(\"foobar\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    target=f\"sub.{var['cloudflare_zone']}/page\",\n    priority=1,\n    actions=cloudflare.PageRuleActionsArgs(\n        ssl=\"flexible\",\n        email_obfuscation=\"on\",\n        minifies=[cloudflare.PageRuleActionsMinifyArgs(\n            html=\"off\",\n            css=\"on\",\n            js=\"on\",\n        )],\n    ))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Add a page rule to the domain\n        var foobar = new Cloudflare.PageRule(\"foobar\", new Cloudflare.PageRuleArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Target = $\"sub.{@var.Cloudflare_zone}/page\",\n            Priority = 1,\n            Actions = new Cloudflare.Inputs.PageRuleActionsArgs\n            {\n                Ssl = \"flexible\",\n                EmailObfuscation = \"on\",\n                Minifies = \n                {\n                    new Cloudflare.Inputs.PageRuleActionsMinifyArgs\n                    {\n                        Html = \"off\",\n                        Css = \"on\",\n                        Js = \"on\",\n                    },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewPageRule(ctx, \"foobar\", \u0026cloudflare.PageRuleArgs{\n\t\t\tZoneId:   pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tTarget:   pulumi.String(fmt.Sprintf(\"%v%v%v\", \"sub.\", _var.Cloudflare_zone, \"/page\")),\n\t\t\tPriority: pulumi.Int(1),\n\t\t\tActions: \u0026PageRuleActionsArgs{\n\t\t\t\tSsl:              pulumi.String(\"flexible\"),\n\t\t\t\tEmailObfuscation: pulumi.String(\"on\"),\n\t\t\t\tMinifies: PageRuleActionsMinifyArray{\n\t\t\t\t\t\u0026PageRuleActionsMinifyArgs{\n\t\t\t\t\t\tHtml: pulumi.String(\"off\"),\n\t\t\t\t\t\tCss:  pulumi.String(\"on\"),\n\t\t\t\t\t\tJs:   pulumi.String(\"on\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPage rules can be imported using a composite ID formed of zone ID and page rule ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/pageRule:PageRule default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43\n```\n\n ",
            "properties": {
                "actions": {
                    "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n"
                }
            },
            "required": [
                "actions",
                "target",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n"
                }
            },
            "requiredInputs": [
                "actions",
                "target",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PageRule resources.\n",
                "properties": {
                    "actions": {
                        "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                        "description": "The actions taken by the page rule, options given below.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Whether the page rule is active or disabled.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The URL pattern to target with the page rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the page rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/rateLimit:RateLimit": {
            "description": "Provides a Cloudflare rate limit resource for a given zone. This can be used to limit the traffic you receive zone-wide, or matching more specific types of requests/responses.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.RateLimit(\"example\", {\n    zoneId: _var.cloudflare_zone_id,\n    threshold: 2000,\n    period: 2,\n    match: {\n        request: {\n            urlPattern: `${_var.cloudflare_zone}/*`,\n            schemes: [\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            methods: [\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        },\n        response: {\n            statuses: [\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            originTraffic: false,\n            headers: [\n                {\n                    name: \"Host\",\n                    op: \"eq\",\n                    value: \"localhost\",\n                },\n                {\n                    name: \"X-Example\",\n                    op: \"ne\",\n                    value: \"my-example\",\n                },\n            ],\n        },\n    },\n    action: {\n        mode: \"simulate\",\n        timeout: 43200,\n        response: {\n            contentType: \"text/plain\",\n            body: \"custom response body\",\n        },\n    },\n    correlate: {\n        by: \"nat\",\n    },\n    disabled: false,\n    description: \"example rate limit for a zone\",\n    bypassUrlPatterns: [\n        `${_var.cloudflare_zone}/bypass1`,\n        `${_var.cloudflare_zone}/bypass2`,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.RateLimit(\"example\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    threshold=2000,\n    period=2,\n    match=cloudflare.RateLimitMatchArgs(\n        request=cloudflare.RateLimitMatchRequestArgs(\n            url_pattern=f\"{var['cloudflare_zone']}/*\",\n            schemes=[\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            methods=[\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        ),\n        response=cloudflare.RateLimitMatchResponseArgs(\n            statuses=[\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            origin_traffic=False,\n            headers=[\n                {\n                    \"name\": \"Host\",\n                    \"op\": \"eq\",\n                    \"value\": \"localhost\",\n                },\n                {\n                    \"name\": \"X-Example\",\n                    \"op\": \"ne\",\n                    \"value\": \"my-example\",\n                },\n            ],\n        ),\n    ),\n    action=cloudflare.RateLimitActionArgs(\n        mode=\"simulate\",\n        timeout=43200,\n        response=cloudflare.RateLimitActionResponseArgs(\n            content_type=\"text/plain\",\n            body=\"custom response body\",\n        ),\n    ),\n    correlate=cloudflare.RateLimitCorrelateArgs(\n        by=\"nat\",\n    ),\n    disabled=False,\n    description=\"example rate limit for a zone\",\n    bypass_url_patterns=[\n        f\"{var['cloudflare_zone']}/bypass1\",\n        f\"{var['cloudflare_zone']}/bypass2\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.RateLimit(\"example\", new Cloudflare.RateLimitArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Threshold = 2000,\n            Period = 2,\n            Match = new Cloudflare.Inputs.RateLimitMatchArgs\n            {\n                Request = new Cloudflare.Inputs.RateLimitMatchRequestArgs\n                {\n                    UrlPattern = $\"{@var.Cloudflare_zone}/*\",\n                    Schemes = \n                    {\n                        \"HTTP\",\n                        \"HTTPS\",\n                    },\n                    Methods = \n                    {\n                        \"GET\",\n                        \"POST\",\n                        \"PUT\",\n                        \"DELETE\",\n                        \"PATCH\",\n                        \"HEAD\",\n                    },\n                },\n                Response = new Cloudflare.Inputs.RateLimitMatchResponseArgs\n                {\n                    Statuses = \n                    {\n                        200,\n                        201,\n                        202,\n                        301,\n                        429,\n                    },\n                    OriginTraffic = false,\n                    Headers = \n                    {\n                        \n                        {\n                            { \"name\", \"Host\" },\n                            { \"op\", \"eq\" },\n                            { \"value\", \"localhost\" },\n                        },\n                        \n                        {\n                            { \"name\", \"X-Example\" },\n                            { \"op\", \"ne\" },\n                            { \"value\", \"my-example\" },\n                        },\n                    },\n                },\n            },\n            Action = new Cloudflare.Inputs.RateLimitActionArgs\n            {\n                Mode = \"simulate\",\n                Timeout = 43200,\n                Response = new Cloudflare.Inputs.RateLimitActionResponseArgs\n                {\n                    ContentType = \"text/plain\",\n                    Body = \"custom response body\",\n                },\n            },\n            Correlate = new Cloudflare.Inputs.RateLimitCorrelateArgs\n            {\n                By = \"nat\",\n            },\n            Disabled = false,\n            Description = \"example rate limit for a zone\",\n            BypassUrlPatterns = \n            {\n                $\"{@var.Cloudflare_zone}/bypass1\",\n                $\"{@var.Cloudflare_zone}/bypass2\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewRateLimit(ctx, \"example\", \u0026cloudflare.RateLimitArgs{\n\t\t\tZoneId:    pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tThreshold: pulumi.Int(2000),\n\t\t\tPeriod:    pulumi.Int(2),\n\t\t\tMatch: \u0026RateLimitMatchArgs{\n\t\t\t\tRequest: \u0026RateLimitMatchRequestArgs{\n\t\t\t\t\tUrlPattern: pulumi.String(fmt.Sprintf(\"%v%v\", _var.Cloudflare_zone, \"/*\")),\n\t\t\t\t\tSchemes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"HTTP\"),\n\t\t\t\t\t\tpulumi.String(\"HTTPS\"),\n\t\t\t\t\t},\n\t\t\t\t\tMethods: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GET\"),\n\t\t\t\t\t\tpulumi.String(\"POST\"),\n\t\t\t\t\t\tpulumi.String(\"PUT\"),\n\t\t\t\t\t\tpulumi.String(\"DELETE\"),\n\t\t\t\t\t\tpulumi.String(\"PATCH\"),\n\t\t\t\t\t\tpulumi.String(\"HEAD\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponse: \u0026RateLimitMatchResponseArgs{\n\t\t\t\t\tStatuses: pulumi.IntArray{\n\t\t\t\t\t\tpulumi.Int(200),\n\t\t\t\t\t\tpulumi.Int(201),\n\t\t\t\t\t\tpulumi.Int(202),\n\t\t\t\t\t\tpulumi.Int(301),\n\t\t\t\t\t\tpulumi.Int(429),\n\t\t\t\t\t},\n\t\t\t\t\tOriginTraffic: pulumi.Bool(false),\n\t\t\t\t\tHeaders: pulumi.StringMapArray{\n\t\t\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\t\t\"name\":  pulumi.String(\"Host\"),\n\t\t\t\t\t\t\t\"op\":    pulumi.String(\"eq\"),\n\t\t\t\t\t\t\t\"value\": pulumi.String(\"localhost\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\t\t\"name\":  pulumi.String(\"X-Example\"),\n\t\t\t\t\t\t\t\"op\":    pulumi.String(\"ne\"),\n\t\t\t\t\t\t\t\"value\": pulumi.String(\"my-example\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: \u0026RateLimitActionArgs{\n\t\t\t\tMode:    pulumi.String(\"simulate\"),\n\t\t\t\tTimeout: pulumi.Int(43200),\n\t\t\t\tResponse: \u0026RateLimitActionResponseArgs{\n\t\t\t\t\tContentType: pulumi.String(\"text/plain\"),\n\t\t\t\t\tBody:        pulumi.String(\"custom response body\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCorrelate: \u0026RateLimitCorrelateArgs{\n\t\t\t\tBy: pulumi.String(\"nat\"),\n\t\t\t},\n\t\t\tDisabled:    pulumi.Bool(false),\n\t\t\tDescription: pulumi.String(\"example rate limit for a zone\"),\n\t\t\tBypassUrlPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(fmt.Sprintf(\"%v%v\", _var.Cloudflare_zone, \"/bypass1\")),\n\t\t\t\tpulumi.String(fmt.Sprintf(\"%v%v\", _var.Cloudflare_zone, \"/bypass2\")),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRate limits can be imported using a composite ID formed of zone name and rate limit ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/rateLimit:RateLimit default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43\n```\n\n ",
            "properties": {
                "action": {
                    "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply rate limiting to.\n"
                }
            },
            "required": [
                "action",
                "match",
                "period",
                "threshold",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply rate limiting to.\n"
                }
            },
            "requiredInputs": [
                "action",
                "period",
                "threshold",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RateLimit resources.\n",
                "properties": {
                    "action": {
                        "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                        "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                    },
                    "bypassUrlPatterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                    },
                    "correlate": {
                        "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                        "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                    },
                    "match": {
                        "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                        "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                    },
                    "threshold": {
                        "type": "integer",
                        "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply rate limiting to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/record:Record": {
            "description": "Provides a Cloudflare record resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a record to the domain\nconst foobar = new cloudflare.Record(\"foobar\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"terraform\",\n    value: \"192.168.0.11\",\n    type: \"A\",\n    ttl: 3600,\n});\n// Add a record requiring a data map\nconst _sipTls = new cloudflare.Record(\"_sipTls\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"_sip._tls\",\n    type: \"SRV\",\n    data: {\n        service: \"_sip\",\n        proto: \"_tls\",\n        name: \"terraform-srv\",\n        priority: 0,\n        weight: 0,\n        port: 443,\n        target: \"example.com\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a record to the domain\nfoobar = cloudflare.Record(\"foobar\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"terraform\",\n    value=\"192.168.0.11\",\n    type=\"A\",\n    ttl=3600)\n# Add a record requiring a data map\n_sip_tls = cloudflare.Record(\"_sipTls\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"_sip._tls\",\n    type=\"SRV\",\n    data=cloudflare.RecordDataArgs(\n        service=\"_sip\",\n        proto=\"_tls\",\n        name=\"terraform-srv\",\n        priority=0,\n        weight=0,\n        port=443,\n        target=\"example.com\",\n    ))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Add a record to the domain\n        var foobar = new Cloudflare.Record(\"foobar\", new Cloudflare.RecordArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Name = \"terraform\",\n            Value = \"192.168.0.11\",\n            Type = \"A\",\n            Ttl = 3600,\n        });\n        // Add a record requiring a data map\n        var _sipTls = new Cloudflare.Record(\"_sipTls\", new Cloudflare.RecordArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Name = \"_sip._tls\",\n            Type = \"SRV\",\n            Data = new Cloudflare.Inputs.RecordDataArgs\n            {\n                Service = \"_sip\",\n                Proto = \"_tls\",\n                Name = \"terraform-srv\",\n                Priority = 0,\n                Weight = 0,\n                Port = 443,\n                Target = \"example.com\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewRecord(ctx, \"foobar\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId: pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:   pulumi.String(\"terraform\"),\n\t\t\tValue:  pulumi.String(\"192.168.0.11\"),\n\t\t\tType:   pulumi.String(\"A\"),\n\t\t\tTtl:    pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewRecord(ctx, \"_sipTls\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId: pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:   pulumi.String(\"_sip._tls\"),\n\t\t\tType:   pulumi.String(\"SRV\"),\n\t\t\tData: \u0026RecordDataArgs{\n\t\t\t\tService:  pulumi.String(\"_sip\"),\n\t\t\t\tProto:    pulumi.String(\"_tls\"),\n\t\t\t\tName:     pulumi.String(\"terraform-srv\"),\n\t\t\t\tPriority: pulumi.Int(0),\n\t\t\t\tWeight:   pulumi.Int(0),\n\t\t\t\tPort:     pulumi.Int(443),\n\t\t\t\tTarget:   pulumi.String(\"example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRecords can be imported using a composite ID formed of zone ID and record ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/record:Record default ae36f999674d196762efcc5abb06b345/d41d8cd98f00b204e9800998ecf8427e\n```\n\n where* `ae36f999674d196762efcc5abb06b345` - the zone ID * `d41d8cd98f00b204e9800998ecf8427e` - record ID as returned by [API](https://api.cloudflare.com/#dns-records-for-a-zone-list-dns-records) ",
            "properties": {
                "allowOverwrite": {
                    "type": "boolean"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was created\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The FQDN of the record\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A key-value map of string metadata Cloudflare associates with the record\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was last modified\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proxiable": {
                    "type": "boolean",
                    "description": "Shows whether this record can be proxied, must be true if setting `proxied=true`\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record\n"
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the record to\n"
                }
            },
            "required": [
                "createdOn",
                "hostname",
                "metadata",
                "modifiedOn",
                "name",
                "proxiable",
                "ttl",
                "type",
                "value",
                "zoneId"
            ],
            "inputProperties": {
                "allowOverwrite": {
                    "type": "boolean"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record\n"
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the record to\n"
                }
            },
            "requiredInputs": [
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Record resources.\n",
                "properties": {
                    "allowOverwrite": {
                        "type": "boolean"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was created\n"
                    },
                    "data": {
                        "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                        "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The FQDN of the record\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A key-value map of string metadata Cloudflare associates with the record\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was last modified\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the record\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the record\n"
                    },
                    "proxiable": {
                        "type": "boolean",
                        "description": "Shows whether this record can be proxied, must be true if setting `proxied=true`\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the record\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The (string) value of the record. Either this or `data` must be specified\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to add the record to\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ruleset:Ruleset": {
            "description": "\n\n\n## Import\n\nCurrently, you cannot import rulesets. ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created. Conflicts with `\"zone_id\"`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset rule and its intended use.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Valid values are `\"custom\"`, `\"managed\"`, `\"root\"`, `\"schema\"` or `\"zone\"`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP request header to target.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Valid values are `\"ddos_l4\"`, `\"ddos_l7\"`, `\"http_request_firewall_custom\"`, `\"http_request_firewall_managed\"`, `\"http_request_late_transform\"`, `\"http_response_headers_transform\"`, `\"http_request_main\"`, `\"http_request_sanitize\"`, `\"http_request_transform\"`, `\"http_response_firewall_managed\"`, `\"magic_transit\"`, or `\"http_ratelimit\"`.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                    },
                    "description": "List of rule-based overrides (refer to the nested schema).\n"
                },
                "shareableEntitlementName": {
                    "type": "string",
                    "description": "Name of entitlement that is shareable between entities.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the zone where the ruleset is being created. Conflicts with `\"account_id\"`.\n"
                }
            },
            "required": [
                "description",
                "kind",
                "name",
                "phase"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created. Conflicts with `\"zone_id\"`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset rule and its intended use.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Valid values are `\"custom\"`, `\"managed\"`, `\"root\"`, `\"schema\"` or `\"zone\"`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the HTTP request header to target.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Valid values are `\"ddos_l4\"`, `\"ddos_l7\"`, `\"http_request_firewall_custom\"`, `\"http_request_firewall_managed\"`, `\"http_request_late_transform\"`, `\"http_response_headers_transform\"`, `\"http_request_main\"`, `\"http_request_sanitize\"`, `\"http_request_transform\"`, `\"http_response_firewall_managed\"`, `\"magic_transit\"`, or `\"http_ratelimit\"`.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                    },
                    "description": "List of rule-based overrides (refer to the nested schema).\n"
                },
                "shareableEntitlementName": {
                    "type": "string",
                    "description": "Name of entitlement that is shareable between entities.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the zone where the ruleset is being created. Conflicts with `\"account_id\"`.\n"
                }
            },
            "requiredInputs": [
                "description",
                "kind",
                "name",
                "phase"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Ruleset resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the ruleset is being created. Conflicts with `\"zone_id\"`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Brief summary of the ruleset rule and its intended use.\n"
                    },
                    "kind": {
                        "type": "string",
                        "description": "Type of Ruleset to create. Valid values are `\"custom\"`, `\"managed\"`, `\"root\"`, `\"schema\"` or `\"zone\"`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the HTTP request header to target.\n"
                    },
                    "phase": {
                        "type": "string",
                        "description": "Point in the request/response lifecycle where the ruleset will be created. Valid values are `\"ddos_l4\"`, `\"ddos_l7\"`, `\"http_request_firewall_custom\"`, `\"http_request_firewall_managed\"`, `\"http_request_late_transform\"`, `\"http_response_headers_transform\"`, `\"http_request_main\"`, `\"http_request_sanitize\"`, `\"http_request_transform\"`, `\"http_response_firewall_managed\"`, `\"magic_transit\"`, or `\"http_ratelimit\"`.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                        },
                        "description": "List of rule-based overrides (refer to the nested schema).\n"
                    },
                    "shareableEntitlementName": {
                        "type": "string",
                        "description": "Name of entitlement that is shareable between entities.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the zone where the ruleset is being created. Conflicts with `\"account_id\"`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/spectrumApplication:SpectrumApplication": {
            "description": "Provides a Cloudflare Spectrum Application. You can extend the power of Cloudflare's DDoS, TLS, and IP Firewall to your other TCP-based services.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Define a spectrum application proxies ssh traffic\nconst sshProxy = new cloudflare.SpectrumApplication(\"sshProxy\", {\n    zoneId: _var.cloudflare_zone_id,\n    protocol: \"tcp/22\",\n    trafficType: \"direct\",\n    dns: {\n        type: \"CNAME\",\n        name: \"ssh.example.com\",\n    },\n    originDirects: [\"tcp://109.151.40.129:22\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Define a spectrum application proxies ssh traffic\nssh_proxy = cloudflare.SpectrumApplication(\"sshProxy\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    protocol=\"tcp/22\",\n    traffic_type=\"direct\",\n    dns=cloudflare.SpectrumApplicationDnsArgs(\n        type=\"CNAME\",\n        name=\"ssh.example.com\",\n    ),\n    origin_directs=[\"tcp://109.151.40.129:22\"])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Define a spectrum application proxies ssh traffic\n        var sshProxy = new Cloudflare.SpectrumApplication(\"sshProxy\", new Cloudflare.SpectrumApplicationArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Protocol = \"tcp/22\",\n            TrafficType = \"direct\",\n            Dns = new Cloudflare.Inputs.SpectrumApplicationDnsArgs\n            {\n                Type = \"CNAME\",\n                Name = \"ssh.example.com\",\n            },\n            OriginDirects = \n            {\n                \"tcp://109.151.40.129:22\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewSpectrumApplication(ctx, \"sshProxy\", \u0026cloudflare.SpectrumApplicationArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tProtocol:    pulumi.String(\"tcp/22\"),\n\t\t\tTrafficType: pulumi.String(\"direct\"),\n\t\t\tDns: \u0026SpectrumApplicationDnsArgs{\n\t\t\t\tType: pulumi.String(\"CNAME\"),\n\t\t\t\tName: pulumi.String(\"ssh.example.com\"),\n\t\t\t},\n\t\t\tOriginDirects: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tcp://109.151.40.129:22\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSpectrum resource can be imported using a zone ID and Application ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/spectrumApplication:SpectrumApplication example d41d8cd98f00b204e9800998ecf8427e/9a7806061c88ada191ed06f989cc3dac\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID, as returned from [API](https://api.cloudflare.com/#zone-list-zones) * `9a7806061c88ada191ed06f989cc3dac` - Application ID ",
            "properties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                },
                "edgeIpConnectivity": {
                    "type": "string",
                    "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                },
                "edgeIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "If using `origin_dns` and not `origin_port_range`, this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                },
                "originPortRange": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                    "description": "If using `origin_dns` and not `origin_port`, this is a required attribute. Origin port range to proxy traffice to.  When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Fields documented below.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflare’s edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Valid values are: `direct`, `http`, `https`.  Defaults to `direct`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the application to\n"
                }
            },
            "required": [
                "dns",
                "protocol",
                "zoneId"
            ],
            "inputProperties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                },
                "edgeIpConnectivity": {
                    "type": "string",
                    "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                },
                "edgeIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "If using `origin_dns` and not `origin_port_range`, this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                },
                "originPortRange": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                    "description": "If using `origin_dns` and not `origin_port`, this is a required attribute. Origin port range to proxy traffice to.  When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Fields documented below.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflare’s edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Valid values are: `direct`, `http`, `https`.  Defaults to `direct`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the application to\n"
                }
            },
            "requiredInputs": [
                "dns",
                "protocol",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SpectrumApplication resources.\n",
                "properties": {
                    "argoSmartRouting": {
                        "type": "boolean",
                        "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                    },
                    "dns": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                        "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                    },
                    "edgeIpConnectivity": {
                        "type": "string",
                        "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                    },
                    "edgeIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                    },
                    "ipFirewall": {
                        "type": "boolean",
                        "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                    },
                    "originDirects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                    },
                    "originDns": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                        "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                    },
                    "originPort": {
                        "type": "integer",
                        "description": "If using `origin_dns` and not `origin_port_range`, this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                    },
                    "originPortRange": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                        "description": "If using `origin_dns` and not `origin_port`, this is a required attribute. Origin port range to proxy traffice to.  When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Fields documented below.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The port configuration at Cloudflare’s edge. e.g. `tcp/22`.\n"
                    },
                    "proxyProtocol": {
                        "type": "string",
                        "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                    },
                    "tls": {
                        "type": "string",
                        "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                    },
                    "trafficType": {
                        "type": "string",
                        "description": "Sets application type. Valid values are: `direct`, `http`, `https`.  Defaults to `direct`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to add the application to\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/splitTunnel:SplitTunnel": {
            "description": "Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either\ninclude or exclude lists of routes from the WARP client's tunnel.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Excluding *.example.com from WARP routes\nconst exampleSplitTunnelExclude = new cloudflare.SplitTunnel(\"example_split_tunnel_exclude\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    mode: \"exclude\",\n    tunnels: [{\n        description: \"example domain\",\n        host: \"*.example.com\",\n    }],\n});\n// Including *.example.com in WARP routes\nconst exampleSplitTunnelInclude = new cloudflare.SplitTunnel(\"example_split_tunnel_include\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    mode: \"include\",\n    tunnels: [{\n        description: \"example domain\",\n        host: \"*.example.com\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Excluding *.example.com from WARP routes\nexample_split_tunnel_exclude = cloudflare.SplitTunnel(\"exampleSplitTunnelExclude\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    mode=\"exclude\",\n    tunnels=[cloudflare.SplitTunnelTunnelArgs(\n        description=\"example domain\",\n        host=\"*.example.com\",\n    )])\n# Including *.example.com in WARP routes\nexample_split_tunnel_include = cloudflare.SplitTunnel(\"exampleSplitTunnelInclude\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    mode=\"include\",\n    tunnels=[cloudflare.SplitTunnelTunnelArgs(\n        description=\"example domain\",\n        host=\"*.example.com\",\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Excluding *.example.com from WARP routes\n        var exampleSplitTunnelExclude = new Cloudflare.SplitTunnel(\"exampleSplitTunnelExclude\", new Cloudflare.SplitTunnelArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Mode = \"exclude\",\n            Tunnels = \n            {\n                new Cloudflare.Inputs.SplitTunnelTunnelArgs\n                {\n                    Description = \"example domain\",\n                    Host = \"*.example.com\",\n                },\n            },\n        });\n        // Including *.example.com in WARP routes\n        var exampleSplitTunnelInclude = new Cloudflare.SplitTunnel(\"exampleSplitTunnelInclude\", new Cloudflare.SplitTunnelArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Mode = \"include\",\n            Tunnels = \n            {\n                new Cloudflare.Inputs.SplitTunnelTunnelArgs\n                {\n                    Description = \"example domain\",\n                    Host = \"*.example.com\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewSplitTunnel(ctx, \"exampleSplitTunnelExclude\", \u0026cloudflare.SplitTunnelArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tMode:      pulumi.String(\"exclude\"),\n\t\t\tTunnels: SplitTunnelTunnelArray{\n\t\t\t\t\u0026SplitTunnelTunnelArgs{\n\t\t\t\t\tDescription: pulumi.String(\"example domain\"),\n\t\t\t\t\tHost:        pulumi.String(\"*.example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewSplitTunnel(ctx, \"exampleSplitTunnelInclude\", \u0026cloudflare.SplitTunnelArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tMode:      pulumi.String(\"include\"),\n\t\t\tTunnels: SplitTunnelTunnelArray{\n\t\t\t\t\u0026SplitTunnelTunnelArgs{\n\t\t\t\t\tDescription: pulumi.String(\"example domain\"),\n\t\t\t\t\tHost:        pulumi.String(\"*.example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSplit Tunnels can be imported using the account identifer and mode.\n\n```sh\n $ pulumi import cloudflare:index/splitTunnel:SplitTunnel example 1d5fdc9e88c8a8c4518b068cd94331fe/exclude\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the device posture rule should be added.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The split tunnel mode. Valid values are `include` or `exclude`.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes (refer to the nested schema).\n"
                }
            },
            "required": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the device posture rule should be added.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The split tunnel mode. Valid values are `include` or `exclude`.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes (refer to the nested schema).\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SplitTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the device posture rule should be added.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The split tunnel mode. Valid values are `include` or `exclude`.\n"
                    },
                    "tunnels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                        },
                        "description": "The value of the tunnel attributes (refer to the nested schema).\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/staticRoute:StaticRoute": {
            "description": "Provides a resource, that manages Cloudflare static routes for Magic Transit or Magic WAN. \nStatic routes are used to route traffic through GRE tunnels.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.StaticRoute(\"example\", {\n    accountId: \"c4a7362d577a6c3019a474fd6f485821\",\n    coloNames: [\"den01\"],\n    coloRegions: [\"APAC\"],\n    description: \"New route for new prefix 192.0.2.0/24\",\n    nexthop: \"10.0.0.0\",\n    prefix: \"192.0.2.0/24\",\n    priority: 100,\n    weight: 10,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.StaticRoute(\"example\",\n    account_id=\"c4a7362d577a6c3019a474fd6f485821\",\n    colo_names=[\"den01\"],\n    colo_regions=[\"APAC\"],\n    description=\"New route for new prefix 192.0.2.0/24\",\n    nexthop=\"10.0.0.0\",\n    prefix=\"192.0.2.0/24\",\n    priority=100,\n    weight=10)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.StaticRoute(\"example\", new Cloudflare.StaticRouteArgs\n        {\n            AccountId = \"c4a7362d577a6c3019a474fd6f485821\",\n            ColoNames = \n            {\n                \"den01\",\n            },\n            ColoRegions = \n            {\n                \"APAC\",\n            },\n            Description = \"New route for new prefix 192.0.2.0/24\",\n            Nexthop = \"10.0.0.0\",\n            Prefix = \"192.0.2.0/24\",\n            Priority = 100,\n            Weight = 10,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewStaticRoute(ctx, \"example\", \u0026cloudflare.StaticRouteArgs{\n\t\t\tAccountId: pulumi.String(\"c4a7362d577a6c3019a474fd6f485821\"),\n\t\t\tColoNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"den01\"),\n\t\t\t},\n\t\t\tColoRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"APAC\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"New route for new prefix 192.0.2.0/24\"),\n\t\t\tNexthop:     pulumi.String(\"10.0.0.0\"),\n\t\t\tPrefix:      pulumi.String(\"192.0.2.0/24\"),\n\t\t\tPriority:    pulumi.Int(100),\n\t\t\tWeight:      pulumi.Int(10),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing static route can be imported using the account ID and static route ID\n\n```sh\n $ pulumi import cloudflare:index/staticRoute:StaticRoute example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the static route is being created.\n"
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation names for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation regions for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes.\n"
                }
            },
            "required": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the static route is being created.\n"
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation names for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation regions for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes.\n"
                }
            },
            "requiredInputs": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StaticRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the static route is being created.\n"
                    },
                    "coloNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of Cloudflare colocation names for this static route.\n"
                    },
                    "coloRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of Cloudflare colocation regions for this static route.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the static route.\n"
                    },
                    "nexthop": {
                        "type": "string",
                        "description": "The nexthop IP address where traffic will be routed to.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "Your network prefix using CIDR notation.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority for the static route.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The optional weight for ECMP routes.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsAccount:TeamsAccount": {
            "description": "Provides a Cloudflare Teams Account resource. The Teams Account resource defines configuration for secure web gateway.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst main = new cloudflare.TeamsAccount(\"main\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    blockPage: {\n        backgroundColor: \"#000000\",\n        footerText: \"hello\",\n        headerText: \"hello\",\n        logoPath: \"https://google.com\",\n    },\n    tlsDecryptEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmain = cloudflare.TeamsAccount(\"main\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    block_page=cloudflare.TeamsAccountBlockPageArgs(\n        background_color=\"#000000\",\n        footer_text=\"hello\",\n        header_text=\"hello\",\n        logo_path=\"https://google.com\",\n    ),\n    tls_decrypt_enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var main = new Cloudflare.TeamsAccount(\"main\", new Cloudflare.TeamsAccountArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            BlockPage = new Cloudflare.Inputs.TeamsAccountBlockPageArgs\n            {\n                BackgroundColor = \"#000000\",\n                FooterText = \"hello\",\n                HeaderText = \"hello\",\n                LogoPath = \"https://google.com\",\n            },\n            TlsDecryptEnabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsAccount(ctx, \"main\", \u0026cloudflare.TeamsAccountArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tBlockPage: \u0026TeamsAccountBlockPageArgs{\n\t\t\t\tBackgroundColor: pulumi.String(\"#000000\"),\n\t\t\t\tFooterText:      pulumi.String(\"hello\"),\n\t\t\t\tHeaderText:      pulumi.String(\"hello\"),\n\t\t\t\tLogoPath:        pulumi.String(\"https://google.com\"),\n\t\t\t},\n\t\t\tTlsDecryptEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSince a Teams account does not have a unique resource ID, configuration can be imported using the account ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsAccount:TeamsAccount example cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                    "description": "Configuration for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                }
            },
            "required": [
                "accountId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                    "description": "Configuration for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsAccount resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams location should be added.\n"
                    },
                    "activityLogEnabled": {
                        "type": "boolean"
                    },
                    "antivirus": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                        "description": "Configuration for antivirus traffic scanning.\n"
                    },
                    "blockPage": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                        "description": "Configuration for a custom block page.\n"
                    },
                    "tlsDecryptEnabled": {
                        "type": "boolean",
                        "description": "Indicator that decryption of TLS traffic is enabled.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsList:TeamsList": {
            "description": "Provides a Cloudflare Teams List resource. Teams lists are referenced when creating secure web gateway policies or device posture rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst corporateDevices = new cloudflare.TeamsList(\"corporate_devices\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    description: \"Serial numbers for all corporate devices.\",\n    items: [\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ],\n    name: \"Corporate devices\",\n    type: \"SERIAL\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ncorporate_devices = cloudflare.TeamsList(\"corporateDevices\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    description=\"Serial numbers for all corporate devices.\",\n    items=[\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ],\n    name=\"Corporate devices\",\n    type=\"SERIAL\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var corporateDevices = new Cloudflare.TeamsList(\"corporateDevices\", new Cloudflare.TeamsListArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Description = \"Serial numbers for all corporate devices.\",\n            Items = \n            {\n                \"8GE8721REF\",\n                \"5RE8543EGG\",\n                \"1YE2880LNP\",\n            },\n            Name = \"Corporate devices\",\n            Type = \"SERIAL\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsList(ctx, \"corporateDevices\", \u0026cloudflare.TeamsListArgs{\n\t\t\tAccountId:   pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tDescription: pulumi.String(\"Serial numbers for all corporate devices.\"),\n\t\t\tItems: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"8GE8721REF\"),\n\t\t\t\tpulumi.String(\"5RE8543EGG\"),\n\t\t\t\tpulumi.String(\"1YE2880LNP\"),\n\t\t\t},\n\t\t\tName: pulumi.String(\"Corporate devices\"),\n\t\t\tType: pulumi.String(\"SERIAL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams lists can be imported using a composite ID formed of account ID and teams list ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsList:TeamsList corporate_devices cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams list should be added.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Valid values are `SERIAL`, `URL`, `DOMAIN`, and `EMAIL`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams list should be added.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Valid values are `SERIAL`, `URL`, `DOMAIN`, and `EMAIL`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsList resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams list should be added.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams list.\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The items of the teams list.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams list.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The teams list type. Valid values are `SERIAL`, `URL`, `DOMAIN`, and `EMAIL`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsLocation:TeamsLocation": {
            "description": "Provides a Cloudflare Teams Location resource. Teams Locations are referenced\nwhen creating secure web gateway policies.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst corporateOffice = new cloudflare.TeamsLocation(\"corporate_office\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    clientDefault: true,\n    name: \"office\",\n    networks: [\n        {\n            network: \"203.0.113.1/32\",\n        },\n        {\n            network: \"203.0.113.2/32\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ncorporate_office = cloudflare.TeamsLocation(\"corporateOffice\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    client_default=True,\n    name=\"office\",\n    networks=[\n        cloudflare.TeamsLocationNetworkArgs(\n            network=\"203.0.113.1/32\",\n        ),\n        cloudflare.TeamsLocationNetworkArgs(\n            network=\"203.0.113.2/32\",\n        ),\n    ])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var corporateOffice = new Cloudflare.TeamsLocation(\"corporateOffice\", new Cloudflare.TeamsLocationArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            ClientDefault = true,\n            Name = \"office\",\n            Networks = \n            {\n                new Cloudflare.Inputs.TeamsLocationNetworkArgs\n                {\n                    Network = \"203.0.113.1/32\",\n                },\n                new Cloudflare.Inputs.TeamsLocationNetworkArgs\n                {\n                    Network = \"203.0.113.2/32\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsLocation(ctx, \"corporateOffice\", \u0026cloudflare.TeamsLocationArgs{\n\t\t\tAccountId:     pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tClientDefault: pulumi.Bool(true),\n\t\t\tName:          pulumi.String(\"office\"),\n\t\t\tNetworks: TeamsLocationNetworkArray{\n\t\t\t\t\u0026TeamsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.1/32\"),\n\t\t\t\t},\n\t\t\t\t\u0026TeamsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.2/32\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams locations can be imported using a composite ID formed of account ID and teams location ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsLocation:TeamsLocation corporate_office cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "anonymizedLogsEnabled": {
                    "type": "boolean",
                    "description": "Indicator that anonymized logs are enabled.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "dohSubdomain": {
                    "type": "string",
                    "description": "The FQDN that DoH clients should be pointed at.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Client IP address\n"
                },
                "ipv4Destination": {
                    "type": "string",
                    "description": "IP to direct all IPv4 DNS queries too.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                },
                "policyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "accountId",
                "anonymizedLogsEnabled",
                "dohSubdomain",
                "ip",
                "ipv4Destination",
                "name",
                "policyIds"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsLocation resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams location should be added.\n"
                    },
                    "anonymizedLogsEnabled": {
                        "type": "boolean",
                        "description": "Indicator that anonymized logs are enabled.\n"
                    },
                    "clientDefault": {
                        "type": "boolean",
                        "description": "Indicator that this is the default location.\n"
                    },
                    "dohSubdomain": {
                        "type": "string",
                        "description": "The FQDN that DoH clients should be pointed at.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "Client IP address\n"
                    },
                    "ipv4Destination": {
                        "type": "string",
                        "description": "IP to direct all IPv4 DNS queries too.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams location.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                        },
                        "description": "The networks CIDRs that comprise the location.\n"
                    },
                    "policyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsRule:TeamsRule": {
            "description": "Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst rule1 = new cloudflare.TeamsRule(\"rule1\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    action: \"l4_override\",\n    description: \"desc\",\n    filters: [\"l4\"],\n    name: \"office\",\n    precedence: 1,\n    ruleSettings: {\n        blockPageEnabled: false,\n        blockPageReason: \"access not permitted\",\n        l4override: {\n            ip: \"192.0.2.1\",\n            port: 1234,\n        },\n    },\n    traffic: \"any(dns.domains[*] == \\\"com.example\\\")\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nrule1 = cloudflare.TeamsRule(\"rule1\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    action=\"l4_override\",\n    description=\"desc\",\n    filters=[\"l4\"],\n    name=\"office\",\n    precedence=1,\n    rule_settings=cloudflare.TeamsRuleRuleSettingsArgs(\n        block_page_enabled=False,\n        block_page_reason=\"access not permitted\",\n        l4override=cloudflare.TeamsRuleRuleSettingsL4overrideArgs(\n            ip=\"192.0.2.1\",\n            port=1234,\n        ),\n    ),\n    traffic=\"any(dns.domains[*] == \\\"com.example\\\")\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var rule1 = new Cloudflare.TeamsRule(\"rule1\", new Cloudflare.TeamsRuleArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Action = \"l4_override\",\n            Description = \"desc\",\n            Filters = \n            {\n                \"l4\",\n            },\n            Name = \"office\",\n            Precedence = 1,\n            RuleSettings = new Cloudflare.Inputs.TeamsRuleRuleSettingsArgs\n            {\n                BlockPageEnabled = false,\n                BlockPageReason = \"access not permitted\",\n                L4override = new Cloudflare.Inputs.TeamsRuleRuleSettingsL4overrideArgs\n                {\n                    Ip = \"192.0.2.1\",\n                    Port = 1234,\n                },\n            },\n            Traffic = \"any(dns.domains[*] == \\\"com.example\\\")\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsRule(ctx, \"rule1\", \u0026cloudflare.TeamsRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tAction:      pulumi.String(\"l4_override\"),\n\t\t\tDescription: pulumi.String(\"desc\"),\n\t\t\tFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"l4\"),\n\t\t\t},\n\t\t\tName:       pulumi.String(\"office\"),\n\t\t\tPrecedence: pulumi.Int(1),\n\t\t\tRuleSettings: \u0026TeamsRuleRuleSettingsArgs{\n\t\t\t\tBlockPageEnabled: pulumi.Bool(false),\n\t\t\t\tBlockPageReason:  pulumi.String(\"access not permitted\"),\n\t\t\t\tL4override: \u0026TeamsRuleRuleSettingsL4overrideArgs{\n\t\t\t\t\tIp:   pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tPort: pulumi.Int(1234),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTraffic: pulumi.String(\"any(dns.domains[*] == \\\"com.example\\\")\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams Rules can be imported using a composite ID formed of account ID and teams rule ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsRule:TeamsRule rule1 cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams rule should be added.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                    "description": "Additional rule settings.\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                },
                "version": {
                    "type": "integer"
                }
            },
            "required": [
                "accountId",
                "action",
                "description",
                "name",
                "precedence",
                "version"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams rule should be added.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                    "description": "Additional rule settings.\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "action",
                "description",
                "name",
                "precedence"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams rule should be added.\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "The action executed by matched teams rule.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams rule.\n"
                    },
                    "devicePosture": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for device_posture check matching.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicator of rule enablement.\n"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for identity matching.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the teams rule.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The evaluation precedence of the teams rule.\n"
                    },
                    "ruleSettings": {
                        "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                        "description": "Additional rule settings.\n"
                    },
                    "traffic": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for traffic matching.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafGroup:WafGroup": {
            "description": "Provides a Cloudflare WAF rule group resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall groups.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst honeyPot = new cloudflare.WafGroup(\"honey_pot\", {\n    groupId: \"de677e5818985db1285d0e80225f06e5\",\n    mode: \"on\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhoney_pot = cloudflare.WafGroup(\"honeyPot\",\n    group_id=\"de677e5818985db1285d0e80225f06e5\",\n    mode=\"on\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var honeyPot = new Cloudflare.WafGroup(\"honeyPot\", new Cloudflare.WafGroupArgs\n        {\n            GroupId = \"de677e5818985db1285d0e80225f06e5\",\n            Mode = \"on\",\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafGroup(ctx, \"honeyPot\", \u0026cloudflare.WafGroupArgs{\n\t\t\tGroupId: pulumi.String(\"de677e5818985db1285d0e80225f06e5\"),\n\t\t\tMode:    pulumi.String(\"on\"),\n\t\t\tZoneId:  pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWAF Rule Groups can be imported using a composite ID formed of zone ID and the WAF Rule Group ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/wafGroup:WafGroup honey_pot ae36f999674d196762efcc5abb06b345/de677e5818985db1285d0e80225f06e5\n```\n\n ",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The WAF Rule Group ID.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the group.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "groupId",
                "packageId",
                "zoneId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "description": "The WAF Rule Group ID.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the group.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafGroup resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The WAF Rule Group ID.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the group.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafOverride:WafOverride": {
            "description": "Provides a Cloudflare WAF override resource. This enables the ability to toggle\nWAF rules and groups on or off based on URIs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst shopEcxample = new cloudflare.WafOverride(\"shopEcxample\", {\n    zoneId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    urls: [\n        \"example.com/no-waf-here\",\n        \"example.com/another/path/*\",\n    ],\n    rules: {\n        \"100015\": \"disable\",\n    },\n    groups: {\n        ea8687e59929c1fd05ba97574ad43f77: \"default\",\n    },\n    rewriteAction: {\n        \"default\": \"block\",\n        challenge: \"block\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nshop_ecxample = cloudflare.WafOverride(\"shopEcxample\",\n    zone_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    urls=[\n        \"example.com/no-waf-here\",\n        \"example.com/another/path/*\",\n    ],\n    rules={\n        \"100015\": \"disable\",\n    },\n    groups={\n        \"ea8687e59929c1fd05ba97574ad43f77\": \"default\",\n    },\n    rewrite_action={\n        \"default\": \"block\",\n        \"challenge\": \"block\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var shopEcxample = new Cloudflare.WafOverride(\"shopEcxample\", new Cloudflare.WafOverrideArgs\n        {\n            ZoneId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Urls = \n            {\n                \"example.com/no-waf-here\",\n                \"example.com/another/path/*\",\n            },\n            Rules = \n            {\n                { \"100015\", \"disable\" },\n            },\n            Groups = \n            {\n                { \"ea8687e59929c1fd05ba97574ad43f77\", \"default\" },\n            },\n            RewriteAction = \n            {\n                { \"default\", \"block\" },\n                { \"challenge\", \"block\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafOverride(ctx, \"shopEcxample\", \u0026cloudflare.WafOverrideArgs{\n\t\t\tZoneId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com/no-waf-here\"),\n\t\t\t\tpulumi.String(\"example.com/another/path/*\"),\n\t\t\t},\n\t\t\tRules: pulumi.StringMap{\n\t\t\t\t\"100015\": pulumi.String(\"disable\"),\n\t\t\t},\n\t\t\tGroups: pulumi.StringMap{\n\t\t\t\t\"ea8687e59929c1fd05ba97574ad43f77\": pulumi.String(\"default\"),\n\t\t\t},\n\t\t\tRewriteAction: pulumi.StringMap{\n\t\t\t\t\"default\":   pulumi.String(\"block\"),\n\t\t\t\t\"challenge\": pulumi.String(\"block\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWAF Overrides can be imported using a composite ID formed of zone ID and override ID.\n\n```sh\n $ pulumi import cloudflare:index/wafOverride:WafOverride my_example_waf_override 3abe5b950053dbddf1516d89f9ef1e8a/9d4e66d7649c178663bf62e06dbacb23\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of what the WAF override does.\n"
                },
                "groups": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Similar to `rules`; which WAF groups you want to alter.\n"
                },
                "overrideId": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this package is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Relative priority of this configuration when multiple configurations match a single URL.\n"
                },
                "rewriteAction": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "When a WAF rule matches, substitute its configured action for a different action specified by this definition.\n"
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of WAF rule ID to rule action you intend to apply.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of URLs to apply the WAF override to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the WAF override condition should be added.\n"
                }
            },
            "required": [
                "overrideId",
                "urls",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of what the WAF override does.\n"
                },
                "groups": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Similar to `rules`; which WAF groups you want to alter.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this package is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Relative priority of this configuration when multiple configurations match a single URL.\n"
                },
                "rewriteAction": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "When a WAF rule matches, substitute its configured action for a different action specified by this definition.\n"
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of WAF rule ID to rule action you intend to apply.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of URLs to apply the WAF override to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the WAF override condition should be added.\n"
                }
            },
            "requiredInputs": [
                "urls",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafOverride resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of what the WAF override does.\n"
                    },
                    "groups": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Similar to `rules`; which WAF groups you want to alter.\n"
                    },
                    "overrideId": {
                        "type": "string"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this package is currently paused.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Relative priority of this configuration when multiple configurations match a single URL.\n"
                    },
                    "rewriteAction": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "When a WAF rule matches, substitute its configured action for a different action specified by this definition.\n"
                    },
                    "rules": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of WAF rule ID to rule action you intend to apply.\n"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of URLs to apply the WAF override to.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the WAF override condition should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafPackage:WafPackage": {
            "description": "Provides a Cloudflare WAF rule package resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall packages.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst owasp = new cloudflare.WafPackage(\"owasp\", {\n    actionMode: \"simulate\",\n    packageId: \"a25a9a7e9c00afc1fb2e0245519d725b\",\n    sensitivity: \"medium\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nowasp = cloudflare.WafPackage(\"owasp\",\n    action_mode=\"simulate\",\n    package_id=\"a25a9a7e9c00afc1fb2e0245519d725b\",\n    sensitivity=\"medium\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var owasp = new Cloudflare.WafPackage(\"owasp\", new Cloudflare.WafPackageArgs\n        {\n            ActionMode = \"simulate\",\n            PackageId = \"a25a9a7e9c00afc1fb2e0245519d725b\",\n            Sensitivity = \"medium\",\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafPackage(ctx, \"owasp\", \u0026cloudflare.WafPackageArgs{\n\t\t\tActionMode:  pulumi.String(\"simulate\"),\n\t\t\tPackageId:   pulumi.String(\"a25a9a7e9c00afc1fb2e0245519d725b\"),\n\t\t\tSensitivity: pulumi.String(\"medium\"),\n\t\t\tZoneId:      pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPackages can be imported using a composite ID formed of zone ID and the WAF Package ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/wafPackage:WafPackage owasp ae36f999674d196762efcc5abb06b345/a25a9a7e9c00afc1fb2e0245519d725b\n```\n\n ",
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The WAF Package ID.\n"
                },
                "sensitivity": {
                    "type": "string",
                    "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "packageId",
                "zoneId"
            ],
            "inputProperties": {
                "actionMode": {
                    "type": "string",
                    "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The WAF Package ID.\n"
                },
                "sensitivity": {
                    "type": "string",
                    "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "packageId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafPackage resources.\n",
                "properties": {
                    "actionMode": {
                        "type": "string",
                        "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The WAF Package ID.\n"
                    },
                    "sensitivity": {
                        "type": "string",
                        "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafRule:WafRule": {
            "description": "Provides a Cloudflare WAF rule resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst rule100000 = new cloudflare.WafRule(\"rule_100000\", {\n    mode: \"simulate\",\n    ruleId: \"100000\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nrule100000 = cloudflare.WafRule(\"rule100000\",\n    mode=\"simulate\",\n    rule_id=\"100000\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var rule100000 = new Cloudflare.WafRule(\"rule100000\", new Cloudflare.WafRuleArgs\n        {\n            Mode = \"simulate\",\n            RuleId = \"100000\",\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafRule(ctx, \"rule100000\", \u0026cloudflare.WafRuleArgs{\n\t\t\tMode:   pulumi.String(\"simulate\"),\n\t\t\tRuleId: pulumi.String(\"100000\"),\n\t\t\tZoneId: pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRules can be imported using a composite ID formed of zone ID and the WAF Rule ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/wafRule:WafRule 100000 ae36f999674d196762efcc5abb06b345/100000\n```\n\n ",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group that contains the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the rule.\n"
                },
                "ruleId": {
                    "type": "string",
                    "description": "The WAF Rule ID.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "groupId",
                "mode",
                "packageId",
                "ruleId",
                "zoneId"
            ],
            "inputProperties": {
                "mode": {
                    "type": "string",
                    "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the rule.\n"
                },
                "ruleId": {
                    "type": "string",
                    "description": "The WAF Rule ID.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "mode",
                "ruleId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafRule resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Group that contains the rule.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the rule.\n"
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "The WAF Rule ID.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoom:WaitingRoom": {
            "description": "Provides a Cloudflare Waiting Room resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WaitingRoom(\"example\", {\n    host: \"foo.example.com\",\n    name: \"foo\",\n    newUsersPerMinute: 200,\n    path: \"/\",\n    totalActiveUsers: 200,\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WaitingRoom(\"example\",\n    host=\"foo.example.com\",\n    name=\"foo\",\n    new_users_per_minute=200,\n    path=\"/\",\n    total_active_users=200,\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.WaitingRoom(\"example\", new Cloudflare.WaitingRoomArgs\n        {\n            Host = \"foo.example.com\",\n            Name = \"foo\",\n            NewUsersPerMinute = 200,\n            Path = \"/\",\n            TotalActiveUsers = 200,\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWaitingRoom(ctx, \"example\", \u0026cloudflare.WaitingRoomArgs{\n\t\t\tHost:              pulumi.String(\"foo.example.com\"),\n\t\t\tName:              pulumi.String(\"foo\"),\n\t\t\tNewUsersPerMinute: pulumi.Int(200),\n\t\t\tPath:              pulumi.String(\"/\"),\n\t\t\tTotalActiveUsers:  pulumi.Int(200),\n\t\t\tZoneId:            pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWaiting rooms can be imported using a composite ID formed of zone ID and waiting room ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/waitingRoom:WaitingRoom default ae36f999674d196762efcc5abb06b345/d41d8cd98f00b204e9800998ecf8427e\n```\n\n where* `ae36f999674d196762efcc5abb06b345` - the zone ID * `d41d8cd98f00b204e9800998ecf8427e` - waiting room ID as returned by [API](https://api.cloudflare.com/#waiting-room-list-waiting-rooms) ",
            "properties": {
                "customPageHtml": {
                    "type": "string",
                    "description": "This a templated html file that will be rendered at the edge.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to let users add more details about the waiting room.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies. Default: false.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                },
                "jsonResponseEnabled": {
                    "type": "boolean",
                    "description": "If true, requests to the waiting room with the header Accept: application/json will receive a JSON response object.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the waiting room.\n"
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the host to enable the waiting room on. Default: \"/\".\n"
                },
                "queueAll": {
                    "type": "boolean",
                    "description": "If queue_all is true all the traffic that is coming to a route will be sent to the waiting room. Default: false.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. Default: 5\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, the traffic doesn't go to the waiting room. Default: false.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "host",
                "name",
                "newUsersPerMinute",
                "totalActiveUsers",
                "zoneId"
            ],
            "inputProperties": {
                "customPageHtml": {
                    "type": "string",
                    "description": "This a templated html file that will be rendered at the edge.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to let users add more details about the waiting room.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies. Default: false.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                },
                "jsonResponseEnabled": {
                    "type": "boolean",
                    "description": "If true, requests to the waiting room with the header Accept: application/json will receive a JSON response object.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the waiting room.\n"
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the host to enable the waiting room on. Default: \"/\".\n"
                },
                "queueAll": {
                    "type": "boolean",
                    "description": "If queue_all is true all the traffic that is coming to a route will be sent to the waiting room. Default: false.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. Default: 5\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, the traffic doesn't go to the waiting room. Default: false.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "host",
                "name",
                "newUsersPerMinute",
                "totalActiveUsers",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoom resources.\n",
                "properties": {
                    "customPageHtml": {
                        "type": "string",
                        "description": "This a templated html file that will be rendered at the edge.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description to let users add more details about the waiting room.\n"
                    },
                    "disableSessionRenewal": {
                        "type": "boolean",
                        "description": "Disables automatic renewal of session cookies. Default: false.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                    },
                    "jsonResponseEnabled": {
                        "type": "boolean",
                        "description": "If true, requests to the waiting room with the header Accept: application/json will receive a JSON response object.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to identify the waiting room.\n"
                    },
                    "newUsersPerMinute": {
                        "type": "integer",
                        "description": "The number of new users that will be let into the route every minute.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path within the host to enable the waiting room on. Default: \"/\".\n"
                    },
                    "queueAll": {
                        "type": "boolean",
                        "description": "If queue_all is true all the traffic that is coming to a route will be sent to the waiting room. Default: false.\n"
                    },
                    "sessionDuration": {
                        "type": "integer",
                        "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. Default: 5\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, the traffic doesn't go to the waiting room. Default: false.\n"
                    },
                    "totalActiveUsers": {
                        "type": "integer",
                        "description": "The total number of active user sessions on the route at a point in time.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerCronTrigger:WorkerCronTrigger": {
            "description": "Worker Cron Triggers allow users to map a cron expression to a Worker script\nusing a `ScheduledEvent` listener that enables Workers to be executed on a\nschedule. Worker Cron Triggers are ideal for running periodic jobs for\nmaintenance or calling third-party APIs to collect up-to-date data.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * from \"fs\";\n\nconst exampleScript = new cloudflare.WorkerScript(\"exampleScript\", {\n    name: \"example-script\",\n    content: fs.readFileSync(\"path/to/my.js\"),\n});\nconst exampleTrigger = new cloudflare.WorkerCronTrigger(\"exampleTrigger\", {\n    scriptName: exampleScript.name,\n    schedules: [\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_script = cloudflare.WorkerScript(\"exampleScript\",\n    name=\"example-script\",\n    content=(lambda path: open(path).read())(\"path/to/my.js\"))\nexample_trigger = cloudflare.WorkerCronTrigger(\"exampleTrigger\",\n    script_name=example_script.name,\n    schedules=[\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleScript = new Cloudflare.WorkerScript(\"exampleScript\", new Cloudflare.WorkerScriptArgs\n        {\n            Name = \"example-script\",\n            Content = File.ReadAllText(\"path/to/my.js\"),\n        });\n        var exampleTrigger = new Cloudflare.WorkerCronTrigger(\"exampleTrigger\", new Cloudflare.WorkerCronTriggerArgs\n        {\n            ScriptName = exampleScript.Name,\n            Schedules = \n            {\n                \"*/5 * * * *\",\n                \"10 7 * * mon-fri\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleScript, err := cloudflare.NewWorkerScript(ctx, \"exampleScript\", \u0026cloudflare.WorkerScriptArgs{\n\t\t\tName:    pulumi.String(\"example-script\"),\n\t\t\tContent: readFileOrPanic(\"path/to/my.js\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerCronTrigger(ctx, \"exampleTrigger\", \u0026cloudflare.WorkerCronTriggerArgs{\n\t\t\tScriptName: exampleScript.Name,\n\t\t\tSchedules: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*/5 * * * *\"),\n\t\t\t\tpulumi.String(\"10 7 * * mon-fri\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWorker Cron Triggers can be imported using the script name of the Worker they are targeting.\n\n```sh\n $ pulumi import cloudflare:index/workerCronTrigger:WorkerCronTrigger example my-script\n```\n\n ",
            "properties": {
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cron expressions to execute the Worker Script\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules\n"
                }
            },
            "required": [
                "schedules",
                "scriptName"
            ],
            "inputProperties": {
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of cron expressions to execute the Worker Script\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules\n"
                }
            },
            "requiredInputs": [
                "schedules",
                "scriptName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerCronTrigger resources.\n",
                "properties": {
                    "schedules": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of cron expressions to execute the Worker Script\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script to target for the schedules\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerRoute:WorkerRoute": {
            "description": "Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`. *NOTE:*  This resource uses the Cloudflare account APIs. This requires setting the `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myScript = new cloudflare.WorkerScript(\"myScript\", {});\n// see \"cloudflare_worker_script\" documentation ...\n// Runs the specified worker script for all URLs that match `example.com/*`\nconst myRoute = new cloudflare.WorkerRoute(\"myRoute\", {\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    pattern: \"example.com/*\",\n    scriptName: myScript.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_script = cloudflare.WorkerScript(\"myScript\")\n# see \"cloudflare_worker_script\" documentation ...\n# Runs the specified worker script for all URLs that match `example.com/*`\nmy_route = cloudflare.WorkerRoute(\"myRoute\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    pattern=\"example.com/*\",\n    script_name=my_script.name)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var myScript = new Cloudflare.WorkerScript(\"myScript\", new Cloudflare.WorkerScriptArgs\n        {\n        });\n        // see \"cloudflare_worker_script\" documentation ...\n        // Runs the specified worker script for all URLs that match `example.com/*`\n        var myRoute = new Cloudflare.WorkerRoute(\"myRoute\", new Cloudflare.WorkerRouteArgs\n        {\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n            Pattern = \"example.com/*\",\n            ScriptName = myScript.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyScript, err := cloudflare.NewWorkerScript(ctx, \"myScript\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerRoute(ctx, \"myRoute\", \u0026cloudflare.WorkerRouteArgs{\n\t\t\tZoneId:     pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tPattern:    pulumi.String(\"example.com/*\"),\n\t\t\tScriptName: myScript.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRecords can be imported using a composite ID formed of zone ID and route ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/workerRoute:WorkerRoute default d41d8cd98f00b204e9800998ecf8427e/9a7806061c88ada191ed06f989cc3dac\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID * `9a7806061c88ada191ed06f989cc3dac` - route ID as returned by [API](https://api.cloudflare.com/#worker-filters-list-filters) ",
            "properties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/)\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Which worker script to run for requests that match the route pattern. If `script_name` is empty, workers will be skipped for matching requests.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the route to.\n"
                }
            },
            "required": [
                "pattern",
                "zoneId"
            ],
            "inputProperties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/)\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Which worker script to run for requests that match the route pattern. If `script_name` is empty, workers will be skipped for matching requests.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the route to.\n"
                }
            },
            "requiredInputs": [
                "pattern",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerRoute resources.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/)\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Which worker script to run for requests that match the route pattern. If `script_name` is empty, workers will be skipped for matching requests.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to add the route to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerScript:WorkerScript": {
            "description": "Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`. *NOTE:*  This resource uses the Cloudflare account APIs. This requires setting the `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * from \"fs\";\n\nconst myNamespace = new cloudflare.WorkersKvNamespace(\"myNamespace\", {title: \"example\"});\n// Sets the script with the name \"script_1\"\nconst myScript = new cloudflare.WorkerScript(\"myScript\", {\n    name: \"script_1\",\n    content: fs.readFileSync(\"script.js\"),\n    kvNamespaceBindings: [{\n        name: \"MY_EXAMPLE_KV_NAMESPACE\",\n        namespaceId: myNamespace.id,\n    }],\n    plainTextBindings: [{\n        name: \"MY_EXAMPLE_PLAIN_TEXT\",\n        text: \"foobar\",\n    }],\n    secretTextBindings: [{\n        name: \"MY_EXAMPLE_SECRET_TEXT\",\n        text: _var.secret_foo_value,\n    }],\n    webassemblyBindings: [{\n        name: \"MY_EXAMPLE_WASM\",\n        module: Buffer.from(fs.readFileSync(\"example.wasm\"), 'binary').toString('base64'),\n    }],\n});\n```\n```python\nimport pulumi\nimport base64\nimport pulumi_cloudflare as cloudflare\n\nmy_namespace = cloudflare.WorkersKvNamespace(\"myNamespace\", title=\"example\")\n# Sets the script with the name \"script_1\"\nmy_script = cloudflare.WorkerScript(\"myScript\",\n    name=\"script_1\",\n    content=(lambda path: open(path).read())(\"script.js\"),\n    kv_namespace_bindings=[cloudflare.WorkerScriptKvNamespaceBindingArgs(\n        name=\"MY_EXAMPLE_KV_NAMESPACE\",\n        namespace_id=my_namespace.id,\n    )],\n    plain_text_bindings=[cloudflare.WorkerScriptPlainTextBindingArgs(\n        name=\"MY_EXAMPLE_PLAIN_TEXT\",\n        text=\"foobar\",\n    )],\n    secret_text_bindings=[cloudflare.WorkerScriptSecretTextBindingArgs(\n        name=\"MY_EXAMPLE_SECRET_TEXT\",\n        text=var[\"secret_foo_value\"],\n    )],\n    webassembly_bindings=[cloudflare.WorkerScriptWebassemblyBindingArgs(\n        name=\"MY_EXAMPLE_WASM\",\n        module=(lambda path: base64.b64encode(open(path).read().encode()).decode())(\"example.wasm\"),\n    )])\n```\n```csharp\nusing System;\nusing System.IO;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n\tprivate static string ReadFileBase64(string path) {\n\t\treturn Convert.ToBase64String(System.Text.UTF8.GetBytes(File.ReadAllText(path)))\n\t}\n\n    public MyStack()\n    {\n        var myNamespace = new Cloudflare.WorkersKvNamespace(\"myNamespace\", new Cloudflare.WorkersKvNamespaceArgs\n        {\n            Title = \"example\",\n        });\n        // Sets the script with the name \"script_1\"\n        var myScript = new Cloudflare.WorkerScript(\"myScript\", new Cloudflare.WorkerScriptArgs\n        {\n            Name = \"script_1\",\n            Content = File.ReadAllText(\"script.js\"),\n            KvNamespaceBindings = \n            {\n                new Cloudflare.Inputs.WorkerScriptKvNamespaceBindingArgs\n                {\n                    Name = \"MY_EXAMPLE_KV_NAMESPACE\",\n                    NamespaceId = myNamespace.Id,\n                },\n            },\n            PlainTextBindings = \n            {\n                new Cloudflare.Inputs.WorkerScriptPlainTextBindingArgs\n                {\n                    Name = \"MY_EXAMPLE_PLAIN_TEXT\",\n                    Text = \"foobar\",\n                },\n            },\n            SecretTextBindings = \n            {\n                new Cloudflare.Inputs.WorkerScriptSecretTextBindingArgs\n                {\n                    Name = \"MY_EXAMPLE_SECRET_TEXT\",\n                    Text = @var.Secret_foo_value,\n                },\n            },\n            WebassemblyBindings = \n            {\n                new Cloudflare.Inputs.WorkerScriptWebassemblyBindingArgs\n                {\n                    Name = \"MY_EXAMPLE_WASM\",\n                    Module = ReadFileBase64(\"example.wasm\"),\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc filebase64OrPanic(path string) pulumi.StringPtrInput {\n\tif fileData, err := ioutil.ReadFile(path); err == nil {\n\t\treturn pulumi.String(base64.StdEncoding.EncodeToString(fileData[:]))\n\t} else {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyNamespace, err := cloudflare.NewWorkersKvNamespace(ctx, \"myNamespace\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tTitle: pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerScript(ctx, \"myScript\", \u0026cloudflare.WorkerScriptArgs{\n\t\t\tName:    pulumi.String(\"script_1\"),\n\t\t\tContent: readFileOrPanic(\"script.js\"),\n\t\t\tKvNamespaceBindings: WorkerScriptKvNamespaceBindingArray{\n\t\t\t\t\u0026WorkerScriptKvNamespaceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_EXAMPLE_KV_NAMESPACE\"),\n\t\t\t\t\tNamespaceId: myNamespace.ID(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPlainTextBindings: WorkerScriptPlainTextBindingArray{\n\t\t\t\t\u0026WorkerScriptPlainTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_PLAIN_TEXT\"),\n\t\t\t\t\tText: pulumi.String(\"foobar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tSecretTextBindings: WorkerScriptSecretTextBindingArray{\n\t\t\t\t\u0026WorkerScriptSecretTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_SECRET_TEXT\"),\n\t\t\t\t\tText: pulumi.Any(_var.Secret_foo_value),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWebassemblyBindings: WorkerScriptWebassemblyBindingArray{\n\t\t\t\t\u0026WorkerScriptWebassemblyBindingArgs{\n\t\t\t\t\tName:   pulumi.String(\"MY_EXAMPLE_WASM\"),\n\t\t\t\t\tModule: filebase64OrPanic(\"example.wasm\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTo import a script, use a script name, e.g. `script_name`\n\n```sh\n $ pulumi import cloudflare:index/workerScript:WorkerScript default script_name\n```\n\n where* `script_name` - the script name ",
            "properties": {
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                    }
                }
            },
            "required": [
                "content",
                "name"
            ],
            "inputProperties": {
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n"
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                    }
                }
            },
            "requiredInputs": [
                "content",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerScript resources.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "The script content.\n"
                    },
                    "kvNamespaceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The global variable for the binding in your Worker code.\n"
                    },
                    "plainTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                        }
                    },
                    "secretTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                        }
                    },
                    "webassemblyBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKv:WorkersKv": {
            "description": "Provides a Workers KV Pair.  *NOTE:*  This resource uses the Cloudflare account APIs.  This requires setting the `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleNs = new cloudflare.WorkersKvNamespace(\"exampleNs\", {title: \"test-namespace\"});\nconst example = new cloudflare.WorkersKv(\"example\", {\n    namespaceId: exampleNs.id,\n    key: \"test-key\",\n    value: \"test value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_ns = cloudflare.WorkersKvNamespace(\"exampleNs\", title=\"test-namespace\")\nexample = cloudflare.WorkersKv(\"example\",\n    namespace_id=example_ns.id,\n    key=\"test-key\",\n    value=\"test value\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleNs = new Cloudflare.WorkersKvNamespace(\"exampleNs\", new Cloudflare.WorkersKvNamespaceArgs\n        {\n            Title = \"test-namespace\",\n        });\n        var example = new Cloudflare.WorkersKv(\"example\", new Cloudflare.WorkersKvArgs\n        {\n            NamespaceId = exampleNs.Id,\n            Key = \"test-key\",\n            Value = \"test value\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleNs, err := cloudflare.NewWorkersKvNamespace(ctx, \"exampleNs\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tTitle: pulumi.String(\"test-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkersKv(ctx, \"example\", \u0026cloudflare.WorkersKvArgs{\n\t\t\tNamespaceId: exampleNs.ID(),\n\t\t\tKey:         pulumi.String(\"test-key\"),\n\t\t\tValue:       pulumi.String(\"test value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/workersKv:WorkersKv example beaeb6716c9443eaa4deef11763ccca6_test-key\n```\n\n where- `beaeb6716c9443eaa4deef11763ccca6` is the ID of the namespace and `test-key` is the key ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key name\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair\n"
                },
                "value": {
                    "type": "string",
                    "description": "The string value to be stored in the key\n"
                }
            },
            "required": [
                "key",
                "namespaceId",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "The key name\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair\n"
                },
                "value": {
                    "type": "string",
                    "description": "The string value to be stored in the key\n"
                }
            },
            "requiredInputs": [
                "key",
                "namespaceId",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKv resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "The key name\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "The ID of the Workers KV namespace in which you want to create the KV pair\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The string value to be stored in the key\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKvNamespace:WorkersKvNamespace": {
            "description": "Provides a Workers KV Namespace\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WorkersKvNamespace(\"example\", {\n    title: \"test-namespace\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WorkersKvNamespace(\"example\", title=\"test-namespace\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Cloudflare.WorkersKvNamespace(\"example\", new Cloudflare.WorkersKvNamespaceArgs\n        {\n            Title = \"test-namespace\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkersKvNamespace(ctx, \"example\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tTitle: pulumi.String(\"test-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWorkers KV Namespace settings can be imported using it's ID\n\n```sh\n $ pulumi import cloudflare:index/workersKvNamespace:WorkersKvNamespace example beaeb6716c9443eaa4deef11763ccca6\n```\n\n where- `beaeb6716c9443eaa4deef11763ccca6` is the ID of the namespace ",
            "properties": {
                "title": {
                    "type": "string",
                    "description": "The name of the namespace you wish to create.\n"
                }
            },
            "required": [
                "title"
            ],
            "inputProperties": {
                "title": {
                    "type": "string",
                    "description": "The name of the namespace you wish to create.\n"
                }
            },
            "requiredInputs": [
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKvNamespace resources.\n",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "The name of the namespace you wish to create.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zone:Zone": {
            "description": "\n\n\n## Import\n\nZone resource can be imported using a zone ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/zone:Zone example d41d8cd98f00b204e9800998ecf8427e\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID, as returned from [API](https://api.cloudflare.com/#zone-list-zones) ",
            "properties": {
                "jumpStart": {
                    "type": "boolean",
                    "description": "Boolean of whether to scan for DNS records on creation. Ignored after zone is created. Default: false.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    }
                },
                "nameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone is paused (traffic bypasses Cloudflare). Default: false.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone, can be updated once the zone is created; one of `free`, `pro`, `business`, `enterprise`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone. Valid values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Valid values: `full`, `partial`. Default is `full`.\n"
                },
                "vanityNameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vanity Nameservers (if set).\n* `meta.wildcard_proxiable` - Indicates whether wildcard DNS records can receive Cloudflare security and performance features.\n* `meta.phishing_detected` - Indicates if URLs on the zone have been identified as hosting phishing content.\n"
                },
                "verificationKey": {
                    "type": "string",
                    "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added.\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    }
                }
            },
            "required": [
                "meta",
                "nameServers",
                "plan",
                "status",
                "vanityNameServers",
                "verificationKey",
                "zone"
            ],
            "inputProperties": {
                "jumpStart": {
                    "type": "boolean",
                    "description": "Boolean of whether to scan for DNS records on creation. Ignored after zone is created. Default: false.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone is paused (traffic bypasses Cloudflare). Default: false.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone, can be updated once the zone is created; one of `free`, `pro`, `business`, `enterprise`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Valid values: `full`, `partial`. Default is `full`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added.\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    }
                }
            },
            "requiredInputs": [
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Zone resources.\n",
                "properties": {
                    "jumpStart": {
                        "type": "boolean",
                        "description": "Boolean of whether to scan for DNS records on creation. Ignored after zone is created. Default: false.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "boolean"
                        }
                    },
                    "nameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Boolean of whether this zone is paused (traffic bypasses Cloudflare). Default: false.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The name of the commercial plan to apply to the zone, can be updated once the zone is created; one of `free`, `pro`, `business`, `enterprise`.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the zone. Valid values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Valid values: `full`, `partial`. Default is `full`.\n"
                    },
                    "vanityNameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vanity Nameservers (if set).\n* `meta.wildcard_proxiable` - Indicates whether wildcard DNS records can receive Cloudflare security and performance features.\n* `meta.phishing_detected` - Indicates if URLs on the zone have been identified as hosting phishing content.\n"
                    },
                    "verificationKey": {
                        "type": "string",
                        "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The DNS zone name which will be added.\n",
                        "language": {
                            "csharp": {
                                "name": "ZoneName"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneDnssec:ZoneDnssec": {
            "description": "Provides a Cloudflare Zone DNSSEC resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleZone = new cloudflare.Zone(\"exampleZone\", {zone: \"example.com\"});\nconst exampleZoneDnssec = new cloudflare.ZoneDnssec(\"exampleZoneDnssec\", {zoneId: exampleZone.id});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_zone = cloudflare.Zone(\"exampleZone\", zone=\"example.com\")\nexample_zone_dnssec = cloudflare.ZoneDnssec(\"exampleZoneDnssec\", zone_id=example_zone.id)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleZone = new Cloudflare.Zone(\"exampleZone\", new Cloudflare.ZoneArgs\n        {\n            Zone = \"example.com\",\n        });\n        var exampleZoneDnssec = new Cloudflare.ZoneDnssec(\"exampleZoneDnssec\", new Cloudflare.ZoneDnssecArgs\n        {\n            ZoneId = exampleZone.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleZone, err := cloudflare.NewZone(ctx, \"exampleZone\", \u0026cloudflare.ZoneArgs{\n\t\t\tZone: pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewZoneDnssec(ctx, \"exampleZoneDnssec\", \u0026cloudflare.ZoneDnssecArgs{\n\t\t\tZoneId: exampleZone.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nZone DNSSEC resource can be imported using a zone ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/zoneDnssec:ZoneDnssec example d41d8cd98f00b204e9800998ecf8427e\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID, as returned from [API](https://api.cloudflare.com/#zone-list-zones) ",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Zone DNSSEC algorithm.\n"
                },
                "digest": {
                    "type": "string",
                    "description": "Zone DNSSEC digest.\n"
                },
                "digestAlgorithm": {
                    "type": "string",
                    "description": "Digest algorithm use for Zone DNSSEC.\n"
                },
                "digestType": {
                    "type": "string",
                    "description": "Digest Type for Zone DNSSEC.\n"
                },
                "ds": {
                    "type": "string",
                    "description": "DS for the Zone DNSSEC.\n"
                },
                "flags": {
                    "type": "integer",
                    "description": "Zone DNSSEC flags.\n"
                },
                "keyTag": {
                    "type": "integer",
                    "description": "Key Tag for the Zone DNSSEC.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Key type used for Zone DNSSEC.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Zone DNSSEC updated time.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Public Key for the Zone DNSSEC.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the Zone DNSSEC.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone id for the zone.\n"
                }
            },
            "required": [
                "algorithm",
                "digest",
                "digestAlgorithm",
                "digestType",
                "ds",
                "flags",
                "keyTag",
                "keyType",
                "modifiedOn",
                "publicKey",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "modifiedOn": {
                    "type": "string",
                    "description": "Zone DNSSEC updated time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone id for the zone.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneDnssec resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Zone DNSSEC algorithm.\n"
                    },
                    "digest": {
                        "type": "string",
                        "description": "Zone DNSSEC digest.\n"
                    },
                    "digestAlgorithm": {
                        "type": "string",
                        "description": "Digest algorithm use for Zone DNSSEC.\n"
                    },
                    "digestType": {
                        "type": "string",
                        "description": "Digest Type for Zone DNSSEC.\n"
                    },
                    "ds": {
                        "type": "string",
                        "description": "DS for the Zone DNSSEC.\n"
                    },
                    "flags": {
                        "type": "integer",
                        "description": "Zone DNSSEC flags.\n"
                    },
                    "keyTag": {
                        "type": "integer",
                        "description": "Key Tag for the Zone DNSSEC.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Key type used for Zone DNSSEC.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Zone DNSSEC updated time.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public Key for the Zone DNSSEC.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the Zone DNSSEC.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone id for the zone.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneLockdown:ZoneLockdown": {
            "description": "Provides a Cloudflare Zone Lockdown resource. Zone Lockdown allows you to define one or more URLs (with wildcard matching on the domain or path) that will only permit access if the request originates from an IP address that matches a safelist of one or more IP addresses and/or IP ranges.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Restrict access to these endpoints to requests from a known IP address range.\nconst endpointLockdown = new cloudflare.ZoneLockdown(\"endpoint_lockdown\", {\n    configurations: [{\n        target: \"ip_range\",\n        value: \"198.51.100.0/16\",\n    }],\n    description: \"Restrict access to these endpoints to requests from a known IP address range\",\n    paused: false,\n    urls: [\"api.mysite.com/some/endpoint*\"],\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Restrict access to these endpoints to requests from a known IP address range.\nendpoint_lockdown = cloudflare.ZoneLockdown(\"endpointLockdown\",\n    configurations=[cloudflare.ZoneLockdownConfigurationArgs(\n        target=\"ip_range\",\n        value=\"198.51.100.0/16\",\n    )],\n    description=\"Restrict access to these endpoints to requests from a known IP address range\",\n    paused=False,\n    urls=[\"api.mysite.com/some/endpoint*\"],\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Restrict access to these endpoints to requests from a known IP address range.\n        var endpointLockdown = new Cloudflare.ZoneLockdown(\"endpointLockdown\", new Cloudflare.ZoneLockdownArgs\n        {\n            Configurations = \n            {\n                new Cloudflare.Inputs.ZoneLockdownConfigurationArgs\n                {\n                    Target = \"ip_range\",\n                    Value = \"198.51.100.0/16\",\n                },\n            },\n            Description = \"Restrict access to these endpoints to requests from a known IP address range\",\n            Paused = false,\n            Urls = \n            {\n                \"api.mysite.com/some/endpoint*\",\n            },\n            ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneLockdown(ctx, \"endpointLockdown\", \u0026cloudflare.ZoneLockdownArgs{\n\t\t\tConfigurations: ZoneLockdownConfigurationArray{\n\t\t\t\t\u0026ZoneLockdownConfigurationArgs{\n\t\t\t\t\tTarget: pulumi.String(\"ip_range\"),\n\t\t\t\t\tValue:  pulumi.String(\"198.51.100.0/16\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"Restrict access to these endpoints to requests from a known IP address range\"),\n\t\t\tPaused:      pulumi.Bool(false),\n\t\t\tUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api.mysite.com/some/endpoint*\"),\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRecords can be imported using a composite ID formed of zone name and record ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/zoneLockdown:ZoneLockdown cloudflare_zone_lockdown d41d8cd98f00b204e9800998ecf8427e/37cb64fe4a90adb5ca3afc04f2c82a2f\n```\n\n where* `d41d8cd98f00b204e9800998ecf8427e` - zone ID * `37cb64fe4a90adb5ca3afc04f2c82a2f` - zone lockdown ID as returned by [API](https://api.cloudflare.com/#zone-lockdown-list-lockdown-rules) ",
            "properties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.  It's a complex value. See description below.   The order of the configuration entries is unimportant.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the access rule should be added.\n"
                }
            },
            "required": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "inputProperties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.  It's a complex value. See description below.   The order of the configuration entries is unimportant.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the access rule should be added.\n"
                }
            },
            "requiredInputs": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneLockdown resources.\n",
                "properties": {
                    "configurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                        },
                        "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs.  It's a complex value. See description below.   The order of the configuration entries is unimportant.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the access rule should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneSettingsOverride:ZoneSettingsOverride": {
            "description": "Provides a resource which customizes Cloudflare zone settings. Note that after destroying this resource Zone Settings will be reset to their initial values.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = new cloudflare.ZoneSettingsOverride(\"test\", {\n    zoneId: _var.cloudflare_zone_id,\n    settings: {\n        brotli: \"on\",\n        challengeTtl: 2700,\n        securityLevel: \"high\",\n        opportunisticEncryption: \"on\",\n        automaticHttpsRewrites: \"on\",\n        mirage: \"on\",\n        waf: \"on\",\n        minify: {\n            css: \"on\",\n            js: \"off\",\n            html: \"off\",\n        },\n        securityHeader: {\n            enabled: true,\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.ZoneSettingsOverride(\"test\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    settings=cloudflare.ZoneSettingsOverrideSettingsArgs(\n        brotli=\"on\",\n        challenge_ttl=2700,\n        security_level=\"high\",\n        opportunistic_encryption=\"on\",\n        automatic_https_rewrites=\"on\",\n        mirage=\"on\",\n        waf=\"on\",\n        minify=cloudflare.ZoneSettingsOverrideSettingsMinifyArgs(\n            css=\"on\",\n            js=\"off\",\n            html=\"off\",\n        ),\n        security_header=cloudflare.ZoneSettingsOverrideSettingsSecurityHeaderArgs(\n            enabled=True,\n        ),\n    ))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Cloudflare.ZoneSettingsOverride(\"test\", new Cloudflare.ZoneSettingsOverrideArgs\n        {\n            ZoneId = @var.Cloudflare_zone_id,\n            Settings = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsArgs\n            {\n                Brotli = \"on\",\n                ChallengeTtl = 2700,\n                SecurityLevel = \"high\",\n                OpportunisticEncryption = \"on\",\n                AutomaticHttpsRewrites = \"on\",\n                Mirage = \"on\",\n                Waf = \"on\",\n                Minify = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsMinifyArgs\n                {\n                    Css = \"on\",\n                    Js = \"off\",\n                    Html = \"off\",\n                },\n                SecurityHeader = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs\n                {\n                    Enabled = true,\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneSettingsOverride(ctx, \"test\", \u0026cloudflare.ZoneSettingsOverrideArgs{\n\t\t\tZoneId: pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tSettings: \u0026ZoneSettingsOverrideSettingsArgs{\n\t\t\t\tBrotli:                  pulumi.String(\"on\"),\n\t\t\t\tChallengeTtl:            pulumi.Int(2700),\n\t\t\t\tSecurityLevel:           pulumi.String(\"high\"),\n\t\t\t\tOpportunisticEncryption: pulumi.String(\"on\"),\n\t\t\t\tAutomaticHttpsRewrites:  pulumi.String(\"on\"),\n\t\t\t\tMirage:                  pulumi.String(\"on\"),\n\t\t\t\tWaf:                     pulumi.String(\"on\"),\n\t\t\t\tMinify: \u0026ZoneSettingsOverrideSettingsMinifyArgs{\n\t\t\t\t\tCss:  pulumi.String(\"on\"),\n\t\t\t\t\tJs:   pulumi.String(\"off\"),\n\t\t\t\t\tHtml: pulumi.String(\"off\"),\n\t\t\t\t},\n\t\t\t\tSecurityHeader: \u0026ZoneSettingsOverrideSettingsSecurityHeaderArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "initialSettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting"
                    },
                    "description": "Settings present in the zone at the time the resource is created. This will be used to restore the original settings when this resource is destroyed. Shares the same schema as the `settings` attribute (Above).\n"
                },
                "initialSettingsReadAt": {
                    "type": "string",
                    "description": "Time when this resource was created and the `initial_settings` were set.\n"
                },
                "readonlySettings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Which of the current `settings` are not able to be set by the user. Which settings these are is determined by plan level and user permissions.\n* `zone_status`. A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup.\n* `zone_type`. Status of the zone. Valid values: active, pending, initializing, moved, deleted, deactivated.\n"
                },
                "settings": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                    "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                },
                "zoneStatus": {
                    "type": "string"
                },
                "zoneType": {
                    "type": "string"
                }
            },
            "required": [
                "initialSettings",
                "initialSettingsReadAt",
                "readonlySettings",
                "settings",
                "zoneId",
                "zoneStatus",
                "zoneType"
            ],
            "inputProperties": {
                "settings": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                    "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneSettingsOverride resources.\n",
                "properties": {
                    "initialSettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting"
                        },
                        "description": "Settings present in the zone at the time the resource is created. This will be used to restore the original settings when this resource is destroyed. Shares the same schema as the `settings` attribute (Above).\n"
                    },
                    "initialSettingsReadAt": {
                        "type": "string",
                        "description": "Time when this resource was created and the `initial_settings` were set.\n"
                    },
                    "readonlySettings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Which of the current `settings` are not able to be set by the user. Which settings these are is determined by plan level and user permissions.\n* `zone_status`. A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup.\n* `zone_type`. Status of the zone. Valid values: active, pending, initializing, moved, deleted, deactivated.\n"
                    },
                    "settings": {
                        "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                        "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which apply settings.\n"
                    },
                    "zoneStatus": {
                        "type": "string"
                    },
                    "zoneType": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "cloudflare:index/getAccessIdentityProvider:getAccessIdentityProvider": {
            "description": "Use this data source to lookup a single [Access Identity Provider][access_identity_provider_guide] by name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst mainAccessIdentityProvider = cloudflare.getAccessIdentityProvider({\n    name: \"Google SSO\",\n    accountId: \"example-account-id\",\n});\nconst mainAccessApplication = new cloudflare.AccessApplication(\"mainAccessApplication\", {\n    zoneId: \"example.com\",\n    name: \"name\",\n    domain: \"name.example.com\",\n    type: \"self_hosted\",\n    sessionDuration: \"24h\",\n    allowedIdps: [mainAccessIdentityProvider.then(mainAccessIdentityProvider =\u003e mainAccessIdentityProvider.id)],\n    autoRedirectToIdentity: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmain_access_identity_provider = cloudflare.get_access_identity_provider(name=\"Google SSO\",\n    account_id=\"example-account-id\")\nmain_access_application = cloudflare.AccessApplication(\"mainAccessApplication\",\n    zone_id=\"example.com\",\n    name=\"name\",\n    domain=\"name.example.com\",\n    type=\"self_hosted\",\n    session_duration=\"24h\",\n    allowed_idps=[main_access_identity_provider.id],\n    auto_redirect_to_identity=True)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var mainAccessIdentityProvider = Output.Create(Cloudflare.GetAccessIdentityProvider.InvokeAsync(new Cloudflare.GetAccessIdentityProviderArgs\n        {\n            Name = \"Google SSO\",\n            AccountId = \"example-account-id\",\n        }));\n        var mainAccessApplication = new Cloudflare.AccessApplication(\"mainAccessApplication\", new Cloudflare.AccessApplicationArgs\n        {\n            ZoneId = \"example.com\",\n            Name = \"name\",\n            Domain = \"name.example.com\",\n            Type = \"self_hosted\",\n            SessionDuration = \"24h\",\n            AllowedIdps = \n            {\n                mainAccessIdentityProvider.Apply(mainAccessIdentityProvider =\u003e mainAccessIdentityProvider.Id),\n            },\n            AutoRedirectToIdentity = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"example-account-id\"\n\t\tmainAccessIdentityProvider, err := cloudflare.LookupAccessIdentityProvider(ctx, \u0026GetAccessIdentityProviderArgs{\n\t\t\tName:      \"Google SSO\",\n\t\t\tAccountId: \u0026opt0,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessApplication(ctx, \"mainAccessApplication\", \u0026cloudflare.AccessApplicationArgs{\n\t\t\tZoneId:          pulumi.String(\"example.com\"),\n\t\t\tName:            pulumi.String(\"name\"),\n\t\t\tDomain:          pulumi.String(\"name.example.com\"),\n\t\t\tType:            pulumi.String(\"self_hosted\"),\n\t\t\tSessionDuration: pulumi.String(\"24h\"),\n\t\t\tAllowedIdps: pulumi.StringArray{\n\t\t\t\tpulumi.String(mainAccessIdentityProvider.Id),\n\t\t\t},\n\t\t\tAutoRedirectToIdentity: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account for which to look for an Access Identity Provider. Conflicts with `zone_id`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Access Identity Provider name to search for.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The Zone's ID. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Access Identity Provider Name\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Access Identity Provider Type\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "cloudflare:index/getAccountRoles:getAccountRoles": {
            "description": "Use this data source to lookup [Account Roles](https://api.cloudflare.com/#account-roles-properties).\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccountRoles.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account for which to list the roles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccountRoles.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getAccountRolesRole:getAccountRolesRole"
                        },
                        "description": "A list of roles object. See below for nested attributes.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "roles",
                    "id"
                ]
            }
        },
        "cloudflare:index/getApiTokenPermissionGroups:getApiTokenPermissionGroups": {
            "description": "Use this data source to look up [API Token Permission Groups](https://developers.cloudflare.com/api/tokens/create/permissions). Commonly used as references within [`cloudflare.ApiToken`](https://www.terraform.io/docs/providers/cloudflare/r/api_token.html) resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getApiTokenPermissionGroups({});\nexport const dnsReadPermissionId = test.then(test =\u003e test.permissions?[\"DNS Read\"]);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_api_token_permission_groups()\npulumi.export(\"dnsReadPermissionId\", test.permissions[\"DNS Read\"])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Cloudflare.GetApiTokenPermissionGroups.InvokeAsync());\n        this.DnsReadPermissionId = test.Apply(test =\u003e test.Permissions?.DNS_Read);\n    }\n\n    [Output(\"dnsReadPermissionId\")]\n    public Output\u003cstring\u003e DnsReadPermissionId { get; set; }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getApiTokenPermissionGroups.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "permissions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of permission groups where keys are human-readable permission names\nand values are permission IDs.\n"
                    }
                },
                "type": "object",
                "required": [
                    "permissions",
                    "id"
                ]
            }
        },
        "cloudflare:index/getIpRanges:getIpRanges": {
            "description": "Use this data source to get the [IP ranges](https://www.cloudflare.com/ips/) of Cloudflare edge nodes.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst cloudflare = cloudflare.getIpRanges({});\nconst allowCloudflareIngress = new gcp.compute.Firewall(\"allowCloudflareIngress\", {\n    network: \"default\",\n    sourceRanges: cloudflare.then(cloudflare =\u003e cloudflare.ipv4CidrBlocks),\n    allows: [{\n        ports: \"443\",\n        protocol: \"tcp\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_gcp as gcp\n\ncloudflare = cloudflare.get_ip_ranges()\nallow_cloudflare_ingress = gcp.compute.Firewall(\"allowCloudflareIngress\",\n    network=\"default\",\n    source_ranges=cloudflare.ipv4_cidr_blocks,\n    allows=[gcp.compute.FirewallAllowArgs(\n        ports=\"443\",\n        protocol=\"tcp\",\n    )])\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Gcp = Pulumi.Gcp;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var cloudflare = Output.Create(Cloudflare.GetIpRanges.InvokeAsync());\n        var allowCloudflareIngress = new Gcp.Compute.Firewall(\"allowCloudflareIngress\", new Gcp.Compute.FirewallArgs\n        {\n            Network = \"default\",\n            SourceRanges = cloudflare.Apply(cloudflare =\u003e cloudflare.Ipv4CidrBlocks),\n            Allows = \n            {\n                new Gcp.Compute.Inputs.FirewallAllowArgs\n                {\n                    Ports = \"443\",\n                    Protocol = \"tcp\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcloudflare, err := cloudflare.GetIpRanges(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewFirewall(ctx, \"allowCloudflareIngress\", \u0026compute.FirewallArgs{\n\t\t\tNetwork:      pulumi.String(\"default\"),\n\t\t\tSourceRanges: interface{}(cloudflare.Ipv4CidrBlocks),\n\t\t\tAllows: compute.FirewallAllowArray{\n\t\t\t\t\u0026compute.FirewallAllowArgs{\n\t\t\t\t\tPorts:    pulumi.StringArray(\"443\"),\n\t\t\t\t\tProtocol: pulumi.String(\"tcp\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getIpRanges.\n",
                "properties": {
                    "chinaIpv4CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv4 China CIDR blocks.\n"
                    },
                    "chinaIpv6CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv6 China CIDR blocks.\n"
                    },
                    "cidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of all non-China CIDR blocks.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipv4CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv4 CIDR blocks.\n"
                    },
                    "ipv6CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv6 CIDR blocks.\n"
                    }
                },
                "type": "object",
                "required": [
                    "chinaIpv4CidrBlocks",
                    "chinaIpv6CidrBlocks",
                    "cidrBlocks",
                    "ipv4CidrBlocks",
                    "ipv6CidrBlocks",
                    "id"
                ]
            }
        },
        "cloudflare:index/getOriginCaRootCertificate:getOriginCaRootCertificate": {
            "description": "Use this data source to get the [Origin CA root certificate](https://developers.cloudflare.com/ssl/origin-configuration/origin-ca#4-required-for-some-add-cloudflare-origin-ca-root-certificates) for a given algorithm.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst originCa = pulumi.output(cloudflare.getOriginCaRootCertificate({\n    algorithm: \"\u003calgorithm\u003e\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\norigin_ca = cloudflare.get_origin_ca_root_certificate(algorithm=\"\u003calgorithm\u003e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var originCa = Output.Create(Cloudflare.GetOriginCaRootCertificate.InvokeAsync(new Cloudflare.GetOriginCaRootCertificateArgs\n        {\n            Algorithm = \"\u003calgorithm\u003e\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetOriginCaRootCertificate(ctx, \u0026GetOriginCaRootCertificateArgs{\n\t\t\tAlgorithm: \"\u003calgorithm\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getOriginCaRootCertificate.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "The name of the algorithm used when creating an Origin CA certificate. Currently-supported values are \"rsa\" and \"ecc\" (case-insensitive).\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOriginCaRootCertificate.\n",
                "properties": {
                    "algorithm": {
                        "type": "string"
                    },
                    "certPem": {
                        "type": "string",
                        "description": "The Origin CA root certificate in PEM format.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "certPem",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafGroups:getWafGroups": {
            "description": "Use this data source to look up [WAF Rule Groups](https://api.cloudflare.com/#waf-rule-groups-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all WAF Rule Groups that contain the word `example` and are currently `on`. The matched WAF Rule Groups are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafGroups({\n    filter: {\n        name: \".*example.*\",\n        mode: \"on\",\n    },\n});\nexport const wafGroups = test.then(test =\u003e test.groups);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_groups(filter=cloudflare.GetWafGroupsFilterArgs(\n    name=\".*example.*\",\n    mode=\"on\",\n))\npulumi.export(\"wafGroups\", test.groups)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Cloudflare.GetWafGroups.InvokeAsync(new Cloudflare.GetWafGroupsArgs\n        {\n            Filter = new Cloudflare.Inputs.GetWafGroupsFilterArgs\n            {\n                Name = \".*example.*\",\n                Mode = \"on\",\n            },\n        }));\n        this.WafGroups = test.Apply(test =\u003e test.Groups);\n    }\n\n    [Output(\"wafGroups\")]\n    public Output\u003cstring\u003e WafGroups { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := cloudflare.GetWafGroups(ctx, \u0026GetWafGroupsArgs{\n\t\t\tFilter: GetWafGroupsFilter{\n\t\t\t\tName: \".*example.*\",\n\t\t\t\tMode: \"on\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafGroups\", test.Groups)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getWafGroups.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafGroupsFilter:getWafGroupsFilter",
                        "description": "One or more values used to look up WAF Rule Groups. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package in which to search for the WAF Rule Groups.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to search for the WAF Rule Groups.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafGroups.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafGroupsFilter:getWafGroupsFilter"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getWafGroupsGroup:getWafGroupsGroup"
                        },
                        "description": "A map of WAF Rule Groups details. Full list below:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the WAF Rule Group\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "groups",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafPackages:getWafPackages": {
            "description": "Use this data source to look up [WAF Rule Packages](https://api.cloudflare.com/#waf-rule-packages-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all `high` sensitivity WAF Rule Packages, with a `challenge` action mode and an `anomaly` detection mode, that contain the word `example`. The matched WAF Rule Packages are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafPackages({\n    filter: {\n        name: \".*example.*\",\n        detectionMode: \"anomaly\",\n        sensitivity: \"high\",\n        actionMode: \"challenge\",\n    },\n});\nexport const wafPackages = test.then(test =\u003e test.packages);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_packages(filter=cloudflare.GetWafPackagesFilterArgs(\n    name=\".*example.*\",\n    detection_mode=\"anomaly\",\n    sensitivity=\"high\",\n    action_mode=\"challenge\",\n))\npulumi.export(\"wafPackages\", test.packages)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Cloudflare.GetWafPackages.InvokeAsync(new Cloudflare.GetWafPackagesArgs\n        {\n            Filter = new Cloudflare.Inputs.GetWafPackagesFilterArgs\n            {\n                Name = \".*example.*\",\n                DetectionMode = \"anomaly\",\n                Sensitivity = \"high\",\n                ActionMode = \"challenge\",\n            },\n        }));\n        this.WafPackages = test.Apply(test =\u003e test.Packages);\n    }\n\n    [Output(\"wafPackages\")]\n    public Output\u003cstring\u003e WafPackages { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := cloudflare.GetWafPackages(ctx, \u0026GetWafPackagesArgs{\n\t\t\tFilter: GetWafPackagesFilter{\n\t\t\t\tName:          \".*example.*\",\n\t\t\t\tDetectionMode: \"anomaly\",\n\t\t\t\tSensitivity:   \"high\",\n\t\t\t\tActionMode:    \"challenge\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafPackages\", test.Packages)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getWafPackages.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafPackagesFilter:getWafPackagesFilter",
                        "description": "One or more values used to look up WAF Rule Packages. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to search for the WAF Rule Packages.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafPackages.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafPackagesFilter:getWafPackagesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getWafPackagesPackage:getWafPackagesPackage"
                        },
                        "description": "A map of WAF Rule Packages details. Full list below:\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "packages",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafRules:getWafRules": {
            "description": "Use this data source to look up [WAF Rules](https://api.cloudflare.com/#waf-rule-groups-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all WAF Rules that are in the group of ID `de677e5818985db1285d0e80225f06e5`, contain `example` in their description, and are currently `on`. The matched WAF Rules are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafRules({\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n    packageId: \"a25a9a7e9c00afc1fb2e0245519d725b\",\n    filter: {\n        description: \".*example.*\",\n        mode: \"on\",\n        groupId: \"de677e5818985db1285d0e80225f06e5\",\n    },\n});\nexport const wafRules = test.then(test =\u003e test.rules);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_rules(zone_id=\"ae36f999674d196762efcc5abb06b345\",\n    package_id=\"a25a9a7e9c00afc1fb2e0245519d725b\",\n    filter=cloudflare.GetWafRulesFilterArgs(\n        description=\".*example.*\",\n        mode=\"on\",\n        group_id=\"de677e5818985db1285d0e80225f06e5\",\n    ))\npulumi.export(\"wafRules\", test.rules)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Cloudflare.GetWafRules.InvokeAsync(new Cloudflare.GetWafRulesArgs\n        {\n            ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n            PackageId = \"a25a9a7e9c00afc1fb2e0245519d725b\",\n            Filter = new Cloudflare.Inputs.GetWafRulesFilterArgs\n            {\n                Description = \".*example.*\",\n                Mode = \"on\",\n                GroupId = \"de677e5818985db1285d0e80225f06e5\",\n            },\n        }));\n        this.WafRules = test.Apply(test =\u003e test.Rules);\n    }\n\n    [Output(\"wafRules\")]\n    public Output\u003cstring\u003e WafRules { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"a25a9a7e9c00afc1fb2e0245519d725b\"\n\t\ttest, err := cloudflare.GetWafRules(ctx, \u0026GetWafRulesArgs{\n\t\t\tZoneId:    \"ae36f999674d196762efcc5abb06b345\",\n\t\t\tPackageId: \u0026opt0,\n\t\t\tFilter: GetWafRulesFilter{\n\t\t\t\tDescription: \".*example.*\",\n\t\t\t\tMode:        \"on\",\n\t\t\t\tGroupId:     \"de677e5818985db1285d0e80225f06e5\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafRules\", test.Rules)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getWafRules.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafRulesFilter:getWafRulesFilter",
                        "description": "One or more values used to look up WAF Rules. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package in which to search for the WAF Rules.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to search for the WAF Rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafRules.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafRulesFilter:getWafRulesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the WAF Rule\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getWafRulesRule:getWafRulesRule"
                        },
                        "description": "A map of WAF Rules details. Full list below:\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "rules",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZone:getZone": {
            "description": "Use this data source to look up [zone] info. This is the singular alternative\nto `cloudflare.getZones`.\n\n\u003e **Note** Cloudflare zone names **are not unique**. It is possible for multiple\n  accounts to have the same zone created but in different states. If you are\n  using this setup, it is advised to use the `account_id` attribute on this\n  resource or swap to `cloudflare.getZones` to further filter the results.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// You can also lookup by zone_id if you prefer.\nconst example = pulumi.output(cloudflare.getZone({\n    zoneId: \"0b6d347b01d437a092be84c2edfce72c\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone(zone_id=\"0b6d347b01d437a092be84c2edfce72c\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Cloudflare.GetZone.InvokeAsync(new Cloudflare.GetZoneArgs\n        {\n            ZoneId = \"0b6d347b01d437a092be84c2edfce72c\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"0b6d347b01d437a092be84c2edfce72c\"\n\t\t_, err := cloudflare.LookupZone(ctx, \u0026GetZoneArgs{\n\t\t\tZoneId: \u0026opt0,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Example usage with other resources\n\nThe example below fetches the zone information for example.com and then is\nreferenced in the `cloudflare.Record` section.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleZone = cloudflare.getZone({\n    name: \"example.com\",\n});\nconst exampleRecord = new cloudflare.Record(\"exampleRecord\", {\n    zoneId: exampleZone.then(exampleZone =\u003e exampleZone.id),\n    name: \"www\",\n    value: \"203.0.113.1\",\n    type: \"A\",\n    proxied: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_zone = cloudflare.get_zone(name=\"example.com\")\nexample_record = cloudflare.Record(\"exampleRecord\",\n    zone_id=example_zone.id,\n    name=\"www\",\n    value=\"203.0.113.1\",\n    type=\"A\",\n    proxied=True)\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleZone = Output.Create(Cloudflare.GetZone.InvokeAsync(new Cloudflare.GetZoneArgs\n        {\n            Name = \"example.com\",\n        }));\n        var exampleRecord = new Cloudflare.Record(\"exampleRecord\", new Cloudflare.RecordArgs\n        {\n            ZoneId = exampleZone.Apply(exampleZone =\u003e exampleZone.Id),\n            Name = \"www\",\n            Value = \"203.0.113.1\",\n            Type = \"A\",\n            Proxied = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\topt0 := \"example.com\"\n\t\texampleZone, err := cloudflare.LookupZone(ctx, \u0026GetZoneArgs{\n\t\t\tName: \u0026opt0,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewRecord(ctx, \"exampleRecord\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId:  pulumi.String(exampleZone.Id),\n\t\t\tName:    pulumi.String(\"www\"),\n\t\t\tValue:   pulumi.String(\"203.0.113.1\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t\tProxied: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getZone.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID associated with the zone.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the zone. Conflicts with `\"zone_id\"`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID. Conflicts with `\"name\"`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZone.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID associated with the zone.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the zone.\n"
                    },
                    "nameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cloudflare assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "`true` if cloudflare is enabled on the zone, otherwise `false`.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The name of the plan associated with the zone.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the zone. Values can be: `\"active\"`, `\"pending\"`, `\"initializing\"`, `\"moved\"`, `\"deleted\"`,\nor `\"deactivated\"`.\n"
                    },
                    "vanityNameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vanity Nameservers (if set).\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name",
                    "nameServers",
                    "paused",
                    "plan",
                    "status",
                    "vanityNameServers",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZoneDnssec:getZoneDnssec": {
            "description": "Use this data source to look up [Zone][1] DNSSEC settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = pulumi.output(cloudflare.getZoneDnssec({\n    zoneId: \"\u003czone_id\u003e\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone_dnssec(zone_id=\"\u003czone_id\u003e\")\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Cloudflare.GetZoneDnssec.InvokeAsync(new Cloudflare.GetZoneDnssecArgs\n        {\n            ZoneId = \"\u003czone_id\u003e\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.LookupZoneDnssec(ctx, \u0026GetZoneDnssecArgs{\n\t\t\tZoneId: \"\u003czone_id\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getZoneDnssec.\n",
                "properties": {
                    "zoneId": {
                        "type": "string",
                        "description": "The zone id for the zone.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZoneDnssec.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Zone DNSSEC algorithm.\n"
                    },
                    "digest": {
                        "type": "string",
                        "description": "Zone DNSSEC digest.\n"
                    },
                    "digestAlgorithm": {
                        "type": "string",
                        "description": "Digest algorithm use for Zone DNSSEC.\n"
                    },
                    "digestType": {
                        "type": "string",
                        "description": "Digest Type for Zone DNSSEC.\n"
                    },
                    "ds": {
                        "type": "string",
                        "description": "DS for the Zone DNSSEC.\n"
                    },
                    "flags": {
                        "type": "integer",
                        "description": "Zone DNSSEC flags.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keyTag": {
                        "type": "integer",
                        "description": "Key Tag for the Zone DNSSEC.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Key type used for Zone DNSSEC.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public Key for the Zone DNSSEC.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the Zone DNSSEC.\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "digest",
                    "digestAlgorithm",
                    "digestType",
                    "ds",
                    "flags",
                    "keyTag",
                    "keyType",
                    "publicKey",
                    "status",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZones:getZones": {
            "description": "Use this data source to look up [Zone](https://api.cloudflare.com/#zone-properties) records.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nGiven you have the following zones in Cloudflare.\n\n- example.com\n- example.net\n- not-example.com\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Look for a single zone that you know exists using an exact match.\n// API request will be for zones?name=example.com. Will not match not-example.com\n// or example.net.\nconst example = pulumi.output(cloudflare.getZones({\n    filter: {\n        name: \"example.com\",\n    },\n}));\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    name=\"example.com\",\n))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Cloudflare.GetZones.InvokeAsync(new Cloudflare.GetZonesArgs\n        {\n            Filter = new Cloudflare.Inputs.GetZonesFilterArgs\n            {\n                Name = \"example.com\",\n            },\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetZones(ctx, \u0026GetZonesArgs{\n\t\t\tFilter: GetZonesFilter{\n\t\t\t\tName: \"example.com\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Look for all zones which include \"example\".\n// API request will be for zones?name=contains:example. Will return all three\n// zones.\nconst example = pulumi.output(cloudflare.getZones({\n    filter: {\n        lookupType: \"contains\",\n        name: \"example\",\n    },\n}));\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    lookup_type=\"contains\",\n    name=\"example\",\n))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Cloudflare.GetZones.InvokeAsync(new Cloudflare.GetZonesArgs\n        {\n            Filter = new Cloudflare.Inputs.GetZonesFilterArgs\n            {\n                LookupType = \"contains\",\n                Name = \"example\",\n            },\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetZones(ctx, \u0026GetZonesArgs{\n\t\t\tFilter: GetZonesFilter{\n\t\t\t\tLookupType: \"contains\",\n\t\t\t\tName:       \"example\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Look for all zones which include \"example\" but start with \"not-\".\n// API request will be for zones?name=contains:example. Will perform client side\n// filtering using the provided regex and will only match the single zone,\n// not-example.com.\nconst example = pulumi.output(cloudflare.getZones({\n    filter: {\n        lookupType: \"contains\",\n        match: \"^not-\",\n        name: \"example\",\n    },\n}));\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    lookup_type=\"contains\",\n    match=\"^not-\",\n    name=\"example\",\n))\n```\n```csharp\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Cloudflare.GetZones.InvokeAsync(new Cloudflare.GetZonesArgs\n        {\n            Filter = new Cloudflare.Inputs.GetZonesFilterArgs\n            {\n                LookupType = \"contains\",\n                Match = \"^not-\",\n                Name = \"example\",\n            },\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.GetZones(ctx, \u0026GetZonesArgs{\n\t\t\tFilter: GetZonesFilter{\n\t\t\t\tLookupType: \"contains\",\n\t\t\t\tMatch:      \"^not-\",\n\t\t\t\tName:       \"example\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getZonesFilter:getZonesFilter",
                        "description": "One or more values used to look up zone records. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "filter"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getZonesFilter:getZonesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "zones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getZonesZone:getZonesZone"
                        },
                        "description": "A list of zone objects. Object format:\n"
                    }
                },
                "type": "object",
                "required": [
                    "filter",
                    "zones",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "cloudflare": "Cloudflare"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing Cloudflare cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`cloudflare/terraform-provider-cloudflare` repo](https://github.com/cloudflare/terraform-provider-cloudflare/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`cloudflare/terraform-provider-cloudflare` repo](https://github.com/cloudflare/terraform-provider-cloudflare/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    }
}