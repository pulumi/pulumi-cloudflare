{
    "name": "cloudflare",
    "description": "A Pulumi package for creating and managing Cloudflare cloud resources.",
    "keywords": [
        "pulumi",
        "cloudflare"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`cloudflare` Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare).",
    "repository": "https://github.com/pulumi/pulumi-cloudflare",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "cloudflare": "Cloudflare"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing Cloudflare cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-cloudflare` repo](https://github.com/cloudflare/terraform-provider-cloudflare/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/cloudflare/terraform-provider-cloudflare)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-cloudflare` repo](https://github.com/pulumi/pulumi-cloudflare/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-cloudflare` repo](https://github.com/cloudflare/terraform-provider-cloudflare/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use a specific account. Alternatively, can be configured using the\n`CLOUDFLARE_ACCOUNT_ID` environment variable.\n",
                "deprecationMessage": "Use resource specific `account_id` attributes instead."
            },
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_BASE_PATH`\nenvironment variable.\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger). Alternatively, can be configured using\nthe `CLOUDFLARE_API_CLIENT_LOGGING` environment variable.\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_HOSTNAME`\nenvironment variable.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations. Alternatively, can be configured using the `CLOUDFLARE_API_KEY` environment variable. API\nkeys are [now considered legacy by Cloudflare](https://developers.cloudflare.com/api/keys/#limitations), API tokens\nshould be used instead.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations. Alternatively, can be configured using the `CLOUDFLARE_API_TOKEN` environment variable.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints. Alternatively, can be configured using the\n`CLOUDFLARE_API_USER_SERVICE_KEY` environment variable.\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address. Alternatively, can be configured using the `CLOUDFLARE_EMAIL` environment\nvariable.\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MAX_BACKOFF` environment variable.\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MIN_BACKOFF` environment variable.\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails. Alternatively, can be configured using the\n`CLOUDFLARE_RETRIES` environment variable.\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API. Alternatively, can be configured using the `CLOUDFLARE_RPS` environment\nvariable.\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            }
        }
    },
    "types": {
        "cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader": {
            "properties": {
                "allowAllHeaders": {
                    "type": "boolean",
                    "description": "Value to determine whether all HTTP headers are exposed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowAllMethods": {
                    "type": "boolean",
                    "description": "Value to determine whether all methods are exposed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowAllOrigins": {
                    "type": "boolean",
                    "description": "Value to determine whether all origins are permitted to make CORS requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowCredentials": {
                    "type": "boolean",
                    "description": "Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowedHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of HTTP headers to expose via CORS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowedMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of methods to expose via CORS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "allowedOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of origins permitted to make CORS requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "The maximum time a preflight request will be cached.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp": {
            "properties": {
                "consumerServiceUrl": {
                    "type": "string",
                    "description": "The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "The format of the name identifier sent to the SaaS application. Defaults to `email`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "spEntityId": {
                    "type": "string",
                    "description": "A globally unique name for an identity or service provider.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "consumerServiceUrl",
                "spEntityId"
            ]
        },
        "cloudflare:index/AccessGroupExclude:AccessGroupExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeAzure:AccessGroupExcludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessGroupExcludeExternalEvaluation:AccessGroupExcludeExternalEvaluation",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeGithub:AccessGroupExcludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeOkta:AccessGroupExcludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExcludeSaml:AccessGroupExcludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeAzure:AccessGroupExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeExternalEvaluation:AccessGroupExcludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keysUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeGithub:AccessGroupExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeGsuite:AccessGroupExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeOkta:AccessGroupExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupExcludeSaml:AccessGroupExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupInclude:AccessGroupInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeAzure:AccessGroupIncludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessGroupIncludeExternalEvaluation:AccessGroupIncludeExternalEvaluation",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeGithub:AccessGroupIncludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeOkta:AccessGroupIncludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupIncludeSaml:AccessGroupIncludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeAzure:AccessGroupIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeExternalEvaluation:AccessGroupIncludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keysUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeGithub:AccessGroupIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeGsuite:AccessGroupIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeOkta:AccessGroupIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupIncludeSaml:AccessGroupIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequire:AccessGroupRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireAzure:AccessGroupRequireAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessGroupRequireExternalEvaluation:AccessGroupRequireExternalEvaluation",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireGithub:AccessGroupRequireGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireGsuite:AccessGroupRequireGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireOkta:AccessGroupRequireOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequireSaml:AccessGroupRequireSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireAzure:AccessGroupRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireExternalEvaluation:AccessGroupRequireExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keysUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireGithub:AccessGroupRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireGsuite:AccessGroupRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireOkta:AccessGroupRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessGroupRequireSaml:AccessGroupRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "appsDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "centrifyAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "centrifyAppId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certsUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directoryId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAttributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "idpPublicCert": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "issuerUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktaAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oneloginAccount": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pkceEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "redirectUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signRequest": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssoTargetUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportGroups": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tokenUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "redirectUrl"
                    ]
                }
            }
        },
        "cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "The background color on the login page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "footerText": {
                    "type": "string",
                    "description": "The text at the bottom of the login page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headerText": {
                    "type": "string",
                    "description": "The text at the top of the login page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logoPath": {
                    "type": "string",
                    "description": "The URL of the logo on the login page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "textColor": {
                    "type": "string",
                    "description": "The text color on the login page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup": {
            "properties": {
                "approvalsNeeded": {
                    "type": "integer",
                    "description": "Number of approvals needed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of emails to request approval from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailListUuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "approvalsNeeded"
            ]
        },
        "cloudflare:index/AccessPolicyExclude:AccessPolicyExclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyExcludeExternalEvaluation:AccessPolicyExcludeExternalEvaluation",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeAzure:AccessPolicyExcludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeExternalEvaluation:AccessPolicyExcludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keysUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeGithub:AccessPolicyExcludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeGsuite:AccessPolicyExcludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeOkta:AccessPolicyExcludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyExcludeSaml:AccessPolicyExcludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyInclude:AccessPolicyInclude": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyIncludeExternalEvaluation:AccessPolicyIncludeExternalEvaluation",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeAzure:AccessPolicyIncludeAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeExternalEvaluation:AccessPolicyIncludeExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keysUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeGithub:AccessPolicyIncludeGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeGsuite:AccessPolicyIncludeGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeOkta:AccessPolicyIncludeOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyIncludeSaml:AccessPolicyIncludeSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequire:AccessPolicyRequire": {
            "properties": {
                "anyValidServiceToken": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authMethod": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireAzure:AccessPolicyRequireAzure"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "devicePostures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "everyone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalEvaluation": {
                    "$ref": "#/types/cloudflare:index/AccessPolicyRequireExternalEvaluation:AccessPolicyRequireExternalEvaluation",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireGithub:AccessPolicyRequireGithub"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gsuites": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginMethods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireOkta:AccessPolicyRequireOkta"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequireSaml:AccessPolicyRequireSaml"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceTokens": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireAzure:AccessPolicyRequireAzure": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireExternalEvaluation:AccessPolicyRequireExternalEvaluation": {
            "properties": {
                "evaluateUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keysUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireGithub:AccessPolicyRequireGithub": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireGsuite:AccessPolicyRequireGsuite": {
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireOkta:AccessPolicyRequireOkta": {
            "properties": {
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Friendly name of the Access Policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessPolicyRequireSaml:AccessPolicyRequireSaml": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attributeValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the characteristic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of characteristic. Available values: `header`, `cookie`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenCondition:ApiTokenCondition": {
            "properties": {
                "requestIp": {
                    "$ref": "#/types/cloudflare:index/ApiTokenConditionRequestIp:ApiTokenConditionRequestIp",
                    "description": "Request IP related conditions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenConditionRequestIp:ApiTokenConditionRequestIp": {
            "properties": {
                "ins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notIns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ApiTokenPolicy:ApiTokenPolicy": {
            "properties": {
                "effect": {
                    "type": "string",
                    "description": "Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permissionGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Describes what operations against which resources are allowed or denied.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "permissionGroups",
                "resources"
            ]
        },
        "cloudflare:index/CertificatePackValidationError:CertificatePackValidationError": {
            "properties": {
                "message": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "message"
                    ]
                }
            }
        },
        "cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord": {
            "properties": {
                "cnameName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTarget": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "txtName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "txtValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cnameName",
                        "cnameTarget",
                        "emails",
                        "httpBody",
                        "httpUrl",
                        "txtName",
                        "txtValue"
                    ]
                }
            }
        },
        "cloudflare:index/CustomHostnameSsl:CustomHostnameSsl": {
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customCertificate": {
                    "type": "string",
                    "description": "If a custom uploaded certificate is used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customKey": {
                    "type": "string",
                    "description": "The key for a custom uploaded certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "method": {
                    "type": "string",
                    "description": "Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslSetting:CustomHostnameSslSetting"
                    },
                    "description": "SSL/TLS settings for the certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Status of the certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "validationErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslValidationError:CustomHostnameSslValidationError"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "validationRecords": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSslValidationRecord:CustomHostnameSslValidationRecord"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "wildcard": {
                    "type": "boolean",
                    "description": "Indicates whether the certificate covers a wildcard.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certificateAuthority",
                        "settings",
                        "status",
                        "validationErrors",
                        "validationRecords"
                    ]
                }
            }
        },
        "cloudflare:index/CustomHostnameSslSetting:CustomHostnameSslSetting": {
            "properties": {
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "earlyHints": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/CustomHostnameSslValidationError:CustomHostnameSslValidationError": {
            "properties": {
                "message": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "message"
                    ]
                }
            }
        },
        "cloudflare:index/CustomHostnameSslValidationRecord:CustomHostnameSslValidationRecord": {
            "properties": {
                "cnameName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTarget": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "txtName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "txtValue": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cnameName",
                        "cnameTarget",
                        "emails",
                        "httpBody",
                        "httpUrl",
                        "txtName",
                        "txtValue"
                    ]
                }
            }
        },
        "cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions": {
            "properties": {
                "bundleMethod": {
                    "type": "string",
                    "description": "Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "description": "Certificate certificate and the intermediate(s)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geoRestrictions": {
                    "type": "string",
                    "description": "Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateKey": {
                    "type": "string",
                    "description": "Certificate's private key\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "type": {
                    "type": "string",
                    "description": "Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig": {
            "properties": {
                "apiUrl": {
                    "type": "string",
                    "description": "The third-party API's URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authUrl": {
                    "type": "string",
                    "description": "The third-party authorization API URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientId": {
                    "type": "string",
                    "description": "The client identifier for authenticating API calls.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientKey": {
                    "type": "string",
                    "description": "The client key for authenticating API calls.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret for authenticating API calls.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "customerId": {
                    "type": "string",
                    "description": "The customer identifier for authenticating API calls.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput": {
            "properties": {
                "complianceStatus": {
                    "type": "string",
                    "description": "The workspace one device compliance status.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionId": {
                    "type": "string",
                    "description": "The workspace one connection id.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domain": {
                    "type": "string",
                    "description": "The domain that the client must join.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "True if the firewall must be enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exists": {
                    "type": "boolean",
                    "description": "Checks if the file should exist.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The Teams List id.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "description": "The version comparison operator.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "osDistroName": {
                    "type": "string",
                    "description": "The operating system excluding version information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "osDistroRevision": {
                    "type": "string",
                    "description": "The operating system version excluding OS name information or release name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the file.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireAll": {
                    "type": "boolean",
                    "description": "True if all drives must be encrypted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "running": {
                    "type": "boolean",
                    "description": "Checks if the application should be running.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sha256": {
                    "type": "string",
                    "description": "The sha256 hash of the file.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thumbprint": {
                    "type": "string",
                    "description": "The thumbprint of the file certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "description": "The operating system semantic version.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "exists",
                        "requireAll",
                        "running"
                    ]
                }
            }
        },
        "cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch": {
            "properties": {
                "platform": {
                    "type": "string",
                    "description": "The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/DlpProfileEntry:DlpProfileEntry": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the entry is active. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique entry identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the entry to deploy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pattern": {
                    "$ref": "#/types/cloudflare:index/DlpProfileEntryPattern:DlpProfileEntryPattern",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "cloudflare:index/DlpProfileEntryPattern:DlpProfileEntryPattern": {
            "properties": {
                "regex": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "validation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "regex"
            ]
        },
        "cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Type of supported action. Available values: `drop`, `forward`, `worker`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list with items in the following form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type",
                "values"
            ]
        },
        "cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Type of matcher. Available values: `all`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Type of supported action.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array with items in the following form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type",
                "values"
            ]
        },
        "cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher": {
            "properties": {
                "field": {
                    "type": "string",
                    "description": "Field for type matcher.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Type of matcher.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value for matcher.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "cloudflare:index/FallbackDomainDomain:FallbackDomainDomain": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description of the fallback domain, displayed in the client UI.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses to handle domain resolution.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "suffix": {
                    "type": "string",
                    "description": "The domain suffix to match when resolving locally.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/HealthcheckHeader:HealthcheckHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/IpListItem:IpListItem": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "A note that can be used to annotate the item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The IPv4 address, IPv4 CIDR or IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "cloudflare:index/ListItem:ListItem": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "An optional comment for the item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "$ref": "#/types/cloudflare:index/ListItemValue:ListItemValue",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "cloudflare:index/ListItemValue:ListItemValue": {
            "properties": {
                "ip": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "redirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItemValueRedirect:ListItemValueRedirect"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/ListItemValueRedirect:ListItemValueRedirect": {
            "properties": {
                "includeSubdomains": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preservePathSuffix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preserveQueryString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sourceUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "subpathMatching": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "sourceUrl",
                "targetUrl"
            ]
        },
        "cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting": {
            "properties": {
                "failoverAcrossPools": {
                    "type": "boolean",
                    "description": "Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool": {
            "properties": {
                "country": {
                    "type": "string",
                    "description": "A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given country.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "country",
                "poolIds"
            ]
        },
        "cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferEcs": {
                    "type": "string",
                    "description": "Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy=\"proximity\"`, and `geo` will prefer ECS only when `steering_policy=\"geo\"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding": {
            "properties": {
                "defaultPercent": {
                    "type": "number",
                    "description": "Percent of traffic to shed 0 - 100.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultPolicy": {
                    "type": "string",
                    "description": "Method of shedding traffic \"\", \"hash\" or \"random\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionPercent": {
                    "type": "number",
                    "description": "Percent of session traffic to shed 0 - 100.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionPolicy": {
                    "type": "string",
                    "description": "Method of shedding session traffic \"\" or \"hash\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginHeader:LoadBalancerPoolOriginHeader"
                    },
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Default: 1.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "name"
            ]
        },
        "cloudflare:index/LoadBalancerPoolOriginHeader:LoadBalancerPoolOriginHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "The header name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of string values for the header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering": {
            "properties": {
                "policy": {
                    "type": "string",
                    "description": "Either \"random\" (default) or \"hash\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering": {
            "properties": {
                "defaultWeight": {
                    "type": "number",
                    "description": "The default weight for pools in the load balancer that are not specified in the `pool_weights` map.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "poolWeights": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:index/LoadBalancerRule:LoadBalancerRule": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A disabled rule will not be executed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fixedResponse": {
                    "$ref": "#/types/cloudflare:index/LoadBalancerRuleFixedResponse:LoadBalancerRuleFixedResponse",
                    "description": "Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Human readable name for this rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrides": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverride:LoadBalancerRuleOverride"
                    },
                    "description": "The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "terminates": {
                    "type": "boolean",
                    "description": "Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "priority",
                        "terminates"
                    ]
                }
            }
        },
        "cloudflare:index/LoadBalancerRuleFixedResponse:LoadBalancerRuleFixedResponse": {
            "properties": {
                "contentType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "location": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "messageBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverride:LoadBalancerRuleOverride": {
            "properties": {
                "adaptiveRoutings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideAdaptiveRouting:LoadBalancerRuleOverrideAdaptiveRouting"
                    },
                    "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideCountryPool:LoadBalancerRuleOverrideCountryPool"
                    },
                    "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultPools": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fallbackPool": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "locationStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideLocationStrategy:LoadBalancerRuleOverrideLocationStrategy"
                    },
                    "description": "Controls location-based steering for non-proxied requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverridePopPool:LoadBalancerRuleOverridePopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "randomSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideRandomSteering:LoadBalancerRuleOverrideRandomSteering"
                    },
                    "description": "Configures pool weights for random steering. When the `steering_policy=\"random\"`, a random pool is selected with probability proportional to these pool weights.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRuleOverrideRegionPool:LoadBalancerRuleOverrideRegionPool"
                    },
                    "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionAffinityAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "See `session_affinity_attributes`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `\"\"` Defaults to `\"\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "countryPools",
                        "popPools",
                        "regionPools"
                    ]
                }
            }
        },
        "cloudflare:index/LoadBalancerRuleOverrideAdaptiveRouting:LoadBalancerRuleOverrideAdaptiveRouting": {
            "properties": {
                "failoverAcrossPools": {
                    "type": "boolean",
                    "description": "Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverrideCountryPool:LoadBalancerRuleOverrideCountryPool": {
            "properties": {
                "country": {
                    "type": "string",
                    "description": "A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given country.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "country",
                "poolIds"
            ]
        },
        "cloudflare:index/LoadBalancerRuleOverrideLocationStrategy:LoadBalancerRuleOverrideLocationStrategy": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferEcs": {
                    "type": "string",
                    "description": "Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy=\"proximity\"`, and `geo` will prefer ECS only when `steering_policy=\"geo\"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverridePopPool:LoadBalancerRuleOverridePopPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use for traffic reaching the given PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pop": {
                    "type": "string",
                    "description": "A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "pop"
            ]
        },
        "cloudflare:index/LoadBalancerRuleOverrideRandomSteering:LoadBalancerRuleOverrideRandomSteering": {
            "properties": {
                "defaultWeight": {
                    "type": "number",
                    "description": "The default weight for pools in the load balancer that are not specified in the `pool_weights` map.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "poolWeights": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/LoadBalancerRuleOverrideRegionPool:LoadBalancerRuleOverrideRegionPool": {
            "properties": {
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs in failover priority to use in the given region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "poolIds",
                "region"
            ]
        },
        "cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the headers rule is active.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique headers rule identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "id"
            ]
        },
        "cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the headers rule is active.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique headers rule identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters": {
            "properties": {
                "enableds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "State of the pool to alert on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eventSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Source configuration to alert on for pool or origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Stream event type to alert on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "healthCheckIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Identifier health check. Required when using `filters.0.status`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "inputIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Stream input id to alert on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A numerical limit. Example: `100`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "newHealths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Health status to alert on for pool or origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packetsPerSeconds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Packets per second threshold for dos alert.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "poolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Load balancer pool identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocols": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Protocol to alert on for dos.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestsPerSeconds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Requests per second threshold for dos alert.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "slos": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A numerical limit. Example: `99.9`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Status to alert on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Target host to alert on for dos.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetZoneNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Target domain to alert on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of zone identifiers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "cloudflare:index/PageRuleActions:PageRuleActions": {
            "properties": {
                "alwaysUseHttps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "string",
                    "description": "The Time To Live for the browser cache. `0` means 'Respect Existing Headers'\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bypassCacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally bypass cache the page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheByDeviceType": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheDeceptionArmor": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheKeyFields": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields",
                    "description": "Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Whether to set the cache level to `\"bypass\"`, `\"basic\"`, `\"simplified\"`, `\"aggressive\"`, or `\"cache_everything\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheOnCookie": {
                    "type": "string",
                    "description": "String value of cookie name to conditionally cache the page.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheTtlByStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PageRuleActionsCacheTtlByStatus:PageRuleActionsCacheTtlByStatus"
                    },
                    "description": "Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableApps": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disablePerformance": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableRailgun": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableSecurity": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableZaraz": {
                    "type": "boolean",
                    "description": "Boolean of whether this action is enabled. Default: false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeCacheTtl": {
                    "type": "integer",
                    "description": "The Time To Live for the edge cache.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "explicitCacheControl": {
                    "type": "string",
                    "description": "Whether origin Cache-Control action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardingUrl": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl",
                    "description": "The URL to forward to, and with what status. See below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeaderOverride": {
                    "type": "string",
                    "description": "Value of the Host header to send.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/PageRuleActionsMinify:PageRuleActionsMinify"
                    },
                    "description": "The configuration for HTML, CSS and JS minification. See below for full list of options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Whether this action is `\"off\"`, `\"lossless\"` or `\"lossy\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resolveOverride": {
                    "type": "string",
                    "description": "Overridden origin server name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "respectStrongEtag": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "description": "Whether to set the rocket loader to `\"on\"`, `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Whether to set the security level to `\"off\"`, `\"essentially_off\"`, `\"low\"`, `\"medium\"`, `\"high\"`, or `\"under_attack\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Whether to set the SSL mode to `\"off\"`, `\"flexible\"`, `\"full\"`, `\"strict\"`, or `\"origin_pull\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "description": "Whether this action is `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PageRuleActionsCacheKeyFields:PageRuleActionsCacheKeyFields": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie",
                    "description": "Controls what cookies go into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "header": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader",
                    "description": "Controls what HTTP headers go into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost",
                    "description": "Controls which Host header goes into Cache Key:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString",
                    "description": "Controls which URL query string parameters go into the Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "user": {
                    "$ref": "#/types/cloudflare:index/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser",
                    "description": "Controls which end user-related features go into the Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cookie",
                "header",
                "host",
                "queryString",
                "user"
            ]
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsCookie:PageRuleActionsCacheKeyFieldsCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsHeader:PageRuleActionsCacheKeyFieldsHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Check for presence of specified HTTP headers, without including their actual values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkPresences",
                        "excludes",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsHost:PageRuleActionsCacheKeyFieldsHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "description": "`false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsQueryString:PageRuleActionsCacheKeyFieldsQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Exclude these query string parameters from Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignore": {
                    "type": "boolean",
                    "description": "`false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Only use values of specified query string parameters in Cache Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "excludes",
                        "ignore",
                        "includes"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheKeyFieldsUser:PageRuleActionsCacheKeyFieldsUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "description": "`true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geo": {
                    "type": "boolean",
                    "description": "`true` - includes the clients country, derived from the IP address; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lang": {
                    "type": "boolean",
                    "description": "`true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceType",
                        "geo",
                        "lang"
                    ]
                }
            }
        },
        "cloudflare:index/PageRuleActionsCacheTtlByStatus:PageRuleActionsCacheTtlByStatus": {
            "properties": {
                "codes": {
                    "type": "string",
                    "description": "A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "Duration a resource lives in the Cloudflare cache.\n- positive number - cache for specified duration in seconds\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "codes",
                "ttl"
            ]
        },
        "cloudflare:index/PageRuleActionsForwardingUrl:PageRuleActionsForwardingUrl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "description": "The status code to use for the redirection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL to which the page rule should forward.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "statusCode",
                "url"
            ]
        },
        "cloudflare:index/PageRuleActionsMinify:PageRuleActionsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "Whether CSS should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "Whether HTML should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "Whether Javascript should be minified. Valid values are `\"on\"` or `\"off\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig": {
            "properties": {
                "buildCommand": {
                    "type": "string",
                    "description": "Command used to build project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "destinationDir": {
                    "type": "string",
                    "description": "Output directory of the build.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootDir": {
                    "type": "string",
                    "description": "Directory to run the command.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webAnalyticsTag": {
                    "type": "string",
                    "description": "The classifying tag for analytics.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webAnalyticsToken": {
                    "type": "string",
                    "description": "The auth token for analytics.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs": {
            "properties": {
                "preview": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsPreview:PagesProjectDeploymentConfigsPreview",
                    "description": "Configuration for preview deploys.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "production": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigsProduction:PagesProjectDeploymentConfigsProduction",
                    "description": "Configuration for production deploys.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PagesProjectDeploymentConfigsPreview:PagesProjectDeploymentConfigsPreview": {
            "properties": {
                "compatibilityDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "d1Databases": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "durableObjectNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "environmentVariables": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kvNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "r2Buckets": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "compatibilityDate",
                        "compatibilityFlags"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectDeploymentConfigsProduction:PagesProjectDeploymentConfigsProduction": {
            "properties": {
                "compatibilityDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compatibilityFlags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "d1Databases": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "durableObjectNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "environmentVariables": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kvNamespaces": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "r2Buckets": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "compatibilityDate",
                        "compatibilityFlags"
                    ]
                }
            }
        },
        "cloudflare:index/PagesProjectSource:PagesProjectSource": {
            "properties": {
                "config": {
                    "$ref": "#/types/cloudflare:index/PagesProjectSourceConfig:PagesProjectSourceConfig",
                    "description": "Configuration for the source of the Cloudflare Pages project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Project host type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/PagesProjectSourceConfig:PagesProjectSourceConfig": {
            "properties": {
                "deploymentsEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "owner": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prCommentsEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "previewBranchExcludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "previewBranchIncludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "previewDeploymentSetting": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionBranch": {
                    "type": "string",
                    "description": "The name of the branch that is used for the production environment.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionDeploymentEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "repoName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "productionBranch"
            ]
        },
        "cloudflare:index/RateLimitAction:RateLimitAction": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The type of action to perform. Allowable values are 'simulate', 'ban', 'challenge', 'js_challenge' and 'managed_challenge'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "response": {
                    "$ref": "#/types/cloudflare:index/RateLimitActionResponse:RateLimitActionResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "description": "The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period (min: 1, max: 86400).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RateLimitActionResponse:RateLimitActionResponse": {
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The body to return, the content here should conform to the content_type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "The content-type of the body, must be one of: 'text/plain', 'text/xml', 'application/json'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "body",
                "contentType"
            ]
        },
        "cloudflare:index/RateLimitCorrelate:RateLimitCorrelate": {
            "properties": {
                "by": {
                    "type": "string",
                    "description": "If set to 'nat', NAT support will be enabled for rate limiting.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RateLimitMatch:RateLimitMatch": {
            "properties": {
                "request": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatchRequest:RateLimitMatchRequest",
                    "description": "Matches HTTP requests (from the client to Cloudflare). See definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "response": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatchResponse:RateLimitMatchResponse",
                    "description": "Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "request",
                        "response"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitMatchRequest:RateLimitMatchRequest": {
            "properties": {
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Methods, can be a subset ['POST','PUT'] or all ['\\_ALL\\_']. Default: ['\\_ALL\\_'].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schemes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "HTTP Schemes, can be one ['HTTPS'], both ['HTTP','HTTPS'] or all ['\\_ALL\\_']. Default: ['\\_ALL\\_'].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "urlPattern": {
                    "type": "string",
                    "description": "The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone. Default: '_'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "methods",
                        "schemes",
                        "urlPattern"
                    ]
                }
            }
        },
        "cloudflare:index/RateLimitMatchResponse:RateLimitMatchResponse": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "description": "block is a list of maps with the following attributes:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originTraffic": {
                    "type": "boolean",
                    "description": "Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting. Default: `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "HTTP Status codes, can be one [403], many [401,403] or indicate all by not providing this value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "originTraffic",
                        "statuses"
                    ]
                }
            }
        },
        "cloudflare:index/RecordData:RecordData": {
            "properties": {
                "algorithm": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "altitude": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "content": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "digest": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "digestType": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fingerprint": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flags": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyTag": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latDegrees": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latDirection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latMinutes": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latSeconds": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longDegrees": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longDirection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longMinutes": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longSeconds": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchingType": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "order": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "precisionHorz": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "precisionVert": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preference": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proto": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regex": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replacement": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "selector": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tag": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "integer",
                    "description": "The type of the record\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usage": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRule:RulesetRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the ruleset rule. Available values: `block`, `challenge`, `ddos_dynamic`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `set_cache_settings`, `set_config`, `serve_error`, `skip`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "actionParameters": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParameters:RulesetRuleActionParameters",
                    "description": "List of parameters that configure the behavior of the ruleset rule action.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset rule and its intended use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the rule is active.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exposedCredentialCheck": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleExposedCredentialCheck:RulesetRuleExposedCredentialCheck",
                    "description": "List of parameters that configure exposed credential checks.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expression": {
                    "type": "string",
                    "description": "Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique rule identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleLogging:RulesetRuleLogging",
                    "description": "List parameters to configure how the rule generates logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ratelimit": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleRatelimit:RulesetRuleRatelimit",
                    "description": "List of parameters that configure HTTP rate limiting behaviour.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ref": {
                    "type": "string",
                    "description": "Rule reference.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "description": "Version of the ruleset to deploy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "expression"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "expression",
                        "id",
                        "ref",
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParameters:RulesetRuleActionParameters": {
            "properties": {
                "automaticHttpsRewrites": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autominifies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersAutominify:RulesetRuleActionParametersAutominify"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bic": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserTtl": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersBrowserTtl:RulesetRuleActionParametersBrowserTtl",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cache": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheKey": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKey:RulesetRuleActionParametersCacheKey",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "content": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cookieFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableApps": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableRailgun": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableZaraz": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeTtl": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersEdgeTtl:RulesetRuleActionParametersEdgeTtl",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromList": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersFromList:RulesetRuleActionParametersFromList",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromValue": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersFromValue:RulesetRuleActionParametersFromValue",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersHeader:RulesetRuleActionParametersHeader"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "increment": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchedData": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersMatchedData:RulesetRuleActionParametersMatchedData",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "origin": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOrigin:RulesetRuleActionParametersOrigin",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassthru": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrides": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverrides:RulesetRuleActionParametersOverrides",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "respectStrongEtags": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersResponse:RulesetRuleActionParametersResponse"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "List of rules to apply to the ruleset.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ruleset": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rulesets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serveStale": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersServeStale:RulesetRuleActionParametersServeStale",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExcludes": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sni": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersSni:RulesetRuleActionParametersSni",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sxg": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uri": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUri:RulesetRuleActionParametersUri",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/RulesetRuleActionParametersAutominify:RulesetRuleActionParametersAutominify": {
            "properties": {
                "css": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersBrowserTtl:RulesetRuleActionParametersBrowserTtl": {
            "properties": {
                "default": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKey:RulesetRuleActionParametersCacheKey": {
            "properties": {
                "cacheByDeviceType": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheDeceptionArmor": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customKey": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKey:RulesetRuleActionParametersCacheKeyCustomKey",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignoreQueryStringsOrder": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKey:RulesetRuleActionParametersCacheKeyCustomKey": {
            "properties": {
                "cookie": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyCookie:RulesetRuleActionParametersCacheKeyCustomKeyCookie",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "header": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHeader:RulesetRuleActionParametersCacheKeyCustomKeyHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHost:RulesetRuleActionParametersCacheKeyCustomKeyHost",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "queryString": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyQueryString:RulesetRuleActionParametersCacheKeyCustomKeyQueryString",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "user": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyUser:RulesetRuleActionParametersCacheKeyCustomKeyUser",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyCookie:RulesetRuleActionParametersCacheKeyCustomKeyCookie": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHeader:RulesetRuleActionParametersCacheKeyCustomKeyHeader": {
            "properties": {
                "checkPresences": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "excludeOrigin": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyHost:RulesetRuleActionParametersCacheKeyCustomKeyHost": {
            "properties": {
                "resolved": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyQueryString:RulesetRuleActionParametersCacheKeyCustomKeyQueryString": {
            "properties": {
                "excludes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersCacheKeyCustomKeyUser:RulesetRuleActionParametersCacheKeyCustomKeyUser": {
            "properties": {
                "deviceType": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geo": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lang": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersEdgeTtl:RulesetRuleActionParametersEdgeTtl": {
            "properties": {
                "default": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCodeTtls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtl:RulesetRuleActionParametersEdgeTtlStatusCodeTtl"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtl:RulesetRuleActionParametersEdgeTtlStatusCodeTtl": {
            "properties": {
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCodeRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange:RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange:RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange": {
            "properties": {
                "from": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "to": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersFromList:RulesetRuleActionParametersFromList": {
            "properties": {
                "key": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "name"
            ]
        },
        "cloudflare:index/RulesetRuleActionParametersFromValue:RulesetRuleActionParametersFromValue": {
            "properties": {
                "preserveQueryString": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetUrl": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersFromValueTargetUrl:RulesetRuleActionParametersFromValueTargetUrl",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersFromValueTargetUrl:RulesetRuleActionParametersFromValueTargetUrl": {
            "properties": {
                "expression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersHeader:RulesetRuleActionParametersHeader": {
            "properties": {
                "expression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersMatchedData:RulesetRuleActionParametersMatchedData": {
            "properties": {
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOrigin:RulesetRuleActionParametersOrigin": {
            "properties": {
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverrides:RulesetRuleActionParametersOverrides": {
            "properties": {
                "action": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "categories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverridesCategory:RulesetRuleActionParametersOverridesCategory"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersOverridesRule:RulesetRuleActionParametersOverridesRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivityLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverridesCategory:RulesetRuleActionParametersOverridesCategory": {
            "properties": {
                "action": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "category": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersOverridesRule:RulesetRuleActionParametersOverridesRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the ruleset rule. Available values: `block`, `challenge`, `ddos_dynamic`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `set_cache_settings`, `set_config`, `serve_error`, `skip`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the rule is active.\n",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique rule identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scoreThreshold": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivityLevel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersResponse:RulesetRuleActionParametersResponse": {
            "properties": {
                "content": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersServeStale:RulesetRuleActionParametersServeStale": {
            "properties": {
                "disableStaleWhileUpdating": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersSni:RulesetRuleActionParametersSni": {
            "properties": {
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUri:RulesetRuleActionParametersUri": {
            "properties": {
                "origin": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUriPath:RulesetRuleActionParametersUriPath",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "$ref": "#/types/cloudflare:index/RulesetRuleActionParametersUriQuery:RulesetRuleActionParametersUriQuery",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUriPath:RulesetRuleActionParametersUriPath": {
            "properties": {
                "expression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleActionParametersUriQuery:RulesetRuleActionParametersUriQuery": {
            "properties": {
                "expression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleExposedCredentialCheck:RulesetRuleExposedCredentialCheck": {
            "properties": {
                "passwordExpression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "usernameExpression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleLogging:RulesetRuleLogging": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "deprecationMessage": "Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/RulesetRuleRatelimit:RulesetRuleRatelimit": {
            "properties": {
                "characteristics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countingExpression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mitigationTimeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "period": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestsPerPeriod": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestsToOrigin": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin e.g. origin-ssh.example.com.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of DNS record associated with the application. Valid values: `CNAME`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Fully qualified domain name of the origin e.g. origin-ssh.example.com.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange": {
            "properties": {
                "end": {
                    "type": "integer",
                    "description": "Upper bound of the origin port range, e.g. `2000`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "Lower bound of the origin port range, e.g. `1000`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "end",
                "start"
            ]
        },
        "cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address for the tunnel.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tunnel.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The domain name for the tunnel.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus": {
            "properties": {
                "enabledDownloadPhase": {
                    "type": "boolean",
                    "description": "Scan on file download.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabledUploadPhase": {
                    "type": "boolean",
                    "description": "Scan on file upload.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failClosed": {
                    "type": "boolean",
                    "description": "Block requests for files that cannot be scanned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabledDownloadPhase",
                "enabledUploadPhase",
                "failClosed"
            ]
        },
        "cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage": {
            "properties": {
                "backgroundColor": {
                    "type": "string",
                    "description": "Hex code of block page background color.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of enablement.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "footerText": {
                    "type": "string",
                    "description": "Block page header text.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headerText": {
                    "type": "string",
                    "description": "Block page footer text.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logoPath": {
                    "type": "string",
                    "description": "URL of block page logo.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of block page configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountFips:TeamsAccountFips": {
            "properties": {
                "tls": {
                    "type": "boolean",
                    "description": "Only allow FIPS-compliant TLS configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsAccountLogging:TeamsAccountLogging": {
            "properties": {
                "redactPii": {
                    "type": "boolean",
                    "description": "Redact personally identifiable information from activity logging (PII fields are: source IP,\nuser email, user ID, device ID, URL, referrer, user agent).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "settingsByRuleType": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleType:TeamsAccountLoggingSettingsByRuleType",
                    "description": "Represents whether all requests are logged or only the blocked requests are\nlogged in DNS, HTTP and L4 filters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "redactPii",
                "settingsByRuleType"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleType:TeamsAccountLoggingSettingsByRuleType": {
            "properties": {
                "dns": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeDns:TeamsAccountLoggingSettingsByRuleTypeDns",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeHttp:TeamsAccountLoggingSettingsByRuleTypeHttp",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "l4": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeL4:TeamsAccountLoggingSettingsByRuleTypeL4",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "dns",
                "http",
                "l4"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeDns:TeamsAccountLoggingSettingsByRuleTypeDns": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logBlocks": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeHttp:TeamsAccountLoggingSettingsByRuleTypeHttp": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logBlocks": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/TeamsAccountLoggingSettingsByRuleTypeL4:TeamsAccountLoggingSettingsByRuleTypeL4": {
            "properties": {
                "logAll": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logBlocks": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "logAll",
                "logBlocks"
            ]
        },
        "cloudflare:index/TeamsAccountProxy:TeamsAccountProxy": {
            "properties": {
                "tcp": {
                    "type": "boolean",
                    "description": "Whether gateway proxy is enabled on gateway devices for tcp traffic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "udp": {
                    "type": "boolean",
                    "description": "Whether gateway proxy is enabled on gateway devices for udp traffic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "tcp",
                "udp"
            ]
        },
        "cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the teams location.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "network": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "network"
                    ]
                }
            }
        },
        "cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings": {
            "properties": {
                "addHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Add custom headers to allowed requests in the form of key-value pairs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bisoAdminControls": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsBisoAdminControls:TeamsRuleRuleSettingsBisoAdminControls",
                    "description": "Configure how browser isolation behaves (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "blockPageEnabled": {
                    "type": "boolean",
                    "description": "Indicator of block page enablement.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "blockPageReason": {
                    "type": "string",
                    "description": "The displayed reason for a user being blocked.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkSession": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsCheckSession:TeamsRuleRuleSettingsCheckSession",
                    "description": "Configure how session check behaves (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "insecureDisableDnssecValidation": {
                    "type": "boolean",
                    "description": "Disable DNSSEC validation (must be Allow rule)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "l4override": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettingsL4override:TeamsRuleRuleSettingsL4override",
                    "description": "Settings to forward layer 4 traffic (refer to the nested schema).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrideHost": {
                    "type": "string",
                    "description": "The host to override matching DNS queries with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "overrideIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IPs to override matching DNS queries with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsBisoAdminControls:TeamsRuleRuleSettingsBisoAdminControls": {
            "properties": {
                "disableCopyPaste": {
                    "type": "boolean",
                    "description": "Disable copy-paste.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableDownload": {
                    "type": "boolean",
                    "description": "Disable download.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableKeyboard": {
                    "type": "boolean",
                    "description": "Disable keyboard usage.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disablePrinting": {
                    "type": "boolean",
                    "description": "Disable printing.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableUpload": {
                    "type": "boolean",
                    "description": "Disable upload.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TeamsRuleRuleSettingsCheckSession:TeamsRuleRuleSettingsCheckSession": {
            "properties": {
                "duration": {
                    "type": "string",
                    "description": "Configure how fresh the session needs to be to be considered valid.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enforce": {
                    "type": "boolean",
                    "description": "Enable session enforcement for this rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "duration",
                "enforce"
            ]
        },
        "cloudflare:index/TeamsRuleRuleSettingsL4override:TeamsRuleRuleSettingsL4override": {
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Override IP to forward traffic to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "Override Port to forward traffic to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "ip",
                "port"
            ]
        },
        "cloudflare:index/TunnelConfigConfig:TunnelConfigConfig": {
            "properties": {
                "ingressRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfigIngressRule:TunnelConfigConfigIngressRule"
                    },
                    "description": "Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originRequest": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigOriginRequest:TunnelConfigConfigOriginRequest",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "warpRouting": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfigWarpRouting:TunnelConfigConfigWarpRouting",
                    "description": "If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "ingressRules"
            ]
        },
        "cloudflare:index/TunnelConfigConfigIngressRule:TunnelConfigConfigIngressRule": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "service"
            ]
        },
        "cloudflare:index/TunnelConfigConfigOriginRequest:TunnelConfigConfigOriginRequest": {
            "properties": {
                "bastionMode": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caPool": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableChunkedEncoding": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpHostHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfigOriginRequestIpRule:TunnelConfigConfigOriginRequestIpRule"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepAliveConnections": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepAliveTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noHappyEyeballs": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTlsVerify": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originServerName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyAddress": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyPort": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tcpKeepAlive": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigOriginRequestIpRule:TunnelConfigConfigOriginRequestIpRule": {
            "properties": {
                "allow": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/TunnelConfigConfigWarpRouting:TunnelConfigConfigWarpRouting": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the waiting room rule and its intended use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expression": {
                    "type": "string",
                    "description": "Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique rule identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "description": "Version of the waiting room rule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "action",
                "expression"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "expression",
                        "id",
                        "version"
                    ]
                }
            }
        },
        "cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding": {
            "properties": {
                "dataset": {
                    "type": "string",
                    "description": "The name of the Analytics Engine dataset to write to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "dataset",
                "name"
            ]
        },
        "cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespaceId": {
                    "type": "string",
                    "description": "ID of the KV namespace you want to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "namespaceId"
            ]
        },
        "cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "text": {
                    "type": "string",
                    "description": "The plain text you want to store.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding": {
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "The name of the Bucket to bind to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bucketName",
                "name"
            ]
        },
        "cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "text": {
                    "type": "string",
                    "description": "The secret text you want to store.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "text"
            ]
        },
        "cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding": {
            "properties": {
                "environment": {
                    "type": "string",
                    "description": "The name of the Worker environment to bind to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "description": "The name of the Worker to bind to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "service"
            ]
        },
        "cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding": {
            "properties": {
                "module": {
                    "type": "string",
                    "description": "The base64 encoded wasm module you want to store.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The global variable for the binding in your Worker code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "module",
                "name"
            ]
        },
        "cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration": {
            "properties": {
                "target": {
                    "type": "string",
                    "description": "The request property to target. Allowed values: \"ip\", \"ip_range\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `198.51.100.4` or `2001:db8::/32` and IP ranges in CIDR format i.e. `198.51.0.0/16`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "target",
                "value"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "binaryAst": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "brotli": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Allowed values: \"aggressive\" (default) - delivers a different resource each time the query string changes, \"basic\" - delivers resources from cache when there is no query string, \"simplified\" - delivers the same resource to everyone independent of the query string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "challengeTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFlattening": {
                    "type": "string",
                    "description": "Allowed values: \"flatten_at_root\" (default), \"flatten_all\", \"flatten_none\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "developmentMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "earlyHints": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "filterLogsToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "h2Prioritization": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"custom\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http3": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "imageResizing": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"open\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxUpload": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "description": "Allowed values: \"1.0\" (default), \"1.1\", \"1.2\", \"1.3\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minify": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingMinify:ZoneSettingsOverrideInitialSettingMinify",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingMobileRedirect:ZoneSettingsOverrideInitialSettingMobileRedirect",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticOnion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orangeToOrange": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originMaxHttpVersion": {
                    "type": "string",
                    "description": "Allowed values: \"1\" (default on Enterprise), \"2\" (default)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"lossless\", \"lossy\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefetchPreload": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privacyPass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyReadTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pseudoIpv4": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"add_header\", \"overwrite_header\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSettingSecurityHeader:ZoneSettingsOverrideInitialSettingSecurityHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (Enterprise only), \"essentially_off\", \"low\", \"medium\" (default), \"high\", \"under_attack\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"flexible\", \"full\", \"strict\", \"origin_pull\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"on\", \"zrt\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsClientAuth": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "universalSsl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "visitorIp": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webp": {
                    "type": "string",
                    "description": ". Note that the value specified will be ignored unless `polish` is turned on (i.e. is \"lossless\" or \"lossy\")\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "websockets": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zeroRtt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "binaryAst",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "ciphers",
                        "cnameFlattening",
                        "developmentMode",
                        "earlyHints",
                        "emailObfuscation",
                        "filterLogsToCloudflare",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "logToCloudflare",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "orangeToOrange",
                        "originErrorPagePassThru",
                        "originMaxHttpVersion",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "proxyReadTimeout",
                        "pseudoIpv4",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "visitorIp",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingMinify:ZoneSettingsOverrideInitialSettingMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingMobileRedirect:ZoneSettingsOverrideInitialSettingMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string",
                    "description": "String value\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stripUri": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideInitialSettingSecurityHeader:ZoneSettingsOverrideInitialSettingSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nosniff": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preload": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings": {
            "properties": {
                "alwaysOnline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "alwaysUseHttps": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticHttpsRewrites": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "binaryAst": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "brotli": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCacheTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "browserCheck": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cacheLevel": {
                    "type": "string",
                    "description": "Allowed values: \"aggressive\" (default) - delivers a different resource each time the query string changes, \"basic\" - delivers resources from cache when there is no query string, \"simplified\" - delivers the same resource to everyone independent of the query string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "challengeTtl": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ciphers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFlattening": {
                    "type": "string",
                    "description": "Allowed values: \"flatten_at_root\" (default), \"flatten_all\", \"flatten_none\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "developmentMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "earlyHints": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailObfuscation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "filterLogsToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "h2Prioritization": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"custom\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hotlinkProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http2": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "http3": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "imageResizing": {
                    "type": "string",
                    "description": "Allowed values: \"on\", \"off\" (default), \"open\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipGeolocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logToCloudflare": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxUpload": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minTlsVersion": {
                    "type": "string",
                    "description": "Allowed values: \"1.0\" (default), \"1.1\", \"1.2\", \"1.3\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minify": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mirage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mobileRedirect": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticEncryption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opportunisticOnion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orangeToOrange": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originErrorPagePassThru": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originMaxHttpVersion": {
                    "type": "string",
                    "description": "Allowed values: \"1\" (default on Enterprise), \"2\" (default)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "polish": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"lossless\", \"lossy\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefetchPreload": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privacyPass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "proxyReadTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pseudoIpv4": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"add_header\", \"overwrite_header\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBuffering": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rocketLoader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityHeader": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "securityLevel": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (Enterprise only), \"essentially_off\", \"low\", \"medium\" (default), \"high\", \"under_attack\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideExclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sortQueryStringForCache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"flexible\", \"full\", \"strict\", \"origin_pull\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls12Only": {
                    "type": "string",
                    "deprecationMessage": "tls_1_2_only has been deprecated in favour of using `min_tls_version = \"1.2\"` instead.",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tls13": {
                    "type": "string",
                    "description": "Allowed values: \"off\" (default), \"on\", \"zrt\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsClientAuth": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "trueClientIpHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "universalSsl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "visitorIp": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waf": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "webp": {
                    "type": "string",
                    "description": ". Note that the value specified will be ignored unless `polish` is turned on (i.e. is \"lossless\" or \"lossy\")\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "websockets": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zeroRtt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "alwaysOnline",
                        "alwaysUseHttps",
                        "automaticHttpsRewrites",
                        "binaryAst",
                        "brotli",
                        "browserCacheTtl",
                        "browserCheck",
                        "cacheLevel",
                        "challengeTtl",
                        "ciphers",
                        "cnameFlattening",
                        "developmentMode",
                        "earlyHints",
                        "emailObfuscation",
                        "filterLogsToCloudflare",
                        "h2Prioritization",
                        "hotlinkProtection",
                        "http2",
                        "http3",
                        "imageResizing",
                        "ipGeolocation",
                        "ipv6",
                        "logToCloudflare",
                        "maxUpload",
                        "minTlsVersion",
                        "minify",
                        "mirage",
                        "mobileRedirect",
                        "opportunisticEncryption",
                        "opportunisticOnion",
                        "orangeToOrange",
                        "originErrorPagePassThru",
                        "originMaxHttpVersion",
                        "polish",
                        "prefetchPreload",
                        "privacyPass",
                        "proxyReadTimeout",
                        "pseudoIpv4",
                        "responseBuffering",
                        "rocketLoader",
                        "securityHeader",
                        "securityLevel",
                        "serverSideExclude",
                        "sortQueryStringForCache",
                        "ssl",
                        "tls12Only",
                        "tls13",
                        "tlsClientAuth",
                        "trueClientIpHeader",
                        "universalSsl",
                        "visitorIp",
                        "waf",
                        "webp",
                        "websockets",
                        "zeroRtt"
                    ]
                }
            }
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsMinify:ZoneSettingsOverrideSettingsMinify": {
            "properties": {
                "css": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "html": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "js": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "css",
                "html",
                "js"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsMobileRedirect:ZoneSettingsOverrideSettingsMobileRedirect": {
            "properties": {
                "mobileSubdomain": {
                    "type": "string",
                    "description": "String value\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "\"on\"/\"off\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stripUri": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "mobileSubdomain",
                "status",
                "stripUri"
            ]
        },
        "cloudflare:index/ZoneSettingsOverrideSettingsSecurityHeader:ZoneSettingsOverrideSettingsSecurityHeader": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeSubdomains": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxAge": {
                    "type": "integer",
                    "description": "Integer\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nosniff": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preload": {
                    "type": "boolean",
                    "description": "true/false\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "includeSubdomains",
                        "maxAge",
                        "nosniff",
                        "preload"
                    ]
                }
            }
        },
        "cloudflare:index/getAccountRolesRole:getAccountRolesRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of role's permissions\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Role identifier tag\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Role Name\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getAccountsAccount:getAccountsAccount": {
            "properties": {
                "enforceTwofactor": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The account name to target for the resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getDevicesDevice:getDevicesDevice": {
            "properties": {
                "created": {
                    "type": "string",
                    "description": "When the device was created.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceType": {
                    "type": "string",
                    "description": "The type of the device.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Device ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ip": {
                    "type": "string",
                    "description": "IPv4 or IPv6 address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "string",
                    "description": "The device's public key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastSeen": {
                    "type": "string",
                    "description": "When the device was last seen.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "model": {
                    "type": "string",
                    "description": "The device model name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The device name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "osDistroName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "osDistroRevision": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "osVersion": {
                    "type": "string",
                    "description": "The operating system version.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updated": {
                    "type": "string",
                    "description": "When the device was updated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userEmail": {
                    "type": "string",
                    "description": "User's email.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "User's ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "User's Name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "string",
                    "description": "The WARP client version.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getLoadBalancerPoolsFilter:getLoadBalancerPoolsFilter": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the Load Balancer pool to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getLoadBalancerPoolsPool:getLoadBalancerPoolsPool": {
            "properties": {
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Brief description of the Load Balancer Pool intention.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "ID for this load balancer pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latitude": {
                    "type": "number",
                    "description": "Latitude this pool is physically located at; used for proximity steering.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPoolLoadShedding:getLoadBalancerPoolsPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longitude": {
                    "type": "number",
                    "description": "Longitude this pool is physically located at; used for proximity steering.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "Minimum number of origins that must be healthy for this pool to serve traffic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "monitor": {
                    "type": "string",
                    "description": "ID of the Monitor to use for health checking origins within this pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Short name (tag) for the pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "Email address to send health status notifications to. Multiple emails are set as a comma delimited list.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPoolOrigin:getLoadBalancerPoolsPoolOrigin"
                    },
                    "description": "The list of origins within this pool.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "checkRegions",
                "createdOn",
                "description",
                "enabled",
                "id",
                "latitude",
                "loadSheddings",
                "longitude",
                "minimumOrigins",
                "modifiedOn",
                "monitor",
                "name",
                "notificationEmail",
                "origins"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "cloudflare:index/getLoadBalancerPoolsPoolLoadShedding:getLoadBalancerPoolsPoolLoadShedding": {
            "properties": {
                "defaultPercent": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionPercent": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getLoadBalancerPoolsPoolOrigin:getLoadBalancerPoolsPoolOrigin": {
            "properties": {
                "address": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPoolOriginHeader:getLoadBalancerPoolsPoolOriginHeader"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "name"
            ]
        },
        "cloudflare:index/getLoadBalancerPoolsPoolOriginHeader:getLoadBalancerPoolsPoolOriginHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "header",
                "values"
            ]
        },
        "cloudflare:index/getWafGroupsFilter:getWafGroupsFilter": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rule Groups to lookup. Valid values: on and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Groups to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafGroupsGroup:getWafGroupsGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The WAF Rule Group description\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The WAF Rule Group ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rule Groups to lookup. Valid values: on and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "modifiedRulesCount": {
                    "type": "integer",
                    "description": "The number of modified rules in the WAF Rule Group\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Groups to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package in which to search for the WAF Rule Groups.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rulesCount": {
                    "type": "integer",
                    "description": "The number of rules in the WAF Rule Group\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafPackagesFilter:getWafPackagesFilter": {
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detectionMode": {
                    "type": "string",
                    "description": "Detection mode of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivity": {
                    "type": "string",
                    "description": "Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafPackagesPackage:getWafPackagesPackage": {
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "Action mode of the WAF Rule Packages to lookup. Valid values: simulate, block and challenge.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "The WAF Rule Package description\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detectionMode": {
                    "type": "string",
                    "description": "Detection mode of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The WAF Rule Package ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A regular expression matching the name of the WAF Rule Packages to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sensitivity": {
                    "type": "string",
                    "description": "Sensitivity of the WAF Rule Packages to lookup. Valid values: high, medium, low and off.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafRulesFilter:getWafRulesFilter": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A regular expression matching the description of the WAF Rules to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rules to lookup. Valid values: one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getWafRulesRule:getWafRulesRule": {
            "properties": {
                "allowedModes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of allowed `mode` values for the WAF Rule\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultMode": {
                    "type": "string",
                    "description": "The default `mode` value for the WAF Rule\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "A regular expression matching the description of the WAF Rules to lookup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group in which the WAF Rules to lookup have to be.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupName": {
                    "type": "string",
                    "description": "The Name of the WAF Rule Group that contains the WAF Rule\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The WAF Rule ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "Mode of the WAF Rules to lookup. Valid values: one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package in which to search for the WAF Rules.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "string",
                    "description": "The WAF Rule priority\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZonesFilter:getZonesFilter": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Only search for zones in this account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lookupType": {
                    "type": "string",
                    "description": "The type of search to perform for the `name` value\nwhen querying the zone API. Valid values: `\"exact\"` and `\"contains\"`. Defaults\nto `\"exact\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "match": {
                    "type": "string",
                    "description": "A RE2 compatible regular expression to filter the\nresults. This is performed client side whereas the `name` and `lookup_type`\nare performed on the Cloudflare server side.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A string value to search for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "paused": {
                    "type": "boolean",
                    "description": "Paused status of the zone to lookup. Valid values are\n`true` or `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone to lookup. Valid values: `\"active\"`,\n`\"pending\"`, `\"initializing\"`, `\"moved\"`, `\"deleted\"`, `\"deactivated\"` and\n`\"read only\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "cloudflare:index/getZonesZone:getZonesZone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The zone ID\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A string value to search for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the cloudflare package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use a specific account. Alternatively, can be configured using the\n`CLOUDFLARE_ACCOUNT_ID` environment variable.\n",
                "deprecationMessage": "Use resource specific `account_id` attributes instead."
            },
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_BASE_PATH`\nenvironment variable.\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger). Alternatively, can be configured using\nthe `CLOUDFLARE_API_CLIENT_LOGGING` environment variable.\n"
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_HOSTNAME`\nenvironment variable.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations. Alternatively, can be configured using the `CLOUDFLARE_API_KEY` environment variable. API\nkeys are [now considered legacy by Cloudflare](https://developers.cloudflare.com/api/keys/#limitations), API tokens\nshould be used instead.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations. Alternatively, can be configured using the `CLOUDFLARE_API_TOKEN` environment variable.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints. Alternatively, can be configured using the\n`CLOUDFLARE_API_USER_SERVICE_KEY` environment variable.\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address. Alternatively, can be configured using the `CLOUDFLARE_EMAIL` environment\nvariable.\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MAX_BACKOFF` environment variable.\n"
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MIN_BACKOFF` environment variable.\n"
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails. Alternatively, can be configured using the\n`CLOUDFLARE_RETRIES` environment variable.\n"
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API. Alternatively, can be configured using the `CLOUDFLARE_RPS` environment\nvariable.\n"
            }
        },
        "inputProperties": {
            "accountId": {
                "type": "string",
                "description": "Configure API client to always use a specific account. Alternatively, can be configured using the\n`CLOUDFLARE_ACCOUNT_ID` environment variable.\n",
                "deprecationMessage": "Use resource specific `account_id` attributes instead."
            },
            "apiBasePath": {
                "type": "string",
                "description": "Configure the base path used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_BASE_PATH`\nenvironment variable.\n"
            },
            "apiClientLogging": {
                "type": "boolean",
                "description": "Whether to print logs from the API client (using the default log library logger). Alternatively, can be configured using\nthe `CLOUDFLARE_API_CLIENT_LOGGING` environment variable.\n",
                "default": false,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_API_CLIENT_LOGGING"
                    ]
                }
            },
            "apiHostname": {
                "type": "string",
                "description": "Configure the hostname used by the API client. Alternatively, can be configured using the `CLOUDFLARE_API_HOSTNAME`\nenvironment variable.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "The API key for operations. Alternatively, can be configured using the `CLOUDFLARE_API_KEY` environment variable. API\nkeys are [now considered legacy by Cloudflare](https://developers.cloudflare.com/api/keys/#limitations), API tokens\nshould be used instead.\n"
            },
            "apiToken": {
                "type": "string",
                "description": "The API Token for operations. Alternatively, can be configured using the `CLOUDFLARE_API_TOKEN` environment variable.\n"
            },
            "apiUserServiceKey": {
                "type": "string",
                "description": "A special Cloudflare API key good for a restricted set of endpoints. Alternatively, can be configured using the\n`CLOUDFLARE_API_USER_SERVICE_KEY` environment variable.\n"
            },
            "email": {
                "type": "string",
                "description": "A registered Cloudflare email address. Alternatively, can be configured using the `CLOUDFLARE_EMAIL` environment\nvariable.\n"
            },
            "maxBackoff": {
                "type": "integer",
                "description": "Maximum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MAX_BACKOFF` environment variable.\n",
                "default": 30,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MAX_BACKOFF"
                    ]
                }
            },
            "minBackoff": {
                "type": "integer",
                "description": "Minimum backoff period in seconds after failed API calls. Alternatively, can be configured using the\n`CLOUDFLARE_MIN_BACKOFF` environment variable.\n",
                "default": 1,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_MIN_BACKOFF"
                    ]
                }
            },
            "retries": {
                "type": "integer",
                "description": "Maximum number of retries to perform when an API request fails. Alternatively, can be configured using the\n`CLOUDFLARE_RETRIES` environment variable.\n",
                "default": 3,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RETRIES"
                    ]
                }
            },
            "rps": {
                "type": "integer",
                "description": "RPS limit to apply when making calls to the API. Alternatively, can be configured using the `CLOUDFLARE_RPS` environment\nvariable.\n",
                "default": 4,
                "defaultInfo": {
                    "environment": [
                        "CLOUDFLARE_RPS"
                    ]
                }
            }
        }
    },
    "resources": {
        "cloudflare:index/accessApplication:AccessApplication": {
            "description": "Provides a Cloudflare Access Application resource. Access\nApplications are used to restrict access to a whole application using an\nauthorisation gateway managed by Cloudflare.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\nmost cases using either is fine. However, if you're using a scoped\naccess token, you must provide the argument that matches the token's\nscope. For example, an access token that is scoped to the \"example.com\"\nzone needs to use the `zone_id` argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// With CORS configuration\nconst stagingApp = new cloudflare.AccessApplication(\"stagingApp\", {\n    corsHeaders: [{\n        allowCredentials: true,\n        allowedMethods: [\n            \"GET\",\n            \"POST\",\n            \"OPTIONS\",\n        ],\n        allowedOrigins: [\"https://example.com\"],\n        maxAge: 10,\n    }],\n    domain: \"staging.example.com\",\n    name: \"staging application\",\n    sessionDuration: \"24h\",\n    type: \"self_hosted\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# With CORS configuration\nstaging_app = cloudflare.AccessApplication(\"stagingApp\",\n    cors_headers=[cloudflare.AccessApplicationCorsHeaderArgs(\n        allow_credentials=True,\n        allowed_methods=[\n            \"GET\",\n            \"POST\",\n            \"OPTIONS\",\n        ],\n        allowed_origins=[\"https://example.com\"],\n        max_age=10,\n    )],\n    domain=\"staging.example.com\",\n    name=\"staging application\",\n    session_duration=\"24h\",\n    type=\"self_hosted\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // With CORS configuration\n    var stagingApp = new Cloudflare.AccessApplication(\"stagingApp\", new()\n    {\n        CorsHeaders = new[]\n        {\n            new Cloudflare.Inputs.AccessApplicationCorsHeaderArgs\n            {\n                AllowCredentials = true,\n                AllowedMethods = new[]\n                {\n                    \"GET\",\n                    \"POST\",\n                    \"OPTIONS\",\n                },\n                AllowedOrigins = new[]\n                {\n                    \"https://example.com\",\n                },\n                MaxAge = 10,\n            },\n        },\n        Domain = \"staging.example.com\",\n        Name = \"staging application\",\n        SessionDuration = \"24h\",\n        Type = \"self_hosted\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessApplication(ctx, \"stagingApp\", \u0026cloudflare.AccessApplicationArgs{\n\t\t\tCorsHeaders: cloudflare.AccessApplicationCorsHeaderArray{\n\t\t\t\t\u0026cloudflare.AccessApplicationCorsHeaderArgs{\n\t\t\t\t\tAllowCredentials: pulumi.Bool(true),\n\t\t\t\t\tAllowedMethods: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GET\"),\n\t\t\t\t\t\tpulumi.String(\"POST\"),\n\t\t\t\t\t\tpulumi.String(\"OPTIONS\"),\n\t\t\t\t\t},\n\t\t\t\t\tAllowedOrigins: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"https://example.com\"),\n\t\t\t\t\t},\n\t\t\t\t\tMaxAge: pulumi.Int(10),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDomain:          pulumi.String(\"staging.example.com\"),\n\t\t\tName:            pulumi.String(\"staging application\"),\n\t\t\tSessionDuration: pulumi.String(\"24h\"),\n\t\t\tType:            pulumi.String(\"self_hosted\"),\n\t\t\tZoneId:          pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessApplication;\nimport com.pulumi.cloudflare.AccessApplicationArgs;\nimport com.pulumi.cloudflare.inputs.AccessApplicationCorsHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var stagingApp = new AccessApplication(\"stagingApp\", AccessApplicationArgs.builder()        \n            .corsHeaders(AccessApplicationCorsHeaderArgs.builder()\n                .allowCredentials(true)\n                .allowedMethods(                \n                    \"GET\",\n                    \"POST\",\n                    \"OPTIONS\")\n                .allowedOrigins(\"https://example.com\")\n                .maxAge(10)\n                .build())\n            .domain(\"staging.example.com\")\n            .name(\"staging application\")\n            .sessionDuration(\"24h\")\n            .type(\"self_hosted\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # With CORS configuration\n  stagingApp:\n    type: cloudflare:AccessApplication\n    properties:\n      corsHeaders:\n        - allowCredentials: true\n          allowedMethods:\n            - GET\n            - POST\n            - OPTIONS\n          allowedOrigins:\n            - https://example.com\n          maxAge: 10\n      domain: staging.example.com\n      name: staging application\n      sessionDuration: 24h\n      type: self_hosted\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/accessApplication:AccessApplication example \u003caccount_id\u003e/\u003capplication_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the application.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The complete URL of the asset you wish to put Cloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean",
                    "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "saasApp": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp",
                    "description": "SaaS configuration for the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string",
                    "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                },
                "serviceAuth401Redirect": {
                    "type": "boolean",
                    "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean",
                    "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`. Defaults to `self_hosted`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "aud",
                "domain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "allowedIdps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identity providers selected for the application.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                },
                "autoRedirectToIdentity": {
                    "type": "boolean",
                    "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                },
                "corsHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                    },
                    "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                },
                "customDenyMessage": {
                    "type": "string",
                    "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                },
                "customDenyUrl": {
                    "type": "string",
                    "description": "Option that redirects to a custom URL when a user is denied access to the application.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The complete URL of the asset you wish to put Cloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                },
                "enableBindingCookie": {
                    "type": "boolean",
                    "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                },
                "httpOnlyCookieAttribute": {
                    "type": "boolean",
                    "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Application.\n"
                },
                "saasApp": {
                    "$ref": "#/types/cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp",
                    "description": "SaaS configuration for the Access Application.\n"
                },
                "sameSiteCookieAttribute": {
                    "type": "string",
                    "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                },
                "serviceAuth401Redirect": {
                    "type": "boolean",
                    "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                },
                "sessionDuration": {
                    "type": "string",
                    "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                },
                "skipInterstitial": {
                    "type": "boolean",
                    "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`. Defaults to `self_hosted`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessApplication resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "allowedIdps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identity providers selected for the application.\n"
                    },
                    "appLauncherVisible": {
                        "type": "boolean",
                        "description": "Option to show/hide applications in App Launcher. Defaults to `true`.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the application.\n"
                    },
                    "autoRedirectToIdentity": {
                        "type": "boolean",
                        "description": "Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.\n"
                    },
                    "corsHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessApplicationCorsHeader:AccessApplicationCorsHeader"
                        },
                        "description": "CORS configuration for the Access Application. See below for reference structure.\n"
                    },
                    "customDenyMessage": {
                        "type": "string",
                        "description": "Option that returns a custom error message when a user is denied access to the application.\n"
                    },
                    "customDenyUrl": {
                        "type": "string",
                        "description": "Option that redirects to a custom URL when a user is denied access to the application.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The complete URL of the asset you wish to put Cloudflare Access in front of. Can include subdomains or paths. Or both.\n"
                    },
                    "enableBindingCookie": {
                        "type": "boolean",
                        "description": "Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional \"binding\" cookie on requests. Defaults to `false`.\n"
                    },
                    "httpOnlyCookieAttribute": {
                        "type": "boolean",
                        "description": "Option to add the `HttpOnly` cookie flag to access tokens.\n"
                    },
                    "logoUrl": {
                        "type": "string",
                        "description": "Image URL for the logo shown in the app launcher dashboard.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Application.\n"
                    },
                    "saasApp": {
                        "$ref": "#/types/cloudflare:index/AccessApplicationSaasApp:AccessApplicationSaasApp",
                        "description": "SaaS configuration for the Access Application.\n"
                    },
                    "sameSiteCookieAttribute": {
                        "type": "string",
                        "description": "Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.\n"
                    },
                    "serviceAuth401Redirect": {
                        "type": "boolean",
                        "description": "Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.\n"
                    },
                    "sessionDuration": {
                        "type": "string",
                        "description": "How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.\n"
                    },
                    "skipInterstitial": {
                        "type": "boolean",
                        "description": "Option to skip the authorization interstitial when using the CLI. Defaults to `false`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`. Defaults to `self_hosted`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessBookmark:AccessBookmark": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myBookmarkApp = new cloudflare.AccessBookmark(\"myBookmarkApp\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    appLauncherVisible: true,\n    domain: \"example.com\",\n    logoUrl: \"https://example.com/example.png\",\n    name: \"My Bookmark App\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_bookmark_app = cloudflare.AccessBookmark(\"myBookmarkApp\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    app_launcher_visible=True,\n    domain=\"example.com\",\n    logo_url=\"https://example.com/example.png\",\n    name=\"My Bookmark App\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myBookmarkApp = new Cloudflare.AccessBookmark(\"myBookmarkApp\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        AppLauncherVisible = true,\n        Domain = \"example.com\",\n        LogoUrl = \"https://example.com/example.png\",\n        Name = \"My Bookmark App\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessBookmark(ctx, \"myBookmarkApp\", \u0026cloudflare.AccessBookmarkArgs{\n\t\t\tAccountId:          pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tAppLauncherVisible: pulumi.Bool(true),\n\t\t\tDomain:             pulumi.String(\"example.com\"),\n\t\t\tLogoUrl:            pulumi.String(\"https://example.com/example.png\"),\n\t\t\tName:               pulumi.String(\"My Bookmark App\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessBookmark;\nimport com.pulumi.cloudflare.AccessBookmarkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myBookmarkApp = new AccessBookmark(\"myBookmarkApp\", AccessBookmarkArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .appLauncherVisible(true)\n            .domain(\"example.com\")\n            .logoUrl(\"https://example.com/example.png\")\n            .name(\"My Bookmark App\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myBookmarkApp:\n    type: cloudflare:AccessBookmark\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      appLauncherVisible: true\n      domain: example.com\n      logoUrl: https://example.com/example.png\n      name: My Bookmark App\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/accessBookmark:AccessBookmark example \u003caccount_id\u003e/\u003cbookmark_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide the bookmark in the app launcher. Defaults to `true`.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain of the bookmark application. Can include subdomains, paths, or both.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "The image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the bookmark application.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "domain",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "appLauncherVisible": {
                    "type": "boolean",
                    "description": "Option to show/hide the bookmark in the app launcher. Defaults to `true`.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain of the bookmark application. Can include subdomains, paths, or both.\n"
                },
                "logoUrl": {
                    "type": "string",
                    "description": "The image URL for the logo shown in the app launcher dashboard.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the bookmark application.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessBookmark resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "appLauncherVisible": {
                        "type": "boolean",
                        "description": "Option to show/hide the bookmark in the app launcher. Defaults to `true`.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The domain of the bookmark application. Can include subdomains, paths, or both.\n"
                    },
                    "logoUrl": {
                        "type": "string",
                        "description": "The image URL for the logo shown in the app launcher dashboard.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the bookmark application.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessCaCertificate:AccessCaCertificate": {
            "description": "Cloudflare Access can replace traditional SSH key models with\nshort-lived certificates issued to your users based on the token\ngenerated by their Access login.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\nmost cases using either is fine. However, if you're using a scoped\naccess token, you must provide the argument that matches the token's\nscope. For example, an access token that is scoped to the \"example.com\"\nzone needs to use the `zone_id` argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// account level\nconst example = new cloudflare.AccessCaCertificate(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    applicationId: \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n});\n// zone level\nconst anotherExample = new cloudflare.AccessCaCertificate(\"anotherExample\", {\n    applicationId: \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# account level\nexample = cloudflare.AccessCaCertificate(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    application_id=\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n# zone level\nanother_example = cloudflare.AccessCaCertificate(\"anotherExample\",\n    application_id=\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // account level\n    var example = new Cloudflare.AccessCaCertificate(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ApplicationId = \"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\",\n    });\n\n    // zone level\n    var anotherExample = new Cloudflare.AccessCaCertificate(\"anotherExample\", new()\n    {\n        ApplicationId = \"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessCaCertificate(ctx, \"example\", \u0026cloudflare.AccessCaCertificateArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tApplicationId: pulumi.String(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessCaCertificate(ctx, \"anotherExample\", \u0026cloudflare.AccessCaCertificateArgs{\n\t\t\tApplicationId: pulumi.String(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\"),\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessCaCertificate;\nimport com.pulumi.cloudflare.AccessCaCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AccessCaCertificate(\"example\", AccessCaCertificateArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .applicationId(\"6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\")\n            .build());\n\n        var anotherExample = new AccessCaCertificate(\"anotherExample\", AccessCaCertificateArgs.builder()        \n            .applicationId(\"fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # account level\n  example:\n    type: cloudflare:AccessCaCertificate\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      applicationId: 6cd6cea3-3ef2-4542-9aea-85a0bbcd5414\n  # zone level\n  anotherExample:\n    type: cloudflare:AccessCaCertificate\n    properties:\n      applicationId: fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccount level CA certificate import.\n\n```sh\n $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/\u003caccount_id\u003e/\u003ccertificate_id\u003e\n```\n\n Zone level CA certificate import.\n\n```sh\n $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/\u003czone_id\u003e/\u003ccertificate_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "aud": {
                    "type": "string",
                    "description": "Application Audience (AUD) Tag of the CA certificate.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Cryptographic public key of the generated CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "applicationId",
                "aud",
                "publicKey",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The Access Application ID to associate with the CA certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "applicationId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessCaCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The Access Application ID to associate with the CA certificate.\n"
                    },
                    "aud": {
                        "type": "string",
                        "description": "Application Audience (AUD) Tag of the CA certificate.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Cryptographic public key of the generated CA certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessGroup:AccessGroup": {
            "description": "Provides a Cloudflare Access Group resource. Access Groups are used\nin conjunction with Access Policies to restrict access to a\nparticular resource based on group membership.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\nmost cases using either is fine. However, if you're using a scoped\naccess token, you must provide the argument that matches the token's\nscope. For example, an access token that is scoped to the \"example.com\"\nzone needs to use the `zone_id` argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Allowing access to `test@example.com` email address only\nconst testGroupAccessGroup = new cloudflare.AccessGroup(\"testGroupAccessGroup\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"staging group\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n});\n// Allowing `test@example.com` to access but only when coming from a\n// specific IP.\nconst testGroupIndex_accessGroupAccessGroup = new cloudflare.AccessGroup(\"testGroupIndex/accessGroupAccessGroup\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"staging group\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n    requires: {\n        ips: [_var.office_ip],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Allowing access to `test@example.com` email address only\ntest_group_access_group = cloudflare.AccessGroup(\"testGroupAccessGroup\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"staging group\",\n    includes=[cloudflare.AccessGroupIncludeArgs(\n        emails=[\"test@example.com\"],\n    )])\n# Allowing `test@example.com` to access but only when coming from a\n# specific IP.\ntest_group_index_access_group_access_group = cloudflare.AccessGroup(\"testGroupIndex/accessGroupAccessGroup\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"staging group\",\n    includes=[cloudflare.AccessGroupIncludeArgs(\n        emails=[\"test@example.com\"],\n    )],\n    requires={\n        \"ips\": [var[\"office_ip\"]],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Allowing access to `test@example.com` email address only\n    var testGroupAccessGroup = new Cloudflare.AccessGroup(\"testGroupAccessGroup\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"staging group\",\n        Includes = new[]\n        {\n            new Cloudflare.Inputs.AccessGroupIncludeArgs\n            {\n                Emails = new[]\n                {\n                    \"test@example.com\",\n                },\n            },\n        },\n    });\n\n    // Allowing `test@example.com` to access but only when coming from a\n    // specific IP.\n    var testGroupIndex_accessGroupAccessGroup = new Cloudflare.AccessGroup(\"testGroupIndex/accessGroupAccessGroup\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"staging group\",\n        Includes = new[]\n        {\n            new Cloudflare.Inputs.AccessGroupIncludeArgs\n            {\n                Emails = new[]\n                {\n                    \"test@example.com\",\n                },\n            },\n        },\n        Requires = \n        {\n            { \"ips\", new[]\n            {\n                @var.Office_ip,\n            } },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessGroup(ctx, \"testGroupAccessGroup\", \u0026cloudflare.AccessGroupArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"staging group\"),\n\t\t\tIncludes: cloudflare.AccessGroupIncludeArray{\n\t\t\t\t\u0026cloudflare.AccessGroupIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessGroup(ctx, \"testGroupIndex/accessGroupAccessGroup\", \u0026cloudflare.AccessGroupArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"staging group\"),\n\t\t\tIncludes: cloudflare.AccessGroupIncludeArray{\n\t\t\t\t\u0026cloudflare.AccessGroupIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequires: cloudflare.AccessGroupRequireArray{\n\t\t\t\tIps: cloudflare.AccessGroupRequireArgs{\n\t\t\t\t\t_var.Office_ip,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessGroup;\nimport com.pulumi.cloudflare.AccessGroupArgs;\nimport com.pulumi.cloudflare.inputs.AccessGroupIncludeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testGroupAccessGroup = new AccessGroup(\"testGroupAccessGroup\", AccessGroupArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"staging group\")\n            .includes(AccessGroupIncludeArgs.builder()\n                .emails(\"test@example.com\")\n                .build())\n            .build());\n\n        var testGroupIndex_accessGroupAccessGroup = new AccessGroup(\"testGroupIndex/accessGroupAccessGroup\", AccessGroupArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"staging group\")\n            .includes(AccessGroupIncludeArgs.builder()\n                .emails(\"test@example.com\")\n                .build())\n            .requires(AccessGroupRequireArgs.builder()\n                .ips(var_.office_ip())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Allowing access to `test@example.com` email address only\n  testGroupAccessGroup:\n    type: cloudflare:AccessGroup\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: staging group\n      includes:\n        - emails:\n            - test@example.com\n  # Allowing `test@example.com` to access but only when coming from a\n  # specific IP.\n  testGroupIndex/accessGroupAccessGroup:\n    type: cloudflare:AccessGroup\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: staging group\n      includes:\n        - emails:\n            - test@example.com\n      requires:\n        ips:\n          - ${var.office_ip}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/accessGroup:AccessGroup example \u003caccount_id\u003e/\u003cgroup_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                    }
                },
                "name": {
                    "type": "string"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "includes",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                    }
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                    }
                },
                "name": {
                    "type": "string"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "includes",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessGroup resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupExclude:AccessGroupExclude"
                        }
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupInclude:AccessGroupInclude"
                        }
                    },
                    "name": {
                        "type": "string"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessGroupRequire:AccessGroupRequire"
                        }
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessIdentityProvider:AccessIdentityProvider": {
            "description": "Provides a Cloudflare Access Identity Provider resource. Identity\nProviders are used as an authentication or authorisation source\nwithin Access.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\nmost cases using either is fine. However, if you're using a scoped\naccess token, you must provide the argument that matches the token's\nscope. For example, an access token that is scoped to the \"example.com\"\nzone needs to use the `zone_id` argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// one time pin\nconst pinLogin = new cloudflare.AccessIdentityProvider(\"pinLogin\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"PIN login\",\n    type: \"onetimepin\",\n});\n// oauth\nconst githubOauth = new cloudflare.AccessIdentityProvider(\"githubOauth\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    configs: [{\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n    }],\n    name: \"GitHub OAuth\",\n    type: \"github\",\n});\n// saml\nconst jumpcloudSaml = new cloudflare.AccessIdentityProvider(\"jumpcloudSaml\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    configs: [{\n        attributes: [\n            \"email\",\n            \"username\",\n        ],\n        idpPublicCert: `MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n`,\n        issuerUrl: \"jumpcloud\",\n        signRequest: false,\n        ssoTargetUrl: \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n    }],\n    name: \"JumpCloud SAML\",\n    type: \"saml\",\n});\n// okta\nconst okta = new cloudflare.AccessIdentityProvider(\"okta\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    configs: [{\n        apiToken: \"okta_api_token\",\n        clientId: \"example\",\n        clientSecret: \"secret_key\",\n        oktaAccount: \"https://example.com\",\n    }],\n    name: \"Okta\",\n    type: \"okta\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# one time pin\npin_login = cloudflare.AccessIdentityProvider(\"pinLogin\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"PIN login\",\n    type=\"onetimepin\")\n# oauth\ngithub_oauth = cloudflare.AccessIdentityProvider(\"githubOauth\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    configs=[cloudflare.AccessIdentityProviderConfigArgs(\n        client_id=\"example\",\n        client_secret=\"secret_key\",\n    )],\n    name=\"GitHub OAuth\",\n    type=\"github\")\n# saml\njumpcloud_saml = cloudflare.AccessIdentityProvider(\"jumpcloudSaml\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    configs=[cloudflare.AccessIdentityProviderConfigArgs(\n        attributes=[\n            \"email\",\n            \"username\",\n        ],\n        idp_public_cert=\"\"\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n\"\"\",\n        issuer_url=\"jumpcloud\",\n        sign_request=False,\n        sso_target_url=\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n    )],\n    name=\"JumpCloud SAML\",\n    type=\"saml\")\n# okta\nokta = cloudflare.AccessIdentityProvider(\"okta\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    configs=[cloudflare.AccessIdentityProviderConfigArgs(\n        api_token=\"okta_api_token\",\n        client_id=\"example\",\n        client_secret=\"secret_key\",\n        okta_account=\"https://example.com\",\n    )],\n    name=\"Okta\",\n    type=\"okta\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // one time pin\n    var pinLogin = new Cloudflare.AccessIdentityProvider(\"pinLogin\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"PIN login\",\n        Type = \"onetimepin\",\n    });\n\n    // oauth\n    var githubOauth = new Cloudflare.AccessIdentityProvider(\"githubOauth\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n            {\n                ClientId = \"example\",\n                ClientSecret = \"secret_key\",\n            },\n        },\n        Name = \"GitHub OAuth\",\n        Type = \"github\",\n    });\n\n    // saml\n    var jumpcloudSaml = new Cloudflare.AccessIdentityProvider(\"jumpcloudSaml\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n            {\n                Attributes = new[]\n                {\n                    \"email\",\n                    \"username\",\n                },\n                IdpPublicCert = @\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n\",\n                IssuerUrl = \"jumpcloud\",\n                SignRequest = false,\n                SsoTargetUrl = \"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\",\n            },\n        },\n        Name = \"JumpCloud SAML\",\n        Type = \"saml\",\n    });\n\n    // okta\n    var okta = new Cloudflare.AccessIdentityProvider(\"okta\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.AccessIdentityProviderConfigArgs\n            {\n                ApiToken = \"okta_api_token\",\n                ClientId = \"example\",\n                ClientSecret = \"secret_key\",\n                OktaAccount = \"https://example.com\",\n            },\n        },\n        Name = \"Okta\",\n        Type = \"okta\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessIdentityProvider(ctx, \"pinLogin\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"PIN login\"),\n\t\t\tType:      pulumi.String(\"onetimepin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"githubOauth\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tConfigs: cloudflare.AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.AccessIdentityProviderConfigArgs{\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"GitHub OAuth\"),\n\t\t\tType: pulumi.String(\"github\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"jumpcloudSaml\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tConfigs: cloudflare.AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.AccessIdentityProviderConfigArgs{\n\t\t\t\t\tAttributes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"email\"),\n\t\t\t\t\t\tpulumi.String(\"username\"),\n\t\t\t\t\t},\n\t\t\t\t\tIdpPublicCert: pulumi.String(fmt.Sprintf(\"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\\n\")),\n\t\t\t\t\tIssuerUrl:     pulumi.String(\"jumpcloud\"),\n\t\t\t\t\tSignRequest:   pulumi.Bool(false),\n\t\t\t\t\tSsoTargetUrl:  pulumi.String(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"JumpCloud SAML\"),\n\t\t\tType: pulumi.String(\"saml\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessIdentityProvider(ctx, \"okta\", \u0026cloudflare.AccessIdentityProviderArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tConfigs: cloudflare.AccessIdentityProviderConfigArray{\n\t\t\t\t\u0026cloudflare.AccessIdentityProviderConfigArgs{\n\t\t\t\t\tApiToken:     pulumi.String(\"okta_api_token\"),\n\t\t\t\t\tClientId:     pulumi.String(\"example\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"secret_key\"),\n\t\t\t\t\tOktaAccount:  pulumi.String(\"https://example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"Okta\"),\n\t\t\tType: pulumi.String(\"okta\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessIdentityProvider;\nimport com.pulumi.cloudflare.AccessIdentityProviderArgs;\nimport com.pulumi.cloudflare.inputs.AccessIdentityProviderConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pinLogin = new AccessIdentityProvider(\"pinLogin\", AccessIdentityProviderArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"PIN login\")\n            .type(\"onetimepin\")\n            .build());\n\n        var githubOauth = new AccessIdentityProvider(\"githubOauth\", AccessIdentityProviderArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .configs(AccessIdentityProviderConfigArgs.builder()\n                .clientId(\"example\")\n                .clientSecret(\"secret_key\")\n                .build())\n            .name(\"GitHub OAuth\")\n            .type(\"github\")\n            .build());\n\n        var jumpcloudSaml = new AccessIdentityProvider(\"jumpcloudSaml\", AccessIdentityProviderArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .configs(AccessIdentityProviderConfigArgs.builder()\n                .attributes(                \n                    \"email\",\n                    \"username\")\n                .idpPublicCert(\"\"\"\nMIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n                \"\"\")\n                .issuerUrl(\"jumpcloud\")\n                .signRequest(false)\n                .ssoTargetUrl(\"https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\")\n                .build())\n            .name(\"JumpCloud SAML\")\n            .type(\"saml\")\n            .build());\n\n        var okta = new AccessIdentityProvider(\"okta\", AccessIdentityProviderArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .configs(AccessIdentityProviderConfigArgs.builder()\n                .apiToken(\"okta_api_token\")\n                .clientId(\"example\")\n                .clientSecret(\"secret_key\")\n                .oktaAccount(\"https://example.com\")\n                .build())\n            .name(\"Okta\")\n            .type(\"okta\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # one time pin\n  pinLogin:\n    type: cloudflare:AccessIdentityProvider\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: PIN login\n      type: onetimepin\n  # oauth\n  githubOauth:\n    type: cloudflare:AccessIdentityProvider\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      configs:\n        - clientId: example\n          clientSecret: secret_key\n      name: GitHub OAuth\n      type: github\n  # saml\n  jumpcloudSaml:\n    type: cloudflare:AccessIdentityProvider\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      configs:\n        - attributes:\n            - email\n            - username\n          idpPublicCert: |\n            MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\n            uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n          issuerUrl: jumpcloud\n          signRequest: false\n          ssoTargetUrl: https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess\n      name: JumpCloud SAML\n      type: saml\n  # okta\n  okta:\n    type: cloudflare:AccessIdentityProvider\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      configs:\n        - apiToken: okta_api_token\n          clientId: example\n          clientSecret: secret_key\n          oktaAccount: https://example.com\n      name: Okta\n      type: okta\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/accessIdentityProvider:AccessIdentityProvider example \u003caccount_id\u003e/\u003cidentity_provider_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Available values: `centrify`, `facebook`, `google-apps`, `oidc`, `github`, `google`, `saml`, `linkedin`, `azureAD`, `okta`, `onetimepin`, `onelogin`, `yandex`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                    },
                    "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Identity Provider configuration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The provider type to use. Available values: `centrify`, `facebook`, `google-apps`, `oidc`, `github`, `google`, `saml`, `linkedin`, `azureAD`, `okta`, `onetimepin`, `onelogin`, `yandex`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessIdentityProvider resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessIdentityProviderConfig:AccessIdentityProviderConfig"
                        },
                        "description": "Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Identity Provider configuration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The provider type to use. Available values: `centrify`, `facebook`, `google-apps`, `oidc`, `github`, `google`, `saml`, `linkedin`, `azureAD`, `okta`, `onetimepin`, `onelogin`, `yandex`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessKeysConfiguration:AccessKeysConfiguration": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "keyRotationIntervalDays": {
                    "type": "integer",
                    "description": "Number of days to trigger a rotation of the keys.\n"
                }
            },
            "required": [
                "accountId",
                "keyRotationIntervalDays"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "keyRotationIntervalDays": {
                    "type": "integer",
                    "description": "Number of days to trigger a rotation of the keys.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessKeysConfiguration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "keyRotationIntervalDays": {
                        "type": "integer",
                        "description": "Number of days to trigger a rotation of the keys.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate": {
            "description": "Provides a Cloudflare Access Mutual TLS Certificate resource.\nMutual TLS authentication ensures that the traffic is secure and\ntrusted in both directions between a client and server and can be\n used with Access to only allows requests from devices with a\n corresponding client certificate.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\nmost cases using either is fine. However, if you're using a scoped\naccess token, you must provide the argument that matches the token's\nscope. For example, an access token that is scoped to the \"example.com\"\nzone needs to use the `zone_id` argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myCert = new cloudflare.AccessMutualTlsCertificate(\"myCert\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"My Root Cert\",\n    certificate: _var.ca_pem,\n    associatedHostnames: [\"staging.example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_cert = cloudflare.AccessMutualTlsCertificate(\"myCert\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"My Root Cert\",\n    certificate=var[\"ca_pem\"],\n    associated_hostnames=[\"staging.example.com\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCert = new Cloudflare.AccessMutualTlsCertificate(\"myCert\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"My Root Cert\",\n        Certificate = @var.Ca_pem,\n        AssociatedHostnames = new[]\n        {\n            \"staging.example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessMutualTlsCertificate(ctx, \"myCert\", \u0026cloudflare.AccessMutualTlsCertificateArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:        pulumi.String(\"My Root Cert\"),\n\t\t\tCertificate: pulumi.Any(_var.Ca_pem),\n\t\t\tAssociatedHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"staging.example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessMutualTlsCertificate;\nimport com.pulumi.cloudflare.AccessMutualTlsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCert = new AccessMutualTlsCertificate(\"myCert\", AccessMutualTlsCertificateArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"My Root Cert\")\n            .certificate(var_.ca_pem())\n            .associatedHostnames(\"staging.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCert:\n    type: cloudflare:AccessMutualTlsCertificate\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: My Root Cert\n      certificate: ${var.ca_pem}\n      associatedHostnames:\n        - staging.example.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccount level import.\n\n```sh\n $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example account/\u003caccount_id\u003e/\u003cmutual_tls_certificate_id\u003e\n```\n\n Zone level import.\n\n```sh\n $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example zone/\u003czone_id\u003e/\u003cmutual_tls_certificate_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "fingerprint": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "fingerprint",
                "name",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "associatedHostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames that will be prompted for this certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The Root CA for your certificates.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessMutualTlsCertificate resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "associatedHostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames that will be prompted for this certificate.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The Root CA for your certificates.\n"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessOrganization:AccessOrganization": {
            "description": "A Zero Trust organization defines the user login experience.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.AccessOrganization(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    authDomain: \"example.cloudflareaccess.com\",\n    isUiReadOnly: false,\n    loginDesigns: [{\n        backgroundColor: \"#ffffff\",\n        footerText: \"My footer text\",\n        headerText: \"My header text\",\n        logoPath: \"https://example.com/logo.png\",\n        textColor: \"#000000\",\n    }],\n    name: \"example.cloudflareaccess.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.AccessOrganization(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    auth_domain=\"example.cloudflareaccess.com\",\n    is_ui_read_only=False,\n    login_designs=[cloudflare.AccessOrganizationLoginDesignArgs(\n        background_color=\"#ffffff\",\n        footer_text=\"My footer text\",\n        header_text=\"My header text\",\n        logo_path=\"https://example.com/logo.png\",\n        text_color=\"#000000\",\n    )],\n    name=\"example.cloudflareaccess.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.AccessOrganization(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        AuthDomain = \"example.cloudflareaccess.com\",\n        IsUiReadOnly = false,\n        LoginDesigns = new[]\n        {\n            new Cloudflare.Inputs.AccessOrganizationLoginDesignArgs\n            {\n                BackgroundColor = \"#ffffff\",\n                FooterText = \"My footer text\",\n                HeaderText = \"My header text\",\n                LogoPath = \"https://example.com/logo.png\",\n                TextColor = \"#000000\",\n            },\n        },\n        Name = \"example.cloudflareaccess.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessOrganization(ctx, \"example\", \u0026cloudflare.AccessOrganizationArgs{\n\t\t\tAccountId:    pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tAuthDomain:   pulumi.String(\"example.cloudflareaccess.com\"),\n\t\t\tIsUiReadOnly: pulumi.Bool(false),\n\t\t\tLoginDesigns: cloudflare.AccessOrganizationLoginDesignArray{\n\t\t\t\t\u0026cloudflare.AccessOrganizationLoginDesignArgs{\n\t\t\t\t\tBackgroundColor: pulumi.String(\"#ffffff\"),\n\t\t\t\t\tFooterText:      pulumi.String(\"My footer text\"),\n\t\t\t\t\tHeaderText:      pulumi.String(\"My header text\"),\n\t\t\t\t\tLogoPath:        pulumi.String(\"https://example.com/logo.png\"),\n\t\t\t\t\tTextColor:       pulumi.String(\"#000000\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: pulumi.String(\"example.cloudflareaccess.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessOrganization;\nimport com.pulumi.cloudflare.AccessOrganizationArgs;\nimport com.pulumi.cloudflare.inputs.AccessOrganizationLoginDesignArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AccessOrganization(\"example\", AccessOrganizationArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .authDomain(\"example.cloudflareaccess.com\")\n            .isUiReadOnly(false)\n            .loginDesigns(AccessOrganizationLoginDesignArgs.builder()\n                .backgroundColor(\"#ffffff\")\n                .footerText(\"My footer text\")\n                .headerText(\"My header text\")\n                .logoPath(\"https://example.com/logo.png\")\n                .textColor(\"#000000\")\n                .build())\n            .name(\"example.cloudflareaccess.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:AccessOrganization\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      authDomain: example.cloudflareaccess.com\n      isUiReadOnly: false\n      loginDesigns:\n        - backgroundColor: '#ffffff'\n          footerText: My footer text\n          headerText: My header text\n          logoPath: https://example.com/logo.png\n          textColor: '#000000'\n      name: example.cloudflareaccess.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/accessOrganization:AccessOrganization example \u003caccount_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "authDomain": {
                    "type": "string",
                    "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                },
                "isUiReadOnly": {
                    "type": "boolean",
                    "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                },
                "loginDesigns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your Zero Trust organization.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "authDomain",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "authDomain": {
                    "type": "string",
                    "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                },
                "isUiReadOnly": {
                    "type": "boolean",
                    "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                },
                "loginDesigns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your Zero Trust organization.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "authDomain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessOrganization resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "authDomain": {
                        "type": "string",
                        "description": "The unique subdomain assigned to your Zero Trust organization.\n"
                    },
                    "isUiReadOnly": {
                        "type": "boolean",
                        "description": "When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.\n"
                    },
                    "loginDesigns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessOrganizationLoginDesign:AccessOrganizationLoginDesign"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of your Zero Trust organization.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessPolicy:AccessPolicy": {
            "description": "Provides a Cloudflare Access Policy resource. Access Policies are\nused in conjunction with Access Applications to restrict access to\na particular resource.\n\n\u003e It's required that an `account_id` or `zone_id` is provided and in\nmost cases using either is fine. However, if you're using a scoped\naccess token, you must provide the argument that matches the token's\nscope. For example, an access token that is scoped to the \"example.com\"\nzone needs to use the `zone_id` argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Allowing access to `test@example.com` email address only\nconst testPolicyAccessPolicy = new cloudflare.AccessPolicy(\"testPolicyAccessPolicy\", {\n    applicationId: \"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"staging policy\",\n    precedence: 1,\n    decision: \"allow\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n    requires: [{\n        emails: [\"test@example.com\"],\n    }],\n});\n// Allowing `test@example.com` to access but only when coming from a\n// specific IP.\nconst testPolicyIndex_accessPolicyAccessPolicy = new cloudflare.AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\", {\n    applicationId: \"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"staging policy\",\n    precedence: 1,\n    decision: \"allow\",\n    includes: [{\n        emails: [\"test@example.com\"],\n    }],\n    requires: [{\n        ips: [_var.office_ip],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Allowing access to `test@example.com` email address only\ntest_policy_access_policy = cloudflare.AccessPolicy(\"testPolicyAccessPolicy\",\n    application_id=\"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"staging policy\",\n    precedence=1,\n    decision=\"allow\",\n    includes=[cloudflare.AccessPolicyIncludeArgs(\n        emails=[\"test@example.com\"],\n    )],\n    requires=[cloudflare.AccessPolicyRequireArgs(\n        emails=[\"test@example.com\"],\n    )])\n# Allowing `test@example.com` to access but only when coming from a\n# specific IP.\ntest_policy_index_access_policy_access_policy = cloudflare.AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\",\n    application_id=\"cb029e245cfdd66dc8d2e570d5dd3322\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"staging policy\",\n    precedence=1,\n    decision=\"allow\",\n    includes=[cloudflare.AccessPolicyIncludeArgs(\n        emails=[\"test@example.com\"],\n    )],\n    requires=[cloudflare.AccessPolicyRequireArgs(\n        ips=[var[\"office_ip\"]],\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Allowing access to `test@example.com` email address only\n    var testPolicyAccessPolicy = new Cloudflare.AccessPolicy(\"testPolicyAccessPolicy\", new()\n    {\n        ApplicationId = \"cb029e245cfdd66dc8d2e570d5dd3322\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"staging policy\",\n        Precedence = 1,\n        Decision = \"allow\",\n        Includes = new[]\n        {\n            new Cloudflare.Inputs.AccessPolicyIncludeArgs\n            {\n                Emails = new[]\n                {\n                    \"test@example.com\",\n                },\n            },\n        },\n        Requires = new[]\n        {\n            new Cloudflare.Inputs.AccessPolicyRequireArgs\n            {\n                Emails = new[]\n                {\n                    \"test@example.com\",\n                },\n            },\n        },\n    });\n\n    // Allowing `test@example.com` to access but only when coming from a\n    // specific IP.\n    var testPolicyIndex_accessPolicyAccessPolicy = new Cloudflare.AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\", new()\n    {\n        ApplicationId = \"cb029e245cfdd66dc8d2e570d5dd3322\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"staging policy\",\n        Precedence = 1,\n        Decision = \"allow\",\n        Includes = new[]\n        {\n            new Cloudflare.Inputs.AccessPolicyIncludeArgs\n            {\n                Emails = new[]\n                {\n                    \"test@example.com\",\n                },\n            },\n        },\n        Requires = new[]\n        {\n            new Cloudflare.Inputs.AccessPolicyRequireArgs\n            {\n                Ips = new[]\n                {\n                    @var.Office_ip,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessPolicy(ctx, \"testPolicyAccessPolicy\", \u0026cloudflare.AccessPolicyArgs{\n\t\t\tApplicationId: pulumi.String(\"cb029e245cfdd66dc8d2e570d5dd3322\"),\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:          pulumi.String(\"staging policy\"),\n\t\t\tPrecedence:    pulumi.Int(1),\n\t\t\tDecision:      pulumi.String(\"allow\"),\n\t\t\tIncludes: cloudflare.AccessPolicyIncludeArray{\n\t\t\t\t\u0026cloudflare.AccessPolicyIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequires: cloudflare.AccessPolicyRequireArray{\n\t\t\t\t\u0026cloudflare.AccessPolicyRequireArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessPolicy(ctx, \"testPolicyIndex/accessPolicyAccessPolicy\", \u0026cloudflare.AccessPolicyArgs{\n\t\t\tApplicationId: pulumi.String(\"cb029e245cfdd66dc8d2e570d5dd3322\"),\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:          pulumi.String(\"staging policy\"),\n\t\t\tPrecedence:    pulumi.Int(1),\n\t\t\tDecision:      pulumi.String(\"allow\"),\n\t\t\tIncludes: cloudflare.AccessPolicyIncludeArray{\n\t\t\t\t\u0026cloudflare.AccessPolicyIncludeArgs{\n\t\t\t\t\tEmails: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"test@example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequires: cloudflare.AccessPolicyRequireArray{\n\t\t\t\t\u0026cloudflare.AccessPolicyRequireArgs{\n\t\t\t\t\tIps: pulumi.StringArray{\n\t\t\t\t\t\t_var.Office_ip,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessPolicy;\nimport com.pulumi.cloudflare.AccessPolicyArgs;\nimport com.pulumi.cloudflare.inputs.AccessPolicyIncludeArgs;\nimport com.pulumi.cloudflare.inputs.AccessPolicyRequireArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPolicyAccessPolicy = new AccessPolicy(\"testPolicyAccessPolicy\", AccessPolicyArgs.builder()        \n            .applicationId(\"cb029e245cfdd66dc8d2e570d5dd3322\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"staging policy\")\n            .precedence(\"1\")\n            .decision(\"allow\")\n            .includes(AccessPolicyIncludeArgs.builder()\n                .emails(\"test@example.com\")\n                .build())\n            .requires(AccessPolicyRequireArgs.builder()\n                .emails(\"test@example.com\")\n                .build())\n            .build());\n\n        var testPolicyIndex_accessPolicyAccessPolicy = new AccessPolicy(\"testPolicyIndex/accessPolicyAccessPolicy\", AccessPolicyArgs.builder()        \n            .applicationId(\"cb029e245cfdd66dc8d2e570d5dd3322\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"staging policy\")\n            .precedence(\"1\")\n            .decision(\"allow\")\n            .includes(AccessPolicyIncludeArgs.builder()\n                .emails(\"test@example.com\")\n                .build())\n            .requires(AccessPolicyRequireArgs.builder()\n                .ips(var_.office_ip())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Allowing access to `test@example.com` email address only\n  testPolicyAccessPolicy:\n    type: cloudflare:AccessPolicy\n    properties:\n      applicationId: cb029e245cfdd66dc8d2e570d5dd3322\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: staging policy\n      precedence: '1'\n      decision: allow\n      includes:\n        - emails:\n            - test@example.com\n      requires:\n        - emails:\n            - test@example.com\n  # Allowing `test@example.com` to access but only when coming from a\n  # specific IP.\n  testPolicyIndex/accessPolicyAccessPolicy:\n    type: cloudflare:AccessPolicy\n    properties:\n      applicationId: cb029e245cfdd66dc8d2e570d5dd3322\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: staging policy\n      precedence: '1'\n      decision: allow\n      includes:\n        - emails:\n            - test@example.com\n      requires:\n        - ips:\n            - ${var.office_ip}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAccount level import.\n\n```sh\n $ pulumi import cloudflare:index/accessPolicy:AccessPolicy example account/\u003caccount_id\u003e/\u003capplication_id\u003e/\u003cpolicy_id\u003e\n```\n\n Zone level import.\n\n```sh\n $ pulumi import cloudflare:index/accessPolicy:AccessPolicy example zone/\u003czone_id\u003e/\u003capplication_id\u003e/\u003cpolicy_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with.\n"
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                    }
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "accountId",
                "applicationId",
                "decision",
                "includes",
                "name",
                "precedence",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "applicationId": {
                    "type": "string",
                    "description": "The ID of the application the policy is associated with.\n"
                },
                "approvalGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                    }
                },
                "approvalRequired": {
                    "type": "boolean"
                },
                "decision": {
                    "type": "string",
                    "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                },
                "excludes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                    },
                    "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "includes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                    },
                    "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the Access Policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The unique precedence for policies on a single application.\n"
                },
                "purposeJustificationPrompt": {
                    "type": "string",
                    "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                },
                "purposeJustificationRequired": {
                    "type": "boolean",
                    "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                },
                "requires": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                    },
                    "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "applicationId",
                "decision",
                "includes",
                "name",
                "precedence"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "applicationId": {
                        "type": "string",
                        "description": "The ID of the application the policy is associated with.\n"
                    },
                    "approvalGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyApprovalGroup:AccessPolicyApprovalGroup"
                        }
                    },
                    "approvalRequired": {
                        "type": "boolean"
                    },
                    "decision": {
                        "type": "string",
                        "description": "Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.\n"
                    },
                    "excludes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyExclude:AccessPolicyExclude"
                        },
                        "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyInclude:AccessPolicyInclude"
                        },
                        "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the Access Policy.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The unique precedence for policies on a single application.\n"
                    },
                    "purposeJustificationPrompt": {
                        "type": "string",
                        "description": "The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.\n"
                    },
                    "purposeJustificationRequired": {
                        "type": "boolean",
                        "description": "Whether to prompt the user for a justification for accessing the resource.\n"
                    },
                    "requires": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/AccessPolicyRequire:AccessPolicyRequire"
                        },
                        "description": "A series of access conditions, see [Access\nGroups](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessRule:AccessRule": {
            "description": "Provides a Cloudflare IP Firewall Access Rule resource. Access\ncontrol can be applied on basis of IP addresses, IP ranges, AS\nnumbers or countries.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Challenge requests coming from known Tor exit nodes.\nconst torExitNodes = new cloudflare.AccessRule(\"torExitNodes\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes: \"Requests coming from known Tor exit nodes\",\n    mode: \"challenge\",\n    configuration: {\n        target: \"country\",\n        value: \"T1\",\n    },\n});\n// Allowlist requests coming from Antarctica, but only for single zone.\nconst antarctica = new cloudflare.AccessRule(\"antarctica\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes: \"Requests coming from Antarctica\",\n    mode: \"whitelist\",\n    configuration: {\n        target: \"country\",\n        value: \"AQ\",\n    },\n});\nconst config = new pulumi.Config();\nconst myOffice = config.getObject(\"myOffice\") || [\n    \"192.0.2.0/24\",\n    \"198.51.100.0/24\",\n    \"2001:db8::/56\",\n];\nconst officeNetwork: cloudflare.AccessRule[] = [];\nfor (const range = {value: 0}; range.value \u003c myOffice.length; range.value++) {\n    officeNetwork.push(new cloudflare.AccessRule(`officeNetwork-${range.value}`, {\n        accountId: \"f037e56e89293a057740de681ac9abbe\",\n        notes: \"Requests coming from office network\",\n        mode: \"whitelist\",\n        configuration: {\n            target: \"ip_range\",\n            value: myOffice[count.index],\n        },\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Challenge requests coming from known Tor exit nodes.\ntor_exit_nodes = cloudflare.AccessRule(\"torExitNodes\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes=\"Requests coming from known Tor exit nodes\",\n    mode=\"challenge\",\n    configuration=cloudflare.AccessRuleConfigurationArgs(\n        target=\"country\",\n        value=\"T1\",\n    ))\n# Allowlist requests coming from Antarctica, but only for single zone.\nantarctica = cloudflare.AccessRule(\"antarctica\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    notes=\"Requests coming from Antarctica\",\n    mode=\"whitelist\",\n    configuration=cloudflare.AccessRuleConfigurationArgs(\n        target=\"country\",\n        value=\"AQ\",\n    ))\nconfig = pulumi.Config()\nmy_office = config.get_object(\"myOffice\")\nif my_office is None:\n    my_office = [\n        \"192.0.2.0/24\",\n        \"198.51.100.0/24\",\n        \"2001:db8::/56\",\n    ]\noffice_network = []\nfor range in [{\"value\": i} for i in range(0, len(my_office))]:\n    office_network.append(cloudflare.AccessRule(f\"officeNetwork-{range['value']}\",\n        account_id=\"f037e56e89293a057740de681ac9abbe\",\n        notes=\"Requests coming from office network\",\n        mode=\"whitelist\",\n        configuration=cloudflare.AccessRuleConfigurationArgs(\n            target=\"ip_range\",\n            value=my_office[count[\"index\"]],\n        )))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Challenge requests coming from known Tor exit nodes.\n    var torExitNodes = new Cloudflare.AccessRule(\"torExitNodes\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Notes = \"Requests coming from known Tor exit nodes\",\n        Mode = \"challenge\",\n        Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs\n        {\n            Target = \"country\",\n            Value = \"T1\",\n        },\n    });\n\n    // Allowlist requests coming from Antarctica, but only for single zone.\n    var antarctica = new Cloudflare.AccessRule(\"antarctica\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Notes = \"Requests coming from Antarctica\",\n        Mode = \"whitelist\",\n        Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs\n        {\n            Target = \"country\",\n            Value = \"AQ\",\n        },\n    });\n\n    var config = new Config();\n    var myOffice = config.GetObject\u003cdynamic\u003e(\"myOffice\") ?? new[]\n    {\n        \"192.0.2.0/24\",\n        \"198.51.100.0/24\",\n        \"2001:db8::/56\",\n    };\n    var officeNetwork = new List\u003cCloudflare.AccessRule\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c myOffice.Length; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        officeNetwork.Add(new Cloudflare.AccessRule($\"officeNetwork-{range.Value}\", new()\n        {\n            AccountId = \"f037e56e89293a057740de681ac9abbe\",\n            Notes = \"Requests coming from office network\",\n            Mode = \"whitelist\",\n            Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs\n            {\n                Target = \"ip_range\",\n                Value = myOffice[count.Index],\n            },\n        }));\n    }\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessRule;\nimport com.pulumi.cloudflare.AccessRuleArgs;\nimport com.pulumi.cloudflare.inputs.AccessRuleConfigurationArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        var torExitNodes = new AccessRule(\"torExitNodes\", AccessRuleArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .notes(\"Requests coming from known Tor exit nodes\")\n            .mode(\"challenge\")\n            .configuration(AccessRuleConfigurationArgs.builder()\n                .target(\"country\")\n                .value(\"T1\")\n                .build())\n            .build());\n\n        var antarctica = new AccessRule(\"antarctica\", AccessRuleArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .notes(\"Requests coming from Antarctica\")\n            .mode(\"whitelist\")\n            .configuration(AccessRuleConfigurationArgs.builder()\n                .target(\"country\")\n                .value(\"AQ\")\n                .build())\n            .build());\n\n        final var myOffice = config.get(\"myOffice\").orElse(        \n            \"192.0.2.0/24\",\n            \"198.51.100.0/24\",\n            \"2001:db8::/56\");\n        for (var i = 0; i \u003c myOffice.length(); i++) {\n            new AccessRule(\"officeNetwork-\" + i, AccessRuleArgs.builder()            \n                .accountId(\"f037e56e89293a057740de681ac9abbe\")\n                .notes(\"Requests coming from office network\")\n                .mode(\"whitelist\")\n                .configuration(AccessRuleConfigurationArgs.builder()\n                    .target(\"ip_range\")\n                    .value(myOffice[count.index()])\n                    .build())\n                .build());\n\n        \n}\n    }\n}\n```\n```yaml\nconfiguration:\n  # Allowlist office's network IP ranges on all account zones (or other lists of\n  # resources).\n  myOffice:\n    type: list(string)\n    default:\n      - 192.0.2.0/24\n      - 198.51.100.0/24\n      - 2001:db8::/56\nresources:\n  # Challenge requests coming from known Tor exit nodes.\n  torExitNodes:\n    type: cloudflare:AccessRule\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      notes: Requests coming from known Tor exit nodes\n      mode: challenge\n      configuration:\n        target: country\n        value: T1\n  # Allowlist requests coming from Antarctica, but only for single zone.\n  antarctica:\n    type: cloudflare:AccessRule\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      notes: Requests coming from Antarctica\n      mode: whitelist\n      configuration:\n        target: country\n        value: AQ\n  officeNetwork:\n    type: cloudflare:AccessRule\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      notes: Requests coming from office network\n      mode: whitelist\n      configuration:\n        target: ip_range\n        value:\n          fn::select:\n            - ${count.index}\n            - ${myOffice}\n    options: {}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nUser level access rule import.\n\n```sh\n $ pulumi import cloudflare:index/accessRule:AccessRule default user/\u003cuser_id\u003e/\u003crule_id\u003e\n```\n\n Zone level access rule import.\n\n```sh\n $ pulumi import cloudflare:index/accessRule:AccessRule default zone/\u003czone_id\u003e/\u003crule_id\u003e\n```\n\n Account level access rule import.\n\n```sh\n $ pulumi import cloudflare:index/accessRule:AccessRule default account/\u003caccount_id\u003e/\u003crule_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "configuration": {
                    "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "configuration",
                "mode",
                "zoneId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "configuration": {
                    "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                    "description": "Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configuration",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "configuration": {
                        "$ref": "#/types/cloudflare:index/AccessRuleConfiguration:AccessRuleConfiguration",
                        "description": "Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "mode": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.\n"
                    },
                    "notes": {
                        "type": "string",
                        "description": "A personal note about the rule. Typically used as a reminder or explanation for the rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accessServiceToken:AccessServiceToken": {
            "description": "Access Service Tokens are used for service-to-service communication\nwhen an application is behind Cloudflare Access.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Generate a service token that will renew if terraform is ran within 30 days of expiration\nconst myApp = new cloudflare.AccessServiceToken(\"myApp\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    minDaysForRenewal: 30,\n    name: \"CI/CD app renewed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Generate a service token that will renew if terraform is ran within 30 days of expiration\nmy_app = cloudflare.AccessServiceToken(\"myApp\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    min_days_for_renewal=30,\n    name=\"CI/CD app renewed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Generate a service token that will renew if terraform is ran within 30 days of expiration\n    var myApp = new Cloudflare.AccessServiceToken(\"myApp\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        MinDaysForRenewal = 30,\n        Name = \"CI/CD app renewed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccessServiceToken(ctx, \"myApp\", \u0026cloudflare.AccessServiceTokenArgs{\n\t\t\tAccountId:         pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tMinDaysForRenewal: pulumi.Int(30),\n\t\t\tName:              pulumi.String(\"CI/CD app renewed\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccessServiceToken;\nimport com.pulumi.cloudflare.AccessServiceTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myApp = new AccessServiceToken(\"myApp\", AccessServiceTokenArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .minDaysForRenewal(30)\n            .name(\"CI/CD app renewed\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Generate a service token that will renew if terraform is ran within 30 days of expiration\n  myApp:\n    type: cloudflare:AccessServiceToken\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      minDaysForRenewal: 30\n      name: CI/CD app renewed\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIf you are importing an Access Service Token you will not have the client_secret available in the state for use. The client_secret is only available once, at creation. In most cases, it is better to just create a new resource should you need to reference it in other resources.\n\n```sh\n $ pulumi import cloudflare:index/accessServiceToken:AccessServiceToken example \u003caccount_id\u003e/\u003cservice_token_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "UUID client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**\n",
                    "secret": true
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Date when the token expires.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer",
                    "description": "Refresh the token if terraform is run within the specified amount of days before expiration\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "clientId",
                "clientSecret",
                "expiresAt",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "minDaysForRenewal": {
                    "type": "integer",
                    "description": "Refresh the token if terraform is run within the specified amount of days before expiration\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the token's intent.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessServiceToken resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "UUID client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Date when the token expires.\n"
                    },
                    "minDaysForRenewal": {
                        "type": "integer",
                        "description": "Refresh the token if terraform is run within the specified amount of days before expiration\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Friendly name of the token's intent.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/account:Account": {
            "description": "Provides a Cloudflare Account resource. Account is the basic resource for\nworking with Cloudflare zones, teams and users.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Account(\"example\", {\n    enforceTwofactor: true,\n    name: \"some-enterprise-account\",\n    type: \"enterprise\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Account(\"example\",\n    enforce_twofactor=True,\n    name=\"some-enterprise-account\",\n    type=\"enterprise\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Account(\"example\", new()\n    {\n        EnforceTwofactor = true,\n        Name = \"some-enterprise-account\",\n        Type = \"enterprise\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccount(ctx, \"example\", \u0026cloudflare.AccountArgs{\n\t\t\tEnforceTwofactor: pulumi.Bool(true),\n\t\t\tName:             pulumi.String(\"some-enterprise-account\"),\n\t\t\tType:             pulumi.String(\"enterprise\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Account;\nimport com.pulumi.cloudflare.AccountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Account(\"example\", AccountArgs.builder()        \n            .enforceTwofactor(true)\n            .name(\"some-enterprise-account\")\n            .type(\"enterprise\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Account\n    properties:\n      enforceTwofactor: true\n      name: some-enterprise-account\n      type: enterprise\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/account:Account example \u003caccount_id\u003e\n```\n\n ",
            "properties": {
                "enforceTwofactor": {
                    "type": "boolean",
                    "description": "Whether 2FA is enforced on the account. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the account that is displayed in the Cloudflare dashboard.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "enforceTwofactor": {
                    "type": "boolean",
                    "description": "Whether 2FA is enforced on the account. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the account that is displayed in the Cloudflare dashboard.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Account resources.\n",
                "properties": {
                    "enforceTwofactor": {
                        "type": "boolean",
                        "description": "Whether 2FA is enforced on the account. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the account that is displayed in the Cloudflare dashboard.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/accountMember:AccountMember": {
            "description": "Provides a resource which manages Cloudflare account members.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleUser = new cloudflare.AccountMember(\"exampleUser\", {\n    emailAddress: \"user@example.com\",\n    roleIds: [\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_user = cloudflare.AccountMember(\"exampleUser\",\n    email_address=\"user@example.com\",\n    role_ids=[\n        \"68b329da9893e34099c7d8ad5cb9c940\",\n        \"d784fa8b6d98d27699781bd9a7cf19f0\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleUser = new Cloudflare.AccountMember(\"exampleUser\", new()\n    {\n        EmailAddress = \"user@example.com\",\n        RoleIds = new[]\n        {\n            \"68b329da9893e34099c7d8ad5cb9c940\",\n            \"d784fa8b6d98d27699781bd9a7cf19f0\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAccountMember(ctx, \"exampleUser\", \u0026cloudflare.AccountMemberArgs{\n\t\t\tEmailAddress: pulumi.String(\"user@example.com\"),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"68b329da9893e34099c7d8ad5cb9c940\"),\n\t\t\t\tpulumi.String(\"d784fa8b6d98d27699781bd9a7cf19f0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AccountMember;\nimport com.pulumi.cloudflare.AccountMemberArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleUser = new AccountMember(\"exampleUser\", AccountMemberArgs.builder()        \n            .emailAddress(\"user@example.com\")\n            .roleIds(            \n                \"68b329da9893e34099c7d8ad5cb9c940\",\n                \"d784fa8b6d98d27699781bd9a7cf19f0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleUser:\n    type: cloudflare:AccountMember\n    properties:\n      emailAddress: user@example.com\n      roleIds:\n        - 68b329da9893e34099c7d8ad5cb9c940\n        - d784fa8b6d98d27699781bd9a7cf19f0\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/accountMember:AccountMember example \u003caccount_id\u003e/\u003cmember_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to create the account member in.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of account role IDs that you want to assign to a member.\n"
                },
                "status": {
                    "type": "string",
                    "description": "A member's status in the account. Available values: `accepted`, `pending`.\n"
                }
            },
            "required": [
                "emailAddress",
                "roleIds"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to create the account member in.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of account role IDs that you want to assign to a member.\n"
                },
                "status": {
                    "type": "string",
                    "description": "A member's status in the account. Available values: `accepted`, `pending`.\n"
                }
            },
            "requiredInputs": [
                "emailAddress",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountMember resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "Account ID to create the account member in.\n"
                    },
                    "emailAddress": {
                        "type": "string",
                        "description": "The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of account role IDs that you want to assign to a member.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "A member's status in the account. Available values: `accepted`, `pending`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiShield:ApiShield": {
            "description": "Provides a resource to manage API Shield configurations.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ApiShield(\"example\", {\n    authIdCharacteristics: [{\n        name: \"my-example-header\",\n        type: \"header\",\n    }],\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ApiShield(\"example\",\n    auth_id_characteristics=[cloudflare.ApiShieldAuthIdCharacteristicArgs(\n        name=\"my-example-header\",\n        type=\"header\",\n    )],\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ApiShield(\"example\", new()\n    {\n        AuthIdCharacteristics = new[]\n        {\n            new Cloudflare.Inputs.ApiShieldAuthIdCharacteristicArgs\n            {\n                Name = \"my-example-header\",\n                Type = \"header\",\n            },\n        },\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewApiShield(ctx, \"example\", \u0026cloudflare.ApiShieldArgs{\n\t\t\tAuthIdCharacteristics: cloudflare.ApiShieldAuthIdCharacteristicArray{\n\t\t\t\t\u0026cloudflare.ApiShieldAuthIdCharacteristicArgs{\n\t\t\t\t\tName: pulumi.String(\"my-example-header\"),\n\t\t\t\t\tType: pulumi.String(\"header\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ApiShield;\nimport com.pulumi.cloudflare.ApiShieldArgs;\nimport com.pulumi.cloudflare.inputs.ApiShieldAuthIdCharacteristicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ApiShield(\"example\", ApiShieldArgs.builder()        \n            .authIdCharacteristics(ApiShieldAuthIdCharacteristicArgs.builder()\n                .name(\"my-example-header\")\n                .type(\"header\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ApiShield\n    properties:\n      authIdCharacteristics:\n        - name: my-example-header\n          type: header\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "authIdCharacteristics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic"
                    },
                    "description": "Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "authIdCharacteristics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic"
                    },
                    "description": "Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiShield resources.\n",
                "properties": {
                    "authIdCharacteristics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ApiShieldAuthIdCharacteristic:ApiShieldAuthIdCharacteristic"
                        },
                        "description": "Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/apiToken:ApiToken": {
            "description": "Provides a resource which manages Cloudflare API tokens.\n\nRead more about permission groups and their applicable scopes in the\n[developer documentation](https://developers.cloudflare.com/api/tokens/create/permissions).\n",
            "properties": {
                "condition": {
                    "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                    "description": "Conditions under which the token should be considered valid.\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The expiration time on or after which the token MUST NOT be accepted for processing.\n"
                },
                "issuedOn": {
                    "type": "string",
                    "description": "Timestamp of when the token was issued.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Timestamp of when the token was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the API Token.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time before which the token MUST NOT be accepted for processing.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                    },
                    "description": "Permissions policy. Multiple policy blocks can be defined.\n"
                },
                "status": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the API Token.\n",
                    "secret": true
                }
            },
            "required": [
                "issuedOn",
                "modifiedOn",
                "name",
                "policies",
                "status",
                "value"
            ],
            "inputProperties": {
                "condition": {
                    "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                    "description": "Conditions under which the token should be considered valid.\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The expiration time on or after which the token MUST NOT be accepted for processing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the API Token.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time before which the token MUST NOT be accepted for processing.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                    },
                    "description": "Permissions policy. Multiple policy blocks can be defined.\n"
                }
            },
            "requiredInputs": [
                "name",
                "policies"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiToken resources.\n",
                "properties": {
                    "condition": {
                        "$ref": "#/types/cloudflare:index/ApiTokenCondition:ApiTokenCondition",
                        "description": "Conditions under which the token should be considered valid.\n"
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "The expiration time on or after which the token MUST NOT be accepted for processing.\n"
                    },
                    "issuedOn": {
                        "type": "string",
                        "description": "Timestamp of when the token was issued.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Timestamp of when the token was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the API Token.\n"
                    },
                    "notBefore": {
                        "type": "string",
                        "description": "The time before which the token MUST NOT be accepted for processing.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ApiTokenPolicy:ApiTokenPolicy"
                        },
                        "description": "Permissions policy. Multiple policy blocks can be defined.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the API Token.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/argo:Argo": {
            "description": "Cloudflare Argo controls the routing to your origin and tiered\ncaching options to speed up your website browsing experience.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Argo(\"example\", {\n    smartRouting: \"on\",\n    tieredCaching: \"on\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Argo(\"example\",\n    smart_routing=\"on\",\n    tiered_caching=\"on\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Argo(\"example\", new()\n    {\n        SmartRouting = \"on\",\n        TieredCaching = \"on\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewArgo(ctx, \"example\", \u0026cloudflare.ArgoArgs{\n\t\t\tSmartRouting:  pulumi.String(\"on\"),\n\t\t\tTieredCaching: pulumi.String(\"on\"),\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Argo;\nimport com.pulumi.cloudflare.ArgoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Argo(\"example\", ArgoArgs.builder()        \n            .smartRouting(\"on\")\n            .tieredCaching(\"on\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Argo\n    properties:\n      smartRouting: on\n      tieredCaching: on\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/argo:Argo example \u003czone_id\u003e\n```\n\n ",
            "properties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Available values: `on`, `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Available values: `on`, `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "smartRouting": {
                    "type": "string",
                    "description": "Whether smart routing is enabled. Available values: `on`, `off`.\n"
                },
                "tieredCaching": {
                    "type": "string",
                    "description": "Whether tiered caching is enabled. Available values: `on`, `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Argo resources.\n",
                "properties": {
                    "smartRouting": {
                        "type": "string",
                        "description": "Whether smart routing is enabled. Available values: `on`, `off`.\n"
                    },
                    "tieredCaching": {
                        "type": "string",
                        "description": "Whether tiered caching is enabled. Available values: `on`, `off`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/argoTunnel:ArgoTunnel": {
            "description": "Argo Tunnel exposes applications running on your local web server on any network with an internet connection without manually adding DNS records or configuring a firewall or router.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ArgoTunnel(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    name: \"my-tunnel\",\n    secret: \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ArgoTunnel(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    name=\"my-tunnel\",\n    secret=\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ArgoTunnel(\"example\", new()\n    {\n        AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Name = \"my-tunnel\",\n        Secret = \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewArgoTunnel(ctx, \"example\", \u0026cloudflare.ArgoTunnelArgs{\n\t\t\tAccountId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tName:      pulumi.String(\"my-tunnel\"),\n\t\t\tSecret:    pulumi.String(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ArgoTunnel;\nimport com.pulumi.cloudflare.ArgoTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ArgoTunnel(\"example\", ArgoTunnelArgs.builder()        \n            .accountId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .name(\"my-tunnel\")\n            .secret(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ArgoTunnel\n    properties:\n      accountId: d41d8cd98f00b204e9800998ecf8427e\n      name: my-tunnel\n      secret: AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nArgo Tunnels can be imported a composite ID of the account ID and tunnel UUID.\n\n```sh\n $ pulumi import cloudflare:index/argoTunnel:ArgoTunnel example d41d8cd98f00b204e9800998ecf8427e/fd2455cb-5fcc-4c13-8738-8d8d2605237f\n```\n\n where - `d41d8cd98f00b204e9800998ecf8427e` is the account ID - `fd2455cb-5fcc-4c13-8738-8d8d2605237f` is the Argo Tunnel UUID ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The Cloudflare account ID that you wish to manage the Argo Tunnel on.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Usable CNAME for accessing the Argo Tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. Cannot be empty.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password.\n",
                    "secret": true
                },
                "tunnelToken": {
                    "type": "string",
                    "description": "Token used by a connector to authenticate and run the tunnel.\n"
                }
            },
            "required": [
                "accountId",
                "cname",
                "name",
                "secret",
                "tunnelToken"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The Cloudflare account ID that you wish to manage the Argo Tunnel on.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the tunnel is created. Cannot be empty.\n",
                    "willReplaceOnChanges": true
                },
                "secret": {
                    "type": "string",
                    "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "secret"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ArgoTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The Cloudflare account ID that you wish to manage the Argo Tunnel on.\n",
                        "willReplaceOnChanges": true
                    },
                    "cname": {
                        "type": "string",
                        "description": "Usable CNAME for accessing the Argo Tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the tunnel is created. Cannot be empty.\n",
                        "willReplaceOnChanges": true
                    },
                    "secret": {
                        "type": "string",
                        "description": "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "tunnelToken": {
                        "type": "string",
                        "description": "Token used by a connector to authenticate and run the tunnel.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls": {
            "description": "Provides a Cloudflare Authenticated Origin Pulls resource. An `cloudflare.AuthenticatedOriginPulls` resource is required to use Per-Zone or Per-Hostname Authenticated Origin Pulls.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe arguments that you provide determine which form of Authenticated Origin Pulls to use:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Authenticated Origin Pulls\nconst myAop = new cloudflare.AuthenticatedOriginPulls(\"myAop\", {\n    zoneId: _var.cloudflare_zone_id,\n    enabled: true,\n});\n// Per-Zone Authenticated Origin Pulls\nconst myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", {\n    zoneId: _var.cloudflare_zone_id,\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-zone\",\n});\nconst myPerZoneAop = new cloudflare.AuthenticatedOriginPulls(\"myPerZoneAop\", {\n    zoneId: _var.cloudflare_zone_id,\n    authenticatedOriginPullsCertificate: myPerZoneAopCert.id,\n    enabled: true,\n});\n// Per-Hostname Authenticated Origin Pulls\nconst myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", {\n    zoneId: _var.cloudflare_zone_id,\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-hostname\",\n});\nconst myPerHostnameAop = new cloudflare.AuthenticatedOriginPulls(\"myPerHostnameAop\", {\n    zoneId: _var.cloudflare_zone_id,\n    authenticatedOriginPullsCertificate: myPerHostnameAopCert.id,\n    hostname: \"aop.example.com\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Authenticated Origin Pulls\nmy_aop = cloudflare.AuthenticatedOriginPulls(\"myAop\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    enabled=True)\n# Per-Zone Authenticated Origin Pulls\nmy_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-zone\")\nmy_per_zone_aop = cloudflare.AuthenticatedOriginPulls(\"myPerZoneAop\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    authenticated_origin_pulls_certificate=my_per_zone_aop_cert.id,\n    enabled=True)\n# Per-Hostname Authenticated Origin Pulls\nmy_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-hostname\")\nmy_per_hostname_aop = cloudflare.AuthenticatedOriginPulls(\"myPerHostnameAop\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    authenticated_origin_pulls_certificate=my_per_hostname_aop_cert.id,\n    hostname=\"aop.example.com\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Authenticated Origin Pulls\n    var myAop = new Cloudflare.AuthenticatedOriginPulls(\"myAop\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Enabled = true,\n    });\n\n    // Per-Zone Authenticated Origin Pulls\n    var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-zone\",\n    });\n\n    var myPerZoneAop = new Cloudflare.AuthenticatedOriginPulls(\"myPerZoneAop\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        AuthenticatedOriginPullsCertificate = myPerZoneAopCert.Id,\n        Enabled = true,\n    });\n\n    // Per-Hostname Authenticated Origin Pulls\n    var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-hostname\",\n    });\n\n    var myPerHostnameAop = new Cloudflare.AuthenticatedOriginPulls(\"myPerHostnameAop\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        AuthenticatedOriginPullsCertificate = myPerHostnameAopCert.Id,\n        Hostname = \"aop.example.com\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAuthenticatedOriginPulls(ctx, \"myAop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:  pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyPerZoneAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerZoneAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-zone\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, \"myPerZoneAop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:                              pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tAuthenticatedOriginPullsCertificate: myPerZoneAopCert.ID(),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyPerHostnameAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerHostnameAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-hostname\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, \"myPerHostnameAop\", \u0026cloudflare.AuthenticatedOriginPullsArgs{\n\t\t\tZoneId:                              pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tAuthenticatedOriginPullsCertificate: myPerHostnameAopCert.ID(),\n\t\t\tHostname:                            pulumi.String(\"aop.example.com\"),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AuthenticatedOriginPulls;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsArgs;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificate;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myAop = new AuthenticatedOriginPulls(\"myAop\", AuthenticatedOriginPullsArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .enabled(true)\n            .build());\n\n        var myPerZoneAopCert = new AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-zone\")\n            .build());\n\n        var myPerZoneAop = new AuthenticatedOriginPulls(\"myPerZoneAop\", AuthenticatedOriginPullsArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .authenticatedOriginPullsCertificate(myPerZoneAopCert.id())\n            .enabled(true)\n            .build());\n\n        var myPerHostnameAopCert = new AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-hostname\")\n            .build());\n\n        var myPerHostnameAop = new AuthenticatedOriginPulls(\"myPerHostnameAop\", AuthenticatedOriginPullsArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .authenticatedOriginPullsCertificate(myPerHostnameAopCert.id())\n            .hostname(\"aop.example.com\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Authenticated Origin Pulls\n  myAop:\n    type: cloudflare:AuthenticatedOriginPulls\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      enabled: true\n  # Per-Zone Authenticated Origin Pulls\n  myPerZoneAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-zone\n  myPerZoneAop:\n    type: cloudflare:AuthenticatedOriginPulls\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      authenticatedOriginPullsCertificate: ${myPerZoneAopCert.id}\n      enabled: true\n  # Per-Hostname Authenticated Origin Pulls\n  myPerHostnameAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-hostname\n  myPerHostnameAop:\n    type: cloudflare:AuthenticatedOriginPulls\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      authenticatedOriginPullsCertificate: ${myPerHostnameAopCert.id}\n      hostname: aop.example.com\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuthenticated Origin Pull configuration can be imported using a composite ID formed of the zone ID, the form of Authenticated Origin Pulls, and the certificate ID, with each section filled or left blank e.g. Import Authenticated Origin Pull configuration\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls my_aop 023e105f4ecef8ad9ca31a8372d0c353//\n```\n\n Import Per-Zone Authenticated Origin Pull configuration\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls my_per_zone_aop 023e105f4ecef8ad9ca31a8372d0c353/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60/\n```\n\n Import Per-Hostname Authenticated Origin Pull configuration\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls my_per_hostname_aop 023e105f4ecef8ad9ca31a8372d0c353/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60/aop.example.com\n```\n\n ",
            "properties": {
                "authenticatedOriginPullsCertificate": {
                    "type": "string",
                    "description": "The id of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "authenticatedOriginPullsCertificate": {
                    "type": "string",
                    "description": "The id of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthenticatedOriginPulls resources.\n",
                "properties": {
                    "authenticatedOriginPullsCertificate": {
                        "type": "string",
                        "description": "The id of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable Authenticated Origin Pulls on the given zone or hostname.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to upload the certificate to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate": {
            "description": "Provides a Cloudflare Authenticated Origin Pulls certificate resource. An uploaded client certificate is required to use Per-Zone or Per-Hostname Authenticated Origin Pulls.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Per-Zone Authenticated Origin Pulls certificate\nconst myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", {\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-zone\",\n    zoneId: _var.cloudflare_zone_id,\n});\n// Per-Hostname Authenticated Origin Pulls certificate\nconst myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", {\n    certificate: \"-----INSERT CERTIFICATE-----\",\n    privateKey: \"-----INSERT PRIVATE KEY-----\",\n    type: \"per-hostname\",\n    zoneId: _var.cloudflare_zone_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Per-Zone Authenticated Origin Pulls certificate\nmy_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-zone\",\n    zone_id=var[\"cloudflare_zone_id\"])\n# Per-Hostname Authenticated Origin Pulls certificate\nmy_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\",\n    certificate=\"-----INSERT CERTIFICATE-----\",\n    private_key=\"-----INSERT PRIVATE KEY-----\",\n    type=\"per-hostname\",\n    zone_id=var[\"cloudflare_zone_id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Per-Zone Authenticated Origin Pulls certificate\n    var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", new()\n    {\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-zone\",\n        ZoneId = @var.Cloudflare_zone_id,\n    });\n\n    // Per-Hostname Authenticated Origin Pulls certificate\n    var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", new()\n    {\n        Certificate = \"-----INSERT CERTIFICATE-----\",\n        PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n        Type = \"per-hostname\",\n        ZoneId = @var.Cloudflare_zone_id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerZoneAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-zone\"),\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, \"myPerHostnameAopCert\", \u0026cloudflare.AuthenticatedOriginPullsCertificateArgs{\n\t\t\tCertificate: pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\tPrivateKey:  pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\tType:        pulumi.String(\"per-hostname\"),\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificate;\nimport com.pulumi.cloudflare.AuthenticatedOriginPullsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myPerZoneAopCert = new AuthenticatedOriginPullsCertificate(\"myPerZoneAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()        \n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-zone\")\n            .zoneId(var_.cloudflare_zone_id())\n            .build());\n\n        var myPerHostnameAopCert = new AuthenticatedOriginPullsCertificate(\"myPerHostnameAopCert\", AuthenticatedOriginPullsCertificateArgs.builder()        \n            .certificate(\"-----INSERT CERTIFICATE-----\")\n            .privateKey(\"-----INSERT PRIVATE KEY-----\")\n            .type(\"per-hostname\")\n            .zoneId(var_.cloudflare_zone_id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Per-Zone Authenticated Origin Pulls certificate\n  myPerZoneAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    properties:\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-zone\n      zoneId: ${var.cloudflare_zone_id}\n  # Per-Hostname Authenticated Origin Pulls certificate\n  myPerHostnameAopCert:\n    type: cloudflare:AuthenticatedOriginPullsCertificate\n    properties:\n      certificate: '-----INSERT CERTIFICATE-----'\n      privateKey: '-----INSERT PRIVATE KEY-----'\n      type: per-hostname\n      zoneId: ${var.cloudflare_zone_id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuthenticated Origin Pull certificates can be imported using a composite ID formed of the zone ID, the form of Authenticated Origin Pulls, and the certificate ID, e.g. Import Per-Zone Authenticated Origin Pull certificate\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate 2458ce5a-0c35-4c7f-82c7-8e9487d3ff60 023e105f4ecef8ad9ca31a8372d0c353/per-zone/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60\n```\n\n Import Per-Hostname Authenticated Origin Pull certificate\n\n```sh\n $ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate 2458ce5a-0c35-4c7f-82c7-8e9487d3ff60 023e105f4ecef8ad9ca31a8372d0c353/per-hostname/2458ce5a-0c35-4c7f-82c7-8e9487d3ff60\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The public client certificate.\n"
                },
                "expiresOn": {
                    "type": "string"
                },
                "issuer": {
                    "type": "string"
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key of the client certificate.\n",
                    "secret": true
                },
                "serialNumber": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The form of Authenticated Origin Pulls to upload the certificate to.\n"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n"
                }
            },
            "required": [
                "certificate",
                "expiresOn",
                "issuer",
                "privateKey",
                "serialNumber",
                "signature",
                "status",
                "type",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "The public client certificate.\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "The private key of the client certificate.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The form of Authenticated Origin Pulls to upload the certificate to.\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to upload the certificate to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuthenticatedOriginPullsCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The public client certificate.\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresOn": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "issuer": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "The private key of the client certificate.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "serialNumber": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The form of Authenticated Origin Pulls to upload the certificate to.\n",
                        "willReplaceOnChanges": true
                    },
                    "uploadedOn": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to upload the certificate to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/byoIpPrefix:ByoIpPrefix": {
            "description": "Provides the ability to manage Bring-Your-Own-IP prefixes (BYOIP)\nwhich are used with or without Magic Transit.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ByoIpPrefix(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    advertisement: \"on\",\n    description: \"Example IP Prefix\",\n    prefixId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ByoIpPrefix(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    advertisement=\"on\",\n    description=\"Example IP Prefix\",\n    prefix_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ByoIpPrefix(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Advertisement = \"on\",\n        Description = \"Example IP Prefix\",\n        PrefixId = \"d41d8cd98f00b204e9800998ecf8427e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewByoIpPrefix(ctx, \"example\", \u0026cloudflare.ByoIpPrefixArgs{\n\t\t\tAccountId:     pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tAdvertisement: pulumi.String(\"on\"),\n\t\t\tDescription:   pulumi.String(\"Example IP Prefix\"),\n\t\t\tPrefixId:      pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ByoIpPrefix;\nimport com.pulumi.cloudflare.ByoIpPrefixArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ByoIpPrefix(\"example\", ByoIpPrefixArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .advertisement(\"on\")\n            .description(\"Example IP Prefix\")\n            .prefixId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ByoIpPrefix\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      advertisement: on\n      description: Example IP Prefix\n      prefixId: d41d8cd98f00b204e9800998ecf8427e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/byoIpPrefix:ByoIpPrefix example \u003caccount_id\u003e/\u003cprefix_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the BYO IP prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "advertisement",
                "description",
                "prefixId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "advertisement": {
                    "type": "string",
                    "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the BYO IP prefix.\n"
                },
                "prefixId": {
                    "type": "string",
                    "description": "The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "prefixId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ByoIpPrefix resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "advertisement": {
                        "type": "string",
                        "description": "Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the BYO IP prefix.\n"
                    },
                    "prefixId": {
                        "type": "string",
                        "description": "The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/certificatePack:CertificatePack": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Advanced certificate manager for Let's Encrypt\nconst example = new cloudflare.CertificatePack(\"example\", {\n    certificateAuthority: \"lets_encrypt\",\n    cloudflareBranding: false,\n    hosts: [\n        \"example.com\",\n        \"*.example.com\",\n    ],\n    type: \"advanced\",\n    validationMethod: \"http\",\n    validityDays: 90,\n    waitForActiveStatus: true,\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Advanced certificate manager for Let's Encrypt\nexample = cloudflare.CertificatePack(\"example\",\n    certificate_authority=\"lets_encrypt\",\n    cloudflare_branding=False,\n    hosts=[\n        \"example.com\",\n        \"*.example.com\",\n    ],\n    type=\"advanced\",\n    validation_method=\"http\",\n    validity_days=90,\n    wait_for_active_status=True,\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Advanced certificate manager for Let's Encrypt\n    var example = new Cloudflare.CertificatePack(\"example\", new()\n    {\n        CertificateAuthority = \"lets_encrypt\",\n        CloudflareBranding = false,\n        Hosts = new[]\n        {\n            \"example.com\",\n            \"*.example.com\",\n        },\n        Type = \"advanced\",\n        ValidationMethod = \"http\",\n        ValidityDays = 90,\n        WaitForActiveStatus = true,\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCertificatePack(ctx, \"example\", \u0026cloudflare.CertificatePackArgs{\n\t\t\tCertificateAuthority: pulumi.String(\"lets_encrypt\"),\n\t\t\tCloudflareBranding:   pulumi.Bool(false),\n\t\t\tHosts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\tpulumi.String(\"*.example.com\"),\n\t\t\t},\n\t\t\tType:                pulumi.String(\"advanced\"),\n\t\t\tValidationMethod:    pulumi.String(\"http\"),\n\t\t\tValidityDays:        pulumi.Int(90),\n\t\t\tWaitForActiveStatus: pulumi.Bool(true),\n\t\t\tZoneId:              pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CertificatePack;\nimport com.pulumi.cloudflare.CertificatePackArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CertificatePack(\"example\", CertificatePackArgs.builder()        \n            .certificateAuthority(\"lets_encrypt\")\n            .cloudflareBranding(false)\n            .hosts(            \n                \"example.com\",\n                \"*.example.com\")\n            .type(\"advanced\")\n            .validationMethod(\"http\")\n            .validityDays(90)\n            .waitForActiveStatus(true)\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Advanced certificate manager for Let's Encrypt\n  example:\n    type: cloudflare:CertificatePack\n    properties:\n      certificateAuthority: lets_encrypt\n      cloudflareBranding: false\n      hosts:\n        - example.com\n        - '*.example.com'\n      type: advanced\n      validationMethod: http\n      validityDays: 90\n      waitForActiveStatus: true\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/certificatePack:CertificatePack example 1d5fdc9e88c8a8c4518b068cd94331fe/8fda82e2-6af9-4eb2-992a-5ab65b792ef1\n```\n\n While supported, importing isn't recommended and it is advised to replace the certificate entirely instead. ",
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "cloudflareBranding": {
                    "type": "boolean",
                    "description": "Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "type": {
                    "type": "string",
                    "description": "Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "validationErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationError:CertificatePackValidationError"
                    }
                },
                "validationMethod": {
                    "type": "string",
                    "description": "Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "validationRecords": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord"
                    }
                },
                "validityDays": {
                    "type": "integer",
                    "description": "How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "waitForActiveStatus": {
                    "type": "boolean",
                    "description": "Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "certificateAuthority",
                "hosts",
                "type",
                "validationErrors",
                "validationMethod",
                "validationRecords",
                "validityDays",
                "zoneId"
            ],
            "inputProperties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "cloudflareBranding": {
                    "type": "boolean",
                    "description": "Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "validationErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationError:CertificatePackValidationError"
                    }
                },
                "validationMethod": {
                    "type": "string",
                    "description": "Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "validationRecords": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord"
                    }
                },
                "validityDays": {
                    "type": "integer",
                    "description": "How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "waitForActiveStatus": {
                    "type": "boolean",
                    "description": "Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "certificateAuthority",
                "hosts",
                "type",
                "validationMethod",
                "validityDays",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertificatePack resources.\n",
                "properties": {
                    "certificateAuthority": {
                        "type": "string",
                        "description": "Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudflareBranding": {
                        "type": "boolean",
                        "description": "Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "validationErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CertificatePackValidationError:CertificatePackValidationError"
                        }
                    },
                    "validationMethod": {
                        "type": "string",
                        "description": "Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "validationRecords": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CertificatePackValidationRecord:CertificatePackValidationRecord"
                        }
                    },
                    "validityDays": {
                        "type": "integer",
                        "description": "How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "waitForActiveStatus": {
                        "type": "boolean",
                        "description": "Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customHostname:CustomHostname": {
            "description": "Provides a Cloudflare custom hostname (also known as SSL for SaaS) resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.CustomHostname(\"example\", {\n    hostname: \"hostname.example.com\",\n    ssls: [{\n        method: \"txt\",\n    }],\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.CustomHostname(\"example\",\n    hostname=\"hostname.example.com\",\n    ssls=[cloudflare.CustomHostnameSslArgs(\n        method=\"txt\",\n    )],\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.CustomHostname(\"example\", new()\n    {\n        Hostname = \"hostname.example.com\",\n        Ssls = new[]\n        {\n            new Cloudflare.Inputs.CustomHostnameSslArgs\n            {\n                Method = \"txt\",\n            },\n        },\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomHostname(ctx, \"example\", \u0026cloudflare.CustomHostnameArgs{\n\t\t\tHostname: pulumi.String(\"hostname.example.com\"),\n\t\t\tSsls: cloudflare.CustomHostnameSslArray{\n\t\t\t\t\u0026cloudflare.CustomHostnameSslArgs{\n\t\t\t\t\tMethod: pulumi.String(\"txt\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomHostname;\nimport com.pulumi.cloudflare.CustomHostnameArgs;\nimport com.pulumi.cloudflare.inputs.CustomHostnameSslArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CustomHostname(\"example\", CustomHostnameArgs.builder()        \n            .hostname(\"hostname.example.com\")\n            .ssls(CustomHostnameSslArgs.builder()\n                .method(\"txt\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:CustomHostname\n    properties:\n      hostname: hostname.example.com\n      ssls:\n        - method: txt\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/customHostname:CustomHostname example 1d5fdc9e88c8a8c4518b068cd94331fe/0d89c70d-ad9f-4843-b99f-6cc0252067e9\n```\n\n ",
            "properties": {
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.\n"
                },
                "customOriginServer": {
                    "type": "string",
                    "description": "The custom origin server used for certificates.\n"
                },
                "customOriginSni": {
                    "type": "string",
                    "description": "The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "ownershipVerification": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ownershipVerificationHttp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ssls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                    },
                    "description": "SSL configuration of the certificate.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the certificate.\n"
                },
                "waitForSslPendingValidation": {
                    "type": "boolean",
                    "description": "Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "hostname",
                "ownershipVerification",
                "ownershipVerificationHttp",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "customMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.\n"
                },
                "customOriginServer": {
                    "type": "string",
                    "description": "The custom origin server used for certificates.\n"
                },
                "customOriginSni": {
                    "type": "string",
                    "description": "The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "ssls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                    },
                    "description": "SSL configuration of the certificate.\n"
                },
                "waitForSslPendingValidation": {
                    "type": "boolean",
                    "description": "Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostname",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomHostname resources.\n",
                "properties": {
                    "customMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.\n"
                    },
                    "customOriginServer": {
                        "type": "string",
                        "description": "The custom origin server used for certificates.\n"
                    },
                    "customOriginSni": {
                        "type": "string",
                        "description": "The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "ownershipVerification": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "ownershipVerificationHttp": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "ssls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CustomHostnameSsl:CustomHostnameSsl"
                        },
                        "description": "SSL configuration of the certificate.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the certificate.\n"
                    },
                    "waitForSslPendingValidation": {
                        "type": "boolean",
                        "description": "Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin": {
            "description": "Provides a Cloudflare custom hostname fallback origin resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst fallbackOrigin = new cloudflare.CustomHostnameFallbackOrigin(\"fallbackOrigin\", {\n    origin: \"fallback.example.com\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nfallback_origin = cloudflare.CustomHostnameFallbackOrigin(\"fallbackOrigin\",\n    origin=\"fallback.example.com\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fallbackOrigin = new Cloudflare.CustomHostnameFallbackOrigin(\"fallbackOrigin\", new()\n    {\n        Origin = \"fallback.example.com\",\n        ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomHostnameFallbackOrigin(ctx, \"fallbackOrigin\", \u0026cloudflare.CustomHostnameFallbackOriginArgs{\n\t\t\tOrigin: pulumi.String(\"fallback.example.com\"),\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomHostnameFallbackOrigin;\nimport com.pulumi.cloudflare.CustomHostnameFallbackOriginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fallbackOrigin = new CustomHostnameFallbackOrigin(\"fallbackOrigin\", CustomHostnameFallbackOriginArgs.builder()        \n            .origin(\"fallback.example.com\")\n            .zoneId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fallbackOrigin:\n    type: cloudflare:CustomHostnameFallbackOrigin\n    properties:\n      origin: fallback.example.com\n      zoneId: d41d8cd98f00b204e9800998ecf8427e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom hostname fallback origins can be imported using a composite ID formed of the zone ID and [fallback origin](https://api.cloudflare.com/#custom-hostname-fallback-origin-for-a-zone-properties), separated by a \"/\" e.g.\n\n```sh\n $ pulumi import cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin example d41d8cd98f00b204e9800998ecf8427e/fallback.example.com\n```\n\n ",
            "properties": {
                "origin": {
                    "type": "string",
                    "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the fallback origin's activation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID where the custom hostname should be assigned.\n"
                }
            },
            "required": [
                "origin",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "origin": {
                    "type": "string",
                    "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID where the custom hostname should be assigned.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "origin",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomHostnameFallbackOrigin resources.\n",
                "properties": {
                    "origin": {
                        "type": "string",
                        "description": "Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the fallback origin's activation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID where the custom hostname should be assigned.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customPages:CustomPages": {
            "description": "Provides a resource which manages Cloudflare custom error pages.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst basicChallenge = new cloudflare.CustomPages(\"basicChallenge\", {\n    state: \"customized\",\n    type: \"basic_challenge\",\n    url: \"https://example.com/challenge.html\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nbasic_challenge = cloudflare.CustomPages(\"basicChallenge\",\n    state=\"customized\",\n    type=\"basic_challenge\",\n    url=\"https://example.com/challenge.html\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var basicChallenge = new Cloudflare.CustomPages(\"basicChallenge\", new()\n    {\n        State = \"customized\",\n        Type = \"basic_challenge\",\n        Url = \"https://example.com/challenge.html\",\n        ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewCustomPages(ctx, \"basicChallenge\", \u0026cloudflare.CustomPagesArgs{\n\t\t\tState:  pulumi.String(\"customized\"),\n\t\t\tType:   pulumi.String(\"basic_challenge\"),\n\t\t\tUrl:    pulumi.String(\"https://example.com/challenge.html\"),\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomPages;\nimport com.pulumi.cloudflare.CustomPagesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var basicChallenge = new CustomPages(\"basicChallenge\", CustomPagesArgs.builder()        \n            .state(\"customized\")\n            .type(\"basic_challenge\")\n            .url(\"https://example.com/challenge.html\")\n            .zoneId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  basicChallenge:\n    type: cloudflare:CustomPages\n    properties:\n      state: customized\n      type: basic_challenge\n      url: https://example.com/challenge.html\n      zoneId: d41d8cd98f00b204e9800998ecf8427e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom pages can be imported using a composite ID formed of- `customPageLevel` - Either `account` or `zone`. - `identifier` - The ID of the account or zone you intend to manage. - `pageType` - The value from the `type` argument. Example for a zone\n\n```sh\n $ pulumi import cloudflare:index/customPages:CustomPages basic_challenge zone/d41d8cd98f00b204e9800998ecf8427e/basic_challenge\n```\n\n Example for an account\n\n```sh\n $ pulumi import cloudflare:index/customPages:CustomPages basic_challenge account/e268443e43d93dab7ebef303bbe9642f/basic_challenge\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`, `managed_challenge`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                }
            },
            "required": [
                "type",
                "url"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`, `managed_challenge`.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL of where the custom page source is located.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                }
            },
            "requiredInputs": [
                "type",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomPages resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID where the custom pages should be\nupdated. Either `account_id` or `zone_id` must be provided. If\n`account_id` is present, it will override the zone setting.\n"
                    },
                    "state": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of custom page you wish to update. Must\nbe one of `basic_challenge`, `waf_challenge`, `waf_block`,\n`ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`,\n`500_errors`, `1000_errors`, `always_online`, `managed_challenge`.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "URL of where the custom page source is located.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the custom pages should be\nupdated. Either `zone_id` or `account_id` must be provided.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/customSsl:CustomSsl": {
            "description": "Provides a Cloudflare custom ssl resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\nconst cloudflareZoneId = config.get(\"cloudflareZoneId\") || \"1d5fdc9e88c8a8c4518b068cd94331fe\";\n// Add a custom ssl certificate to the domain\nconst foossl = new cloudflare.CustomSsl(\"foossl\", {\n    customSslOptions: {\n        bundleMethod: \"ubiquitous\",\n        certificate: \"-----INSERT CERTIFICATE-----\",\n        geoRestrictions: \"us\",\n        privateKey: \"-----INSERT PRIVATE KEY-----\",\n        type: \"legacy_custom\",\n    },\n    zoneId: cloudflareZoneId,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nconfig = pulumi.Config()\ncloudflare_zone_id = config.get(\"cloudflareZoneId\")\nif cloudflare_zone_id is None:\n    cloudflare_zone_id = \"1d5fdc9e88c8a8c4518b068cd94331fe\"\n# Add a custom ssl certificate to the domain\nfoossl = cloudflare.CustomSsl(\"foossl\",\n    custom_ssl_options=cloudflare.CustomSslCustomSslOptionsArgs(\n        bundle_method=\"ubiquitous\",\n        certificate=\"-----INSERT CERTIFICATE-----\",\n        geo_restrictions=\"us\",\n        private_key=\"-----INSERT PRIVATE KEY-----\",\n        type=\"legacy_custom\",\n    ),\n    zone_id=cloudflare_zone_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var cloudflareZoneId = config.Get(\"cloudflareZoneId\") ?? \"1d5fdc9e88c8a8c4518b068cd94331fe\";\n    // Add a custom ssl certificate to the domain\n    var foossl = new Cloudflare.CustomSsl(\"foossl\", new()\n    {\n        CustomSslOptions = new Cloudflare.Inputs.CustomSslCustomSslOptionsArgs\n        {\n            BundleMethod = \"ubiquitous\",\n            Certificate = \"-----INSERT CERTIFICATE-----\",\n            GeoRestrictions = \"us\",\n            PrivateKey = \"-----INSERT PRIVATE KEY-----\",\n            Type = \"legacy_custom\",\n        },\n        ZoneId = cloudflareZoneId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tcloudflareZoneId := \"1d5fdc9e88c8a8c4518b068cd94331fe\"\n\t\tif param := cfg.Get(\"cloudflareZoneId\"); param != \"\" {\n\t\t\tcloudflareZoneId = param\n\t\t}\n\t\t_, err := cloudflare.NewCustomSsl(ctx, \"foossl\", \u0026cloudflare.CustomSslArgs{\n\t\t\tCustomSslOptions: \u0026cloudflare.CustomSslCustomSslOptionsArgs{\n\t\t\t\tBundleMethod:    pulumi.String(\"ubiquitous\"),\n\t\t\t\tCertificate:     pulumi.String(\"-----INSERT CERTIFICATE-----\"),\n\t\t\t\tGeoRestrictions: pulumi.String(\"us\"),\n\t\t\t\tPrivateKey:      pulumi.String(\"-----INSERT PRIVATE KEY-----\"),\n\t\t\t\tType:            pulumi.String(\"legacy_custom\"),\n\t\t\t},\n\t\t\tZoneId: pulumi.String(cloudflareZoneId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CustomSsl;\nimport com.pulumi.cloudflare.CustomSslArgs;\nimport com.pulumi.cloudflare.inputs.CustomSslCustomSslOptionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var cloudflareZoneId = config.get(\"cloudflareZoneId\").orElse(\"1d5fdc9e88c8a8c4518b068cd94331fe\");\n        var foossl = new CustomSsl(\"foossl\", CustomSslArgs.builder()        \n            .customSslOptions(CustomSslCustomSslOptionsArgs.builder()\n                .bundleMethod(\"ubiquitous\")\n                .certificate(\"-----INSERT CERTIFICATE-----\")\n                .geoRestrictions(\"us\")\n                .privateKey(\"-----INSERT PRIVATE KEY-----\")\n                .type(\"legacy_custom\")\n                .build())\n            .zoneId(cloudflareZoneId)\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  cloudflareZoneId:\n    type: string\n    default: 1d5fdc9e88c8a8c4518b068cd94331fe\nresources:\n  # Add a custom ssl certificate to the domain\n  foossl:\n    type: cloudflare:CustomSsl\n    properties:\n      customSslOptions:\n        bundleMethod: ubiquitous\n        certificate: '-----INSERT CERTIFICATE-----'\n        geoRestrictions: us\n        privateKey: '-----INSERT PRIVATE KEY-----'\n        type: legacy_custom\n      zoneId: ${cloudflareZoneId}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom SSL Certs can be imported using a composite ID formed of the zone ID and [certificate ID](https://api.cloudflare.com/#custom-ssl-for-a-zone-properties), separated by a \"/\" e.g.\n\n```sh\n $ pulumi import cloudflare:index/customSsl:CustomSsl default 1d5fdc9e88c8a8c4518b068cd94331fe/0123f0ab-9cde-45b2-80bd-4da3010f1337\n```\n\n ",
            "properties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n"
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "expiresOn": {
                    "type": "string"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "issuer": {
                    "type": "string"
                },
                "modifiedOn": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "signature": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "uploadedOn": {
                    "type": "string"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone id to the custom ssl cert should be added.\n"
                }
            },
            "required": [
                "expiresOn",
                "hosts",
                "issuer",
                "modifiedOn",
                "priority",
                "signature",
                "status",
                "uploadedOn",
                "zoneId"
            ],
            "inputProperties": {
                "customSslOptions": {
                    "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                    "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n",
                    "willReplaceOnChanges": true
                },
                "customSslPriorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                    }
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone id to the custom ssl cert should be added.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomSsl resources.\n",
                "properties": {
                    "customSslOptions": {
                        "$ref": "#/types/cloudflare:index/CustomSslCustomSslOptions:CustomSslCustomSslOptions",
                        "description": "The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.\n",
                        "willReplaceOnChanges": true
                    },
                    "customSslPriorities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/CustomSslCustomSslPriority:CustomSslCustomSslPriority"
                        }
                    },
                    "expiresOn": {
                        "type": "string"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "modifiedOn": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    },
                    "uploadedOn": {
                        "type": "string"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone id to the custom ssl cert should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates": {
            "description": "Provides a Cloudflare device policy certificates resource. Device policy certificate resources enable client device certificate generation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.DevicePolicyCertificates(\"example\", {\n    enabled: true,\n    zoneId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.DevicePolicyCertificates(\"example\",\n    enabled=True,\n    zone_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.DevicePolicyCertificates(\"example\", new()\n    {\n        Enabled = true,\n        ZoneId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePolicyCertificates(ctx, \"example\", \u0026cloudflare.DevicePolicyCertificatesArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tZoneId:  pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DevicePolicyCertificates;\nimport com.pulumi.cloudflare.DevicePolicyCertificatesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DevicePolicyCertificates(\"example\", DevicePolicyCertificatesArgs.builder()        \n            .enabled(true)\n            .zoneId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:DevicePolicyCertificates\n    properties:\n      enabled: true\n      zoneId: 1d5fdc9e88c8a8c4518b068cd94331fe\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDevice policy certificate settings can be imported using the zone ID.\n\n```sh\n $ pulumi import cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates example cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "True if certificate generation is enabled.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where certificate generation is allowed.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "True if certificate generation is enabled.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where certificate generation is allowed.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePolicyCertificates resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "True if certificate generation is enabled.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where certificate generation is allowed.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePostureIntegration:DevicePostureIntegration": {
            "description": "Provides a Cloudflare Device Posture Integration resource. Device posture integrations configure third-party data providers for device posture rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst thirdPartyDevicesPostureIntegration = new cloudflare.DevicePostureIntegration(\"thirdPartyDevicesPostureIntegration\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs: [{\n        apiUrl: \"https://example.com/api\",\n        authUrl: \"https://example.com/connect/token\",\n        clientId: \"client-id\",\n        clientSecret: \"client-secret\",\n    }],\n    interval: \"24h\",\n    name: \"Device posture integration\",\n    type: \"workspace_one\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nthird_party_devices_posture_integration = cloudflare.DevicePostureIntegration(\"thirdPartyDevicesPostureIntegration\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    configs=[cloudflare.DevicePostureIntegrationConfigArgs(\n        api_url=\"https://example.com/api\",\n        auth_url=\"https://example.com/connect/token\",\n        client_id=\"client-id\",\n        client_secret=\"client-secret\",\n    )],\n    interval=\"24h\",\n    name=\"Device posture integration\",\n    type=\"workspace_one\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thirdPartyDevicesPostureIntegration = new Cloudflare.DevicePostureIntegration(\"thirdPartyDevicesPostureIntegration\", new()\n    {\n        AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        Configs = new[]\n        {\n            new Cloudflare.Inputs.DevicePostureIntegrationConfigArgs\n            {\n                ApiUrl = \"https://example.com/api\",\n                AuthUrl = \"https://example.com/connect/token\",\n                ClientId = \"client-id\",\n                ClientSecret = \"client-secret\",\n            },\n        },\n        Interval = \"24h\",\n        Name = \"Device posture integration\",\n        Type = \"workspace_one\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePostureIntegration(ctx, \"thirdPartyDevicesPostureIntegration\", \u0026cloudflare.DevicePostureIntegrationArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tConfigs: cloudflare.DevicePostureIntegrationConfigArray{\n\t\t\t\t\u0026cloudflare.DevicePostureIntegrationConfigArgs{\n\t\t\t\t\tApiUrl:       pulumi.String(\"https://example.com/api\"),\n\t\t\t\t\tAuthUrl:      pulumi.String(\"https://example.com/connect/token\"),\n\t\t\t\t\tClientId:     pulumi.String(\"client-id\"),\n\t\t\t\t\tClientSecret: pulumi.String(\"client-secret\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tInterval: pulumi.String(\"24h\"),\n\t\t\tName:     pulumi.String(\"Device posture integration\"),\n\t\t\tType:     pulumi.String(\"workspace_one\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DevicePostureIntegration;\nimport com.pulumi.cloudflare.DevicePostureIntegrationArgs;\nimport com.pulumi.cloudflare.inputs.DevicePostureIntegrationConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var thirdPartyDevicesPostureIntegration = new DevicePostureIntegration(\"thirdPartyDevicesPostureIntegration\", DevicePostureIntegrationArgs.builder()        \n            .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .configs(DevicePostureIntegrationConfigArgs.builder()\n                .apiUrl(\"https://example.com/api\")\n                .authUrl(\"https://example.com/connect/token\")\n                .clientId(\"client-id\")\n                .clientSecret(\"client-secret\")\n                .build())\n            .interval(\"24h\")\n            .name(\"Device posture integration\")\n            .type(\"workspace_one\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  thirdPartyDevicesPostureIntegration:\n    type: cloudflare:DevicePostureIntegration\n    properties:\n      accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      configs:\n        - apiUrl: https://example.com/api\n          authUrl: https://example.com/connect/token\n          clientId: client-id\n          clientSecret: client-secret\n      interval: 24h\n      name: Device posture integration\n      type: workspace_one\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDevice posture integrations can be imported using a composite ID formed of account ID and device posture integration ID.\n\n```sh\n $ pulumi import cloudflare:index/devicePostureIntegration:DevicePostureIntegration corporate_devices cb029e245cfdd66dc8d2e570d5dd3322/0ade592a-62d6-46ab-bac8-01f47c7fa792\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the device posture integration should be added.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig"
                    },
                    "description": "The device posture integration's connection authorization parameters.\n"
                },
                "identifier": {
                    "type": "string"
                },
                "interval": {
                    "type": "string",
                    "description": "Indicates the frequency with which to poll the third-party API.\nMust be in the format `\"1h\"` or `\"30m\"`. Valid units are `h` and `m`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture integration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture integration type. Valid values are `workspace_one`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the device posture integration should be added.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig"
                    },
                    "description": "The device posture integration's connection authorization parameters.\n"
                },
                "identifier": {
                    "type": "string"
                },
                "interval": {
                    "type": "string",
                    "description": "Indicates the frequency with which to poll the third-party API.\nMust be in the format `\"1h\"` or `\"30m\"`. Valid units are `h` and `m`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture integration.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture integration type. Valid values are `workspace_one`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePostureIntegration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the device posture integration should be added.\n"
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureIntegrationConfig:DevicePostureIntegrationConfig"
                        },
                        "description": "The device posture integration's connection authorization parameters.\n"
                    },
                    "identifier": {
                        "type": "string"
                    },
                    "interval": {
                        "type": "string",
                        "description": "Indicates the frequency with which to poll the third-party API.\nMust be in the format `\"1h\"` or `\"30m\"`. Valid units are `h` and `m`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture integration.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture integration type. Valid values are `workspace_one`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/devicePostureRule:DevicePostureRule": {
            "description": "Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst eaxmple = new cloudflare.DevicePostureRule(\"eaxmple\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"Corporate devices posture rule\",\n    type: \"os_version\",\n    description: \"Device posture rule for corporate devices.\",\n    schedule: \"24h\",\n    expiration: \"24h\",\n    matches: [{\n        platform: \"linux\",\n    }],\n    inputs: [{\n        id: cloudflare_teams_list.corporate_devices.id,\n        version: \"1.0.0\",\n        operator: \"\u003c\",\n        osDistroName: \"ubuntu\",\n        osDistroRevision: \"1.0.0\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\neaxmple = cloudflare.DevicePostureRule(\"eaxmple\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"Corporate devices posture rule\",\n    type=\"os_version\",\n    description=\"Device posture rule for corporate devices.\",\n    schedule=\"24h\",\n    expiration=\"24h\",\n    matches=[cloudflare.DevicePostureRuleMatchArgs(\n        platform=\"linux\",\n    )],\n    inputs=[cloudflare.DevicePostureRuleInputArgs(\n        id=cloudflare_teams_list[\"corporate_devices\"][\"id\"],\n        version=\"1.0.0\",\n        operator=\"\u003c\",\n        os_distro_name=\"ubuntu\",\n        os_distro_revision=\"1.0.0\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var eaxmple = new Cloudflare.DevicePostureRule(\"eaxmple\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"Corporate devices posture rule\",\n        Type = \"os_version\",\n        Description = \"Device posture rule for corporate devices.\",\n        Schedule = \"24h\",\n        Expiration = \"24h\",\n        Matches = new[]\n        {\n            new Cloudflare.Inputs.DevicePostureRuleMatchArgs\n            {\n                Platform = \"linux\",\n            },\n        },\n        Inputs = new[]\n        {\n            new Cloudflare.Inputs.DevicePostureRuleInputArgs\n            {\n                Id = cloudflare_teams_list.Corporate_devices.Id,\n                Version = \"1.0.0\",\n                Operator = \"\u003c\",\n                OsDistroName = \"ubuntu\",\n                OsDistroRevision = \"1.0.0\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDevicePostureRule(ctx, \"eaxmple\", \u0026cloudflare.DevicePostureRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:        pulumi.String(\"Corporate devices posture rule\"),\n\t\t\tType:        pulumi.String(\"os_version\"),\n\t\t\tDescription: pulumi.String(\"Device posture rule for corporate devices.\"),\n\t\t\tSchedule:    pulumi.String(\"24h\"),\n\t\t\tExpiration:  pulumi.String(\"24h\"),\n\t\t\tMatches: cloudflare.DevicePostureRuleMatchArray{\n\t\t\t\t\u0026cloudflare.DevicePostureRuleMatchArgs{\n\t\t\t\t\tPlatform: pulumi.String(\"linux\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tInputs: cloudflare.DevicePostureRuleInputTypeArray{\n\t\t\t\t\u0026cloudflare.DevicePostureRuleInputTypeArgs{\n\t\t\t\t\tId:               pulumi.Any(cloudflare_teams_list.Corporate_devices.Id),\n\t\t\t\t\tVersion:          pulumi.String(\"1.0.0\"),\n\t\t\t\t\tOperator:         pulumi.String(\"\u003c\"),\n\t\t\t\t\tOsDistroName:     pulumi.String(\"ubuntu\"),\n\t\t\t\t\tOsDistroRevision: pulumi.String(\"1.0.0\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DevicePostureRule;\nimport com.pulumi.cloudflare.DevicePostureRuleArgs;\nimport com.pulumi.cloudflare.inputs.DevicePostureRuleMatchArgs;\nimport com.pulumi.cloudflare.inputs.DevicePostureRuleInputArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var eaxmple = new DevicePostureRule(\"eaxmple\", DevicePostureRuleArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"Corporate devices posture rule\")\n            .type(\"os_version\")\n            .description(\"Device posture rule for corporate devices.\")\n            .schedule(\"24h\")\n            .expiration(\"24h\")\n            .matches(DevicePostureRuleMatchArgs.builder()\n                .platform(\"linux\")\n                .build())\n            .inputs(DevicePostureRuleInputArgs.builder()\n                .id(cloudflare_teams_list.corporate_devices().id())\n                .version(\"1.0.0\")\n                .operator(\"\u003c\")\n                .osDistroName(\"ubuntu\")\n                .osDistroRevision(\"1.0.0\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  eaxmple:\n    type: cloudflare:DevicePostureRule\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: Corporate devices posture rule\n      type: os_version\n      description: Device posture rule for corporate devices.\n      schedule: 24h\n      expiration: 24h\n      matches:\n        - platform: linux\n      inputs:\n        - id: ${cloudflare_teams_list.corporate_devices.id}\n          version: 1.0.0\n          operator: \u003c\n          osDistroName: ubuntu\n          osDistroRevision: 1.0.0\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/devicePostureRule:DevicePostureRule example \u003caccount_id\u003e/\u003cdevice_posture_rule_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `workspace_one`, `unique_client_id`.\n"
                }
            },
            "required": [
                "accountId",
                "inputs",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                    },
                    "description": "The conditions that the client must match to run the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the device posture rule.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `workspace_one`, `unique_client_id`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DevicePostureRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string",
                        "description": "Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                    },
                    "inputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureRuleInput:DevicePostureRuleInput"
                        }
                    },
                    "matches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DevicePostureRuleMatch:DevicePostureRuleMatch"
                        },
                        "description": "The conditions that the client must match to run the rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the device posture rule.\n"
                    },
                    "schedule": {
                        "type": "string",
                        "description": "Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `workspace_one`, `unique_client_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy": {
            "description": "Provides a Cloudflare Device Settings Policy resource. Device policies configure settings applied to WARP devices.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst developerWarpPolicy = new cloudflare.DeviceSettingsPolicy(\"developerWarpPolicy\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    allowModeSwitch: true,\n    allowUpdates: true,\n    allowedToLeave: true,\n    autoConnect: 0,\n    captivePortal: 5,\n    \"default\": false,\n    disableAutoFallback: true,\n    enabled: true,\n    match: \"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n    name: \"Developers WARP settings policy\",\n    precedence: 10,\n    serviceModeV2Mode: \"warp\",\n    serviceModeV2Port: 3000,\n    supportUrl: \"https://cloudflare.com\",\n    switchLocked: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ndeveloper_warp_policy = cloudflare.DeviceSettingsPolicy(\"developerWarpPolicy\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    allow_mode_switch=True,\n    allow_updates=True,\n    allowed_to_leave=True,\n    auto_connect=0,\n    captive_portal=5,\n    default=False,\n    disable_auto_fallback=True,\n    enabled=True,\n    match=\"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n    name=\"Developers WARP settings policy\",\n    precedence=10,\n    service_mode_v2_mode=\"warp\",\n    service_mode_v2_port=3000,\n    support_url=\"https://cloudflare.com\",\n    switch_locked=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var developerWarpPolicy = new Cloudflare.DeviceSettingsPolicy(\"developerWarpPolicy\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        AllowModeSwitch = true,\n        AllowUpdates = true,\n        AllowedToLeave = true,\n        AutoConnect = 0,\n        CaptivePortal = 5,\n        Default = false,\n        DisableAutoFallback = true,\n        Enabled = true,\n        Match = \"any(identity.groups.name[*] in {\\\"Developers\\\"})\",\n        Name = \"Developers WARP settings policy\",\n        Precedence = 10,\n        ServiceModeV2Mode = \"warp\",\n        ServiceModeV2Port = 3000,\n        SupportUrl = \"https://cloudflare.com\",\n        SwitchLocked = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewDeviceSettingsPolicy(ctx, \"developerWarpPolicy\", \u0026cloudflare.DeviceSettingsPolicyArgs{\n\t\t\tAccountId:           pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tAllowModeSwitch:     pulumi.Bool(true),\n\t\t\tAllowUpdates:        pulumi.Bool(true),\n\t\t\tAllowedToLeave:      pulumi.Bool(true),\n\t\t\tAutoConnect:         pulumi.Int(0),\n\t\t\tCaptivePortal:       pulumi.Int(5),\n\t\t\tDefault:             pulumi.Bool(false),\n\t\t\tDisableAutoFallback: pulumi.Bool(true),\n\t\t\tEnabled:             pulumi.Bool(true),\n\t\t\tMatch:               pulumi.String(\"any(identity.groups.name[*] in {\\\"Developers\\\"})\"),\n\t\t\tName:                pulumi.String(\"Developers WARP settings policy\"),\n\t\t\tPrecedence:          pulumi.Int(10),\n\t\t\tServiceModeV2Mode:   pulumi.String(\"warp\"),\n\t\t\tServiceModeV2Port:   pulumi.Int(3000),\n\t\t\tSupportUrl:          pulumi.String(\"https://cloudflare.com\"),\n\t\t\tSwitchLocked:        pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.DeviceSettingsPolicy;\nimport com.pulumi.cloudflare.DeviceSettingsPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var developerWarpPolicy = new DeviceSettingsPolicy(\"developerWarpPolicy\", DeviceSettingsPolicyArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .allowModeSwitch(true)\n            .allowUpdates(true)\n            .allowedToLeave(true)\n            .autoConnect(0)\n            .captivePortal(5)\n            .default_(false)\n            .disableAutoFallback(true)\n            .enabled(true)\n            .match(\"any(identity.groups.name[*] in {\\\"Developers\\\"})\")\n            .name(\"Developers WARP settings policy\")\n            .precedence(10)\n            .serviceModeV2Mode(\"warp\")\n            .serviceModeV2Port(3000)\n            .supportUrl(\"https://cloudflare.com\")\n            .switchLocked(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  developerWarpPolicy:\n    type: cloudflare:DeviceSettingsPolicy\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      allowModeSwitch: true\n      allowUpdates: true\n      allowedToLeave: true\n      autoConnect: 0\n      captivePortal: 5\n      default: false\n      disableAutoFallback: true\n      enabled: true\n      match: any(identity.groups.name[*] in {\"Developers\"})\n      name: Developers WARP settings policy\n      precedence: 10\n      serviceModeV2Mode: warp\n      serviceModeV2Port: 3000\n      supportUrl: https://cloudflare.com\n      switchLocked: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nFor default device settings policies you must use \"default\" as the policy ID.\n\n```sh\n $ pulumi import cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy example \u003caccount_id\u003e/\u003cdevice_policy_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowModeSwitch": {
                    "type": "boolean",
                    "description": "Whether to allow mode switch for this policy.\n"
                },
                "allowUpdates": {
                    "type": "boolean",
                    "description": "Whether to allow updates under this policy.\n"
                },
                "allowedToLeave": {
                    "type": "boolean",
                    "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                },
                "autoConnect": {
                    "type": "integer",
                    "description": "The amount of time in minutes to reconnect after having been disabled.\n"
                },
                "captivePortal": {
                    "type": "integer",
                    "description": "The captive portal value for this policy. Defaults to `180`.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Whether the policy refers to the default account policy.\n"
                },
                "disableAutoFallback": {
                    "type": "boolean",
                    "description": "Whether to disable auto fallback for this policy.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                },
                "match": {
                    "type": "string",
                    "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                },
                "serviceModeV2Mode": {
                    "type": "string",
                    "description": "The service mode. Defaults to `warp`.\n"
                },
                "serviceModeV2Port": {
                    "type": "integer",
                    "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "The support URL that will be opened when sending feedback.\n"
                },
                "switchLocked": {
                    "type": "boolean",
                    "description": "Enablement of the ZT client switch lock.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowModeSwitch": {
                    "type": "boolean",
                    "description": "Whether to allow mode switch for this policy.\n"
                },
                "allowUpdates": {
                    "type": "boolean",
                    "description": "Whether to allow updates under this policy.\n"
                },
                "allowedToLeave": {
                    "type": "boolean",
                    "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                },
                "autoConnect": {
                    "type": "integer",
                    "description": "The amount of time in minutes to reconnect after having been disabled.\n"
                },
                "captivePortal": {
                    "type": "integer",
                    "description": "The captive portal value for this policy. Defaults to `180`.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Whether the policy refers to the default account policy.\n"
                },
                "disableAutoFallback": {
                    "type": "boolean",
                    "description": "Whether to disable auto fallback for this policy.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                },
                "match": {
                    "type": "string",
                    "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the policy.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                },
                "serviceModeV2Mode": {
                    "type": "string",
                    "description": "The service mode. Defaults to `warp`.\n"
                },
                "serviceModeV2Port": {
                    "type": "integer",
                    "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                },
                "supportUrl": {
                    "type": "string",
                    "description": "The support URL that will be opened when sending feedback.\n"
                },
                "switchLocked": {
                    "type": "boolean",
                    "description": "Enablement of the ZT client switch lock.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeviceSettingsPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "allowModeSwitch": {
                        "type": "boolean",
                        "description": "Whether to allow mode switch for this policy.\n"
                    },
                    "allowUpdates": {
                        "type": "boolean",
                        "description": "Whether to allow updates under this policy.\n"
                    },
                    "allowedToLeave": {
                        "type": "boolean",
                        "description": "Whether to allow devices to leave the organization. Defaults to `true`.\n"
                    },
                    "autoConnect": {
                        "type": "integer",
                        "description": "The amount of time in minutes to reconnect after having been disabled.\n"
                    },
                    "captivePortal": {
                        "type": "integer",
                        "description": "The captive portal value for this policy. Defaults to `180`.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Whether the policy refers to the default account policy.\n"
                    },
                    "disableAutoFallback": {
                        "type": "boolean",
                        "description": "Whether to disable auto fallback for this policy.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.\n"
                    },
                    "match": {
                        "type": "string",
                        "description": "Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the policy.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The precedence of the policy. Lower values indicate higher precedence.\n"
                    },
                    "serviceModeV2Mode": {
                        "type": "string",
                        "description": "The service mode. Defaults to `warp`.\n"
                    },
                    "serviceModeV2Port": {
                        "type": "integer",
                        "description": "The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.\n"
                    },
                    "supportUrl": {
                        "type": "string",
                        "description": "The support URL that will be opened when sending feedback.\n"
                    },
                    "switchLocked": {
                        "type": "boolean",
                        "description": "Enablement of the ZT client switch lock.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/dlpProfile:DlpProfile": {
            "description": "Provides a Cloudflare DLP Profile resource. Data Loss Prevention profiles\nare a set of entries that can be matched in HTTP bodies or files.\nThey are referenced in Zero Trust Gateway rules.\n\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/dlpProfile:DlpProfile example \u003caccount_id\u003e/\u003cdlp_profile_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the profile and its intended use.\n"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DlpProfileEntry:DlpProfileEntry"
                    },
                    "description": "List of entries to apply to the profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "entries",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the profile and its intended use.\n"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/DlpProfileEntry:DlpProfileEntry"
                    },
                    "description": "List of entries to apply to the profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "entries",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DlpProfile resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "Brief summary of the profile and its intended use.\n"
                    },
                    "entries": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/DlpProfileEntry:DlpProfileEntry"
                        },
                        "description": "List of entries to apply to the profile.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the profile. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingAddress:EmailRoutingAddress": {
            "description": "Provides a resource for managing Email Routing Addresses.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.EmailRoutingAddress(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    email: \"user@example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.EmailRoutingAddress(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    email=\"user@example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.EmailRoutingAddress(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Email = \"user@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingAddress(ctx, \"example\", \u0026cloudflare.EmailRoutingAddressArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tEmail:     pulumi.String(\"user@example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingAddress;\nimport com.pulumi.cloudflare.EmailRoutingAddressArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new EmailRoutingAddress(\"example\", EmailRoutingAddressArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .email(\"user@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:EmailRoutingAddress\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      email: user@example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "created": {
                    "type": "string",
                    "description": "The date and time the destination address has been created.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The contact email address of the user. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "modified": {
                    "type": "string",
                    "description": "The date and time the destination address was last modified.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Destination address identifier.\n"
                },
                "verified": {
                    "type": "string",
                    "description": "The date and time the destination address has been verified. Null means not verified yet.\n"
                }
            },
            "required": [
                "accountId",
                "created",
                "email",
                "modified",
                "tag",
                "verified"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "email": {
                    "type": "string",
                    "description": "The contact email address of the user. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "email"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingAddress resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "created": {
                        "type": "string",
                        "description": "The date and time the destination address has been created.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The contact email address of the user. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "modified": {
                        "type": "string",
                        "description": "The date and time the destination address was last modified.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Destination address identifier.\n"
                    },
                    "verified": {
                        "type": "string",
                        "description": "The date and time the destination address has been verified. Null means not verified yet.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingCatchAll:EmailRoutingCatchAll": {
            "description": "Provides a resource for managing Email Routing Addresses catch all behaviour.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.EmailRoutingCatchAll(\"example\", {\n    actions: [{\n        type: \"forward\",\n        values: [\"destinationaddress@example.net\"],\n    }],\n    enabled: true,\n    matchers: [{\n        type: \"all\",\n    }],\n    name: \"example catch all\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.EmailRoutingCatchAll(\"example\",\n    actions=[cloudflare.EmailRoutingCatchAllActionArgs(\n        type=\"forward\",\n        values=[\"destinationaddress@example.net\"],\n    )],\n    enabled=True,\n    matchers=[cloudflare.EmailRoutingCatchAllMatcherArgs(\n        type=\"all\",\n    )],\n    name=\"example catch all\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.EmailRoutingCatchAll(\"example\", new()\n    {\n        Actions = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingCatchAllActionArgs\n            {\n                Type = \"forward\",\n                Values = new[]\n                {\n                    \"destinationaddress@example.net\",\n                },\n            },\n        },\n        Enabled = true,\n        Matchers = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingCatchAllMatcherArgs\n            {\n                Type = \"all\",\n            },\n        },\n        Name = \"example catch all\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingCatchAll(ctx, \"example\", \u0026cloudflare.EmailRoutingCatchAllArgs{\n\t\t\tActions: cloudflare.EmailRoutingCatchAllActionArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingCatchAllActionArgs{\n\t\t\t\t\tType: pulumi.String(\"forward\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"destinationaddress@example.net\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tMatchers: cloudflare.EmailRoutingCatchAllMatcherArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingCatchAllMatcherArgs{\n\t\t\t\t\tType: pulumi.String(\"all\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName:   pulumi.String(\"example catch all\"),\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingCatchAll;\nimport com.pulumi.cloudflare.EmailRoutingCatchAllArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingCatchAllActionArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingCatchAllMatcherArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new EmailRoutingCatchAll(\"example\", EmailRoutingCatchAllArgs.builder()        \n            .actions(EmailRoutingCatchAllActionArgs.builder()\n                .type(\"forward\")\n                .values(\"destinationaddress@example.net\")\n                .build())\n            .enabled(true)\n            .matchers(EmailRoutingCatchAllMatcherArgs.builder()\n                .type(\"all\")\n                .build())\n            .name(\"example catch all\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:EmailRoutingCatchAll\n    properties:\n      actions:\n        - type: forward\n          values:\n            - destinationaddress@example.net\n      enabled: true\n      matchers:\n        - type: all\n      name: example catch all\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction"
                    },
                    "description": "List actions patterns.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Routing rule status.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Routing rule identifier.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "actions",
                "matchers",
                "name",
                "tag",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction"
                    },
                    "description": "List actions patterns.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Routing rule status.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "actions",
                "matchers",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingCatchAll resources.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllAction:EmailRoutingCatchAllAction"
                        },
                        "description": "List actions patterns.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Routing rule status.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingCatchAllMatcher:EmailRoutingCatchAllMatcher"
                        },
                        "description": "Matching patterns to forward to your actions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Routing rule name.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Routing rule identifier.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingRule:EmailRoutingRule": {
            "description": "Provides a resource for managing Email Routing rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst main = new cloudflare.EmailRoutingRule(\"main\", {\n    actions: [{\n        type: \"forward\",\n        values: [\"destinationaddress@example.net\"],\n    }],\n    enabled: true,\n    matchers: [{\n        field: \"to\",\n        type: \"literal\",\n        value: \"test@example.com\",\n    }],\n    name: \"terraform rule\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmain = cloudflare.EmailRoutingRule(\"main\",\n    actions=[cloudflare.EmailRoutingRuleActionArgs(\n        type=\"forward\",\n        values=[\"destinationaddress@example.net\"],\n    )],\n    enabled=True,\n    matchers=[cloudflare.EmailRoutingRuleMatcherArgs(\n        field=\"to\",\n        type=\"literal\",\n        value=\"test@example.com\",\n    )],\n    name=\"terraform rule\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new Cloudflare.EmailRoutingRule(\"main\", new()\n    {\n        Actions = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingRuleActionArgs\n            {\n                Type = \"forward\",\n                Values = new[]\n                {\n                    \"destinationaddress@example.net\",\n                },\n            },\n        },\n        Enabled = true,\n        Matchers = new[]\n        {\n            new Cloudflare.Inputs.EmailRoutingRuleMatcherArgs\n            {\n                Field = \"to\",\n                Type = \"literal\",\n                Value = \"test@example.com\",\n            },\n        },\n        Name = \"terraform rule\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingRule(ctx, \"main\", \u0026cloudflare.EmailRoutingRuleArgs{\n\t\t\tActions: cloudflare.EmailRoutingRuleActionArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingRuleActionArgs{\n\t\t\t\t\tType: pulumi.String(\"forward\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"destinationaddress@example.net\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tMatchers: cloudflare.EmailRoutingRuleMatcherArray{\n\t\t\t\t\u0026cloudflare.EmailRoutingRuleMatcherArgs{\n\t\t\t\t\tField: pulumi.String(\"to\"),\n\t\t\t\t\tType:  pulumi.String(\"literal\"),\n\t\t\t\t\tValue: pulumi.String(\"test@example.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tName:   pulumi.String(\"terraform rule\"),\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingRule;\nimport com.pulumi.cloudflare.EmailRoutingRuleArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingRuleActionArgs;\nimport com.pulumi.cloudflare.inputs.EmailRoutingRuleMatcherArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new EmailRoutingRule(\"main\", EmailRoutingRuleArgs.builder()        \n            .actions(EmailRoutingRuleActionArgs.builder()\n                .type(\"forward\")\n                .values(\"destinationaddress@example.net\")\n                .build())\n            .enabled(true)\n            .matchers(EmailRoutingRuleMatcherArgs.builder()\n                .field(\"to\")\n                .type(\"literal\")\n                .value(\"test@example.com\")\n                .build())\n            .name(\"terraform rule\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: cloudflare:EmailRoutingRule\n    properties:\n      actions:\n        - type: forward\n          values:\n            - destinationaddress@example.net\n      enabled: true\n      matchers:\n        - field: to\n          type: literal\n          value: test@example.com\n      name: terraform rule\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction"
                    },
                    "description": "List actions patterns.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Routing rule status.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of the routing rule.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Routing rule identifier.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "actions",
                "matchers",
                "name",
                "priority",
                "tag",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction"
                    },
                    "description": "List actions patterns.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Routing rule status.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher"
                    },
                    "description": "Matching patterns to forward to your actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Routing rule name.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of the routing rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "actions",
                "matchers",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingRule resources.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingRuleAction:EmailRoutingRuleAction"
                        },
                        "description": "List actions patterns.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Routing rule status.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/EmailRoutingRuleMatcher:EmailRoutingRuleMatcher"
                        },
                        "description": "Matching patterns to forward to your actions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Routing rule name.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of the routing rule.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Routing rule identifier.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/emailRoutingSettings:EmailRoutingSettings": {
            "description": "Provides a resource for managing Email Routing settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myZone = new cloudflare.EmailRoutingSettings(\"myZone\", {\n    enabled: true,\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_zone = cloudflare.EmailRoutingSettings(\"myZone\",\n    enabled=True,\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myZone = new Cloudflare.EmailRoutingSettings(\"myZone\", new()\n    {\n        Enabled = true,\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewEmailRoutingSettings(ctx, \"myZone\", \u0026cloudflare.EmailRoutingSettingsArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tZoneId:  pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.EmailRoutingSettings;\nimport com.pulumi.cloudflare.EmailRoutingSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myZone = new EmailRoutingSettings(\"myZone\", EmailRoutingSettingsArgs.builder()        \n            .enabled(\"true\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myZone:\n    type: cloudflare:EmailRoutingSettings\n    properties:\n      enabled: 'true'\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "created": {
                    "type": "string",
                    "description": "The date and time the settings have been created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "modified": {
                    "type": "string",
                    "description": "The date and time the settings have been modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Domain of your zone.\n"
                },
                "skipWizard": {
                    "type": "boolean",
                    "description": "Flag to check if the user skipped the configuration wizard.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Show the state of your account, and the type or configuration error.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Email Routing settings identifier.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "created",
                "enabled",
                "modified",
                "name",
                "skipWizard",
                "status",
                "tag",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "skipWizard": {
                    "type": "boolean",
                    "description": "Flag to check if the user skipped the configuration wizard.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailRoutingSettings resources.\n",
                "properties": {
                    "created": {
                        "type": "string",
                        "description": "The date and time the settings have been created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "modified": {
                        "type": "string",
                        "description": "The date and time the settings have been modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Domain of your zone.\n"
                    },
                    "skipWizard": {
                        "type": "boolean",
                        "description": "Flag to check if the user skipped the configuration wizard.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Show the state of your account, and the type or configuration error.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Email Routing settings identifier.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/fallbackDomain:FallbackDomain": {
            "description": "Provides a Cloudflare Fallback Domain resource. Fallback domains are\nused to ignore DNS requests to a given list of domains. These DNS\nrequests will be passed back to other DNS servers configured on\nexisting network interfaces on the device.\n\n\n## Import\n\nFallback Domains for default device policies must use \"default\" as the policy ID.\n\n```sh\n $ pulumi import cloudflare:index/fallbackDomain:FallbackDomain example \u003caccount_id\u003e/\u003cpolicy_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/FallbackDomainDomain:FallbackDomainDomain"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this fallback domain policy.\n"
                }
            },
            "required": [
                "accountId",
                "domains"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/FallbackDomainDomain:FallbackDomainDomain"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this fallback domain policy.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "domains"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FallbackDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "domains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/FallbackDomainDomain:FallbackDomainDomain"
                        }
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The settings policy for which to configure this fallback domain policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/filter:Filter": {
            "description": "Filter expressions that can be referenced across multiple features,\ne.g. Firewall Rules. See [what is a filter](https://developers.cloudflare.com/firewall/api/cf-filters/what-is-a-filter/)\nfor more details and available fields and operators.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpress = new cloudflare.Filter(\"wordpress\", {\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress = cloudflare.Filter(\"wordpress\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var wordpress = new Cloudflare.Filter(\"wordpress\", new()\n    {\n        Description = \"Wordpress break-in attempts that are outside of the office\",\n        Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewFilter(ctx, \"wordpress\", \u0026cloudflare.FilterArgs{\n\t\t\tDescription: pulumi.String(\"Wordpress break-in attempts that are outside of the office\"),\n\t\t\tExpression:  pulumi.String(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\"),\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Filter;\nimport com.pulumi.cloudflare.FilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var wordpress = new Filter(\"wordpress\", FilterArgs.builder()        \n            .description(\"Wordpress break-in attempts that are outside of the office\")\n            .expression(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  wordpress:\n    type: cloudflare:Filter\n    properties:\n      description: Wordpress break-in attempts that are outside of the office\n      expression: (http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/filter:Filter example \u003czone_id\u003e/\u003cfilter_id\u003e\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "expression",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the purpose of the filter.\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The filter expression to be used.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter is currently paused.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Short reference tag to quickly select related rules.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "expression",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Filter resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the purpose of the filter.\n"
                    },
                    "expression": {
                        "type": "string",
                        "description": "The filter expression to be used.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter is currently paused.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "Short reference tag to quickly select related rules.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/firewallRule:FirewallRule": {
            "description": "Define Firewall rules using filter expressions for more control over\nhow traffic is matched to the rule. A filter expression permits\nselecting traffic by multiple criteria allowing greater freedom in\nrule creation.\n\nFilter expressions needs to be created first before using Firewall\nRule.\n\n\u003e If you want to configure Custom Firewall rules, you need to use\n`cloudflare.Ruleset`, because Custom Rules are built upon the\n[Cloudflare Ruleset Engine](https://developers.cloudflare.com/ruleset-engine/).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst wordpressFilter = new cloudflare.Filter(\"wordpressFilter\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    description: \"Wordpress break-in attempts that are outside of the office\",\n    expression: \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n});\nconst wordpressFirewallRule = new cloudflare.FirewallRule(\"wordpressFirewallRule\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    description: \"Block wordpress break-in attempts\",\n    filterId: wordpressFilter.id,\n    action: \"block\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nwordpress_filter = cloudflare.Filter(\"wordpressFilter\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    description=\"Wordpress break-in attempts that are outside of the office\",\n    expression=\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\nwordpress_firewall_rule = cloudflare.FirewallRule(\"wordpressFirewallRule\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    description=\"Block wordpress break-in attempts\",\n    filter_id=wordpress_filter.id,\n    action=\"block\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var wordpressFilter = new Cloudflare.Filter(\"wordpressFilter\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Description = \"Wordpress break-in attempts that are outside of the office\",\n        Expression = \"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\",\n    });\n\n    var wordpressFirewallRule = new Cloudflare.FirewallRule(\"wordpressFirewallRule\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Description = \"Block wordpress break-in attempts\",\n        FilterId = wordpressFilter.Id,\n        Action = \"block\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\twordpressFilter, err := cloudflare.NewFilter(ctx, \"wordpressFilter\", \u0026cloudflare.FilterArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tDescription: pulumi.String(\"Wordpress break-in attempts that are outside of the office\"),\n\t\t\tExpression:  pulumi.String(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewFirewallRule(ctx, \"wordpressFirewallRule\", \u0026cloudflare.FirewallRuleArgs{\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tDescription: pulumi.String(\"Block wordpress break-in attempts\"),\n\t\t\tFilterId:    wordpressFilter.ID(),\n\t\t\tAction:      pulumi.String(\"block\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Filter;\nimport com.pulumi.cloudflare.FilterArgs;\nimport com.pulumi.cloudflare.FirewallRule;\nimport com.pulumi.cloudflare.FirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var wordpressFilter = new Filter(\"wordpressFilter\", FilterArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .description(\"Wordpress break-in attempts that are outside of the office\")\n            .expression(\"(http.request.uri.path ~ \\\".*wp-login.php\\\" or http.request.uri.path ~ \\\".*xmlrpc.php\\\") and ip.src ne 192.0.2.1\")\n            .build());\n\n        var wordpressFirewallRule = new FirewallRule(\"wordpressFirewallRule\", FirewallRuleArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .description(\"Block wordpress break-in attempts\")\n            .filterId(wordpressFilter.id())\n            .action(\"block\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  wordpressFilter:\n    type: cloudflare:Filter\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      description: Wordpress break-in attempts that are outside of the office\n      expression: (http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1\n  wordpressFirewallRule:\n    type: cloudflare:FirewallRule\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      description: Block wordpress break-in attempts\n      filterId: ${wordpressFilter.id}\n      action: block\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/firewallRule:FirewallRule example \u003czone_id\u003e/\u003cfirewall_rule_id\u003e\n```\n\n ",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string",
                    "description": "The identifier of the Filter to use for determining if the Firewall Rule should be triggered.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "action",
                "filterId",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the rule to help identify it.\n"
                },
                "filterId": {
                    "type": "string",
                    "description": "The identifier of the Filter to use for determining if the Firewall Rule should be triggered.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this filter based firewall rule is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                },
                "products": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "filterId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallRule resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the rule to help identify it.\n"
                    },
                    "filterId": {
                        "type": "string",
                        "description": "The identifier of the Filter to use for determining if the Firewall Rule should be triggered.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this filter based firewall rule is currently paused.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.\n"
                    },
                    "products": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/greTunnel:GreTunnel": {
            "description": "Provides a resource, that manages GRE tunnels for Magic Transit.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.GreTunnel(\"example\", {\n    accountId: \"c4a7362d577a6c3019a474fd6f485821\",\n    cloudflareGreEndpoint: \"203.0.113.1\",\n    customerGreEndpoint: \"203.0.113.1\",\n    description: \"Tunnel for ISP X\",\n    healthCheckEnabled: true,\n    healthCheckTarget: \"203.0.113.1\",\n    healthCheckType: \"reply\",\n    interfaceAddress: \"192.0.2.0/31\",\n    mtu: 1476,\n    name: \"GRE_1\",\n    ttl: 64,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.GreTunnel(\"example\",\n    account_id=\"c4a7362d577a6c3019a474fd6f485821\",\n    cloudflare_gre_endpoint=\"203.0.113.1\",\n    customer_gre_endpoint=\"203.0.113.1\",\n    description=\"Tunnel for ISP X\",\n    health_check_enabled=True,\n    health_check_target=\"203.0.113.1\",\n    health_check_type=\"reply\",\n    interface_address=\"192.0.2.0/31\",\n    mtu=1476,\n    name=\"GRE_1\",\n    ttl=64)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.GreTunnel(\"example\", new()\n    {\n        AccountId = \"c4a7362d577a6c3019a474fd6f485821\",\n        CloudflareGreEndpoint = \"203.0.113.1\",\n        CustomerGreEndpoint = \"203.0.113.1\",\n        Description = \"Tunnel for ISP X\",\n        HealthCheckEnabled = true,\n        HealthCheckTarget = \"203.0.113.1\",\n        HealthCheckType = \"reply\",\n        InterfaceAddress = \"192.0.2.0/31\",\n        Mtu = 1476,\n        Name = \"GRE_1\",\n        Ttl = 64,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewGreTunnel(ctx, \"example\", \u0026cloudflare.GreTunnelArgs{\n\t\t\tAccountId:             pulumi.String(\"c4a7362d577a6c3019a474fd6f485821\"),\n\t\t\tCloudflareGreEndpoint: pulumi.String(\"203.0.113.1\"),\n\t\t\tCustomerGreEndpoint:   pulumi.String(\"203.0.113.1\"),\n\t\t\tDescription:           pulumi.String(\"Tunnel for ISP X\"),\n\t\t\tHealthCheckEnabled:    pulumi.Bool(true),\n\t\t\tHealthCheckTarget:     pulumi.String(\"203.0.113.1\"),\n\t\t\tHealthCheckType:       pulumi.String(\"reply\"),\n\t\t\tInterfaceAddress:      pulumi.String(\"192.0.2.0/31\"),\n\t\t\tMtu:                   pulumi.Int(1476),\n\t\t\tName:                  pulumi.String(\"GRE_1\"),\n\t\t\tTtl:                   pulumi.Int(64),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.GreTunnel;\nimport com.pulumi.cloudflare.GreTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new GreTunnel(\"example\", GreTunnelArgs.builder()        \n            .accountId(\"c4a7362d577a6c3019a474fd6f485821\")\n            .cloudflareGreEndpoint(\"203.0.113.1\")\n            .customerGreEndpoint(\"203.0.113.1\")\n            .description(\"Tunnel for ISP X\")\n            .healthCheckEnabled(true)\n            .healthCheckTarget(\"203.0.113.1\")\n            .healthCheckType(\"reply\")\n            .interfaceAddress(\"192.0.2.0/31\")\n            .mtu(1476)\n            .name(\"GRE_1\")\n            .ttl(64)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:GreTunnel\n    properties:\n      accountId: c4a7362d577a6c3019a474fd6f485821\n      cloudflareGreEndpoint: 203.0.113.1\n      customerGreEndpoint: 203.0.113.1\n      description: Tunnel for ISP X\n      healthCheckEnabled: true\n      healthCheckTarget: 203.0.113.1\n      healthCheckType: reply\n      interfaceAddress: 192.0.2.0/31\n      mtu: 1476\n      name: GRE_1\n      ttl: 64\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing GRE tunnel can be imported using the account ID and tunnel ID\n\n```sh\n $ pulumi import cloudflare:index/greTunnel:GreTunnel example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the tunnel is being created.\n"
                },
                "cloudflareGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                },
                "customerGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the GRE tunnel.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled Default: `true`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`) Default: `reply`.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. Maximum value 1476 and minimum value 576. Default: `1476`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the GRE tunnel.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time To Live (TTL) in number of hops of the GRE tunnel. Minimum value 64. Default: `64`.\n"
                }
            },
            "required": [
                "cloudflareGreEndpoint",
                "customerGreEndpoint",
                "healthCheckEnabled",
                "healthCheckTarget",
                "healthCheckType",
                "interfaceAddress",
                "mtu",
                "name",
                "ttl"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the tunnel is being created.\n",
                    "willReplaceOnChanges": true
                },
                "cloudflareGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                },
                "customerGreEndpoint": {
                    "type": "string",
                    "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the GRE tunnel.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled Default: `true`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`) Default: `reply`.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. Maximum value 1476 and minimum value 576. Default: `1476`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the GRE tunnel.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time To Live (TTL) in number of hops of the GRE tunnel. Minimum value 64. Default: `64`.\n"
                }
            },
            "requiredInputs": [
                "cloudflareGreEndpoint",
                "customerGreEndpoint",
                "interfaceAddress",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GreTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the tunnel is being created.\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudflareGreEndpoint": {
                        "type": "string",
                        "description": "The IP address assigned to the Cloudflare side of the GRE tunnel.\n"
                    },
                    "customerGreEndpoint": {
                        "type": "string",
                        "description": "The IP address assigned to the customer side of the GRE tunnel.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the GRE tunnel.\n"
                    },
                    "healthCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies if ICMP tunnel health checks are enabled Default: `true`.\n"
                    },
                    "healthCheckTarget": {
                        "type": "string",
                        "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                    },
                    "healthCheckType": {
                        "type": "string",
                        "description": "Specifies the ICMP echo type for the health check (`request` or `reply`) Default: `reply`.\n"
                    },
                    "interfaceAddress": {
                        "type": "string",
                        "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. Maximum value 1476 and minimum value 576. Default: `1476`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the GRE tunnel.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Time To Live (TTL) in number of hops of the GRE tunnel. Minimum value 64. Default: `64`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/healthcheck:Healthcheck": {
            "description": "Standalone Health Checks provide a way to monitor origin servers\nwithout needing a Cloudflare Load Balancer.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// HTTPS Healthcheck\nconst httpHealthCheck = new cloudflare.Healthcheck(\"httpHealthCheck\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"http-health-check\",\n    description: \"example http health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    type: \"HTTPS\",\n    port: 443,\n    method: \"GET\",\n    path: \"/health\",\n    expectedBody: \"alive\",\n    expectedCodes: [\n        \"2xx\",\n        \"301\",\n    ],\n    followRedirects: true,\n    allowInsecure: false,\n    headers: [{\n        header: \"Host\",\n        values: [\"example.com\"],\n    }],\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n// TCP Healthcheck\nconst tcpHealthCheck = new cloudflare.Healthcheck(\"tcpHealthCheck\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"tcp-health-check\",\n    description: \"example tcp health check\",\n    address: \"example.com\",\n    suspended: false,\n    checkRegions: [\n        \"WEU\",\n        \"EEU\",\n    ],\n    type: \"TCP\",\n    port: 22,\n    method: \"connection_established\",\n    timeout: 10,\n    retries: 2,\n    interval: 60,\n    consecutiveFails: 3,\n    consecutiveSuccesses: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# HTTPS Healthcheck\nhttp_health_check = cloudflare.Healthcheck(\"httpHealthCheck\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"http-health-check\",\n    description=\"example http health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    type=\"HTTPS\",\n    port=443,\n    method=\"GET\",\n    path=\"/health\",\n    expected_body=\"alive\",\n    expected_codes=[\n        \"2xx\",\n        \"301\",\n    ],\n    follow_redirects=True,\n    allow_insecure=False,\n    headers=[cloudflare.HealthcheckHeaderArgs(\n        header=\"Host\",\n        values=[\"example.com\"],\n    )],\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n# TCP Healthcheck\ntcp_health_check = cloudflare.Healthcheck(\"tcpHealthCheck\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"tcp-health-check\",\n    description=\"example tcp health check\",\n    address=\"example.com\",\n    suspended=False,\n    check_regions=[\n        \"WEU\",\n        \"EEU\",\n    ],\n    type=\"TCP\",\n    port=22,\n    method=\"connection_established\",\n    timeout=10,\n    retries=2,\n    interval=60,\n    consecutive_fails=3,\n    consecutive_successes=2)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // HTTPS Healthcheck\n    var httpHealthCheck = new Cloudflare.Healthcheck(\"httpHealthCheck\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Name = \"http-health-check\",\n        Description = \"example http health check\",\n        Address = \"example.com\",\n        Suspended = false,\n        CheckRegions = new[]\n        {\n            \"WEU\",\n            \"EEU\",\n        },\n        Type = \"HTTPS\",\n        Port = 443,\n        Method = \"GET\",\n        Path = \"/health\",\n        ExpectedBody = \"alive\",\n        ExpectedCodes = new[]\n        {\n            \"2xx\",\n            \"301\",\n        },\n        FollowRedirects = true,\n        AllowInsecure = false,\n        Headers = new[]\n        {\n            new Cloudflare.Inputs.HealthcheckHeaderArgs\n            {\n                Header = \"Host\",\n                Values = new[]\n                {\n                    \"example.com\",\n                },\n            },\n        },\n        Timeout = 10,\n        Retries = 2,\n        Interval = 60,\n        ConsecutiveFails = 3,\n        ConsecutiveSuccesses = 2,\n    });\n\n    // TCP Healthcheck\n    var tcpHealthCheck = new Cloudflare.Healthcheck(\"tcpHealthCheck\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Name = \"tcp-health-check\",\n        Description = \"example tcp health check\",\n        Address = \"example.com\",\n        Suspended = false,\n        CheckRegions = new[]\n        {\n            \"WEU\",\n            \"EEU\",\n        },\n        Type = \"TCP\",\n        Port = 22,\n        Method = \"connection_established\",\n        Timeout = 10,\n        Retries = 2,\n        Interval = 60,\n        ConsecutiveFails = 3,\n        ConsecutiveSuccesses = 2,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewHealthcheck(ctx, \"httpHealthCheck\", \u0026cloudflare.HealthcheckArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:        pulumi.String(\"http-health-check\"),\n\t\t\tDescription: pulumi.String(\"example http health check\"),\n\t\t\tAddress:     pulumi.String(\"example.com\"),\n\t\t\tSuspended:   pulumi.Bool(false),\n\t\t\tCheckRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WEU\"),\n\t\t\t\tpulumi.String(\"EEU\"),\n\t\t\t},\n\t\t\tType:         pulumi.String(\"HTTPS\"),\n\t\t\tPort:         pulumi.Int(443),\n\t\t\tMethod:       pulumi.String(\"GET\"),\n\t\t\tPath:         pulumi.String(\"/health\"),\n\t\t\tExpectedBody: pulumi.String(\"alive\"),\n\t\t\tExpectedCodes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"2xx\"),\n\t\t\t\tpulumi.String(\"301\"),\n\t\t\t},\n\t\t\tFollowRedirects: pulumi.Bool(true),\n\t\t\tAllowInsecure:   pulumi.Bool(false),\n\t\t\tHeaders: cloudflare.HealthcheckHeaderArray{\n\t\t\t\t\u0026cloudflare.HealthcheckHeaderArgs{\n\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTimeout:              pulumi.Int(10),\n\t\t\tRetries:              pulumi.Int(2),\n\t\t\tInterval:             pulumi.Int(60),\n\t\t\tConsecutiveFails:     pulumi.Int(3),\n\t\t\tConsecutiveSuccesses: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewHealthcheck(ctx, \"tcpHealthCheck\", \u0026cloudflare.HealthcheckArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:        pulumi.String(\"tcp-health-check\"),\n\t\t\tDescription: pulumi.String(\"example tcp health check\"),\n\t\t\tAddress:     pulumi.String(\"example.com\"),\n\t\t\tSuspended:   pulumi.Bool(false),\n\t\t\tCheckRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WEU\"),\n\t\t\t\tpulumi.String(\"EEU\"),\n\t\t\t},\n\t\t\tType:                 pulumi.String(\"TCP\"),\n\t\t\tPort:                 pulumi.Int(22),\n\t\t\tMethod:               pulumi.String(\"connection_established\"),\n\t\t\tTimeout:              pulumi.Int(10),\n\t\t\tRetries:              pulumi.Int(2),\n\t\t\tInterval:             pulumi.Int(60),\n\t\t\tConsecutiveFails:     pulumi.Int(3),\n\t\t\tConsecutiveSuccesses: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Healthcheck;\nimport com.pulumi.cloudflare.HealthcheckArgs;\nimport com.pulumi.cloudflare.inputs.HealthcheckHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var httpHealthCheck = new Healthcheck(\"httpHealthCheck\", HealthcheckArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .name(\"http-health-check\")\n            .description(\"example http health check\")\n            .address(\"example.com\")\n            .suspended(false)\n            .checkRegions(            \n                \"WEU\",\n                \"EEU\")\n            .type(\"HTTPS\")\n            .port(\"443\")\n            .method(\"GET\")\n            .path(\"/health\")\n            .expectedBody(\"alive\")\n            .expectedCodes(            \n                \"2xx\",\n                \"301\")\n            .followRedirects(true)\n            .allowInsecure(false)\n            .headers(HealthcheckHeaderArgs.builder()\n                .header(\"Host\")\n                .values(\"example.com\")\n                .build())\n            .timeout(10)\n            .retries(2)\n            .interval(60)\n            .consecutiveFails(3)\n            .consecutiveSuccesses(2)\n            .build());\n\n        var tcpHealthCheck = new Healthcheck(\"tcpHealthCheck\", HealthcheckArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .name(\"tcp-health-check\")\n            .description(\"example tcp health check\")\n            .address(\"example.com\")\n            .suspended(false)\n            .checkRegions(            \n                \"WEU\",\n                \"EEU\")\n            .type(\"TCP\")\n            .port(\"22\")\n            .method(\"connection_established\")\n            .timeout(10)\n            .retries(2)\n            .interval(60)\n            .consecutiveFails(3)\n            .consecutiveSuccesses(2)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # HTTPS Healthcheck\n  httpHealthCheck:\n    type: cloudflare:Healthcheck\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      name: http-health-check\n      description: example http health check\n      address: example.com\n      suspended: false\n      checkRegions:\n        - WEU\n        - EEU\n      type: HTTPS\n      port: '443'\n      method: GET\n      path: /health\n      expectedBody: alive\n      expectedCodes:\n        - 2xx\n        - '301'\n      followRedirects: true\n      allowInsecure: false\n      headers:\n        - header: Host\n          values:\n            - example.com\n      timeout: 10\n      retries: 2\n      interval: 60\n      consecutiveFails: 3\n      consecutiveSuccesses: 2\n  # TCP Healthcheck\n  tcpHealthCheck:\n    type: cloudflare:Healthcheck\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      name: tcp-health-check\n      description: example tcp health check\n      address: example.com\n      suspended: false\n      checkRegions:\n        - WEU\n        - EEU\n      type: TCP\n      port: '22'\n      method: connection_established\n      timeout: 10\n      retries: 2\n      interval: 60\n      consecutiveFails: 3\n      consecutiveSuccesses: 2\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nUse the Zone ID and Healthcheck ID to import.\n\n```sh\n $ pulumi import cloudflare:index/healthcheck:Healthcheck example \u003czone_id\u003e/\u003chealthcheck_id\u003e\n```\n\n ",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Defaults to `false`.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Last modified time.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Defaults to `/`.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check. Defaults to `80`.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Defaults to `false`.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "address",
                "checkRegions",
                "createdOn",
                "method",
                "modifiedOn",
                "name",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The hostname or IP address of the origin server to run health checks on.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                },
                "consecutiveFails": {
                    "type": "integer",
                    "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.\n"
                },
                "consecutiveSuccesses": {
                    "type": "integer",
                    "description": "The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A human-readable description of the health check.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.\n"
                },
                "expectedCodes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if the origin returns a 3xx status code. Defaults to `false`.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                    },
                    "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Defaults to `/`.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect to for the health check. Defaults to `80`.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, no health checks are sent to the origin. Defaults to `false`.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "address",
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Healthcheck resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The hostname or IP address of the origin server to run health checks on.\n"
                    },
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.\n"
                    },
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.\n"
                    },
                    "consecutiveFails": {
                        "type": "integer",
                        "description": "The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.\n"
                    },
                    "consecutiveSuccesses": {
                        "type": "integer",
                        "description": "The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A human-readable description of the health check.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.\n"
                    },
                    "expectedCodes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if the origin returns a 3xx status code. Defaults to `false`.\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/HealthcheckHeader:HealthcheckHeader"
                        },
                        "description": "The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Last modified time.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. Defaults to `/`.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port number to connect to for the health check. Defaults to `80`.\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, no health checks are sent to the origin. Defaults to `false`.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. Defaults to `5`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ipList:IpList": {
            "description": "IP Lists are a set of IP addresses or CIDR ranges that are configured on the account level. Once created, IP Lists can be\nused in Firewall Rules across all zones within the same account.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.IpList(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"list description\",\n    items: [\n        {\n            comment: \"Office IP\",\n            value: \"192.0.2.1\",\n        },\n        {\n            comment: \"Datacenter range\",\n            value: \"203.0.113.0/24\",\n        },\n    ],\n    kind: \"ip\",\n    name: \"example_list\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.IpList(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"list description\",\n    items=[\n        cloudflare.IpListItemArgs(\n            comment=\"Office IP\",\n            value=\"192.0.2.1\",\n        ),\n        cloudflare.IpListItemArgs(\n            comment=\"Datacenter range\",\n            value=\"203.0.113.0/24\",\n        ),\n    ],\n    kind=\"ip\",\n    name=\"example_list\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.IpList(\"example\", new()\n    {\n        AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Description = \"list description\",\n        Items = new[]\n        {\n            new Cloudflare.Inputs.IpListItemArgs\n            {\n                Comment = \"Office IP\",\n                Value = \"192.0.2.1\",\n            },\n            new Cloudflare.Inputs.IpListItemArgs\n            {\n                Comment = \"Datacenter range\",\n                Value = \"203.0.113.0/24\",\n            },\n        },\n        Kind = \"ip\",\n        Name = \"example_list\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewIpList(ctx, \"example\", \u0026cloudflare.IpListArgs{\n\t\t\tAccountId:   pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription: pulumi.String(\"list description\"),\n\t\t\tItems: cloudflare.IpListItemArray{\n\t\t\t\t\u0026cloudflare.IpListItemArgs{\n\t\t\t\t\tComment: pulumi.String(\"Office IP\"),\n\t\t\t\t\tValue:   pulumi.String(\"192.0.2.1\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.IpListItemArgs{\n\t\t\t\t\tComment: pulumi.String(\"Datacenter range\"),\n\t\t\t\t\tValue:   pulumi.String(\"203.0.113.0/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tKind: pulumi.String(\"ip\"),\n\t\t\tName: pulumi.String(\"example_list\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.IpList;\nimport com.pulumi.cloudflare.IpListArgs;\nimport com.pulumi.cloudflare.inputs.IpListItemArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IpList(\"example\", IpListArgs.builder()        \n            .accountId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .description(\"list description\")\n            .items(            \n                IpListItemArgs.builder()\n                    .comment(\"Office IP\")\n                    .value(\"192.0.2.1\")\n                    .build(),\n                IpListItemArgs.builder()\n                    .comment(\"Datacenter range\")\n                    .value(\"203.0.113.0/24\")\n                    .build())\n            .kind(\"ip\")\n            .name(\"example_list\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:IpList\n    properties:\n      accountId: d41d8cd98f00b204e9800998ecf8427e\n      description: list description\n      items:\n        - comment: Office IP\n          value: 192.0.2.1\n        - comment: Datacenter range\n          value: 203.0.113.0/24\n      kind: ip\n      name: example_list\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing IP List can be imported using the account ID and list ID\n\n```sh\n $ pulumi import cloudflare:index/ipList:IpList example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the IP List is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the List. Maximum Length: 500\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/IpListItem:IpListItem"
                    }
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of values in the List. Valid values: `ip`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list (used in filter expressions). Valid pattern: `^[a-zA-Z0-9_]+$`. Maximum Length: 50\n"
                }
            },
            "required": [
                "accountId",
                "kind",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the IP List is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the List. Maximum Length: 500\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/IpListItem:IpListItem"
                    }
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of values in the List. Valid values: `ip`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list (used in filter expressions). Valid pattern: `^[a-zA-Z0-9_]+$`. Maximum Length: 50\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "kind",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpList resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the IP List is being created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that can be used to annotate the List. Maximum Length: 500\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/IpListItem:IpListItem"
                        }
                    },
                    "kind": {
                        "type": "string",
                        "description": "The kind of values in the List. Valid values: `ip`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the list (used in filter expressions). Valid pattern: `^[a-zA-Z0-9_]+$`. Maximum Length: 50\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ipsecTunnel:IpsecTunnel": {
            "description": "Provides a resource, that manages IPsec tunnels for Magic Transit.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.IpsecTunnel(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    allowNullCipher: false,\n    cloudflareEndpoint: \"203.0.113.1\",\n    customerEndpoint: \"203.0.113.1\",\n    description: \"Tunnel for ISP X\",\n    healthCheckEnabled: true,\n    healthCheckTarget: \"203.0.113.1\",\n    healthCheckType: \"reply\",\n    interfaceAddress: \"192.0.2.0/31\",\n    name: \"IPsec_1\",\n    psk: \"asdf12341234\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.IpsecTunnel(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    allow_null_cipher=False,\n    cloudflare_endpoint=\"203.0.113.1\",\n    customer_endpoint=\"203.0.113.1\",\n    description=\"Tunnel for ISP X\",\n    health_check_enabled=True,\n    health_check_target=\"203.0.113.1\",\n    health_check_type=\"reply\",\n    interface_address=\"192.0.2.0/31\",\n    name=\"IPsec_1\",\n    psk=\"asdf12341234\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.IpsecTunnel(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        AllowNullCipher = false,\n        CloudflareEndpoint = \"203.0.113.1\",\n        CustomerEndpoint = \"203.0.113.1\",\n        Description = \"Tunnel for ISP X\",\n        HealthCheckEnabled = true,\n        HealthCheckTarget = \"203.0.113.1\",\n        HealthCheckType = \"reply\",\n        InterfaceAddress = \"192.0.2.0/31\",\n        Name = \"IPsec_1\",\n        Psk = \"asdf12341234\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewIpsecTunnel(ctx, \"example\", \u0026cloudflare.IpsecTunnelArgs{\n\t\t\tAccountId:          pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tAllowNullCipher:    pulumi.Bool(false),\n\t\t\tCloudflareEndpoint: pulumi.String(\"203.0.113.1\"),\n\t\t\tCustomerEndpoint:   pulumi.String(\"203.0.113.1\"),\n\t\t\tDescription:        pulumi.String(\"Tunnel for ISP X\"),\n\t\t\tHealthCheckEnabled: pulumi.Bool(true),\n\t\t\tHealthCheckTarget:  pulumi.String(\"203.0.113.1\"),\n\t\t\tHealthCheckType:    pulumi.String(\"reply\"),\n\t\t\tInterfaceAddress:   pulumi.String(\"192.0.2.0/31\"),\n\t\t\tName:               pulumi.String(\"IPsec_1\"),\n\t\t\tPsk:                pulumi.String(\"asdf12341234\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.IpsecTunnel;\nimport com.pulumi.cloudflare.IpsecTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IpsecTunnel(\"example\", IpsecTunnelArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .allowNullCipher(false)\n            .cloudflareEndpoint(\"203.0.113.1\")\n            .customerEndpoint(\"203.0.113.1\")\n            .description(\"Tunnel for ISP X\")\n            .healthCheckEnabled(true)\n            .healthCheckTarget(\"203.0.113.1\")\n            .healthCheckType(\"reply\")\n            .interfaceAddress(\"192.0.2.0/31\")\n            .name(\"IPsec_1\")\n            .psk(\"asdf12341234\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:IpsecTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      allowNullCipher: false\n      cloudflareEndpoint: 203.0.113.1\n      customerEndpoint: 203.0.113.1\n      description: Tunnel for ISP X\n      healthCheckEnabled: true\n      healthCheckTarget: 203.0.113.1\n      healthCheckType: reply\n      interfaceAddress: 192.0.2.0/31\n      name: IPsec_1\n      psk: asdf12341234\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/ipsecTunnel:IpsecTunnel example \u003caccount_id\u003e/\u003ctunnel_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "allowNullCipher": {
                    "type": "boolean",
                    "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                },
                "cloudflareEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                },
                "customerEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the IPsec tunnel.\n"
                },
                "fqdnId": {
                    "type": "string",
                    "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                },
                "hexId": {
                    "type": "string",
                    "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IPsec tunnel.\n"
                },
                "psk": {
                    "type": "string",
                    "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                }
            },
            "required": [
                "cloudflareEndpoint",
                "customerEndpoint",
                "fqdnId",
                "healthCheckEnabled",
                "healthCheckTarget",
                "healthCheckType",
                "hexId",
                "interfaceAddress",
                "name",
                "psk",
                "remoteId",
                "userId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "allowNullCipher": {
                    "type": "boolean",
                    "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                },
                "cloudflareEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                },
                "customerEndpoint": {
                    "type": "string",
                    "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the IPsec tunnel.\n"
                },
                "fqdnId": {
                    "type": "string",
                    "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                },
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                },
                "healthCheckTarget": {
                    "type": "string",
                    "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                },
                "hexId": {
                    "type": "string",
                    "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                },
                "interfaceAddress": {
                    "type": "string",
                    "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IPsec tunnel.\n"
                },
                "psk": {
                    "type": "string",
                    "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                    "secret": true
                },
                "remoteId": {
                    "type": "string",
                    "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                }
            },
            "requiredInputs": [
                "cloudflareEndpoint",
                "customerEndpoint",
                "interfaceAddress",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpsecTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "allowNullCipher": {
                        "type": "boolean",
                        "description": "Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.\n"
                    },
                    "cloudflareEndpoint": {
                        "type": "string",
                        "description": "IP address assigned to the Cloudflare side of the IPsec tunnel.\n"
                    },
                    "customerEndpoint": {
                        "type": "string",
                        "description": "IP address assigned to the customer side of the IPsec tunnel.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the IPsec tunnel.\n"
                    },
                    "fqdnId": {
                        "type": "string",
                        "description": "`remote_id` in the form of a fqdn. This value is generated by cloudflare.\n"
                    },
                    "healthCheckEnabled": {
                        "type": "boolean",
                        "description": "Specifies if ICMP tunnel health checks are enabled. Default: `true`.\n"
                    },
                    "healthCheckTarget": {
                        "type": "string",
                        "description": "The IP address of the customer endpoint that will receive tunnel health checks. Default: `\u003ccustomer_gre_endpoint\u003e`.\n"
                    },
                    "healthCheckType": {
                        "type": "string",
                        "description": "Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.\n"
                    },
                    "hexId": {
                        "type": "string",
                        "description": "`remote_id` as a hex string. This value is generated by cloudflare.\n"
                    },
                    "interfaceAddress": {
                        "type": "string",
                        "description": "31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the IPsec tunnel.\n"
                    },
                    "psk": {
                        "type": "string",
                        "description": "Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.\n",
                        "secret": true
                    },
                    "remoteId": {
                        "type": "string",
                        "description": "ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "`remote_id` in the form of an email address. This value is generated by cloudflare.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/list:List": {
            "description": "Provides Lists (IPs, Redirects) to be used in Edge Rules Engine\nacross all zones within the same account.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.List;\nimport com.pulumi.cloudflare.ListArgs;\nimport com.pulumi.cloudflare.inputs.ListItemArgs;\nimport com.pulumi.cloudflare.inputs.ListItemValueArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new List(\"example\", ListArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .description(\"example redirects for a list\")\n            .items(            \n                ListItemArgs.builder()\n                    .comment(\"one\")\n                    .value(ListItemValueArgs.builder()\n                        .redirect(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .build(),\n                ListItemArgs.builder()\n                    .comment(\"two\")\n                    .value(ListItemValueArgs.builder()\n                        .redirect(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .build())\n            .kind(\"redirect\")\n            .name(\"example list\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Redirect list\n  example:\n    type: cloudflare:List\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      description: example redirects for a list\n      items:\n        - comment: one\n          value:\n            redirect:\n              - sourceUrl: example.com/blog\n                targetUrl: https://blog.example.com\n        - comment: two\n          value:\n            redirect:\n              - includeSubdomains: enabled\n                preservePathSuffix: disabled\n                preserveQueryString: enabled\n                sourceUrl: example.com/foo\n                statusCode: 301\n                subpathMatching: enabled\n                targetUrl: https://foo.example.com\n      kind: redirect\n      name: example list\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/list:List example \u003caccount_id\u003e/\u003clist_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItem:ListItem"
                    }
                },
                "kind": {
                    "type": "string",
                    "description": "The type of items the list will contain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "kind",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ListItem:ListItem"
                    }
                },
                "kind": {
                    "type": "string",
                    "description": "The type of items the list will contain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the list. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "kind",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering List resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the list.\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ListItem:ListItem"
                        }
                    },
                    "kind": {
                        "type": "string",
                        "description": "The type of items the list will contain.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the list. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancer:LoadBalancer": {
            "description": "Provides a Cloudflare Load Balancer resource. This sits in front of\na number of defined pools of origins and provides various options\nfor geographically-aware load balancing. Note that the load balancing\nfeature must be enabled in your Cloudflare account before you can use\nthis resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleLoadBalancerPool = new cloudflare.LoadBalancerPool(\"exampleLoadBalancerPool\", {\n    name: \"example-lb-pool\",\n    origins: [{\n        name: \"example-1\",\n        address: \"192.0.2.1\",\n        enabled: false,\n    }],\n});\n// Define a load balancer which always points to a pool we define below.\n// In normal usage, would have different pools set for different pops\n// (cloudflare points-of-presence) and/or for different regions.\n// Within each pop or region we can define multiple pools in failover order.\nconst exampleLoadBalancer = new cloudflare.LoadBalancer(\"exampleLoadBalancer\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    name: \"example-load-balancer.example.com\",\n    fallbackPoolId: exampleLoadBalancerPool.id,\n    defaultPoolIds: [exampleLoadBalancerPool.id],\n    description: \"example load balancer using geo-balancing\",\n    proxied: true,\n    steeringPolicy: \"geo\",\n    popPools: [{\n        pop: \"LAX\",\n        poolIds: [exampleLoadBalancerPool.id],\n    }],\n    countryPools: [{\n        country: \"US\",\n        poolIds: [exampleLoadBalancerPool.id],\n    }],\n    regionPools: [{\n        region: \"WNAM\",\n        poolIds: [exampleLoadBalancerPool.id],\n    }],\n    rules: [{\n        name: \"example rule\",\n        condition: \"http.request.uri.path contains \\\"testing\\\"\",\n        fixedResponse: {\n            messageBody: \"hello\",\n            statusCode: 200,\n            contentType: \"html\",\n            location: \"www.example.com\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_load_balancer_pool = cloudflare.LoadBalancerPool(\"exampleLoadBalancerPool\",\n    name=\"example-lb-pool\",\n    origins=[cloudflare.LoadBalancerPoolOriginArgs(\n        name=\"example-1\",\n        address=\"192.0.2.1\",\n        enabled=False,\n    )])\n# Define a load balancer which always points to a pool we define below.\n# In normal usage, would have different pools set for different pops\n# (cloudflare points-of-presence) and/or for different regions.\n# Within each pop or region we can define multiple pools in failover order.\nexample_load_balancer = cloudflare.LoadBalancer(\"exampleLoadBalancer\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    name=\"example-load-balancer.example.com\",\n    fallback_pool_id=example_load_balancer_pool.id,\n    default_pool_ids=[example_load_balancer_pool.id],\n    description=\"example load balancer using geo-balancing\",\n    proxied=True,\n    steering_policy=\"geo\",\n    pop_pools=[cloudflare.LoadBalancerPopPoolArgs(\n        pop=\"LAX\",\n        pool_ids=[example_load_balancer_pool.id],\n    )],\n    country_pools=[cloudflare.LoadBalancerCountryPoolArgs(\n        country=\"US\",\n        pool_ids=[example_load_balancer_pool.id],\n    )],\n    region_pools=[cloudflare.LoadBalancerRegionPoolArgs(\n        region=\"WNAM\",\n        pool_ids=[example_load_balancer_pool.id],\n    )],\n    rules=[cloudflare.LoadBalancerRuleArgs(\n        name=\"example rule\",\n        condition=\"http.request.uri.path contains \\\"testing\\\"\",\n        fixed_response=cloudflare.LoadBalancerRuleFixedResponseArgs(\n            message_body=\"hello\",\n            status_code=200,\n            content_type=\"html\",\n            location=\"www.example.com\",\n        ),\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleLoadBalancerPool = new Cloudflare.LoadBalancerPool(\"exampleLoadBalancerPool\", new()\n    {\n        Name = \"example-lb-pool\",\n        Origins = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n            {\n                Name = \"example-1\",\n                Address = \"192.0.2.1\",\n                Enabled = false,\n            },\n        },\n    });\n\n    // Define a load balancer which always points to a pool we define below.\n    // In normal usage, would have different pools set for different pops\n    // (cloudflare points-of-presence) and/or for different regions.\n    // Within each pop or region we can define multiple pools in failover order.\n    var exampleLoadBalancer = new Cloudflare.LoadBalancer(\"exampleLoadBalancer\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Name = \"example-load-balancer.example.com\",\n        FallbackPoolId = exampleLoadBalancerPool.Id,\n        DefaultPoolIds = new[]\n        {\n            exampleLoadBalancerPool.Id,\n        },\n        Description = \"example load balancer using geo-balancing\",\n        Proxied = true,\n        SteeringPolicy = \"geo\",\n        PopPools = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPopPoolArgs\n            {\n                Pop = \"LAX\",\n                PoolIds = new[]\n                {\n                    exampleLoadBalancerPool.Id,\n                },\n            },\n        },\n        CountryPools = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerCountryPoolArgs\n            {\n                Country = \"US\",\n                PoolIds = new[]\n                {\n                    exampleLoadBalancerPool.Id,\n                },\n            },\n        },\n        RegionPools = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerRegionPoolArgs\n            {\n                Region = \"WNAM\",\n                PoolIds = new[]\n                {\n                    exampleLoadBalancerPool.Id,\n                },\n            },\n        },\n        Rules = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerRuleArgs\n            {\n                Name = \"example rule\",\n                Condition = \"http.request.uri.path contains \\\"testing\\\"\",\n                FixedResponse = new Cloudflare.Inputs.LoadBalancerRuleFixedResponseArgs\n                {\n                    MessageBody = \"hello\",\n                    StatusCode = 200,\n                    ContentType = \"html\",\n                    Location = \"www.example.com\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleLoadBalancerPool, err := cloudflare.NewLoadBalancerPool(ctx, \"exampleLoadBalancerPool\", \u0026cloudflare.LoadBalancerPoolArgs{\n\t\t\tName: pulumi.String(\"example-lb-pool\"),\n\t\t\tOrigins: cloudflare.LoadBalancerPoolOriginArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginArgs{\n\t\t\t\t\tName:    pulumi.String(\"example-1\"),\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewLoadBalancer(ctx, \"exampleLoadBalancer\", \u0026cloudflare.LoadBalancerArgs{\n\t\t\tZoneId:         pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tName:           pulumi.String(\"example-load-balancer.example.com\"),\n\t\t\tFallbackPoolId: exampleLoadBalancerPool.ID(),\n\t\t\tDefaultPoolIds: pulumi.StringArray{\n\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t},\n\t\t\tDescription:    pulumi.String(\"example load balancer using geo-balancing\"),\n\t\t\tProxied:        pulumi.Bool(true),\n\t\t\tSteeringPolicy: pulumi.String(\"geo\"),\n\t\t\tPopPools: cloudflare.LoadBalancerPopPoolArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPopPoolArgs{\n\t\t\t\t\tPop: pulumi.String(\"LAX\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCountryPools: cloudflare.LoadBalancerCountryPoolArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerCountryPoolArgs{\n\t\t\t\t\tCountry: pulumi.String(\"US\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRegionPools: cloudflare.LoadBalancerRegionPoolArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerRegionPoolArgs{\n\t\t\t\t\tRegion: pulumi.String(\"WNAM\"),\n\t\t\t\t\tPoolIds: pulumi.StringArray{\n\t\t\t\t\t\texampleLoadBalancerPool.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRules: cloudflare.LoadBalancerRuleArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerRuleArgs{\n\t\t\t\t\tName:      pulumi.String(\"example rule\"),\n\t\t\t\t\tCondition: pulumi.String(\"http.request.uri.path contains \\\"testing\\\"\"),\n\t\t\t\t\tFixedResponse: \u0026cloudflare.LoadBalancerRuleFixedResponseArgs{\n\t\t\t\t\t\tMessageBody: pulumi.String(\"hello\"),\n\t\t\t\t\t\tStatusCode:  pulumi.Int(200),\n\t\t\t\t\t\tContentType: pulumi.String(\"html\"),\n\t\t\t\t\t\tLocation:    pulumi.String(\"www.example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LoadBalancerPool;\nimport com.pulumi.cloudflare.LoadBalancerPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginArgs;\nimport com.pulumi.cloudflare.LoadBalancer;\nimport com.pulumi.cloudflare.LoadBalancerArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerPopPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerCountryPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerRegionPoolArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerRuleArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerRuleFixedResponseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleLoadBalancerPool = new LoadBalancerPool(\"exampleLoadBalancerPool\", LoadBalancerPoolArgs.builder()        \n            .name(\"example-lb-pool\")\n            .origins(LoadBalancerPoolOriginArgs.builder()\n                .name(\"example-1\")\n                .address(\"192.0.2.1\")\n                .enabled(false)\n                .build())\n            .build());\n\n        var exampleLoadBalancer = new LoadBalancer(\"exampleLoadBalancer\", LoadBalancerArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .name(\"example-load-balancer.example.com\")\n            .fallbackPoolId(exampleLoadBalancerPool.id())\n            .defaultPoolIds(exampleLoadBalancerPool.id())\n            .description(\"example load balancer using geo-balancing\")\n            .proxied(true)\n            .steeringPolicy(\"geo\")\n            .popPools(LoadBalancerPopPoolArgs.builder()\n                .pop(\"LAX\")\n                .poolIds(exampleLoadBalancerPool.id())\n                .build())\n            .countryPools(LoadBalancerCountryPoolArgs.builder()\n                .country(\"US\")\n                .poolIds(exampleLoadBalancerPool.id())\n                .build())\n            .regionPools(LoadBalancerRegionPoolArgs.builder()\n                .region(\"WNAM\")\n                .poolIds(exampleLoadBalancerPool.id())\n                .build())\n            .rules(LoadBalancerRuleArgs.builder()\n                .name(\"example rule\")\n                .condition(\"http.request.uri.path contains \\\"testing\\\"\")\n                .fixedResponse(LoadBalancerRuleFixedResponseArgs.builder()\n                    .messageBody(\"hello\")\n                    .statusCode(200)\n                    .contentType(\"html\")\n                    .location(\"www.example.com\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Define a load balancer which always points to a pool we define below.\n  # In normal usage, would have different pools set for different pops\n  # (cloudflare points-of-presence) and/or for different regions.\n  # Within each pop or region we can define multiple pools in failover order.\n  exampleLoadBalancer:\n    type: cloudflare:LoadBalancer\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      name: example-load-balancer.example.com\n      fallbackPoolId: ${exampleLoadBalancerPool.id}\n      defaultPoolIds:\n        - ${exampleLoadBalancerPool.id}\n      description: example load balancer using geo-balancing\n      proxied: true\n      steeringPolicy: geo\n      popPools:\n        - pop: LAX\n          poolIds:\n            - ${exampleLoadBalancerPool.id}\n      countryPools:\n        - country: US\n          poolIds:\n            - ${exampleLoadBalancerPool.id}\n      regionPools:\n        - region: WNAM\n          poolIds:\n            - ${exampleLoadBalancerPool.id}\n      rules:\n        - name: example rule\n          condition: http.request.uri.path contains \"testing\"\n          fixedResponse:\n            messageBody: hello\n            statusCode: 200\n            contentType: html\n            location: www.example.com\n  exampleLoadBalancerPool:\n    type: cloudflare:LoadBalancerPool\n    properties:\n      name: example-lb-pool\n      origins:\n        - name: example-1\n          address: 192.0.2.1\n          enabled: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/loadBalancer:LoadBalancer example \u003czone_id\u003e/\u003cload_balancer_id\u003e\n```\n\n ",
            "properties": {
                "adaptiveRoutings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting"
                    },
                    "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                },
                "countryPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool"
                    },
                    "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true`.\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "locationStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy"
                    },
                    "description": "Controls location-based steering for non-proxied requests.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.\n"
                },
                "randomSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering"
                    },
                    "description": "Configures pool weights for random steering. When the `steering_policy=\"random\"`, a random pool is selected with probability proportional to these pool weights.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                    },
                    "description": "A list of rules for this load balancer to execute.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "See `session_affinity_attributes`.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `\"\"` Defaults to `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "countryPools",
                "createdOn",
                "defaultPoolIds",
                "fallbackPoolId",
                "modifiedOn",
                "name",
                "popPools",
                "regionPools",
                "steeringPolicy",
                "ttl",
                "zoneId"
            ],
            "inputProperties": {
                "adaptiveRoutings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting"
                    },
                    "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                },
                "countryPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool"
                    },
                    "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                },
                "defaultPoolIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the load balancer. Defaults to `true`.\n"
                },
                "fallbackPoolId": {
                    "type": "string",
                    "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                },
                "locationStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy"
                    },
                    "description": "Controls location-based steering for non-proxied requests.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.\n"
                },
                "popPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                    },
                    "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.\n"
                },
                "randomSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering"
                    },
                    "description": "Configures pool weights for random steering. When the `steering_policy=\"random\"`, a random pool is selected with probability proportional to these pool weights.\n"
                },
                "regionPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                    },
                    "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                    },
                    "description": "A list of rules for this load balancer to execute.\n"
                },
                "sessionAffinity": {
                    "type": "string",
                    "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.\n"
                },
                "sessionAffinityAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "See `session_affinity_attributes`.\n"
                },
                "sessionAffinityTtl": {
                    "type": "integer",
                    "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                },
                "steeringPolicy": {
                    "type": "string",
                    "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `\"\"` Defaults to `\"\"`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "defaultPoolIds",
                "fallbackPoolId",
                "name",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancer resources.\n",
                "properties": {
                    "adaptiveRoutings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerAdaptiveRouting:LoadBalancerAdaptiveRouting"
                        },
                        "description": "Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.\n"
                    },
                    "countryPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerCountryPool:LoadBalancerCountryPool"
                        },
                        "description": "A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "defaultPoolIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable or disable the load balancer. Defaults to `true`.\n"
                    },
                    "fallbackPoolId": {
                        "type": "string",
                        "description": "The pool ID to use when all other pools are detected as unhealthy.\n"
                    },
                    "locationStrategies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerLocationStrategy:LoadBalancerLocationStrategy"
                        },
                        "description": "Controls location-based steering for non-proxied requests.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.\n"
                    },
                    "popPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPopPool:LoadBalancerPopPool"
                        },
                        "description": "A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.\n"
                    },
                    "randomSteerings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRandomSteering:LoadBalancerRandomSteering"
                        },
                        "description": "Configures pool weights for random steering. When the `steering_policy=\"random\"`, a random pool is selected with probability proportional to these pool weights.\n"
                    },
                    "regionPools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRegionPool:LoadBalancerRegionPool"
                        },
                        "description": "A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerRule:LoadBalancerRule"
                        },
                        "description": "A list of rules for this load balancer to execute.\n"
                    },
                    "sessionAffinity": {
                        "type": "string",
                        "description": "Specifies the type of session affinity the load balancer should use unless specified as `none` or `\"\"` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `\"\"`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.\n"
                    },
                    "sessionAffinityAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "See `session_affinity_attributes`.\n"
                    },
                    "sessionAffinityTtl": {
                        "type": "integer",
                        "description": "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.\n"
                    },
                    "steeringPolicy": {
                        "type": "string",
                        "description": "The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `\"\"` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `\"\"` Defaults to `\"\"`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor": {
            "description": "If you're using Cloudflare's Load Balancing to load-balance across multiple origin servers or data centers, you configure one of these Monitors to actively check the availability of those servers over HTTP(S) or TCP.\n\n\u003e **Note:** When creating a monitor, you have to pass `account_id` to the provider configuration in order to create account level resources. Otherwise, by default, it will be a user level resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### HTTP Monitor\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst httpMonitor = new cloudflare.LoadBalancerMonitor(\"httpMonitor\", {\n    allowInsecure: false,\n    description: \"example http load balancer\",\n    expectedBody: \"alive\",\n    expectedCodes: \"2xx\",\n    followRedirects: true,\n    headers: [{\n        header: \"Host\",\n        values: [\"example.com\"],\n    }],\n    interval: 60,\n    method: \"GET\",\n    path: \"/health\",\n    probeZone: \"example.com\",\n    retries: 5,\n    timeout: 7,\n    type: \"http\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhttp_monitor = cloudflare.LoadBalancerMonitor(\"httpMonitor\",\n    allow_insecure=False,\n    description=\"example http load balancer\",\n    expected_body=\"alive\",\n    expected_codes=\"2xx\",\n    follow_redirects=True,\n    headers=[cloudflare.LoadBalancerMonitorHeaderArgs(\n        header=\"Host\",\n        values=[\"example.com\"],\n    )],\n    interval=60,\n    method=\"GET\",\n    path=\"/health\",\n    probe_zone=\"example.com\",\n    retries=5,\n    timeout=7,\n    type=\"http\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var httpMonitor = new Cloudflare.LoadBalancerMonitor(\"httpMonitor\", new()\n    {\n        AllowInsecure = false,\n        Description = \"example http load balancer\",\n        ExpectedBody = \"alive\",\n        ExpectedCodes = \"2xx\",\n        FollowRedirects = true,\n        Headers = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerMonitorHeaderArgs\n            {\n                Header = \"Host\",\n                Values = new[]\n                {\n                    \"example.com\",\n                },\n            },\n        },\n        Interval = 60,\n        Method = \"GET\",\n        Path = \"/health\",\n        ProbeZone = \"example.com\",\n        Retries = 5,\n        Timeout = 7,\n        Type = \"http\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerMonitor(ctx, \"httpMonitor\", \u0026cloudflare.LoadBalancerMonitorArgs{\n\t\t\tAllowInsecure:   pulumi.Bool(false),\n\t\t\tDescription:     pulumi.String(\"example http load balancer\"),\n\t\t\tExpectedBody:    pulumi.String(\"alive\"),\n\t\t\tExpectedCodes:   pulumi.String(\"2xx\"),\n\t\t\tFollowRedirects: pulumi.Bool(true),\n\t\t\tHeaders: cloudflare.LoadBalancerMonitorHeaderArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerMonitorHeaderArgs{\n\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tInterval:  pulumi.Int(60),\n\t\t\tMethod:    pulumi.String(\"GET\"),\n\t\t\tPath:      pulumi.String(\"/health\"),\n\t\t\tProbeZone: pulumi.String(\"example.com\"),\n\t\t\tRetries:   pulumi.Int(5),\n\t\t\tTimeout:   pulumi.Int(7),\n\t\t\tType:      pulumi.String(\"http\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LoadBalancerMonitor;\nimport com.pulumi.cloudflare.LoadBalancerMonitorArgs;\nimport com.pulumi.cloudflare.inputs.LoadBalancerMonitorHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var httpMonitor = new LoadBalancerMonitor(\"httpMonitor\", LoadBalancerMonitorArgs.builder()        \n            .allowInsecure(false)\n            .description(\"example http load balancer\")\n            .expectedBody(\"alive\")\n            .expectedCodes(\"2xx\")\n            .followRedirects(true)\n            .headers(LoadBalancerMonitorHeaderArgs.builder()\n                .header(\"Host\")\n                .values(\"example.com\")\n                .build())\n            .interval(60)\n            .method(\"GET\")\n            .path(\"/health\")\n            .probeZone(\"example.com\")\n            .retries(5)\n            .timeout(7)\n            .type(\"http\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  httpMonitor:\n    type: cloudflare:LoadBalancerMonitor\n    properties:\n      allowInsecure: false\n      description: example http load balancer\n      expectedBody: alive\n      expectedCodes: 2xx\n      followRedirects: true\n      headers:\n        - header: Host\n          values:\n            - example.com\n      interval: 60\n      method: GET\n      path: /health\n      probeZone: example.com\n      retries: 5\n      timeout: 7\n      type: http\n```\n{{% /example %}}\n{{% example %}}\n### TCP Monitor\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst tcpMonitor = new cloudflare.LoadBalancerMonitor(\"tcpMonitor\", {\n    description: \"example tcp load balancer\",\n    interval: 60,\n    method: \"connection_established\",\n    port: 8080,\n    retries: 5,\n    timeout: 7,\n    type: \"tcp\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntcp_monitor = cloudflare.LoadBalancerMonitor(\"tcpMonitor\",\n    description=\"example tcp load balancer\",\n    interval=60,\n    method=\"connection_established\",\n    port=8080,\n    retries=5,\n    timeout=7,\n    type=\"tcp\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tcpMonitor = new Cloudflare.LoadBalancerMonitor(\"tcpMonitor\", new()\n    {\n        Description = \"example tcp load balancer\",\n        Interval = 60,\n        Method = \"connection_established\",\n        Port = 8080,\n        Retries = 5,\n        Timeout = 7,\n        Type = \"tcp\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerMonitor(ctx, \"tcpMonitor\", \u0026cloudflare.LoadBalancerMonitorArgs{\n\t\t\tDescription: pulumi.String(\"example tcp load balancer\"),\n\t\t\tInterval:    pulumi.Int(60),\n\t\t\tMethod:      pulumi.String(\"connection_established\"),\n\t\t\tPort:        pulumi.Int(8080),\n\t\t\tRetries:     pulumi.Int(5),\n\t\t\tTimeout:     pulumi.Int(7),\n\t\t\tType:        pulumi.String(\"tcp\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LoadBalancerMonitor;\nimport com.pulumi.cloudflare.LoadBalancerMonitorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tcpMonitor = new LoadBalancerMonitor(\"tcpMonitor\", LoadBalancerMonitorArgs.builder()        \n            .description(\"example tcp load balancer\")\n            .interval(60)\n            .method(\"connection_established\")\n            .port(8080)\n            .retries(5)\n            .timeout(7)\n            .type(\"tcp\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tcpMonitor:\n    type: cloudflare:LoadBalancerMonitor\n    properties:\n      description: example tcp load balancer\n      interval: 60\n      method: connection_established\n      port: 8080\n      retries: 5\n      timeout: 7\n      type: tcp\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", \"connection_established\" if `type` is \"tcp\", and empty otherwise.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number to use for the healthcheck, required when creating a TCP monitor. Valid values are in the range `0-65535`.\n"
                },
                "probeZone": {
                    "type": "string",
                    "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS', 'TCP', 'UDP-ICMP', 'ICMP-PING', and 'SMTP'. Default: \"http\".\n"
                }
            },
            "required": [
                "createdOn",
                "method",
                "modifiedOn",
                "path"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "allowInsecure": {
                    "type": "boolean",
                    "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "expectedBody": {
                    "type": "string",
                    "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                },
                "expectedCodes": {
                    "type": "string",
                    "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                },
                "followRedirects": {
                    "type": "boolean",
                    "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                    },
                    "description": "The header name.\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", \"connection_established\" if `type` is \"tcp\", and empty otherwise.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port number to use for the healthcheck, required when creating a TCP monitor. Valid values are in the range `0-65535`.\n"
                },
                "probeZone": {
                    "type": "string",
                    "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS', 'TCP', 'UDP-ICMP', 'ICMP-PING', and 'SMTP'. Default: \"http\".\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerMonitor resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "allowInsecure": {
                        "type": "boolean",
                        "description": "Do not validate the certificate when monitor use HTTPS. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "expectedBody": {
                        "type": "string",
                        "description": "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is \"http\" or \"https\". Default: \"\".\n"
                    },
                    "expectedCodes": {
                        "type": "string",
                        "description": "The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is \"http\" or \"https\".\n"
                    },
                    "followRedirects": {
                        "type": "boolean",
                        "description": "Follow redirects if returned by the origin. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerMonitorHeader:LoadBalancerMonitorHeader"
                        },
                        "description": "The header name.\n"
                    },
                    "interval": {
                        "type": "integer",
                        "description": "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The method to use for the health check. Valid values are any valid HTTP verb if `type` is \"http\" or \"https\", or `connection_established` if `type` is \"tcp\". Default: \"GET\" if `type` is \"http\" or \"https\", \"connection_established\" if `type` is \"tcp\", and empty otherwise.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer monitor was last modified.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path to health check against. Default: \"/\". Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port number to use for the healthcheck, required when creating a TCP monitor. Valid values are in the range `0-65535`.\n"
                    },
                    "probeZone": {
                        "type": "string",
                        "description": "Assign this monitor to emulate the specified zone while probing. Only valid if `type` is \"http\" or \"https\".\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "The timeout (in seconds) before marking the health check as failed. Default: 5.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS', 'TCP', 'UDP-ICMP', 'ICMP-PING', and 'SMTP'. Default: \"http\".\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/loadBalancerPool:LoadBalancerPool": {
            "description": "Provides a Cloudflare Load Balancer pool resource. This provides a pool of origins that can be used by a Cloudflare Load Balancer. Note that the load balancing feature must be enabled in your Cloudflare account before you can use this resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst foo = new cloudflare.LoadBalancerPool(\"foo\", {\n    description: \"example load balancer pool\",\n    enabled: false,\n    latitude: 55,\n    loadSheddings: [{\n        defaultPercent: 55,\n        defaultPolicy: \"random\",\n        sessionPercent: 12,\n        sessionPolicy: \"hash\",\n    }],\n    longitude: -12,\n    minimumOrigins: 1,\n    name: \"example-pool\",\n    notificationEmail: \"someone@example.com\",\n    originSteerings: [{\n        policy: \"random\",\n    }],\n    origins: [\n        {\n            address: \"192.0.2.1\",\n            enabled: false,\n            headers: [{\n                header: \"Host\",\n                values: [\"example-1\"],\n            }],\n            name: \"example-1\",\n        },\n        {\n            address: \"192.0.2.2\",\n            headers: [{\n                header: \"Host\",\n                values: [\"example-2\"],\n            }],\n            name: \"example-2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nfoo = cloudflare.LoadBalancerPool(\"foo\",\n    description=\"example load balancer pool\",\n    enabled=False,\n    latitude=55,\n    load_sheddings=[cloudflare.LoadBalancerPoolLoadSheddingArgs(\n        default_percent=55,\n        default_policy=\"random\",\n        session_percent=12,\n        session_policy=\"hash\",\n    )],\n    longitude=-12,\n    minimum_origins=1,\n    name=\"example-pool\",\n    notification_email=\"someone@example.com\",\n    origin_steerings=[cloudflare.LoadBalancerPoolOriginSteeringArgs(\n        policy=\"random\",\n    )],\n    origins=[\n        cloudflare.LoadBalancerPoolOriginArgs(\n            address=\"192.0.2.1\",\n            enabled=False,\n            headers=[cloudflare.LoadBalancerPoolOriginHeaderArgs(\n                header=\"Host\",\n                values=[\"example-1\"],\n            )],\n            name=\"example-1\",\n        ),\n        cloudflare.LoadBalancerPoolOriginArgs(\n            address=\"192.0.2.2\",\n            headers=[cloudflare.LoadBalancerPoolOriginHeaderArgs(\n                header=\"Host\",\n                values=[\"example-2\"],\n            )],\n            name=\"example-2\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new Cloudflare.LoadBalancerPool(\"foo\", new()\n    {\n        Description = \"example load balancer pool\",\n        Enabled = false,\n        Latitude = 55,\n        LoadSheddings = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolLoadSheddingArgs\n            {\n                DefaultPercent = 55,\n                DefaultPolicy = \"random\",\n                SessionPercent = 12,\n                SessionPolicy = \"hash\",\n            },\n        },\n        Longitude = -12,\n        MinimumOrigins = 1,\n        Name = \"example-pool\",\n        NotificationEmail = \"someone@example.com\",\n        OriginSteerings = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolOriginSteeringArgs\n            {\n                Policy = \"random\",\n            },\n        },\n        Origins = new[]\n        {\n            new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n            {\n                Address = \"192.0.2.1\",\n                Enabled = false,\n                Headers = new[]\n                {\n                    new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs\n                    {\n                        Header = \"Host\",\n                        Values = new[]\n                        {\n                            \"example-1\",\n                        },\n                    },\n                },\n                Name = \"example-1\",\n            },\n            new Cloudflare.Inputs.LoadBalancerPoolOriginArgs\n            {\n                Address = \"192.0.2.2\",\n                Headers = new[]\n                {\n                    new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs\n                    {\n                        Header = \"Host\",\n                        Values = new[]\n                        {\n                            \"example-2\",\n                        },\n                    },\n                },\n                Name = \"example-2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLoadBalancerPool(ctx, \"foo\", \u0026cloudflare.LoadBalancerPoolArgs{\n\t\t\tDescription: pulumi.String(\"example load balancer pool\"),\n\t\t\tEnabled:     pulumi.Bool(false),\n\t\t\tLatitude:    pulumi.Float64(55),\n\t\t\tLoadSheddings: cloudflare.LoadBalancerPoolLoadSheddingArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolLoadSheddingArgs{\n\t\t\t\t\tDefaultPercent: pulumi.Float64(55),\n\t\t\t\t\tDefaultPolicy:  pulumi.String(\"random\"),\n\t\t\t\t\tSessionPercent: pulumi.Float64(12),\n\t\t\t\t\tSessionPolicy:  pulumi.String(\"hash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLongitude:         -12,\n\t\t\tMinimumOrigins:    pulumi.Int(1),\n\t\t\tName:              pulumi.String(\"example-pool\"),\n\t\t\tNotificationEmail: pulumi.String(\"someone@example.com\"),\n\t\t\tOriginSteerings: cloudflare.LoadBalancerPoolOriginSteeringArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginSteeringArgs{\n\t\t\t\t\tPolicy: pulumi.String(\"random\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tOrigins: cloudflare.LoadBalancerPoolOriginArray{\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginArgs{\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.1\"),\n\t\t\t\t\tEnabled: pulumi.Bool(false),\n\t\t\t\t\tHeaders: cloudflare.LoadBalancerPoolOriginHeaderArray{\n\t\t\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginHeaderArgs{\n\t\t\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"example-1\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.String(\"example-1\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginArgs{\n\t\t\t\t\tAddress: pulumi.String(\"192.0.2.2\"),\n\t\t\t\t\tHeaders: cloudflare.LoadBalancerPoolOriginHeaderArray{\n\t\t\t\t\t\t\u0026cloudflare.LoadBalancerPoolOriginHeaderArgs{\n\t\t\t\t\t\t\tHeader: pulumi.String(\"Host\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"example-2\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.String(\"example-2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude this pool is physically located at; used for proximity steering. Values should be between -90 and 90.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude this pool is physically located at; used for proximity steering. Values should be between -180 and 180.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "originSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                    },
                    "description": "Set an origin steering policy to control origin selection within a pool.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                }
            },
            "required": [
                "checkRegions",
                "createdOn",
                "modifiedOn",
                "name",
                "origins"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "checkRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).\n"
                },
                "description": {
                    "type": "string",
                    "description": "Free text description.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude this pool is physically located at; used for proximity steering. Values should be between -90 and 90.\n"
                },
                "loadSheddings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                    },
                    "description": "Setting for controlling load shedding for this pool.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude this pool is physically located at; used for proximity steering. Values should be between -180 and 180.\n"
                },
                "minimumOrigins": {
                    "type": "integer",
                    "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-identifiable name for the origin.\n"
                },
                "notificationEmail": {
                    "type": "string",
                    "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                },
                "originSteerings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                    },
                    "description": "Set an origin steering policy to control origin selection within a pool.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                    },
                    "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                }
            },
            "requiredInputs": [
                "name",
                "origins"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadBalancerPool resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "checkRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Free text description.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "The latitude this pool is physically located at; used for proximity steering. Values should be between -90 and 90.\n"
                    },
                    "loadSheddings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolLoadShedding:LoadBalancerPoolLoadShedding"
                        },
                        "description": "Setting for controlling load shedding for this pool.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "The longitude this pool is physically located at; used for proximity steering. Values should be between -180 and 180.\n"
                    },
                    "minimumOrigins": {
                        "type": "integer",
                        "description": "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Default: 1.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the load balancer was last modified.\n"
                    },
                    "monitor": {
                        "type": "string",
                        "description": "The ID of the Monitor to use for health checking origins within this pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-identifiable name for the origin.\n"
                    },
                    "notificationEmail": {
                        "type": "string",
                        "description": "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.\n"
                    },
                    "originSteerings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolOriginSteering:LoadBalancerPoolOriginSteering"
                        },
                        "description": "Set an origin steering policy to control origin selection within a pool.\n"
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/LoadBalancerPoolOrigin:LoadBalancerPoolOrigin"
                        },
                        "description": "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. It's a complex value. See description below.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpullRetention:LogpullRetention": {
            "description": "Allows management of the Logpull Retention settings used to control whether or not to retain HTTP request logs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpullRetention(\"example\", {\n    enabled: true,\n    zoneId: \"fb54f084ca7f7b732d3d3ecbd8ef7bf2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpullRetention(\"example\",\n    enabled=True,\n    zone_id=\"fb54f084ca7f7b732d3d3ecbd8ef7bf2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.LogpullRetention(\"example\", new()\n    {\n        Enabled = true,\n        ZoneId = \"fb54f084ca7f7b732d3d3ecbd8ef7bf2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogpullRetention(ctx, \"example\", \u0026cloudflare.LogpullRetentionArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tZoneId:  pulumi.String(\"fb54f084ca7f7b732d3d3ecbd8ef7bf2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LogpullRetention;\nimport com.pulumi.cloudflare.LogpullRetentionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LogpullRetention(\"example\", LogpullRetentionArgs.builder()        \n            .enabled(\"true\")\n            .zoneId(\"fb54f084ca7f7b732d3d3ecbd8ef7bf2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:LogpullRetention\n    properties:\n      enabled: 'true'\n      zoneId: fb54f084ca7f7b732d3d3ecbd8ef7bf2\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import existing Logpull Retention using the zone ID as the identifier.\n\n```sh\n $ pulumi import cloudflare:index/logpullRetention:LogpullRetention example fb54f084ca7f7b732d3d3ecbd8ef7bf2\n```\n\n ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to apply the log retention to.\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether you wish to retain logs or not.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID to apply the log retention to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpullRetention resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether you wish to retain logs or not.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID to apply the log retention to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpushJob:LogpushJob": {
            "description": "\n\n## Import\n\nImport an account-scoped job.\n\n```sh\n $ pulumi import cloudflare:index/logpushJob:LogpushJob example account/\u003caccount_id\u003e/\u003cjob_id\u003e\n```\n\n Import a zone-scoped job.\n\n```sh\n $ pulumi import cloudflare:index/logpushJob:LogpushJob example zone/\u003czone_id\u003e/\u003cjob_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination). Available values: `access_requests`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable the job.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of logpush job to create. Available values: `edge`, `instant-logs`, `\"\"`.\n"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                }
            },
            "required": [
                "dataset",
                "destinationConf"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination). Available values: `access_requests`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable the job.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of logpush job to create. Available values: `edge`, `instant-logs`, `\"\"`.\n"
                },
                "logpullOptions": {
                    "type": "string",
                    "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the logpush job to create.\n"
                },
                "ownershipChallenge": {
                    "type": "string",
                    "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                }
            },
            "requiredInputs": [
                "dataset",
                "destinationConf"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpushJob resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                    },
                    "dataset": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination). Available values: `access_requests`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`.\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable the job.\n"
                    },
                    "filter": {
                        "type": "string",
                        "description": "Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).\n"
                    },
                    "frequency": {
                        "type": "string",
                        "description": "A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.\n"
                    },
                    "kind": {
                        "type": "string",
                        "description": "The kind of logpush job to create. Available values: `edge`, `instant-logs`, `\"\"`.\n"
                    },
                    "logpullOptions": {
                        "type": "string",
                        "description": "Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpull options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the logpush job to create.\n"
                    },
                    "ownershipChallenge": {
                        "type": "string",
                        "description": "Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/logpushOwnershipChallenge:LogpushOwnershipChallenge": {
            "description": "Provides a resource which manages Cloudflare Logpush ownership challenges to use\nin a Logpush Job. On it's own, doesn't do much however this resource should\nbe used in conjunction to create Logpush jobs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpushOwnershipChallenge(\"example\", {\n    destinationConf: \"s3://my-bucket-path?region=us-west-2\",\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpushOwnershipChallenge(\"example\",\n    destination_conf=\"s3://my-bucket-path?region=us-west-2\",\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.LogpushOwnershipChallenge(\"example\", new()\n    {\n        DestinationConf = \"s3://my-bucket-path?region=us-west-2\",\n        ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogpushOwnershipChallenge(ctx, \"example\", \u0026cloudflare.LogpushOwnershipChallengeArgs{\n\t\t\tDestinationConf: pulumi.String(\"s3://my-bucket-path?region=us-west-2\"),\n\t\t\tZoneId:          pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LogpushOwnershipChallenge;\nimport com.pulumi.cloudflare.LogpushOwnershipChallengeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LogpushOwnershipChallenge(\"example\", LogpushOwnershipChallengeArgs.builder()        \n            .destinationConf(\"s3://my-bucket-path?region=us-west-2\")\n            .zoneId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:LogpushOwnershipChallenge\n    properties:\n      destinationConf: s3://my-bucket-path?region=us-west-2\n      zoneId: d41d8cd98f00b204e9800998ecf8427e\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.LogpushOwnershipChallenge(\"example\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    destinationConf: \"s3://my-bucket-path?region=us-west-2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.LogpushOwnershipChallenge(\"example\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    destination_conf=\"s3://my-bucket-path?region=us-west-2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.LogpushOwnershipChallenge(\"example\", new()\n    {\n        AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        DestinationConf = \"s3://my-bucket-path?region=us-west-2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewLogpushOwnershipChallenge(ctx, \"example\", \u0026cloudflare.LogpushOwnershipChallengeArgs{\n\t\t\tAccountId:       pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tDestinationConf: pulumi.String(\"s3://my-bucket-path?region=us-west-2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.LogpushOwnershipChallenge;\nimport com.pulumi.cloudflare.LogpushOwnershipChallengeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LogpushOwnershipChallenge(\"example\", LogpushOwnershipChallengeArgs.builder()        \n            .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .destinationConf(\"s3://my-bucket-path?region=us-west-2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:LogpushOwnershipChallenge\n    properties:\n      accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      destinationConf: s3://my-bucket-path?region=us-west-2\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n"
                },
                "ownershipChallengeFilename": {
                    "type": "string",
                    "description": "The filename of the ownership challenge which\ncontains the contents required for Logpush Job creation.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                }
            },
            "required": [
                "destinationConf",
                "ownershipChallengeFilename"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                },
                "destinationConf": {
                    "type": "string",
                    "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                }
            },
            "requiredInputs": [
                "destinationConf"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogpushOwnershipChallenge resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                    },
                    "destinationConf": {
                        "type": "string",
                        "description": "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination).\n",
                        "willReplaceOnChanges": true
                    },
                    "ownershipChallengeFilename": {
                        "type": "string",
                        "description": "The filename of the ownership challenge which\ncontains the contents required for Logpush Job creation.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID where the logpush ownership challenge should be created. Either `account_id` or `zone_id` are required.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset": {
            "description": "Magic Firewall is a network-level firewall to protect networks that are onboarded to Cloudflare's Magic Transit. This resource\ncreates a root ruleset on the account level and contains one or more rules. Rules can be crafted in Wireshark syntax and\nare evaluated in order, with the first rule having the highest priority.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.MagicFirewallRuleset(\"example\", {\n    accountId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    description: \"Global mitigations\",\n    name: \"Magic Transit Ruleset\",\n    rules: [\n        {\n            action: \"allow\",\n            description: \"Allow TCP Ephemeral Ports\",\n            enabled: \"true\",\n            expression: \"tcp.dstport in { 32768..65535 }\",\n        },\n        {\n            action: \"block\",\n            description: \"Block all\",\n            enabled: \"true\",\n            expression: \"ip.len \u003e= 0\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.MagicFirewallRuleset(\"example\",\n    account_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    description=\"Global mitigations\",\n    name=\"Magic Transit Ruleset\",\n    rules=[\n        {\n            \"action\": \"allow\",\n            \"description\": \"Allow TCP Ephemeral Ports\",\n            \"enabled\": \"true\",\n            \"expression\": \"tcp.dstport in { 32768..65535 }\",\n        },\n        {\n            \"action\": \"block\",\n            \"description\": \"Block all\",\n            \"enabled\": \"true\",\n            \"expression\": \"ip.len \u003e= 0\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.MagicFirewallRuleset(\"example\", new()\n    {\n        AccountId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        Description = \"Global mitigations\",\n        Name = \"Magic Transit Ruleset\",\n        Rules = new[]\n        {\n            \n            {\n                { \"action\", \"allow\" },\n                { \"description\", \"Allow TCP Ephemeral Ports\" },\n                { \"enabled\", \"true\" },\n                { \"expression\", \"tcp.dstport in { 32768..65535 }\" },\n            },\n            \n            {\n                { \"action\", \"block\" },\n                { \"description\", \"Block all\" },\n                { \"enabled\", \"true\" },\n                { \"expression\", \"ip.len \u003e= 0\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewMagicFirewallRuleset(ctx, \"example\", \u0026cloudflare.MagicFirewallRulesetArgs{\n\t\t\tAccountId:   pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tDescription: pulumi.String(\"Global mitigations\"),\n\t\t\tName:        pulumi.String(\"Magic Transit Ruleset\"),\n\t\t\tRules: pulumi.StringMapArray{\n\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\"action\":      pulumi.String(\"allow\"),\n\t\t\t\t\t\"description\": pulumi.String(\"Allow TCP Ephemeral Ports\"),\n\t\t\t\t\t\"enabled\":     pulumi.String(\"true\"),\n\t\t\t\t\t\"expression\":  pulumi.String(\"tcp.dstport in { 32768..65535 }\"),\n\t\t\t\t},\n\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\"action\":      pulumi.String(\"block\"),\n\t\t\t\t\t\"description\": pulumi.String(\"Block all\"),\n\t\t\t\t\t\"enabled\":     pulumi.String(\"true\"),\n\t\t\t\t\t\"expression\":  pulumi.String(\"ip.len \u003e= 0\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.MagicFirewallRuleset;\nimport com.pulumi.cloudflare.MagicFirewallRulesetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MagicFirewallRuleset(\"example\", MagicFirewallRulesetArgs.builder()        \n            .accountId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .description(\"Global mitigations\")\n            .name(\"Magic Transit Ruleset\")\n            .rules(            \n                Map.ofEntries(\n                    Map.entry(\"action\", \"allow\"),\n                    Map.entry(\"description\", \"Allow TCP Ephemeral Ports\"),\n                    Map.entry(\"enabled\", \"true\"),\n                    Map.entry(\"expression\", \"tcp.dstport in { 32768..65535 }\")\n                ),\n                Map.ofEntries(\n                    Map.entry(\"action\", \"block\"),\n                    Map.entry(\"description\", \"Block all\"),\n                    Map.entry(\"enabled\", \"true\"),\n                    Map.entry(\"expression\", \"ip.len \u003e= 0\")\n                ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:MagicFirewallRuleset\n    properties:\n      accountId: d41d8cd98f00b204e9800998ecf8427e\n      description: Global mitigations\n      name: Magic Transit Ruleset\n      rules:\n        - action: allow\n          description: Allow TCP Ephemeral Ports\n          enabled: 'true'\n          expression: tcp.dstport in { 32768..65535 }\n        - action: block\n          description: Block all\n          enabled: 'true'\n          expression: ip.len \u003e= 0\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing Magic Firewall Ruleset can be imported using the account ID and ruleset ID\n\n```sh\n $ pulumi import cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ruleset.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the ruleset is being created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that can be used to annotate the rule.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ruleset.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MagicFirewallRuleset resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the ruleset is being created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that can be used to annotate the rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ruleset.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/managedHeaders:ManagedHeaders": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Enable security headers using Managed Meaders\nconst example = new cloudflare.ManagedHeaders(\"example\", {\n    managedRequestHeaders: [{\n        enabled: true,\n        id: \"add_true_client_ip_headers\",\n    }],\n    managedResponseHeaders: [{\n        enabled: true,\n        id: \"remove_x-powered-by_header\",\n    }],\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Enable security headers using Managed Meaders\nexample = cloudflare.ManagedHeaders(\"example\",\n    managed_request_headers=[cloudflare.ManagedHeadersManagedRequestHeaderArgs(\n        enabled=True,\n        id=\"add_true_client_ip_headers\",\n    )],\n    managed_response_headers=[cloudflare.ManagedHeadersManagedResponseHeaderArgs(\n        enabled=True,\n        id=\"remove_x-powered-by_header\",\n    )],\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Enable security headers using Managed Meaders\n    var example = new Cloudflare.ManagedHeaders(\"example\", new()\n    {\n        ManagedRequestHeaders = new[]\n        {\n            new Cloudflare.Inputs.ManagedHeadersManagedRequestHeaderArgs\n            {\n                Enabled = true,\n                Id = \"add_true_client_ip_headers\",\n            },\n        },\n        ManagedResponseHeaders = new[]\n        {\n            new Cloudflare.Inputs.ManagedHeadersManagedResponseHeaderArgs\n            {\n                Enabled = true,\n                Id = \"remove_x-powered-by_header\",\n            },\n        },\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewManagedHeaders(ctx, \"example\", \u0026cloudflare.ManagedHeadersArgs{\n\t\t\tManagedRequestHeaders: cloudflare.ManagedHeadersManagedRequestHeaderArray{\n\t\t\t\t\u0026cloudflare.ManagedHeadersManagedRequestHeaderArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tId:      pulumi.String(\"add_true_client_ip_headers\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tManagedResponseHeaders: cloudflare.ManagedHeadersManagedResponseHeaderArray{\n\t\t\t\t\u0026cloudflare.ManagedHeadersManagedResponseHeaderArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t\tId:      pulumi.String(\"remove_x-powered-by_header\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ManagedHeaders;\nimport com.pulumi.cloudflare.ManagedHeadersArgs;\nimport com.pulumi.cloudflare.inputs.ManagedHeadersManagedRequestHeaderArgs;\nimport com.pulumi.cloudflare.inputs.ManagedHeadersManagedResponseHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ManagedHeaders(\"example\", ManagedHeadersArgs.builder()        \n            .managedRequestHeaders(ManagedHeadersManagedRequestHeaderArgs.builder()\n                .enabled(true)\n                .id(\"add_true_client_ip_headers\")\n                .build())\n            .managedResponseHeaders(ManagedHeadersManagedResponseHeaderArgs.builder()\n                .enabled(true)\n                .id(\"remove_x-powered-by_header\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Enable security headers using Managed Meaders\n  example:\n    type: cloudflare:ManagedHeaders\n    properties:\n      managedRequestHeaders:\n        - enabled: true\n          id: add_true_client_ip_headers\n      managedResponseHeaders:\n        - enabled: true\n          id: remove_x-powered-by_header\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport is not supported for this resource. ",
            "properties": {
                "managedRequestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader"
                    },
                    "description": "The list of managed request headers.\n"
                },
                "managedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader"
                    },
                    "description": "The list of managed response headers.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "managedRequestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader"
                    },
                    "description": "The list of managed request headers.\n"
                },
                "managedResponseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader"
                    },
                    "description": "The list of managed response headers.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedHeaders resources.\n",
                "properties": {
                    "managedRequestHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ManagedHeadersManagedRequestHeader:ManagedHeadersManagedRequestHeader"
                        },
                        "description": "The list of managed request headers.\n"
                    },
                    "managedResponseHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ManagedHeadersManagedResponseHeader:ManagedHeadersManagedResponseHeader"
                        },
                        "description": "The list of managed response headers.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/notificationPolicy:NotificationPolicy": {
            "description": "Provides a resource, that manages a notification policy for\nCloudflare's products. The delivery mechanisms supported are email,\nwebhooks, and PagerDuty.\n\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/notificationPolicy:NotificationPolicy example \u003caccount_id\u003e/\u003cpolicy_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "alertType": {
                    "type": "string",
                    "description": "The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `billing_usage_alert`, `health_check_status_notification`, `g6_pool_toggle_alert`, `real_origin_monitoring`, `universal_ssl_event_type`, `dedicated_ssl_certificate_event_type`, `custom_ssl_certificate_event_type`, `access_custom_certificate_expiration_type`, `zone_aop_custom_certificate_expiration_type`, `bgp_hijack_notification`, `http_alert_origin_error`, `workers_alert`, `weekly_account_overview`, `expiring_service_token_alert`, `secondary_dns_all_primaries_failing`, `secondary_dns_zone_validation_warning`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `dos_attack_l7`, `dos_attack_l4`, `advanced_ddos_attack_l7_alert`, `advanced_ddos_attack_l4_alert`, `fbm_volumetric_attack`, `fbm_auto_advertisement`, `load_balancing_pool_enablement_alert`, `load_balancing_health_alert`, `g6_health_alert`, `http_alert_edge_error`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `failing_logpush_job_disabled_alert`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_scripts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_max_length_script_url`, `scriptmonitor_alert_new_malicious_hosts`, `sentinel_alert`, `hostname_aop_custom_certificate_expiration_type`, `stream_live_notifications`, `block_notification_new_block`, `block_notification_review_rejected`, `block_notification_review_accepted`, `web_analytics_metrics_update`, `workers_uptime`.\n"
                },
                "created": {
                    "type": "string",
                    "description": "When the notification policy was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the notification policy.\n"
                },
                "emailIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                    },
                    "description": "The email id to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "The status of the notification policy.\n"
                },
                "filters": {
                    "$ref": "#/types/cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters",
                    "description": "An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).\n"
                },
                "modified": {
                    "type": "string",
                    "description": "When the notification policy was last modified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n"
                },
                "pagerdutyIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                    },
                    "description": "The unique id of a configured pagerduty endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "webhooksIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                    },
                    "description": "The unique id of a configured webhooks endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                }
            },
            "required": [
                "accountId",
                "alertType",
                "created",
                "enabled",
                "modified",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "alertType": {
                    "type": "string",
                    "description": "The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `billing_usage_alert`, `health_check_status_notification`, `g6_pool_toggle_alert`, `real_origin_monitoring`, `universal_ssl_event_type`, `dedicated_ssl_certificate_event_type`, `custom_ssl_certificate_event_type`, `access_custom_certificate_expiration_type`, `zone_aop_custom_certificate_expiration_type`, `bgp_hijack_notification`, `http_alert_origin_error`, `workers_alert`, `weekly_account_overview`, `expiring_service_token_alert`, `secondary_dns_all_primaries_failing`, `secondary_dns_zone_validation_warning`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `dos_attack_l7`, `dos_attack_l4`, `advanced_ddos_attack_l7_alert`, `advanced_ddos_attack_l4_alert`, `fbm_volumetric_attack`, `fbm_auto_advertisement`, `load_balancing_pool_enablement_alert`, `load_balancing_health_alert`, `g6_health_alert`, `http_alert_edge_error`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `failing_logpush_job_disabled_alert`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_scripts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_max_length_script_url`, `scriptmonitor_alert_new_malicious_hosts`, `sentinel_alert`, `hostname_aop_custom_certificate_expiration_type`, `stream_live_notifications`, `block_notification_new_block`, `block_notification_review_rejected`, `block_notification_review_accepted`, `web_analytics_metrics_update`, `workers_uptime`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the notification policy.\n"
                },
                "emailIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                    },
                    "description": "The email id to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "The status of the notification policy.\n"
                },
                "filters": {
                    "$ref": "#/types/cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters",
                    "description": "An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the notification policy.\n"
                },
                "pagerdutyIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                    },
                    "description": "The unique id of a configured pagerduty endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                },
                "webhooksIntegrations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                    },
                    "description": "The unique id of a configured webhooks endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "alertType",
                "enabled",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationPolicy resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "alertType": {
                        "type": "string",
                        "description": "The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `billing_usage_alert`, `health_check_status_notification`, `g6_pool_toggle_alert`, `real_origin_monitoring`, `universal_ssl_event_type`, `dedicated_ssl_certificate_event_type`, `custom_ssl_certificate_event_type`, `access_custom_certificate_expiration_type`, `zone_aop_custom_certificate_expiration_type`, `bgp_hijack_notification`, `http_alert_origin_error`, `workers_alert`, `weekly_account_overview`, `expiring_service_token_alert`, `secondary_dns_all_primaries_failing`, `secondary_dns_zone_validation_warning`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `dos_attack_l7`, `dos_attack_l4`, `advanced_ddos_attack_l7_alert`, `advanced_ddos_attack_l4_alert`, `fbm_volumetric_attack`, `fbm_auto_advertisement`, `load_balancing_pool_enablement_alert`, `load_balancing_health_alert`, `g6_health_alert`, `http_alert_edge_error`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `failing_logpush_job_disabled_alert`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_scripts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_max_length_script_url`, `scriptmonitor_alert_new_malicious_hosts`, `sentinel_alert`, `hostname_aop_custom_certificate_expiration_type`, `stream_live_notifications`, `block_notification_new_block`, `block_notification_review_rejected`, `block_notification_review_accepted`, `web_analytics_metrics_update`, `workers_uptime`.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "When the notification policy was created.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the notification policy.\n"
                    },
                    "emailIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyEmailIntegration:NotificationPolicyEmailIntegration"
                        },
                        "description": "The email id to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "The status of the notification policy.\n"
                    },
                    "filters": {
                        "$ref": "#/types/cloudflare:index/NotificationPolicyFilters:NotificationPolicyFilters",
                        "description": "An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).\n"
                    },
                    "modified": {
                        "type": "string",
                        "description": "When the notification policy was last modified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the notification policy.\n"
                    },
                    "pagerdutyIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyPagerdutyIntegration:NotificationPolicyPagerdutyIntegration"
                        },
                        "description": "The unique id of a configured pagerduty endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                    },
                    "webhooksIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/NotificationPolicyWebhooksIntegration:NotificationPolicyWebhooksIntegration"
                        },
                        "description": "The unique id of a configured webhooks endpoint to which the notification should be dispatched. One of email, webhooks, or PagerDuty mechanisms is required.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks": {
            "description": "Provides a resource, that manages a webhook destination. These destinations can be tied to the notification policies created for Cloudflare's products.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.NotificationPolicyWebhooks(\"example\", {\n    accountId: \"c4a7362d577a6c3019a474fd6f485821\",\n    name: \"Webhooks destination\",\n    secret: \"my-secret\",\n    url: \"https://example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.NotificationPolicyWebhooks(\"example\",\n    account_id=\"c4a7362d577a6c3019a474fd6f485821\",\n    name=\"Webhooks destination\",\n    secret=\"my-secret\",\n    url=\"https://example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.NotificationPolicyWebhooks(\"example\", new()\n    {\n        AccountId = \"c4a7362d577a6c3019a474fd6f485821\",\n        Name = \"Webhooks destination\",\n        Secret = \"my-secret\",\n        Url = \"https://example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewNotificationPolicyWebhooks(ctx, \"example\", \u0026cloudflare.NotificationPolicyWebhooksArgs{\n\t\t\tAccountId: pulumi.String(\"c4a7362d577a6c3019a474fd6f485821\"),\n\t\t\tName:      pulumi.String(\"Webhooks destination\"),\n\t\t\tSecret:    pulumi.String(\"my-secret\"),\n\t\t\tUrl:       pulumi.String(\"https://example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.NotificationPolicyWebhooks;\nimport com.pulumi.cloudflare.NotificationPolicyWebhooksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new NotificationPolicyWebhooks(\"example\", NotificationPolicyWebhooksArgs.builder()        \n            .accountId(\"c4a7362d577a6c3019a474fd6f485821\")\n            .name(\"Webhooks destination\")\n            .secret(\"my-secret\")\n            .url(\"https://example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:NotificationPolicyWebhooks\n    properties:\n      accountId: c4a7362d577a6c3019a474fd6f485821\n      name: Webhooks destination\n      secret: my-secret\n      url: https://example.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing notification policy can be imported using the account ID and the webhook ID\n\n```sh\n $ pulumi import cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks example 72c379d136459405d964d27aa0f18605/c4a7362d577a6c3019a474fd6f485821\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account for which the webhook destination has to be connected.\n"
                },
                "createdAt": {
                    "type": "string"
                },
                "lastFailure": {
                    "type": "string"
                },
                "lastSuccess": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the webhook destination.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification.\nSecrets are not returned in any API response body.\nRefer to the documentation for more details - https://api.cloudflare.com/#notification-webhooks-create-webhook.\n"
                },
                "type": {
                    "type": "string"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the webhook destinations.\n"
                }
            },
            "required": [
                "accountId",
                "createdAt",
                "lastFailure",
                "lastSuccess",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account for which the webhook destination has to be connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the webhook destination.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification.\nSecrets are not returned in any API response body.\nRefer to the documentation for more details - https://api.cloudflare.com/#notification-webhooks-create-webhook.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the webhook destinations.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationPolicyWebhooks resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account for which the webhook destination has to be connected.\n"
                    },
                    "createdAt": {
                        "type": "string"
                    },
                    "lastFailure": {
                        "type": "string"
                    },
                    "lastSuccess": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the webhook destination.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification.\nSecrets are not returned in any API response body.\nRefer to the documentation for more details - https://api.cloudflare.com/#notification-webhooks-create-webhook.\n"
                    },
                    "type": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the webhook destinations.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/originCaCertificate:OriginCaCertificate": {
            "description": "Provides a Cloudflare Origin CA certificate used to protect traffic to your origin without involving a third party Certificate Authority.\n\n\u003e This resource requires you use your Origin CA Key as the\n`api_user_service_key` value.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as tls from \"@pulumi/tls\";\n\n// Create a CSR and generate a CA certificate\nconst examplePrivateKey = new tls.PrivateKey(\"examplePrivateKey\", {algorithm: \"RSA\"});\nconst exampleCertRequest = new tls.CertRequest(\"exampleCertRequest\", {\n    keyAlgorithm: examplePrivateKey.algorithm,\n    privateKeyPem: examplePrivateKey.privateKeyPem,\n    subject: {\n        commonName: \"\",\n        organization: \"Terraform Test\",\n    },\n});\nconst exampleOriginCaCertificate = new cloudflare.OriginCaCertificate(\"exampleOriginCaCertificate\", {\n    csr: exampleCertRequest.certRequestPem,\n    hostnames: [\"example.com\"],\n    requestType: \"origin-rsa\",\n    requestedValidity: 7,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_tls as tls\n\n# Create a CSR and generate a CA certificate\nexample_private_key = tls.PrivateKey(\"examplePrivateKey\", algorithm=\"RSA\")\nexample_cert_request = tls.CertRequest(\"exampleCertRequest\",\n    key_algorithm=example_private_key.algorithm,\n    private_key_pem=example_private_key.private_key_pem,\n    subject=tls.CertRequestSubjectArgs(\n        common_name=\"\",\n        organization=\"Terraform Test\",\n    ))\nexample_origin_ca_certificate = cloudflare.OriginCaCertificate(\"exampleOriginCaCertificate\",\n    csr=example_cert_request.cert_request_pem,\n    hostnames=[\"example.com\"],\n    request_type=\"origin-rsa\",\n    requested_validity=7)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Tls = Pulumi.Tls;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a CSR and generate a CA certificate\n    var examplePrivateKey = new Tls.PrivateKey(\"examplePrivateKey\", new()\n    {\n        Algorithm = \"RSA\",\n    });\n\n    var exampleCertRequest = new Tls.CertRequest(\"exampleCertRequest\", new()\n    {\n        KeyAlgorithm = examplePrivateKey.Algorithm,\n        PrivateKeyPem = examplePrivateKey.PrivateKeyPem,\n        Subject = new Tls.Inputs.CertRequestSubjectArgs\n        {\n            CommonName = \"\",\n            Organization = \"Terraform Test\",\n        },\n    });\n\n    var exampleOriginCaCertificate = new Cloudflare.OriginCaCertificate(\"exampleOriginCaCertificate\", new()\n    {\n        Csr = exampleCertRequest.CertRequestPem,\n        Hostnames = new[]\n        {\n            \"example.com\",\n        },\n        RequestType = \"origin-rsa\",\n        RequestedValidity = 7,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-tls/sdk/v4/go/tls\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePrivateKey, err := tls.NewPrivateKey(ctx, \"examplePrivateKey\", \u0026tls.PrivateKeyArgs{\n\t\t\tAlgorithm: pulumi.String(\"RSA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCertRequest, err := tls.NewCertRequest(ctx, \"exampleCertRequest\", \u0026tls.CertRequestArgs{\n\t\t\tKeyAlgorithm:  examplePrivateKey.Algorithm,\n\t\t\tPrivateKeyPem: examplePrivateKey.PrivateKeyPem,\n\t\t\tSubject: \u0026tls.CertRequestSubjectArgs{\n\t\t\t\tCommonName:   pulumi.String(\"\"),\n\t\t\t\tOrganization: pulumi.String(\"Terraform Test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewOriginCaCertificate(ctx, \"exampleOriginCaCertificate\", \u0026cloudflare.OriginCaCertificateArgs{\n\t\t\tCsr: exampleCertRequest.CertRequestPem,\n\t\t\tHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t},\n\t\t\tRequestType:       pulumi.String(\"origin-rsa\"),\n\t\t\tRequestedValidity: pulumi.Int(7),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.tls.PrivateKey;\nimport com.pulumi.tls.PrivateKeyArgs;\nimport com.pulumi.tls.CertRequest;\nimport com.pulumi.tls.CertRequestArgs;\nimport com.pulumi.tls.inputs.CertRequestSubjectArgs;\nimport com.pulumi.cloudflare.OriginCaCertificate;\nimport com.pulumi.cloudflare.OriginCaCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var examplePrivateKey = new PrivateKey(\"examplePrivateKey\", PrivateKeyArgs.builder()        \n            .algorithm(\"RSA\")\n            .build());\n\n        var exampleCertRequest = new CertRequest(\"exampleCertRequest\", CertRequestArgs.builder()        \n            .keyAlgorithm(examplePrivateKey.algorithm())\n            .privateKeyPem(examplePrivateKey.privateKeyPem())\n            .subject(CertRequestSubjectArgs.builder()\n                .commonName(\"\")\n                .organization(\"Terraform Test\")\n                .build())\n            .build());\n\n        var exampleOriginCaCertificate = new OriginCaCertificate(\"exampleOriginCaCertificate\", OriginCaCertificateArgs.builder()        \n            .csr(exampleCertRequest.certRequestPem())\n            .hostnames(\"example.com\")\n            .requestType(\"origin-rsa\")\n            .requestedValidity(7)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a CSR and generate a CA certificate\n  examplePrivateKey:\n    type: tls:PrivateKey\n    properties:\n      algorithm: RSA\n  exampleCertRequest:\n    type: tls:CertRequest\n    properties:\n      keyAlgorithm: ${examplePrivateKey.algorithm}\n      privateKeyPem: ${examplePrivateKey.privateKeyPem}\n      subject:\n        commonName:\n        organization: Terraform Test\n  exampleOriginCaCertificate:\n    type: cloudflare:OriginCaCertificate\n    properties:\n      csr: ${exampleCertRequest.certRequestPem}\n      hostnames:\n        - example.com\n      requestType: origin-rsa\n      requestedValidity: 7\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/originCaCertificate:OriginCaCertificate example \u003ccertificate_id\u003e\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "The Origin CA certificate.\n"
                },
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "expiresOn": {
                    "type": "string",
                    "description": "The datetime when the certificate will expire.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "minDaysForRenewal": {
                    "type": "integer",
                    "description": "Number of days prior to the expiry to trigger a renewal of the certificate if a Terraform operation is run.\n"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "certificate",
                "expiresOn",
                "hostnames",
                "requestType",
                "requestedValidity"
            ],
            "inputProperties": {
                "csr": {
                    "type": "string",
                    "description": "The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "minDaysForRenewal": {
                    "type": "integer",
                    "description": "Number of days prior to the expiry to trigger a renewal of the certificate if a Terraform operation is run.\n"
                },
                "requestType": {
                    "type": "string",
                    "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "requestedValidity": {
                    "type": "integer",
                    "description": "The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostnames",
                "requestType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OriginCaCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "The Origin CA certificate.\n"
                    },
                    "csr": {
                        "type": "string",
                        "description": "The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresOn": {
                        "type": "string",
                        "description": "The datetime when the certificate will expire.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "minDaysForRenewal": {
                        "type": "integer",
                        "description": "Number of days prior to the expiry to trigger a renewal of the certificate if a Terraform operation is run.\n"
                    },
                    "requestType": {
                        "type": "string",
                        "description": "The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "requestedValidity": {
                        "type": "integer",
                        "description": "The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pageRule:PageRule": {
            "description": "Provides a Cloudflare page rule resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a page rule to the domain\nconst foobar = new cloudflare.PageRule(\"foobar\", {\n    zoneId: _var.cloudflare_zone_id,\n    target: `sub.${_var.cloudflare_zone}/page`,\n    priority: 1,\n    actions: {\n        ssl: \"flexible\",\n        emailObfuscation: \"on\",\n        minifies: [{\n            html: \"off\",\n            css: \"on\",\n            js: \"on\",\n        }],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a page rule to the domain\nfoobar = cloudflare.PageRule(\"foobar\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    target=f\"sub.{var['cloudflare_zone']}/page\",\n    priority=1,\n    actions=cloudflare.PageRuleActionsArgs(\n        ssl=\"flexible\",\n        email_obfuscation=\"on\",\n        minifies=[cloudflare.PageRuleActionsMinifyArgs(\n            html=\"off\",\n            css=\"on\",\n            js=\"on\",\n        )],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Add a page rule to the domain\n    var foobar = new Cloudflare.PageRule(\"foobar\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Target = $\"sub.{@var.Cloudflare_zone}/page\",\n        Priority = 1,\n        Actions = new Cloudflare.Inputs.PageRuleActionsArgs\n        {\n            Ssl = \"flexible\",\n            EmailObfuscation = \"on\",\n            Minifies = new[]\n            {\n                new Cloudflare.Inputs.PageRuleActionsMinifyArgs\n                {\n                    Html = \"off\",\n                    Css = \"on\",\n                    Js = \"on\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewPageRule(ctx, \"foobar\", \u0026cloudflare.PageRuleArgs{\n\t\t\tZoneId:   pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tTarget:   pulumi.String(fmt.Sprintf(\"sub.%v/page\", _var.Cloudflare_zone)),\n\t\t\tPriority: pulumi.Int(1),\n\t\t\tActions: \u0026cloudflare.PageRuleActionsArgs{\n\t\t\t\tSsl:              pulumi.String(\"flexible\"),\n\t\t\t\tEmailObfuscation: pulumi.String(\"on\"),\n\t\t\t\tMinifies: cloudflare.PageRuleActionsMinifyArray{\n\t\t\t\t\t\u0026cloudflare.PageRuleActionsMinifyArgs{\n\t\t\t\t\t\tHtml: pulumi.String(\"off\"),\n\t\t\t\t\t\tCss:  pulumi.String(\"on\"),\n\t\t\t\t\t\tJs:   pulumi.String(\"on\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.PageRule;\nimport com.pulumi.cloudflare.PageRuleArgs;\nimport com.pulumi.cloudflare.inputs.PageRuleActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foobar = new PageRule(\"foobar\", PageRuleArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .target(String.format(\"sub.%s/page\", var_.cloudflare_zone()))\n            .priority(1)\n            .actions(PageRuleActionsArgs.builder()\n                .ssl(\"flexible\")\n                .emailObfuscation(\"on\")\n                .minifies(PageRuleActionsMinifyArgs.builder()\n                    .html(\"off\")\n                    .css(\"on\")\n                    .js(\"on\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Add a page rule to the domain\n  foobar:\n    type: cloudflare:PageRule\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      target: sub.${var.cloudflare_zone}/page\n      priority: 1\n      actions:\n        ssl: flexible\n        emailObfuscation: on\n        minifies:\n          - html: off\n            css: on\n            js: on\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPage rules can be imported using a composite ID formed of zone ID and page rule ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/pageRule:PageRule default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43\n```\n\n ",
            "properties": {
                "actions": {
                    "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n"
                }
            },
            "required": [
                "actions",
                "target",
                "zoneId"
            ],
            "inputProperties": {
                "actions": {
                    "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                    "description": "The actions taken by the page rule, options given below.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Whether the page rule is active or disabled.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The URL pattern to target with the page rule.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the page rule should be added.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "actions",
                "target",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PageRule resources.\n",
                "properties": {
                    "actions": {
                        "$ref": "#/types/cloudflare:index/PageRuleActions:PageRuleActions",
                        "description": "The actions taken by the page rule, options given below.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Whether the page rule is active or disabled.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The URL pattern to target with the page rule.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the page rule should be added.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pagesDomain:PagesDomain": {
            "description": "Provides a resource for managing Cloudflare Pages domains.\n\n\u003e A DNS record for the domain is not automatically created. You need to create a `cloudflare.Record` resource for the domain you want to use.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst my_domain = new cloudflare.PagesDomain(\"my-domain\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    domain: \"example.com\",\n    projectName: \"my-example-project\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_domain = cloudflare.PagesDomain(\"my-domain\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    domain=\"example.com\",\n    project_name=\"my-example-project\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_domain = new Cloudflare.PagesDomain(\"my-domain\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Domain = \"example.com\",\n        ProjectName = \"my-example-project\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewPagesDomain(ctx, \"my-domain\", \u0026cloudflare.PagesDomainArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tDomain:      pulumi.String(\"example.com\"),\n\t\t\tProjectName: pulumi.String(\"my-example-project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.PagesDomain;\nimport com.pulumi.cloudflare.PagesDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var my_domain = new PagesDomain(\"my-domain\", PagesDomainArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .domain(\"example.com\")\n            .projectName(\"my-example-project\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  my-domain:\n    type: cloudflare:PagesDomain\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      domain: example.com\n      projectName: my-example-project\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/pagesDomain:PagesDomain example \u003caccount_id\u003e/\u003cproject_name\u003e/\u003cdomain-name\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "domain": {
                    "type": "string",
                    "description": "Custom domain. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "projectName": {
                    "type": "string",
                    "description": "Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the custom domain.\n"
                }
            },
            "required": [
                "accountId",
                "domain",
                "projectName",
                "status"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "domain": {
                    "type": "string",
                    "description": "Custom domain. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "projectName": {
                    "type": "string",
                    "description": "Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "domain",
                "projectName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PagesDomain resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "domain": {
                        "type": "string",
                        "description": "Custom domain. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "projectName": {
                        "type": "string",
                        "description": "Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the custom domain.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/pagesProject:PagesProject": {
            "description": "Provides a resource which manages Cloudflare Pages projects.\n\n\u003e If you are using a `source` block configuration, you must first have a\nconnected GitHub or GitLab account connected to Cloudflare. See the\n[Getting Started with Pages] documentation on how to link your accounts.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Basic project\nconst basicProject = new cloudflare.PagesProject(\"basicProject\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"this-is-my-project-01\",\n    productionBranch: \"main\",\n});\n// Manage build config\nconst buildConfig = new cloudflare.PagesProject(\"buildConfig\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    buildConfig: {\n        buildCommand: \"npm run build\",\n        destinationDir: \"build\",\n        rootDir: \"/\",\n        webAnalyticsTag: \"cee1c73f6e4743d0b5e6bb1a0bcaabcc\",\n        webAnalyticsToken: \"021e1057c18547eca7b79f2516f06o7x\",\n    },\n    name: \"this-is-my-project-01\",\n    productionBranch: \"main\",\n});\n// Manage project source\nconst sourceConfig = new cloudflare.PagesProject(\"sourceConfig\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"this-is-my-project-01\",\n    productionBranch: \"main\",\n    source: {\n        config: {\n            deploymentsEnabled: true,\n            owner: \"cloudflare\",\n            prCommentsEnabled: true,\n            previewBranchExcludes: [\n                \"main\",\n                \"prod\",\n            ],\n            previewBranchIncludes: [\n                \"dev\",\n                \"preview\",\n            ],\n            previewDeploymentSetting: \"custom\",\n            productionBranch: \"main\",\n            productionDeploymentEnabled: true,\n            repoName: \"ninjakittens\",\n        },\n        type: \"github\",\n    },\n});\n// Manage deployment configs\nconst deploymentConfigs = new cloudflare.PagesProject(\"deploymentConfigs\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    deploymentConfigs: {\n        preview: {\n            compatibilityDate: \"2022-08-15\",\n            compatibilityFlags: [\"preview_flag\"],\n            d1Databases: {\n                D1BINDING: \"445e2955-951a-4358-a35b-a4d0c813f63\",\n            },\n            durableObjectNamespaces: {\n                DOBINDING: \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n            },\n            environmentVariables: {\n                ENVIRONMENT: \"preview\",\n            },\n            kvNamespaces: {\n                KVBINDING: \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n            },\n            r2Buckets: {\n                R2BINDING: \"some-bucket\",\n            },\n        },\n        production: {\n            compatibilityDate: \"2022-08-16\",\n            compatibilityFlags: [\n                \"production_flag\",\n                \"second flag\",\n            ],\n            d1Databases: {\n                D1BINDING1: \"445e2955-951a-4358-a35b-a4d0c813f63\",\n                D1BINDING2: \"a399414b-c697-409a-a688-377db6433cd9\",\n            },\n            durableObjectNamespaces: {\n                DOBINDING1: \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n                DOBINDING2: \"3cdca5f8bb22bc390deee10ebbb36be5\",\n            },\n            environmentVariables: {\n                ENVIRONMENT: \"production\",\n                OTHERVALUE: \"other value\",\n            },\n            kvNamespaces: {\n                KVBINDING1: \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n                KVBINDING2: \"3cdca5f8bb22bc390deee10ebbb36be5\",\n            },\n            r2Buckets: {\n                R2BINDING1: \"some-bucket\",\n                R2BINDING2: \"other-bucket\",\n            },\n        },\n    },\n    name: \"this-is-my-project-01\",\n    productionBranch: \"main\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Basic project\nbasic_project = cloudflare.PagesProject(\"basicProject\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"this-is-my-project-01\",\n    production_branch=\"main\")\n# Manage build config\nbuild_config = cloudflare.PagesProject(\"buildConfig\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    build_config=cloudflare.PagesProjectBuildConfigArgs(\n        build_command=\"npm run build\",\n        destination_dir=\"build\",\n        root_dir=\"/\",\n        web_analytics_tag=\"cee1c73f6e4743d0b5e6bb1a0bcaabcc\",\n        web_analytics_token=\"021e1057c18547eca7b79f2516f06o7x\",\n    ),\n    name=\"this-is-my-project-01\",\n    production_branch=\"main\")\n# Manage project source\nsource_config = cloudflare.PagesProject(\"sourceConfig\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"this-is-my-project-01\",\n    production_branch=\"main\",\n    source=cloudflare.PagesProjectSourceArgs(\n        config=cloudflare.PagesProjectSourceConfigArgs(\n            deployments_enabled=True,\n            owner=\"cloudflare\",\n            pr_comments_enabled=True,\n            preview_branch_excludes=[\n                \"main\",\n                \"prod\",\n            ],\n            preview_branch_includes=[\n                \"dev\",\n                \"preview\",\n            ],\n            preview_deployment_setting=\"custom\",\n            production_branch=\"main\",\n            production_deployment_enabled=True,\n            repo_name=\"ninjakittens\",\n        ),\n        type=\"github\",\n    ))\n# Manage deployment configs\ndeployment_configs = cloudflare.PagesProject(\"deploymentConfigs\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    deployment_configs=cloudflare.PagesProjectDeploymentConfigsArgs(\n        preview=cloudflare.PagesProjectDeploymentConfigsPreviewArgs(\n            compatibility_date=\"2022-08-15\",\n            compatibility_flags=[\"preview_flag\"],\n            d1_databases={\n                \"D1BINDING\": \"445e2955-951a-4358-a35b-a4d0c813f63\",\n            },\n            durable_object_namespaces={\n                \"DOBINDING\": \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n            },\n            environment_variables={\n                \"ENVIRONMENT\": \"preview\",\n            },\n            kv_namespaces={\n                \"KVBINDING\": \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n            },\n            r2_buckets={\n                \"R2BINDING\": \"some-bucket\",\n            },\n        ),\n        production=cloudflare.PagesProjectDeploymentConfigsProductionArgs(\n            compatibility_date=\"2022-08-16\",\n            compatibility_flags=[\n                \"production_flag\",\n                \"second flag\",\n            ],\n            d1_databases={\n                \"D1BINDING1\": \"445e2955-951a-4358-a35b-a4d0c813f63\",\n                \"D1BINDING2\": \"a399414b-c697-409a-a688-377db6433cd9\",\n            },\n            durable_object_namespaces={\n                \"DOBINDING1\": \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n                \"DOBINDING2\": \"3cdca5f8bb22bc390deee10ebbb36be5\",\n            },\n            environment_variables={\n                \"ENVIRONMENT\": \"production\",\n                \"OTHERVALUE\": \"other value\",\n            },\n            kv_namespaces={\n                \"KVBINDING1\": \"5eb63bbbe01eeed093cb22bb8f5acdc3\",\n                \"KVBINDING2\": \"3cdca5f8bb22bc390deee10ebbb36be5\",\n            },\n            r2_buckets={\n                \"R2BINDING1\": \"some-bucket\",\n                \"R2BINDING2\": \"other-bucket\",\n            },\n        ),\n    ),\n    name=\"this-is-my-project-01\",\n    production_branch=\"main\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic project\n    var basicProject = new Cloudflare.PagesProject(\"basicProject\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"this-is-my-project-01\",\n        ProductionBranch = \"main\",\n    });\n\n    // Manage build config\n    var buildConfig = new Cloudflare.PagesProject(\"buildConfig\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        BuildConfig = new Cloudflare.Inputs.PagesProjectBuildConfigArgs\n        {\n            BuildCommand = \"npm run build\",\n            DestinationDir = \"build\",\n            RootDir = \"/\",\n            WebAnalyticsTag = \"cee1c73f6e4743d0b5e6bb1a0bcaabcc\",\n            WebAnalyticsToken = \"021e1057c18547eca7b79f2516f06o7x\",\n        },\n        Name = \"this-is-my-project-01\",\n        ProductionBranch = \"main\",\n    });\n\n    // Manage project source\n    var sourceConfig = new Cloudflare.PagesProject(\"sourceConfig\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"this-is-my-project-01\",\n        ProductionBranch = \"main\",\n        Source = new Cloudflare.Inputs.PagesProjectSourceArgs\n        {\n            Config = new Cloudflare.Inputs.PagesProjectSourceConfigArgs\n            {\n                DeploymentsEnabled = true,\n                Owner = \"cloudflare\",\n                PrCommentsEnabled = true,\n                PreviewBranchExcludes = new[]\n                {\n                    \"main\",\n                    \"prod\",\n                },\n                PreviewBranchIncludes = new[]\n                {\n                    \"dev\",\n                    \"preview\",\n                },\n                PreviewDeploymentSetting = \"custom\",\n                ProductionBranch = \"main\",\n                ProductionDeploymentEnabled = true,\n                RepoName = \"ninjakittens\",\n            },\n            Type = \"github\",\n        },\n    });\n\n    // Manage deployment configs\n    var deploymentConfigs = new Cloudflare.PagesProject(\"deploymentConfigs\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        DeploymentConfigs = new Cloudflare.Inputs.PagesProjectDeploymentConfigsArgs\n        {\n            Preview = new Cloudflare.Inputs.PagesProjectDeploymentConfigsPreviewArgs\n            {\n                CompatibilityDate = \"2022-08-15\",\n                CompatibilityFlags = new[]\n                {\n                    \"preview_flag\",\n                },\n                D1Databases = \n                {\n                    { \"D1BINDING\", \"445e2955-951a-4358-a35b-a4d0c813f63\" },\n                },\n                DurableObjectNamespaces = \n                {\n                    { \"DOBINDING\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\" },\n                },\n                EnvironmentVariables = \n                {\n                    { \"ENVIRONMENT\", \"preview\" },\n                },\n                KvNamespaces = \n                {\n                    { \"KVBINDING\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\" },\n                },\n                R2Buckets = \n                {\n                    { \"R2BINDING\", \"some-bucket\" },\n                },\n            },\n            Production = new Cloudflare.Inputs.PagesProjectDeploymentConfigsProductionArgs\n            {\n                CompatibilityDate = \"2022-08-16\",\n                CompatibilityFlags = new[]\n                {\n                    \"production_flag\",\n                    \"second flag\",\n                },\n                D1Databases = \n                {\n                    { \"D1BINDING1\", \"445e2955-951a-4358-a35b-a4d0c813f63\" },\n                    { \"D1BINDING2\", \"a399414b-c697-409a-a688-377db6433cd9\" },\n                },\n                DurableObjectNamespaces = \n                {\n                    { \"DOBINDING1\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\" },\n                    { \"DOBINDING2\", \"3cdca5f8bb22bc390deee10ebbb36be5\" },\n                },\n                EnvironmentVariables = \n                {\n                    { \"ENVIRONMENT\", \"production\" },\n                    { \"OTHERVALUE\", \"other value\" },\n                },\n                KvNamespaces = \n                {\n                    { \"KVBINDING1\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\" },\n                    { \"KVBINDING2\", \"3cdca5f8bb22bc390deee10ebbb36be5\" },\n                },\n                R2Buckets = \n                {\n                    { \"R2BINDING1\", \"some-bucket\" },\n                    { \"R2BINDING2\", \"other-bucket\" },\n                },\n            },\n        },\n        Name = \"this-is-my-project-01\",\n        ProductionBranch = \"main\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewPagesProject(ctx, \"basicProject\", \u0026cloudflare.PagesProjectArgs{\n\t\t\tAccountId:        pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:             pulumi.String(\"this-is-my-project-01\"),\n\t\t\tProductionBranch: pulumi.String(\"main\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewPagesProject(ctx, \"buildConfig\", \u0026cloudflare.PagesProjectArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tBuildConfig: \u0026cloudflare.PagesProjectBuildConfigArgs{\n\t\t\t\tBuildCommand:      pulumi.String(\"npm run build\"),\n\t\t\t\tDestinationDir:    pulumi.String(\"build\"),\n\t\t\t\tRootDir:           pulumi.String(\"/\"),\n\t\t\t\tWebAnalyticsTag:   pulumi.String(\"cee1c73f6e4743d0b5e6bb1a0bcaabcc\"),\n\t\t\t\tWebAnalyticsToken: pulumi.String(\"021e1057c18547eca7b79f2516f06o7x\"),\n\t\t\t},\n\t\t\tName:             pulumi.String(\"this-is-my-project-01\"),\n\t\t\tProductionBranch: pulumi.String(\"main\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewPagesProject(ctx, \"sourceConfig\", \u0026cloudflare.PagesProjectArgs{\n\t\t\tAccountId:        pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:             pulumi.String(\"this-is-my-project-01\"),\n\t\t\tProductionBranch: pulumi.String(\"main\"),\n\t\t\tSource: \u0026cloudflare.PagesProjectSourceArgs{\n\t\t\t\tConfig: \u0026cloudflare.PagesProjectSourceConfigArgs{\n\t\t\t\t\tDeploymentsEnabled: pulumi.Bool(true),\n\t\t\t\t\tOwner:              pulumi.String(\"cloudflare\"),\n\t\t\t\t\tPrCommentsEnabled:  pulumi.Bool(true),\n\t\t\t\t\tPreviewBranchExcludes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"main\"),\n\t\t\t\t\t\tpulumi.String(\"prod\"),\n\t\t\t\t\t},\n\t\t\t\t\tPreviewBranchIncludes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"dev\"),\n\t\t\t\t\t\tpulumi.String(\"preview\"),\n\t\t\t\t\t},\n\t\t\t\t\tPreviewDeploymentSetting:    pulumi.String(\"custom\"),\n\t\t\t\t\tProductionBranch:            pulumi.String(\"main\"),\n\t\t\t\t\tProductionDeploymentEnabled: pulumi.Bool(true),\n\t\t\t\t\tRepoName:                    pulumi.String(\"ninjakittens\"),\n\t\t\t\t},\n\t\t\t\tType: pulumi.String(\"github\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewPagesProject(ctx, \"deploymentConfigs\", \u0026cloudflare.PagesProjectArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tDeploymentConfigs: \u0026cloudflare.PagesProjectDeploymentConfigsArgs{\n\t\t\t\tPreview: \u0026cloudflare.PagesProjectDeploymentConfigsPreviewArgs{\n\t\t\t\t\tCompatibilityDate: pulumi.String(\"2022-08-15\"),\n\t\t\t\t\tCompatibilityFlags: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"preview_flag\"),\n\t\t\t\t\t},\n\t\t\t\t\tD1Databases: pulumi.AnyMap{\n\t\t\t\t\t\t\"D1BINDING\": pulumi.Any(\"445e2955-951a-4358-a35b-a4d0c813f63\"),\n\t\t\t\t\t},\n\t\t\t\t\tDurableObjectNamespaces: pulumi.AnyMap{\n\t\t\t\t\t\t\"DOBINDING\": pulumi.Any(\"5eb63bbbe01eeed093cb22bb8f5acdc3\"),\n\t\t\t\t\t},\n\t\t\t\t\tEnvironmentVariables: pulumi.AnyMap{\n\t\t\t\t\t\t\"ENVIRONMENT\": pulumi.Any(\"preview\"),\n\t\t\t\t\t},\n\t\t\t\t\tKvNamespaces: pulumi.AnyMap{\n\t\t\t\t\t\t\"KVBINDING\": pulumi.Any(\"5eb63bbbe01eeed093cb22bb8f5acdc3\"),\n\t\t\t\t\t},\n\t\t\t\t\tR2Buckets: pulumi.AnyMap{\n\t\t\t\t\t\t\"R2BINDING\": pulumi.Any(\"some-bucket\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tProduction: \u0026cloudflare.PagesProjectDeploymentConfigsProductionArgs{\n\t\t\t\t\tCompatibilityDate: pulumi.String(\"2022-08-16\"),\n\t\t\t\t\tCompatibilityFlags: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"production_flag\"),\n\t\t\t\t\t\tpulumi.String(\"second flag\"),\n\t\t\t\t\t},\n\t\t\t\t\tD1Databases: pulumi.AnyMap{\n\t\t\t\t\t\t\"D1BINDING1\": pulumi.Any(\"445e2955-951a-4358-a35b-a4d0c813f63\"),\n\t\t\t\t\t\t\"D1BINDING2\": pulumi.Any(\"a399414b-c697-409a-a688-377db6433cd9\"),\n\t\t\t\t\t},\n\t\t\t\t\tDurableObjectNamespaces: pulumi.AnyMap{\n\t\t\t\t\t\t\"DOBINDING1\": pulumi.Any(\"5eb63bbbe01eeed093cb22bb8f5acdc3\"),\n\t\t\t\t\t\t\"DOBINDING2\": pulumi.Any(\"3cdca5f8bb22bc390deee10ebbb36be5\"),\n\t\t\t\t\t},\n\t\t\t\t\tEnvironmentVariables: pulumi.AnyMap{\n\t\t\t\t\t\t\"ENVIRONMENT\": pulumi.Any(\"production\"),\n\t\t\t\t\t\t\"OTHERVALUE\":  pulumi.Any(\"other value\"),\n\t\t\t\t\t},\n\t\t\t\t\tKvNamespaces: pulumi.AnyMap{\n\t\t\t\t\t\t\"KVBINDING1\": pulumi.Any(\"5eb63bbbe01eeed093cb22bb8f5acdc3\"),\n\t\t\t\t\t\t\"KVBINDING2\": pulumi.Any(\"3cdca5f8bb22bc390deee10ebbb36be5\"),\n\t\t\t\t\t},\n\t\t\t\t\tR2Buckets: pulumi.AnyMap{\n\t\t\t\t\t\t\"R2BINDING1\": pulumi.Any(\"some-bucket\"),\n\t\t\t\t\t\t\"R2BINDING2\": pulumi.Any(\"other-bucket\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tName:             pulumi.String(\"this-is-my-project-01\"),\n\t\t\tProductionBranch: pulumi.String(\"main\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.PagesProject;\nimport com.pulumi.cloudflare.PagesProjectArgs;\nimport com.pulumi.cloudflare.inputs.PagesProjectBuildConfigArgs;\nimport com.pulumi.cloudflare.inputs.PagesProjectSourceArgs;\nimport com.pulumi.cloudflare.inputs.PagesProjectSourceConfigArgs;\nimport com.pulumi.cloudflare.inputs.PagesProjectDeploymentConfigsArgs;\nimport com.pulumi.cloudflare.inputs.PagesProjectDeploymentConfigsPreviewArgs;\nimport com.pulumi.cloudflare.inputs.PagesProjectDeploymentConfigsProductionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var basicProject = new PagesProject(\"basicProject\", PagesProjectArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"this-is-my-project-01\")\n            .productionBranch(\"main\")\n            .build());\n\n        var buildConfig = new PagesProject(\"buildConfig\", PagesProjectArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .buildConfig(PagesProjectBuildConfigArgs.builder()\n                .buildCommand(\"npm run build\")\n                .destinationDir(\"build\")\n                .rootDir(\"/\")\n                .webAnalyticsTag(\"cee1c73f6e4743d0b5e6bb1a0bcaabcc\")\n                .webAnalyticsToken(\"021e1057c18547eca7b79f2516f06o7x\")\n                .build())\n            .name(\"this-is-my-project-01\")\n            .productionBranch(\"main\")\n            .build());\n\n        var sourceConfig = new PagesProject(\"sourceConfig\", PagesProjectArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"this-is-my-project-01\")\n            .productionBranch(\"main\")\n            .source(PagesProjectSourceArgs.builder()\n                .config(PagesProjectSourceConfigArgs.builder()\n                    .deploymentsEnabled(true)\n                    .owner(\"cloudflare\")\n                    .prCommentsEnabled(true)\n                    .previewBranchExcludes(                    \n                        \"main\",\n                        \"prod\")\n                    .previewBranchIncludes(                    \n                        \"dev\",\n                        \"preview\")\n                    .previewDeploymentSetting(\"custom\")\n                    .productionBranch(\"main\")\n                    .productionDeploymentEnabled(true)\n                    .repoName(\"ninjakittens\")\n                    .build())\n                .type(\"github\")\n                .build())\n            .build());\n\n        var deploymentConfigs = new PagesProject(\"deploymentConfigs\", PagesProjectArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .deploymentConfigs(PagesProjectDeploymentConfigsArgs.builder()\n                .preview(PagesProjectDeploymentConfigsPreviewArgs.builder()\n                    .compatibilityDate(\"2022-08-15\")\n                    .compatibilityFlags(\"preview_flag\")\n                    .d1Databases(Map.of(\"D1BINDING\", \"445e2955-951a-4358-a35b-a4d0c813f63\"))\n                    .durableObjectNamespaces(Map.of(\"DOBINDING\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\"))\n                    .environmentVariables(Map.of(\"ENVIRONMENT\", \"preview\"))\n                    .kvNamespaces(Map.of(\"KVBINDING\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\"))\n                    .r2Buckets(Map.of(\"R2BINDING\", \"some-bucket\"))\n                    .build())\n                .production(PagesProjectDeploymentConfigsProductionArgs.builder()\n                    .compatibilityDate(\"2022-08-16\")\n                    .compatibilityFlags(                    \n                        \"production_flag\",\n                        \"second flag\")\n                    .d1Databases(Map.ofEntries(\n                        Map.entry(\"D1BINDING1\", \"445e2955-951a-4358-a35b-a4d0c813f63\"),\n                        Map.entry(\"D1BINDING2\", \"a399414b-c697-409a-a688-377db6433cd9\")\n                    ))\n                    .durableObjectNamespaces(Map.ofEntries(\n                        Map.entry(\"DOBINDING1\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\"),\n                        Map.entry(\"DOBINDING2\", \"3cdca5f8bb22bc390deee10ebbb36be5\")\n                    ))\n                    .environmentVariables(Map.ofEntries(\n                        Map.entry(\"ENVIRONMENT\", \"production\"),\n                        Map.entry(\"OTHERVALUE\", \"other value\")\n                    ))\n                    .kvNamespaces(Map.ofEntries(\n                        Map.entry(\"KVBINDING1\", \"5eb63bbbe01eeed093cb22bb8f5acdc3\"),\n                        Map.entry(\"KVBINDING2\", \"3cdca5f8bb22bc390deee10ebbb36be5\")\n                    ))\n                    .r2Buckets(Map.ofEntries(\n                        Map.entry(\"R2BINDING1\", \"some-bucket\"),\n                        Map.entry(\"R2BINDING2\", \"other-bucket\")\n                    ))\n                    .build())\n                .build())\n            .name(\"this-is-my-project-01\")\n            .productionBranch(\"main\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic project\n  basicProject:\n    type: cloudflare:PagesProject\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: this-is-my-project-01\n      productionBranch: main\n  # Manage build config\n  buildConfig:\n    type: cloudflare:PagesProject\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      buildConfig:\n        buildCommand: npm run build\n        destinationDir: build\n        rootDir: /\n        webAnalyticsTag: cee1c73f6e4743d0b5e6bb1a0bcaabcc\n        webAnalyticsToken: 021e1057c18547eca7b79f2516f06o7x\n      name: this-is-my-project-01\n      productionBranch: main\n  # Manage project source\n  sourceConfig:\n    type: cloudflare:PagesProject\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: this-is-my-project-01\n      productionBranch: main\n      source:\n        config:\n          deploymentsEnabled: true\n          owner: cloudflare\n          prCommentsEnabled: true\n          previewBranchExcludes:\n            - main\n            - prod\n          previewBranchIncludes:\n            - dev\n            - preview\n          previewDeploymentSetting: custom\n          productionBranch: main\n          productionDeploymentEnabled: true\n          repoName: ninjakittens\n        type: github\n  # Manage deployment configs\n  deploymentConfigs:\n    type: cloudflare:PagesProject\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      deploymentConfigs:\n        preview:\n          compatibilityDate: 2022-08-15\n          compatibilityFlags:\n            - preview_flag\n          d1Databases:\n            D1BINDING: 445e2955-951a-4358-a35b-a4d0c813f63\n          durableObjectNamespaces:\n            DOBINDING: 5eb63bbbe01eeed093cb22bb8f5acdc3\n          environmentVariables:\n            ENVIRONMENT: preview\n          kvNamespaces:\n            KVBINDING: 5eb63bbbe01eeed093cb22bb8f5acdc3\n          r2Buckets:\n            R2BINDING: some-bucket\n        production:\n          compatibilityDate: 2022-08-16\n          compatibilityFlags:\n            - production_flag\n            - second flag\n          d1Databases:\n            D1BINDING1: 445e2955-951a-4358-a35b-a4d0c813f63\n            D1BINDING2: a399414b-c697-409a-a688-377db6433cd9\n          durableObjectNamespaces:\n            DOBINDING1: 5eb63bbbe01eeed093cb22bb8f5acdc3\n            DOBINDING2: 3cdca5f8bb22bc390deee10ebbb36be5\n          environmentVariables:\n            ENVIRONMENT: production\n            OTHERVALUE: other value\n          kvNamespaces:\n            KVBINDING1: 5eb63bbbe01eeed093cb22bb8f5acdc3\n            KVBINDING2: 3cdca5f8bb22bc390deee10ebbb36be5\n          r2Buckets:\n            R2BINDING1: some-bucket\n            R2BINDING2: other-bucket\n      name: this-is-my-project-01\n      productionBranch: main\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/pagesProject:PagesProject example \u003caccount_id\u003e/\u003cproject_name\u003e\n```\n\n [Getting Started with Pages]https://developers.cloudflare.com/pages/get-started/#connect-your-git-provider-to-pages ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "buildConfig": {
                    "$ref": "#/types/cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig",
                    "description": "Configuration for the project build process.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "When the project was created.\n"
                },
                "deploymentConfigs": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs",
                    "description": "Configuration for deployments in a project.\n"
                },
                "domains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of associated custom domains for the project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the project.\n"
                },
                "productionBranch": {
                    "type": "string",
                    "description": "The name of the branch that is used for the production environment.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/PagesProjectSource:PagesProjectSource",
                    "description": "Configuration for the project source.\n"
                },
                "subdomain": {
                    "type": "string",
                    "description": "The Cloudflare subdomain associated with the project.\n"
                }
            },
            "required": [
                "accountId",
                "createdOn",
                "domains",
                "name",
                "productionBranch",
                "subdomain"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "buildConfig": {
                    "$ref": "#/types/cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig",
                    "description": "Configuration for the project build process.\n"
                },
                "deploymentConfigs": {
                    "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs",
                    "description": "Configuration for deployments in a project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the project.\n"
                },
                "productionBranch": {
                    "type": "string",
                    "description": "The name of the branch that is used for the production environment.\n"
                },
                "source": {
                    "$ref": "#/types/cloudflare:index/PagesProjectSource:PagesProjectSource",
                    "description": "Configuration for the project source.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "productionBranch"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PagesProject resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "buildConfig": {
                        "$ref": "#/types/cloudflare:index/PagesProjectBuildConfig:PagesProjectBuildConfig",
                        "description": "Configuration for the project build process.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "When the project was created.\n"
                    },
                    "deploymentConfigs": {
                        "$ref": "#/types/cloudflare:index/PagesProjectDeploymentConfigs:PagesProjectDeploymentConfigs",
                        "description": "Configuration for deployments in a project.\n"
                    },
                    "domains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of associated custom domains for the project.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the project.\n"
                    },
                    "productionBranch": {
                        "type": "string",
                        "description": "The name of the branch that is used for the production environment.\n"
                    },
                    "source": {
                        "$ref": "#/types/cloudflare:index/PagesProjectSource:PagesProjectSource",
                        "description": "Configuration for the project source.\n"
                    },
                    "subdomain": {
                        "type": "string",
                        "description": "The Cloudflare subdomain associated with the project.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/rateLimit:RateLimit": {
            "description": "Provides a Cloudflare rate limit resource for a given zone. This can be used to limit the traffic you receive zone-wide, or matching more specific types of requests/responses.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.RateLimit(\"example\", {\n    zoneId: _var.cloudflare_zone_id,\n    threshold: 2000,\n    period: 2,\n    match: {\n        request: {\n            urlPattern: `${_var.cloudflare_zone}/*`,\n            schemes: [\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            methods: [\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        },\n        response: {\n            statuses: [\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            originTraffic: false,\n            headers: [\n                {\n                    name: \"Host\",\n                    op: \"eq\",\n                    value: \"localhost\",\n                },\n                {\n                    name: \"X-Example\",\n                    op: \"ne\",\n                    value: \"my-example\",\n                },\n            ],\n        },\n    },\n    action: {\n        mode: \"simulate\",\n        timeout: 43200,\n        response: {\n            contentType: \"text/plain\",\n            body: \"custom response body\",\n        },\n    },\n    correlate: {\n        by: \"nat\",\n    },\n    disabled: false,\n    description: \"example rate limit for a zone\",\n    bypassUrlPatterns: [\n        `${_var.cloudflare_zone}/bypass1`,\n        `${_var.cloudflare_zone}/bypass2`,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.RateLimit(\"example\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    threshold=2000,\n    period=2,\n    match=cloudflare.RateLimitMatchArgs(\n        request=cloudflare.RateLimitMatchRequestArgs(\n            url_pattern=f\"{var['cloudflare_zone']}/*\",\n            schemes=[\n                \"HTTP\",\n                \"HTTPS\",\n            ],\n            methods=[\n                \"GET\",\n                \"POST\",\n                \"PUT\",\n                \"DELETE\",\n                \"PATCH\",\n                \"HEAD\",\n            ],\n        ),\n        response=cloudflare.RateLimitMatchResponseArgs(\n            statuses=[\n                200,\n                201,\n                202,\n                301,\n                429,\n            ],\n            origin_traffic=False,\n            headers=[\n                {\n                    \"name\": \"Host\",\n                    \"op\": \"eq\",\n                    \"value\": \"localhost\",\n                },\n                {\n                    \"name\": \"X-Example\",\n                    \"op\": \"ne\",\n                    \"value\": \"my-example\",\n                },\n            ],\n        ),\n    ),\n    action=cloudflare.RateLimitActionArgs(\n        mode=\"simulate\",\n        timeout=43200,\n        response=cloudflare.RateLimitActionResponseArgs(\n            content_type=\"text/plain\",\n            body=\"custom response body\",\n        ),\n    ),\n    correlate=cloudflare.RateLimitCorrelateArgs(\n        by=\"nat\",\n    ),\n    disabled=False,\n    description=\"example rate limit for a zone\",\n    bypass_url_patterns=[\n        f\"{var['cloudflare_zone']}/bypass1\",\n        f\"{var['cloudflare_zone']}/bypass2\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.RateLimit(\"example\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Threshold = 2000,\n        Period = 2,\n        Match = new Cloudflare.Inputs.RateLimitMatchArgs\n        {\n            Request = new Cloudflare.Inputs.RateLimitMatchRequestArgs\n            {\n                UrlPattern = $\"{@var.Cloudflare_zone}/*\",\n                Schemes = new[]\n                {\n                    \"HTTP\",\n                    \"HTTPS\",\n                },\n                Methods = new[]\n                {\n                    \"GET\",\n                    \"POST\",\n                    \"PUT\",\n                    \"DELETE\",\n                    \"PATCH\",\n                    \"HEAD\",\n                },\n            },\n            Response = new Cloudflare.Inputs.RateLimitMatchResponseArgs\n            {\n                Statuses = new[]\n                {\n                    200,\n                    201,\n                    202,\n                    301,\n                    429,\n                },\n                OriginTraffic = false,\n                Headers = new[]\n                {\n                    \n                    {\n                        { \"name\", \"Host\" },\n                        { \"op\", \"eq\" },\n                        { \"value\", \"localhost\" },\n                    },\n                    \n                    {\n                        { \"name\", \"X-Example\" },\n                        { \"op\", \"ne\" },\n                        { \"value\", \"my-example\" },\n                    },\n                },\n            },\n        },\n        Action = new Cloudflare.Inputs.RateLimitActionArgs\n        {\n            Mode = \"simulate\",\n            Timeout = 43200,\n            Response = new Cloudflare.Inputs.RateLimitActionResponseArgs\n            {\n                ContentType = \"text/plain\",\n                Body = \"custom response body\",\n            },\n        },\n        Correlate = new Cloudflare.Inputs.RateLimitCorrelateArgs\n        {\n            By = \"nat\",\n        },\n        Disabled = false,\n        Description = \"example rate limit for a zone\",\n        BypassUrlPatterns = new[]\n        {\n            $\"{@var.Cloudflare_zone}/bypass1\",\n            $\"{@var.Cloudflare_zone}/bypass2\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewRateLimit(ctx, \"example\", \u0026cloudflare.RateLimitArgs{\n\t\t\tZoneId:    pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tThreshold: pulumi.Int(2000),\n\t\t\tPeriod:    pulumi.Int(2),\n\t\t\tMatch: \u0026cloudflare.RateLimitMatchArgs{\n\t\t\t\tRequest: \u0026cloudflare.RateLimitMatchRequestArgs{\n\t\t\t\t\tUrlPattern: pulumi.String(fmt.Sprintf(\"%v/*\", _var.Cloudflare_zone)),\n\t\t\t\t\tSchemes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"HTTP\"),\n\t\t\t\t\t\tpulumi.String(\"HTTPS\"),\n\t\t\t\t\t},\n\t\t\t\t\tMethods: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GET\"),\n\t\t\t\t\t\tpulumi.String(\"POST\"),\n\t\t\t\t\t\tpulumi.String(\"PUT\"),\n\t\t\t\t\t\tpulumi.String(\"DELETE\"),\n\t\t\t\t\t\tpulumi.String(\"PATCH\"),\n\t\t\t\t\t\tpulumi.String(\"HEAD\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponse: \u0026cloudflare.RateLimitMatchResponseArgs{\n\t\t\t\t\tStatuses: pulumi.IntArray{\n\t\t\t\t\t\tpulumi.Int(200),\n\t\t\t\t\t\tpulumi.Int(201),\n\t\t\t\t\t\tpulumi.Int(202),\n\t\t\t\t\t\tpulumi.Int(301),\n\t\t\t\t\t\tpulumi.Int(429),\n\t\t\t\t\t},\n\t\t\t\t\tOriginTraffic: pulumi.Bool(false),\n\t\t\t\t\tHeaders: pulumi.StringMapArray{\n\t\t\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\t\t\"name\":  pulumi.String(\"Host\"),\n\t\t\t\t\t\t\t\"op\":    pulumi.String(\"eq\"),\n\t\t\t\t\t\t\t\"value\": pulumi.String(\"localhost\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpulumi.StringMap{\n\t\t\t\t\t\t\t\"name\":  pulumi.String(\"X-Example\"),\n\t\t\t\t\t\t\t\"op\":    pulumi.String(\"ne\"),\n\t\t\t\t\t\t\t\"value\": pulumi.String(\"my-example\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: \u0026cloudflare.RateLimitActionArgs{\n\t\t\t\tMode:    pulumi.String(\"simulate\"),\n\t\t\t\tTimeout: pulumi.Int(43200),\n\t\t\t\tResponse: \u0026cloudflare.RateLimitActionResponseArgs{\n\t\t\t\t\tContentType: pulumi.String(\"text/plain\"),\n\t\t\t\t\tBody:        pulumi.String(\"custom response body\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCorrelate: \u0026cloudflare.RateLimitCorrelateArgs{\n\t\t\t\tBy: pulumi.String(\"nat\"),\n\t\t\t},\n\t\t\tDisabled:    pulumi.Bool(false),\n\t\t\tDescription: pulumi.String(\"example rate limit for a zone\"),\n\t\t\tBypassUrlPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(fmt.Sprintf(\"%v/bypass1\", _var.Cloudflare_zone)),\n\t\t\t\tpulumi.String(fmt.Sprintf(\"%v/bypass2\", _var.Cloudflare_zone)),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.RateLimit;\nimport com.pulumi.cloudflare.RateLimitArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitMatchArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitMatchRequestArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitMatchResponseArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitActionArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitActionResponseArgs;\nimport com.pulumi.cloudflare.inputs.RateLimitCorrelateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new RateLimit(\"example\", RateLimitArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .threshold(2000)\n            .period(2)\n            .match(RateLimitMatchArgs.builder()\n                .request(RateLimitMatchRequestArgs.builder()\n                    .urlPattern(String.format(\"%s/*\", var_.cloudflare_zone()))\n                    .schemes(                    \n                        \"HTTP\",\n                        \"HTTPS\")\n                    .methods(                    \n                        \"GET\",\n                        \"POST\",\n                        \"PUT\",\n                        \"DELETE\",\n                        \"PATCH\",\n                        \"HEAD\")\n                    .build())\n                .response(RateLimitMatchResponseArgs.builder()\n                    .statuses(                    \n                        200,\n                        201,\n                        202,\n                        301,\n                        429)\n                    .originTraffic(false)\n                    .headers(                    \n                        Map.ofEntries(\n                            Map.entry(\"name\", \"Host\"),\n                            Map.entry(\"op\", \"eq\"),\n                            Map.entry(\"value\", \"localhost\")\n                        ),\n                        Map.ofEntries(\n                            Map.entry(\"name\", \"X-Example\"),\n                            Map.entry(\"op\", \"ne\"),\n                            Map.entry(\"value\", \"my-example\")\n                        ))\n                    .build())\n                .build())\n            .action(RateLimitActionArgs.builder()\n                .mode(\"simulate\")\n                .timeout(43200)\n                .response(RateLimitActionResponseArgs.builder()\n                    .contentType(\"text/plain\")\n                    .body(\"custom response body\")\n                    .build())\n                .build())\n            .correlate(RateLimitCorrelateArgs.builder()\n                .by(\"nat\")\n                .build())\n            .disabled(false)\n            .description(\"example rate limit for a zone\")\n            .bypassUrlPatterns(            \n                String.format(\"%s/bypass1\", var_.cloudflare_zone()),\n                String.format(\"%s/bypass2\", var_.cloudflare_zone()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:RateLimit\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      threshold: 2000\n      period: 2\n      match:\n        request:\n          urlPattern: ${var.cloudflare_zone}/*\n          schemes:\n            - HTTP\n            - HTTPS\n          methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n            - PATCH\n            - HEAD\n        response:\n          statuses:\n            - 200\n            - 201\n            - 202\n            - 301\n            - 429\n          originTraffic: false\n          headers:\n            - name: Host\n              op: eq\n              value: localhost\n            - name: X-Example\n              op: ne\n              value: my-example\n      action:\n        mode: simulate\n        timeout: 43200\n        response:\n          contentType: text/plain\n          body: custom response body\n      correlate:\n        by: nat\n      disabled: false\n      description: example rate limit for a zone\n      bypassUrlPatterns:\n        - ${var.cloudflare_zone}/bypass1\n        - ${var.cloudflare_zone}/bypass2\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRate limits can be imported using a composite ID formed of zone name and rate limit ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/rateLimit:RateLimit default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43\n```\n\n ",
            "properties": {
                "action": {
                    "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply rate limiting to.\n"
                }
            },
            "required": [
                "action",
                "match",
                "period",
                "threshold",
                "zoneId"
            ],
            "inputProperties": {
                "action": {
                    "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                    "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                },
                "bypassUrlPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                },
                "correlate": {
                    "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                    "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                },
                "match": {
                    "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                    "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                },
                "period": {
                    "type": "integer",
                    "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                },
                "threshold": {
                    "type": "integer",
                    "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply rate limiting to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "period",
                "threshold",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RateLimit resources.\n",
                "properties": {
                    "action": {
                        "$ref": "#/types/cloudflare:index/RateLimitAction:RateLimitAction",
                        "description": "The action to be performed when the threshold of matched traffic within the period defined is exceeded.\n"
                    },
                    "bypassUrlPatterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "URLs matching the patterns specified here will be excluded from rate limiting.\n"
                    },
                    "correlate": {
                        "$ref": "#/types/cloudflare:index/RateLimitCorrelate:RateLimitCorrelate",
                        "description": "Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Whether this ratelimit is currently disabled. Default: `false`.\n"
                    },
                    "match": {
                        "$ref": "#/types/cloudflare:index/RateLimitMatch:RateLimitMatch",
                        "description": "Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone. See definition below.\n"
                    },
                    "period": {
                        "type": "integer",
                        "description": "The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed (min: 1, max: 86,400).\n"
                    },
                    "threshold": {
                        "type": "integer",
                        "description": "The threshold that triggers the rate limit mitigations, combine with period. i.e. threshold per period (min: 2, max: 1,000,000).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply rate limiting to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/record:Record": {
            "description": "Provides a Cloudflare record resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Add a record to the domain\nconst foobar = new cloudflare.Record(\"foobar\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"example\",\n    value: \"192.168.0.11\",\n    type: \"A\",\n    ttl: 3600,\n});\n// Add a record requiring a data map\nconst _sipTls = new cloudflare.Record(\"_sipTls\", {\n    zoneId: _var.cloudflare_zone_id,\n    name: \"_sip._tls\",\n    type: \"SRV\",\n    data: {\n        service: \"_sip\",\n        proto: \"_tls\",\n        name: \"example-srv\",\n        priority: 0,\n        weight: 0,\n        port: 443,\n        target: \"example.com\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Add a record to the domain\nfoobar = cloudflare.Record(\"foobar\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"example\",\n    value=\"192.168.0.11\",\n    type=\"A\",\n    ttl=3600)\n# Add a record requiring a data map\n_sip_tls = cloudflare.Record(\"_sipTls\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    name=\"_sip._tls\",\n    type=\"SRV\",\n    data=cloudflare.RecordDataArgs(\n        service=\"_sip\",\n        proto=\"_tls\",\n        name=\"example-srv\",\n        priority=0,\n        weight=0,\n        port=443,\n        target=\"example.com\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Add a record to the domain\n    var foobar = new Cloudflare.Record(\"foobar\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Name = \"example\",\n        Value = \"192.168.0.11\",\n        Type = \"A\",\n        Ttl = 3600,\n    });\n\n    // Add a record requiring a data map\n    var _sipTls = new Cloudflare.Record(\"_sipTls\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Name = \"_sip._tls\",\n        Type = \"SRV\",\n        Data = new Cloudflare.Inputs.RecordDataArgs\n        {\n            Service = \"_sip\",\n            Proto = \"_tls\",\n            Name = \"example-srv\",\n            Priority = 0,\n            Weight = 0,\n            Port = 443,\n            Target = \"example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewRecord(ctx, \"foobar\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId: pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:   pulumi.String(\"example\"),\n\t\t\tValue:  pulumi.String(\"192.168.0.11\"),\n\t\t\tType:   pulumi.String(\"A\"),\n\t\t\tTtl:    pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewRecord(ctx, \"_sipTls\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId: pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tName:   pulumi.String(\"_sip._tls\"),\n\t\t\tType:   pulumi.String(\"SRV\"),\n\t\t\tData: \u0026cloudflare.RecordDataArgs{\n\t\t\t\tService:  pulumi.String(\"_sip\"),\n\t\t\t\tProto:    pulumi.String(\"_tls\"),\n\t\t\t\tName:     pulumi.String(\"example-srv\"),\n\t\t\t\tPriority: pulumi.Int(0),\n\t\t\t\tWeight:   pulumi.Int(0),\n\t\t\t\tPort:     pulumi.Int(443),\n\t\t\t\tTarget:   pulumi.String(\"example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Record;\nimport com.pulumi.cloudflare.RecordArgs;\nimport com.pulumi.cloudflare.inputs.RecordDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foobar = new Record(\"foobar\", RecordArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .name(\"example\")\n            .value(\"192.168.0.11\")\n            .type(\"A\")\n            .ttl(3600)\n            .build());\n\n        var _sipTls = new Record(\"_sipTls\", RecordArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .name(\"_sip._tls\")\n            .type(\"SRV\")\n            .data(RecordDataArgs.builder()\n                .service(\"_sip\")\n                .proto(\"_tls\")\n                .name(\"example-srv\")\n                .priority(0)\n                .weight(0)\n                .port(443)\n                .target(\"example.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Add a record to the domain\n  foobar:\n    type: cloudflare:Record\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      name: example\n      value: 192.168.0.11\n      type: A\n      ttl: 3600\n  # Add a record requiring a data map\n  _sipTls:\n    type: cloudflare:Record\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      name: _sip._tls\n      type: SRV\n      data:\n        service: _sip\n        proto: _tls\n        name: example-srv\n        priority: 0\n        weight: 0\n        port: 443\n        target: example.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRecords can be imported using a composite ID formed of zone ID and record ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/record:Record default ae36f999674d196762efcc5abb06b345/d41d8cd98f00b204e9800998ecf8427e\n```\n\n where- `ae36f999674d196762efcc5abb06b345` - the zone ID - `d41d8cd98f00b204e9800998ecf8427e` - record ID as returned by [API](https://api.cloudflare.com/#dns-records-for-a-zone-list-dns-records) ",
            "properties": {
                "allowOverwrite": {
                    "type": "boolean"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was created\n"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The FQDN of the record\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A key-value map of string metadata Cloudflare associates with the record\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "The RFC3339 timestamp of when the record was last modified\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proxiable": {
                    "type": "boolean",
                    "description": "Shows whether this record can be proxied, must be true if setting `proxied=true`\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record\n"
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the record to\n"
                }
            },
            "required": [
                "createdOn",
                "hostname",
                "metadata",
                "modifiedOn",
                "name",
                "proxiable",
                "ttl",
                "type",
                "value",
                "zoneId"
            ],
            "inputProperties": {
                "allowOverwrite": {
                    "type": "boolean"
                },
                "data": {
                    "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                    "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the record\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the record\n"
                },
                "proxied": {
                    "type": "boolean",
                    "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the record\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "The (string) value of the record. Either this or `data` must be specified\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the record to\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Record resources.\n",
                "properties": {
                    "allowOverwrite": {
                        "type": "boolean"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was created\n"
                    },
                    "data": {
                        "$ref": "#/types/cloudflare:index/RecordData:RecordData",
                        "description": "Map of attributes that constitute the record value. Primarily used for LOC and SRV record types. Either this or `value` must be specified\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The FQDN of the record\n"
                    },
                    "metadata": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A key-value map of string metadata Cloudflare associates with the record\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "The RFC3339 timestamp of when the record was last modified\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the record\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the record\n"
                    },
                    "proxiable": {
                        "type": "boolean",
                        "description": "Shows whether this record can be proxied, must be true if setting `proxied=true`\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Whether the record gets Cloudflare's origin protection; defaults to `false`.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The TTL of the record ([automatic: '1'](https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record))\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the record\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "The (string) value of the record. Either this or `data` must be specified\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to add the record to\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/ruleset:Ruleset": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Ruleset;\nimport com.pulumi.cloudflare.RulesetArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersOverridesArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersUriArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersUriPathArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersUriQueryArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleRatelimitArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersOriginArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersBrowserTtlArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyHostArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyUserArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersEdgeTtlArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersServeStaleArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersFromListArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersFromValueArgs;\nimport com.pulumi.cloudflare.inputs.RulesetRuleActionParametersFromValueTargetUrlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var magicTransitExample = new Ruleset(\"magicTransitExample\", RulesetArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .description(\"example magic transit ruleset description\")\n            .kind(\"root\")\n            .name(\"account magic transit\")\n            .phase(\"magic_transit\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"allow\")\n                .description(\"Allow TCP Ephemeral Ports\")\n                .expression(\"tcp.dstport in { 32768..65535 }\")\n                .build())\n            .build());\n\n        var zoneLevelManagedWaf = new Ruleset(\"zoneLevelManagedWaf\", RulesetArgs.builder()        \n            .description(\"managed WAF ruleset description\")\n            .kind(\"zone\")\n            .name(\"managed WAF\")\n            .phase(\"http_request_firewall_managed\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"execute\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .id(\"efb7b8c949ac4650a09736fc376e9aee\")\n                    .build())\n                .description(\"Execute Cloudflare Managed Ruleset on my zone-level phase entry point ruleset\")\n                .enabled(true)\n                .expression(\"(http.host eq \\\"example.host.com\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var zoneLevelManagedWafWithCategoryBasedOverrides = new Ruleset(\"zoneLevelManagedWafWithCategoryBasedOverrides\", RulesetArgs.builder()        \n            .description(\"managed WAF with tag-based overrides ruleset description\")\n            .kind(\"zone\")\n            .name(\"managed WAF with tag-based overrides\")\n            .phase(\"http_request_firewall_managed\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"execute\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .id(\"efb7b8c949ac4650a09736fc376e9aee\")\n                    .overrides(RulesetRuleActionParametersOverridesArgs.builder()\n                        .categories(                        \n                            RulesetRuleActionParametersOverridesCategoryArgs.builder()\n                                .action(\"block\")\n                                .category(\"wordpress\")\n                                .status(\"enabled\")\n                                .build(),\n                            RulesetRuleActionParametersOverridesCategoryArgs.builder()\n                                .action(\"block\")\n                                .category(\"joomla\")\n                                .status(\"enabled\")\n                                .build())\n                        .build())\n                    .build())\n                .description(\"overrides to only enable wordpress rules to block\")\n                .enabled(false)\n                .expression(\"(http.host eq \\\"example.host.com\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var transformUriRulePath = new Ruleset(\"transformUriRulePath\", RulesetArgs.builder()        \n            .description(\"change the URI path to a new static path\")\n            .kind(\"zone\")\n            .name(\"transform rule for URI path\")\n            .phase(\"http_request_transform\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"rewrite\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .uri(RulesetRuleActionParametersUriArgs.builder()\n                        .path(RulesetRuleActionParametersUriPathArgs.builder()\n                            .value(\"/my-new-route\")\n                            .build())\n                        .build())\n                    .build())\n                .description(\"example URI path transform rule\")\n                .enabled(true)\n                .expression(\"(http.host eq \\\"example.com\\\" and http.request.uri.path eq \\\"/old-path\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var transformUriRuleQuery = new Ruleset(\"transformUriRuleQuery\", RulesetArgs.builder()        \n            .description(\"change the URI query to a new static query\")\n            .kind(\"zone\")\n            .name(\"transform rule for URI query parameter\")\n            .phase(\"http_request_transform\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"rewrite\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .uri(RulesetRuleActionParametersUriArgs.builder()\n                        .query(RulesetRuleActionParametersUriQueryArgs.builder()\n                            .value(\"old=new_again\")\n                            .build())\n                        .build())\n                    .build())\n                .description(\"URI transformation query example\")\n                .enabled(true)\n                .expression(\"(http.host eq \\\"example.host.com\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var transformUriHttpHeaders = new Ruleset(\"transformUriHttpHeaders\", RulesetArgs.builder()        \n            .description(\"modify HTTP headers before reaching origin\")\n            .kind(\"zone\")\n            .name(\"transform rule for HTTP headers\")\n            .phase(\"http_request_late_transform\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"rewrite\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .headers(                    \n                        RulesetRuleActionParametersHeaderArgs.builder()\n                            .name(\"example-http-header-1\")\n                            .operation(\"set\")\n                            .value(\"my-http-header-value-1\")\n                            .build(),\n                        RulesetRuleActionParametersHeaderArgs.builder()\n                            .expression(\"cf.zone.name\")\n                            .name(\"example-http-header-2\")\n                            .operation(\"set\")\n                            .build(),\n                        RulesetRuleActionParametersHeaderArgs.builder()\n                            .name(\"example-http-header-3-to-remove\")\n                            .operation(\"remove\")\n                            .build())\n                    .build())\n                .description(\"example request header transform rule\")\n                .enabled(false)\n                .expression(\"(http.host eq \\\"example.host.com\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var rateLimitingExample = new Ruleset(\"rateLimitingExample\", RulesetArgs.builder()        \n            .description(\"apply HTTP rate limiting for a route\")\n            .kind(\"zone\")\n            .name(\"restrict API requests count\")\n            .phase(\"http_ratelimit\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"block\")\n                .description(\"rate limit for API\")\n                .enabled(true)\n                .expression(\"(http.request.uri.path matches \\\"^/api/\\\")\")\n                .ratelimit(RulesetRuleRatelimitArgs.builder()\n                    .characteristics(                    \n                        \"cf.colo.id\",\n                        \"ip.src\")\n                    .mitigationTimeout(600)\n                    .period(60)\n                    .requestsPerPeriod(100)\n                    .build())\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var httpOriginExample = new Ruleset(\"httpOriginExample\", RulesetArgs.builder()        \n            .description(\"Change origin for a route\")\n            .kind(\"zone\")\n            .name(\"Change to some origin\")\n            .phase(\"http_request_origin\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"route\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .hostHeader(\"some.host\")\n                    .origin(RulesetRuleActionParametersOriginArgs.builder()\n                        .host(\"some.host\")\n                        .port(80)\n                        .build())\n                    .build())\n                .description(\"change origin to some.host\")\n                .enabled(true)\n                .expression(\"(http.request.uri.path matches \\\"^/api/\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var customFieldsLoggingExample = new Ruleset(\"customFieldsLoggingExample\", RulesetArgs.builder()        \n            .description(\"add custom fields to logging\")\n            .kind(\"zone\")\n            .name(\"log custom fields\")\n            .phase(\"http_log_custom_fields\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"log_custom_field\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .cookieFields(                    \n                        \"__ga\",\n                        \"accountNumber\",\n                        \"__cfruid\")\n                    .requestFields(                    \n                        \"content-type\",\n                        \"x-forwarded-for\",\n                        \"host\")\n                    .responseFields(                    \n                        \"server\",\n                        \"content-type\",\n                        \"allow\")\n                    .build())\n                .description(\"log custom fields rule\")\n                .enabled(true)\n                .expression(\"(http.host eq \\\"example.host.com\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var cacheSettingsExample = new Ruleset(\"cacheSettingsExample\", RulesetArgs.builder()        \n            .description(\"set cache settings for the request\")\n            .kind(\"zone\")\n            .name(\"set cache settings\")\n            .phase(\"http_request_cache_settings\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"set_cache_settings\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .browserTtl(RulesetRuleActionParametersBrowserTtlArgs.builder()\n                        .mode(\"respect_origin\")\n                        .build())\n                    .cacheKey(RulesetRuleActionParametersCacheKeyArgs.builder()\n                        .cacheDeceptionArmor(true)\n                        .customKey(RulesetRuleActionParametersCacheKeyCustomKeyArgs.builder()\n                            .cookie(RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs.builder()\n                                .checkPresence(                                \n                                    \"cabc_t\",\n                                    \"cdef_t\")\n                                .include(                                \n                                    \"cabc\",\n                                    \"cdef\")\n                                .build())\n                            .header(RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs.builder()\n                                .checkPresence(                                \n                                    \"habc_t\",\n                                    \"hdef_t\")\n                                .excludeOrigin(true)\n                                .include(                                \n                                    \"habc\",\n                                    \"hdef\")\n                                .build())\n                            .host(RulesetRuleActionParametersCacheKeyCustomKeyHostArgs.builder()\n                                .resolved(true)\n                                .build())\n                            .queryString(RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs.builder()\n                                .exclude(\"*\")\n                                .build())\n                            .user(RulesetRuleActionParametersCacheKeyCustomKeyUserArgs.builder()\n                                .deviceType(true)\n                                .geo(false)\n                                .build())\n                            .build())\n                        .ignoreQueryStringsOrder(false)\n                        .build())\n                    .edgeTtl(RulesetRuleActionParametersEdgeTtlArgs.builder()\n                        .default_(60)\n                        .mode(\"override_origin\")\n                        .statusCodeTtl(                        \n                            %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n                            %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .originErrorPagePassthru(false)\n                    .respectStrongEtags(true)\n                    .serveStale(RulesetRuleActionParametersServeStaleArgs.builder()\n                        .disableStaleWhileUpdating(true)\n                        .build())\n                    .build())\n                .description(\"set cache settings rule\")\n                .enabled(true)\n                .expression(\"(http.host eq \\\"example.host.com\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var redirectFromListExample = new Ruleset(\"redirectFromListExample\", RulesetArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .description(\"Redirect ruleset\")\n            .kind(\"root\")\n            .name(\"redirects\")\n            .phase(\"http_request_redirect\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"redirect\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .fromList(RulesetRuleActionParametersFromListArgs.builder()\n                        .key(\"http.request.full_uri\")\n                        .name(\"redirect_list\")\n                        .build())\n                    .build())\n                .description(\"Apply redirects from redirect_list\")\n                .enabled(true)\n                .expression(\"http.request.full_uri in $redirect_list\")\n                .build())\n            .build());\n\n        var redirectFromValueExample = new Ruleset(\"redirectFromValueExample\", RulesetArgs.builder()        \n            .description(\"Redirect ruleset\")\n            .kind(\"root\")\n            .name(\"redirects\")\n            .phase(\"http_request_dynamic_redirect\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"redirect\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .fromValue(RulesetRuleActionParametersFromValueArgs.builder()\n                        .preserveQueryString(true)\n                        .statusCode(301)\n                        .targetUrl(RulesetRuleActionParametersFromValueTargetUrlArgs.builder()\n                            .value(\"some_host.com\")\n                            .build())\n                        .build())\n                    .build())\n                .description(\"Apply redirect from value\")\n                .enabled(true)\n                .expression(\"(http.request.uri.path matches \\\"^/api/\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var httpCustomErrorExample = new Ruleset(\"httpCustomErrorExample\", RulesetArgs.builder()        \n            .description(\"Serve some error response\")\n            .kind(\"zone\")\n            .name(\"Serve some error response\")\n            .phase(\"http_custom_errors\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"serve_error\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .content(\"some error html\")\n                    .contentType(\"text/html\")\n                    .statusCode(\"530\")\n                    .build())\n                .description(\"serve some error response\")\n                .enabled(true)\n                .expression(\"(http.request.uri.path matches \\\"^/api/\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var httpConfigRulesExample = new Ruleset(\"httpConfigRulesExample\", RulesetArgs.builder()        \n            .description(\"set config rules for request\")\n            .kind(\"zone\")\n            .name(\"set config rules\")\n            .phase(\"http_config_settings\")\n            .rules(RulesetRuleArgs.builder()\n                .action(\"set_config\")\n                .actionParameters(RulesetRuleActionParametersArgs.builder()\n                    .bic(true)\n                    .emailObfuscation(true)\n                    .build())\n                .description(\"set config rules for matching request\")\n                .enabled(true)\n                .expression(\"(http.request.uri.path matches \\\"^/api/\\\")\")\n                .build())\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Magic Transit\n  magicTransitExample:\n    type: cloudflare:Ruleset\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      description: example magic transit ruleset description\n      kind: root\n      name: account magic transit\n      phase: magic_transit\n      rules:\n        - action: allow\n          description: Allow TCP Ephemeral Ports\n          expression: tcp.dstport in { 32768..65535 }\n  # Zone-level WAF Managed Ruleset\n  zoneLevelManagedWaf:\n    type: cloudflare:Ruleset\n    properties:\n      description: managed WAF ruleset description\n      kind: zone\n      name: managed WAF\n      phase: http_request_firewall_managed\n      rules:\n        - action: execute\n          actionParameters:\n            id: efb7b8c949ac4650a09736fc376e9aee\n          description: Execute Cloudflare Managed Ruleset on my zone-level phase entry point ruleset\n          enabled: true\n          expression: (http.host eq \"example.host.com\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Zone-level WAF with tag-based overrides\n  zoneLevelManagedWafWithCategoryBasedOverrides:\n    type: cloudflare:Ruleset\n    properties:\n      description: managed WAF with tag-based overrides ruleset description\n      kind: zone\n      name: managed WAF with tag-based overrides\n      phase: http_request_firewall_managed\n      rules:\n        - action: execute\n          actionParameters:\n            id: efb7b8c949ac4650a09736fc376e9aee\n            overrides:\n              categories:\n                - action: block\n                  category: wordpress\n                  status: enabled\n                - action: block\n                  category: joomla\n                  status: enabled\n          description: overrides to only enable wordpress rules to block\n          enabled: false\n          expression: (http.host eq \"example.host.com\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Rewrite the URI path component to a static path\n  transformUriRulePath:\n    type: cloudflare:Ruleset\n    properties:\n      description: change the URI path to a new static path\n      kind: zone\n      name: transform rule for URI path\n      phase: http_request_transform\n      rules:\n        - action: rewrite\n          actionParameters:\n            uri:\n              path:\n                value: /my-new-route\n          description: example URI path transform rule\n          enabled: true\n          expression: (http.host eq \"example.com\" and http.request.uri.path eq \"/old-path\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Rewrite the URI query component to a static query\n  transformUriRuleQuery:\n    type: cloudflare:Ruleset\n    properties:\n      description: change the URI query to a new static query\n      kind: zone\n      name: transform rule for URI query parameter\n      phase: http_request_transform\n      rules:\n        - action: rewrite\n          actionParameters:\n            uri:\n              query:\n                value: old=new_again\n          description: URI transformation query example\n          enabled: true\n          expression: (http.host eq \"example.host.com\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Rewrite HTTP headers to a modified values\n  transformUriHttpHeaders:\n    type: cloudflare:Ruleset\n    properties:\n      description: modify HTTP headers before reaching origin\n      kind: zone\n      name: transform rule for HTTP headers\n      phase: http_request_late_transform\n      rules:\n        - action: rewrite\n          actionParameters:\n            headers:\n              - name: example-http-header-1\n                operation: set\n                value: my-http-header-value-1\n              - expression: cf.zone.name\n                name: example-http-header-2\n                operation: set\n              - name: example-http-header-3-to-remove\n                operation: remove\n          description: example request header transform rule\n          enabled: false\n          expression: (http.host eq \"example.host.com\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # HTTP rate limit for an API route\n  rateLimitingExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: apply HTTP rate limiting for a route\n      kind: zone\n      name: restrict API requests count\n      phase: http_ratelimit\n      rules:\n        - action: block\n          description: rate limit for API\n          enabled: true\n          expression: (http.request.uri.path matches \"^/api/\")\n          ratelimit:\n            characteristics:\n              - cf.colo.id\n              - ip.src\n            mitigationTimeout: 600\n            period: 60\n            requestsPerPeriod: 100\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Change origin for an API route\n  httpOriginExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: Change origin for a route\n      kind: zone\n      name: Change to some origin\n      phase: http_request_origin\n      rules:\n        - action: route\n          actionParameters:\n            hostHeader: some.host\n            origin:\n              host: some.host\n              port: 80\n          description: change origin to some.host\n          enabled: true\n          expression: (http.request.uri.path matches \"^/api/\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Custom fields logging\n  customFieldsLoggingExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: add custom fields to logging\n      kind: zone\n      name: log custom fields\n      phase: http_log_custom_fields\n      rules:\n        - action: log_custom_field\n          actionParameters:\n            cookieFields:\n              - __ga\n              - accountNumber\n              - __cfruid\n            requestFields:\n              - content-type\n              - x-forwarded-for\n              - host\n            responseFields:\n              - server\n              - content-type\n              - allow\n          description: log custom fields rule\n          enabled: true\n          expression: (http.host eq \"example.host.com\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Custom cache keys + settings\n  cacheSettingsExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: set cache settings for the request\n      kind: zone\n      name: set cache settings\n      phase: http_request_cache_settings\n      rules:\n        - action: set_cache_settings\n          actionParameters:\n            browserTtl:\n              mode: respect_origin\n            cacheKey:\n              cacheDeceptionArmor: true\n              customKey:\n                cookie:\n                  checkPresence:\n                    - cabc_t\n                    - cdef_t\n                  include:\n                    - cabc\n                    - cdef\n                header:\n                  checkPresence:\n                    - habc_t\n                    - hdef_t\n                  excludeOrigin: true\n                  include:\n                    - habc\n                    - hdef\n                host:\n                  resolved: true\n                queryString:\n                  exclude:\n                    - '*'\n                user:\n                  deviceType: true\n                  geo: false\n              ignoreQueryStringsOrder: false\n            edgeTtl:\n              default: 60\n              mode: override_origin\n              statusCodeTtl:\n                - statusCode: 200\n                  value: 50\n                - statusCodeRange:\n                    - from: 201\n                      to: 300\n                  value: 30\n            originErrorPagePassthru: false\n            respectStrongEtags: true\n            serveStale:\n              disableStaleWhileUpdating: true\n          description: set cache settings rule\n          enabled: true\n          expression: (http.host eq \"example.host.com\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Redirects based on a List resource\n  redirectFromListExample:\n    type: cloudflare:Ruleset\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      description: Redirect ruleset\n      kind: root\n      name: redirects\n      phase: http_request_redirect\n      rules:\n        - action: redirect\n          actionParameters:\n            fromList:\n              key: http.request.full_uri\n              name: redirect_list\n          description: Apply redirects from redirect_list\n          enabled: true\n          expression: http.request.full_uri in $redirect_list\n  # Dynamic Redirects from value resource\n  redirectFromValueExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: Redirect ruleset\n      kind: root\n      name: redirects\n      phase: http_request_dynamic_redirect\n      rules:\n        - action: redirect\n          actionParameters:\n            fromValue:\n              preserveQueryString: true\n              statusCode: 301\n              targetUrl:\n                value: some_host.com\n          description: Apply redirect from value\n          enabled: true\n          expression: (http.request.uri.path matches \"^/api/\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Serve some custom error response\n  httpCustomErrorExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: Serve some error response\n      kind: zone\n      name: Serve some error response\n      phase: http_custom_errors\n      rules:\n        - action: serve_error\n          actionParameters:\n            content: some error html\n            contentType: text/html\n            statusCode: '530'\n          description: serve some error response\n          enabled: true\n          expression: (http.request.uri.path matches \"^/api/\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  # Set Configuration Rules for an API route\n  httpConfigRulesExample:\n    type: cloudflare:Ruleset\n    properties:\n      description: set config rules for request\n      kind: zone\n      name: set config rules\n      phase: http_config_settings\n      rules:\n        - action: set_config\n          actionParameters:\n            bic: true\n            emailObfuscation: true\n          description: set config rules for matching request\n          enabled: true\n          expression: (http.request.uri.path matches \"^/api/\")\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport an account scoped Ruleset configuration.\n\n```sh\n $ pulumi import cloudflare:index/ruleset:Ruleset example account/\u003caccount_id\u003e/\u003cruleset_id\u003e\n```\n\n Import a zone scoped Ruleset configuration.\n\n```sh\n $ pulumi import cloudflare:index/ruleset:Ruleset example zone/\u003czone_id\u003e/\u003cruleset_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset and its intended use.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `schema`, `zone`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_custom_errors`, `http_log_custom_fields`, `http_request_cache_settings`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_late_transform_managed`, `http_request_main`, `http_request_origin`, `http_request_dynamic_redirect`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_firewall_managed`, `http_response_headers_transform`, `http_response_headers_transform_managed`, `magic_transit`, `http_ratelimit`, `http_request_sbfm`, `http_config_settings`.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "shareableEntitlementName": {
                    "type": "string",
                    "description": "Name of entitlement that is shareable between entities.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "required": [
                "kind",
                "name",
                "phase"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Brief summary of the ruleset and its intended use.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `schema`, `zone`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the ruleset. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "phase": {
                    "type": "string",
                    "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_custom_errors`, `http_log_custom_fields`, `http_request_cache_settings`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_late_transform_managed`, `http_request_main`, `http_request_origin`, `http_request_dynamic_redirect`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_firewall_managed`, `http_response_headers_transform`, `http_response_headers_transform_managed`, `magic_transit`, `http_ratelimit`, `http_request_sbfm`, `http_config_settings`.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "shareableEntitlementName": {
                    "type": "string",
                    "description": "Name of entitlement that is shareable between entities.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                }
            },
            "requiredInputs": [
                "kind",
                "name",
                "phase"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Ruleset resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. Conflicts with `zone_id`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Brief summary of the ruleset and its intended use.\n"
                    },
                    "kind": {
                        "type": "string",
                        "description": "Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `schema`, `zone`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the ruleset. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "phase": {
                        "type": "string",
                        "description": "Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_custom_errors`, `http_log_custom_fields`, `http_request_cache_settings`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_late_transform_managed`, `http_request_main`, `http_request_origin`, `http_request_dynamic_redirect`, `http_request_redirect`, `http_request_sanitize`, `http_request_transform`, `http_response_firewall_managed`, `http_response_headers_transform`, `http_response_headers_transform_managed`, `magic_transit`, `http_ratelimit`, `http_request_sbfm`, `http_config_settings`.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/RulesetRule:RulesetRule"
                        },
                        "description": "List of rules to apply to the ruleset.\n"
                    },
                    "shareableEntitlementName": {
                        "type": "string",
                        "description": "Name of entitlement that is shareable between entities.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/spectrumApplication:SpectrumApplication": {
            "description": "Provides a Cloudflare Spectrum Application. You can extend the power of Cloudflare's DDoS, TLS, and IP Firewall to your other TCP-based services.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Define a spectrum application proxies ssh traffic\nconst sshProxy = new cloudflare.SpectrumApplication(\"sshProxy\", {\n    zoneId: _var.cloudflare_zone_id,\n    protocol: \"tcp/22\",\n    trafficType: \"direct\",\n    dns: {\n        type: \"CNAME\",\n        name: \"ssh.example.com\",\n    },\n    originDirects: [\"tcp://109.151.40.129:22\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Define a spectrum application proxies ssh traffic\nssh_proxy = cloudflare.SpectrumApplication(\"sshProxy\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    protocol=\"tcp/22\",\n    traffic_type=\"direct\",\n    dns=cloudflare.SpectrumApplicationDnsArgs(\n        type=\"CNAME\",\n        name=\"ssh.example.com\",\n    ),\n    origin_directs=[\"tcp://109.151.40.129:22\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Define a spectrum application proxies ssh traffic\n    var sshProxy = new Cloudflare.SpectrumApplication(\"sshProxy\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Protocol = \"tcp/22\",\n        TrafficType = \"direct\",\n        Dns = new Cloudflare.Inputs.SpectrumApplicationDnsArgs\n        {\n            Type = \"CNAME\",\n            Name = \"ssh.example.com\",\n        },\n        OriginDirects = new[]\n        {\n            \"tcp://109.151.40.129:22\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewSpectrumApplication(ctx, \"sshProxy\", \u0026cloudflare.SpectrumApplicationArgs{\n\t\t\tZoneId:      pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tProtocol:    pulumi.String(\"tcp/22\"),\n\t\t\tTrafficType: pulumi.String(\"direct\"),\n\t\t\tDns: \u0026cloudflare.SpectrumApplicationDnsArgs{\n\t\t\t\tType: pulumi.String(\"CNAME\"),\n\t\t\t\tName: pulumi.String(\"ssh.example.com\"),\n\t\t\t},\n\t\t\tOriginDirects: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tcp://109.151.40.129:22\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.SpectrumApplication;\nimport com.pulumi.cloudflare.SpectrumApplicationArgs;\nimport com.pulumi.cloudflare.inputs.SpectrumApplicationDnsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sshProxy = new SpectrumApplication(\"sshProxy\", SpectrumApplicationArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .protocol(\"tcp/22\")\n            .trafficType(\"direct\")\n            .dns(SpectrumApplicationDnsArgs.builder()\n                .type(\"CNAME\")\n                .name(\"ssh.example.com\")\n                .build())\n            .originDirects(\"tcp://109.151.40.129:22\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Define a spectrum application proxies ssh traffic\n  sshProxy:\n    type: cloudflare:SpectrumApplication\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      protocol: tcp/22\n      trafficType: direct\n      dns:\n        type: CNAME\n        name: ssh.example.com\n      originDirects:\n        - tcp://109.151.40.129:22\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSpectrum resource can be imported using a zone ID and Application ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/spectrumApplication:SpectrumApplication example d41d8cd98f00b204e9800998ecf8427e/9a7806061c88ada191ed06f989cc3dac\n```\n\n where- `d41d8cd98f00b204e9800998ecf8427e` - zone ID, as returned from [API](https://api.cloudflare.com/#zone-list-zones) - `9a7806061c88ada191ed06f989cc3dac` - Application ID ",
            "properties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                },
                "edgeIpConnectivity": {
                    "type": "string",
                    "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                },
                "edgeIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "If using `origin_dns` and not `origin_port_range`, this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                },
                "originPortRange": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                    "description": "If using `origin_dns` and not `origin_port`, this is a required attribute. Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Fields documented below.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflares edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Valid values are: `direct`, `http`, `https`. Defaults to `direct`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the application to\n"
                }
            },
            "required": [
                "dns",
                "edgeIpConnectivity",
                "protocol",
                "zoneId"
            ],
            "inputProperties": {
                "argoSmartRouting": {
                    "type": "boolean",
                    "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                },
                "dns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                    "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                },
                "edgeIpConnectivity": {
                    "type": "string",
                    "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                },
                "edgeIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                },
                "ipFirewall": {
                    "type": "boolean",
                    "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                },
                "originDirects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                },
                "originDns": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                    "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                },
                "originPort": {
                    "type": "integer",
                    "description": "If using `origin_dns` and not `origin_port_range`, this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                },
                "originPortRange": {
                    "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                    "description": "If using `origin_dns` and not `origin_port`, this is a required attribute. Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Fields documented below.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The port configuration at Cloudflares edge. e.g. `tcp/22`.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                },
                "tls": {
                    "type": "string",
                    "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                },
                "trafficType": {
                    "type": "string",
                    "description": "Sets application type. Valid values are: `direct`, `http`, `https`. Defaults to `direct`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to add the application to\n"
                }
            },
            "requiredInputs": [
                "dns",
                "protocol",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SpectrumApplication resources.\n",
                "properties": {
                    "argoSmartRouting": {
                        "type": "boolean",
                        "description": ". Enables Argo Smart Routing. Defaults to `false`.\n"
                    },
                    "dns": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationDns:SpectrumApplicationDns",
                        "description": "The name and type of DNS record for the Spectrum application. Fields documented below.\n"
                    },
                    "edgeIpConnectivity": {
                        "type": "string",
                        "description": ". Choose which types of IP addresses will be provisioned for this subdomain. Valid values are: `all`, `ipv4`, `ipv6`. Defaults to `all`.\n"
                    },
                    "edgeIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". A list of edge IPs (IPv4 and/or IPv6) to configure Spectrum application to. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.\n"
                    },
                    "ipFirewall": {
                        "type": "boolean",
                        "description": "Enables the IP Firewall for this application. Defaults to `true`.\n"
                    },
                    "originDirects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.\n"
                    },
                    "originDns": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginDns:SpectrumApplicationOriginDns",
                        "description": "A destination DNS addresses to the origin. Fields documented below.\n"
                    },
                    "originPort": {
                        "type": "integer",
                        "description": "If using `origin_dns` and not `origin_port_range`, this is a required attribute. Origin port to proxy traffice to e.g. `22`.\n"
                    },
                    "originPortRange": {
                        "$ref": "#/types/cloudflare:index/SpectrumApplicationOriginPortRange:SpectrumApplicationOriginPortRange",
                        "description": "If using `origin_dns` and not `origin_port`, this is a required attribute. Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Fields documented below.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The port configuration at Cloudflares edge. e.g. `tcp/22`.\n"
                    },
                    "proxyProtocol": {
                        "type": "string",
                        "description": "Enables a proxy protocol to the origin. Valid values are: `off`, `v1`, `v2`, and `simple`. Defaults to `off`.\n"
                    },
                    "tls": {
                        "type": "string",
                        "description": "TLS configuration option for Cloudflare to connect to your origin. Valid values are: `off`, `flexible`, `full` and `strict`. Defaults to `off`.\n"
                    },
                    "trafficType": {
                        "type": "string",
                        "description": "Sets application type. Valid values are: `direct`, `http`, `https`. Defaults to `direct`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to add the application to\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/splitTunnel:SplitTunnel": {
            "description": "Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either\ninclude or exclude lists of routes from the WARP client's tunnel.\n\n\n## Import\n\nSplit Tunnels for default device policies must use \"default\" as the policy ID.\n\n```sh\n $ pulumi import cloudflare:index/splitTunnel:SplitTunnel example \u003caccount_id\u003e/\u003cpolicy_id\u003e/\u003cmode\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this split tunnel policy.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes.\n"
                }
            },
            "required": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The settings policy for which to configure this split tunnel policy.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                    },
                    "description": "The value of the tunnel attributes.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "mode",
                "tunnels"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SplitTunnel resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the split tunnel policy. Available values: `include`, `exclude`.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The settings policy for which to configure this split tunnel policy.\n"
                    },
                    "tunnels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/SplitTunnelTunnel:SplitTunnelTunnel"
                        },
                        "description": "The value of the tunnel attributes.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/staticRoute:StaticRoute": {
            "description": "Provides a resource, that manages Cloudflare static routes for Magic Transit or Magic WAN.\nStatic routes are used to route traffic through GRE tunnels.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.StaticRoute(\"example\", {\n    accountId: \"c4a7362d577a6c3019a474fd6f485821\",\n    coloNames: [\"den01\"],\n    coloRegions: [\"APAC\"],\n    description: \"New route for new prefix 192.0.2.0/24\",\n    nexthop: \"10.0.0.0\",\n    prefix: \"192.0.2.0/24\",\n    priority: 100,\n    weight: 10,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.StaticRoute(\"example\",\n    account_id=\"c4a7362d577a6c3019a474fd6f485821\",\n    colo_names=[\"den01\"],\n    colo_regions=[\"APAC\"],\n    description=\"New route for new prefix 192.0.2.0/24\",\n    nexthop=\"10.0.0.0\",\n    prefix=\"192.0.2.0/24\",\n    priority=100,\n    weight=10)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.StaticRoute(\"example\", new()\n    {\n        AccountId = \"c4a7362d577a6c3019a474fd6f485821\",\n        ColoNames = new[]\n        {\n            \"den01\",\n        },\n        ColoRegions = new[]\n        {\n            \"APAC\",\n        },\n        Description = \"New route for new prefix 192.0.2.0/24\",\n        Nexthop = \"10.0.0.0\",\n        Prefix = \"192.0.2.0/24\",\n        Priority = 100,\n        Weight = 10,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewStaticRoute(ctx, \"example\", \u0026cloudflare.StaticRouteArgs{\n\t\t\tAccountId: pulumi.String(\"c4a7362d577a6c3019a474fd6f485821\"),\n\t\t\tColoNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"den01\"),\n\t\t\t},\n\t\t\tColoRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"APAC\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"New route for new prefix 192.0.2.0/24\"),\n\t\t\tNexthop:     pulumi.String(\"10.0.0.0\"),\n\t\t\tPrefix:      pulumi.String(\"192.0.2.0/24\"),\n\t\t\tPriority:    pulumi.Int(100),\n\t\t\tWeight:      pulumi.Int(10),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.StaticRoute;\nimport com.pulumi.cloudflare.StaticRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new StaticRoute(\"example\", StaticRouteArgs.builder()        \n            .accountId(\"c4a7362d577a6c3019a474fd6f485821\")\n            .coloNames(\"den01\")\n            .coloRegions(\"APAC\")\n            .description(\"New route for new prefix 192.0.2.0/24\")\n            .nexthop(\"10.0.0.0\")\n            .prefix(\"192.0.2.0/24\")\n            .priority(100)\n            .weight(10)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:StaticRoute\n    properties:\n      accountId: c4a7362d577a6c3019a474fd6f485821\n      coloNames:\n        - den01\n      coloRegions:\n        - APAC\n      description: New route for new prefix 192.0.2.0/24\n      nexthop: 10.0.0.0\n      prefix: 192.0.2.0/24\n      priority: 100\n      weight: 10\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAn existing static route can be imported using the account ID and static route ID\n\n```sh\n $ pulumi import cloudflare:index/staticRoute:StaticRoute example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the static route is being created.\n"
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation names for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation regions for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes.\n"
                }
            },
            "required": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The ID of the account where the static route is being created.\n",
                    "willReplaceOnChanges": true
                },
                "coloNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation names for this static route.\n"
                },
                "coloRegions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of Cloudflare colocation regions for this static route.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the static route.\n"
                },
                "nexthop": {
                    "type": "string",
                    "description": "The nexthop IP address where traffic will be routed to.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Your network prefix using CIDR notation.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority for the static route.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The optional weight for ECMP routes.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nexthop",
                "prefix",
                "priority"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StaticRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The ID of the account where the static route is being created.\n",
                        "willReplaceOnChanges": true
                    },
                    "coloNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of Cloudflare colocation names for this static route.\n"
                    },
                    "coloRegions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional list of Cloudflare colocation regions for this static route.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the static route.\n"
                    },
                    "nexthop": {
                        "type": "string",
                        "description": "The nexthop IP address where traffic will be routed to.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "Your network prefix using CIDR notation.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority for the static route.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The optional weight for ECMP routes.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsAccount:TeamsAccount": {
            "description": "Provides a Cloudflare Teams Account resource. The Teams Account resource defines configuration for secure web gateway.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst main = new cloudflare.TeamsAccount(\"main\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    antivirus: {\n        enabledDownloadPhase: true,\n        enabledUploadPhase: false,\n        failClosed: true,\n    },\n    blockPage: {\n        backgroundColor: \"#000000\",\n        footerText: \"hello\",\n        headerText: \"hello\",\n        logoPath: \"https://google.com\",\n    },\n    fips: {\n        tls: true,\n    },\n    logging: {\n        redactPii: true,\n        settingsByRuleType: {\n            dns: {\n                logAll: false,\n                logBlocks: true,\n            },\n            http: {\n                logAll: true,\n                logBlocks: true,\n            },\n            l4: {\n                logAll: false,\n                logBlocks: true,\n            },\n        },\n    },\n    proxy: {\n        tcp: true,\n        udp: true,\n    },\n    tlsDecryptEnabled: true,\n    urlBrowserIsolationEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmain = cloudflare.TeamsAccount(\"main\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    antivirus=cloudflare.TeamsAccountAntivirusArgs(\n        enabled_download_phase=True,\n        enabled_upload_phase=False,\n        fail_closed=True,\n    ),\n    block_page=cloudflare.TeamsAccountBlockPageArgs(\n        background_color=\"#000000\",\n        footer_text=\"hello\",\n        header_text=\"hello\",\n        logo_path=\"https://google.com\",\n    ),\n    fips=cloudflare.TeamsAccountFipsArgs(\n        tls=True,\n    ),\n    logging=cloudflare.TeamsAccountLoggingArgs(\n        redact_pii=True,\n        settings_by_rule_type=cloudflare.TeamsAccountLoggingSettingsByRuleTypeArgs(\n            dns=cloudflare.TeamsAccountLoggingSettingsByRuleTypeDnsArgs(\n                log_all=False,\n                log_blocks=True,\n            ),\n            http=cloudflare.TeamsAccountLoggingSettingsByRuleTypeHttpArgs(\n                log_all=True,\n                log_blocks=True,\n            ),\n            l4=cloudflare.TeamsAccountLoggingSettingsByRuleTypeL4Args(\n                log_all=False,\n                log_blocks=True,\n            ),\n        ),\n    ),\n    proxy=cloudflare.TeamsAccountProxyArgs(\n        tcp=True,\n        udp=True,\n    ),\n    tls_decrypt_enabled=True,\n    url_browser_isolation_enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new Cloudflare.TeamsAccount(\"main\", new()\n    {\n        AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        Antivirus = new Cloudflare.Inputs.TeamsAccountAntivirusArgs\n        {\n            EnabledDownloadPhase = true,\n            EnabledUploadPhase = false,\n            FailClosed = true,\n        },\n        BlockPage = new Cloudflare.Inputs.TeamsAccountBlockPageArgs\n        {\n            BackgroundColor = \"#000000\",\n            FooterText = \"hello\",\n            HeaderText = \"hello\",\n            LogoPath = \"https://google.com\",\n        },\n        Fips = new Cloudflare.Inputs.TeamsAccountFipsArgs\n        {\n            Tls = true,\n        },\n        Logging = new Cloudflare.Inputs.TeamsAccountLoggingArgs\n        {\n            RedactPii = true,\n            SettingsByRuleType = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeArgs\n            {\n                Dns = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeDnsArgs\n                {\n                    LogAll = false,\n                    LogBlocks = true,\n                },\n                Http = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeHttpArgs\n                {\n                    LogAll = true,\n                    LogBlocks = true,\n                },\n                L4 = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeL4Args\n                {\n                    LogAll = false,\n                    LogBlocks = true,\n                },\n            },\n        },\n        Proxy = new Cloudflare.Inputs.TeamsAccountProxyArgs\n        {\n            Tcp = true,\n            Udp = true,\n        },\n        TlsDecryptEnabled = true,\n        UrlBrowserIsolationEnabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsAccount(ctx, \"main\", \u0026cloudflare.TeamsAccountArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tAntivirus: \u0026cloudflare.TeamsAccountAntivirusArgs{\n\t\t\t\tEnabledDownloadPhase: pulumi.Bool(true),\n\t\t\t\tEnabledUploadPhase:   pulumi.Bool(false),\n\t\t\t\tFailClosed:           pulumi.Bool(true),\n\t\t\t},\n\t\t\tBlockPage: \u0026cloudflare.TeamsAccountBlockPageArgs{\n\t\t\t\tBackgroundColor: pulumi.String(\"#000000\"),\n\t\t\t\tFooterText:      pulumi.String(\"hello\"),\n\t\t\t\tHeaderText:      pulumi.String(\"hello\"),\n\t\t\t\tLogoPath:        pulumi.String(\"https://google.com\"),\n\t\t\t},\n\t\t\tFips: \u0026cloudflare.TeamsAccountFipsArgs{\n\t\t\t\tTls: pulumi.Bool(true),\n\t\t\t},\n\t\t\tLogging: \u0026cloudflare.TeamsAccountLoggingArgs{\n\t\t\t\tRedactPii: pulumi.Bool(true),\n\t\t\t\tSettingsByRuleType: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeArgs{\n\t\t\t\t\tDns: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeDnsArgs{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(false),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tHttp: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeHttpArgs{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(true),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\tL4: \u0026cloudflare.TeamsAccountLoggingSettingsByRuleTypeL4Args{\n\t\t\t\t\t\tLogAll:    pulumi.Bool(false),\n\t\t\t\t\t\tLogBlocks: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tProxy: \u0026cloudflare.TeamsAccountProxyArgs{\n\t\t\t\tTcp: pulumi.Bool(true),\n\t\t\t\tUdp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tTlsDecryptEnabled:          pulumi.Bool(true),\n\t\t\tUrlBrowserIsolationEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsAccount;\nimport com.pulumi.cloudflare.TeamsAccountArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountAntivirusArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountBlockPageArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountFipsArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeDnsArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeHttpArgs;\nimport com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeL4Args;\nimport com.pulumi.cloudflare.inputs.TeamsAccountProxyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new TeamsAccount(\"main\", TeamsAccountArgs.builder()        \n            .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .antivirus(TeamsAccountAntivirusArgs.builder()\n                .enabledDownloadPhase(true)\n                .enabledUploadPhase(false)\n                .failClosed(true)\n                .build())\n            .blockPage(TeamsAccountBlockPageArgs.builder()\n                .backgroundColor(\"#000000\")\n                .footerText(\"hello\")\n                .headerText(\"hello\")\n                .logoPath(\"https://google.com\")\n                .build())\n            .fips(TeamsAccountFipsArgs.builder()\n                .tls(true)\n                .build())\n            .logging(TeamsAccountLoggingArgs.builder()\n                .redactPii(true)\n                .settingsByRuleType(TeamsAccountLoggingSettingsByRuleTypeArgs.builder()\n                    .dns(TeamsAccountLoggingSettingsByRuleTypeDnsArgs.builder()\n                        .logAll(false)\n                        .logBlocks(true)\n                        .build())\n                    .http(TeamsAccountLoggingSettingsByRuleTypeHttpArgs.builder()\n                        .logAll(true)\n                        .logBlocks(true)\n                        .build())\n                    .l4(TeamsAccountLoggingSettingsByRuleTypeL4Args.builder()\n                        .logAll(false)\n                        .logBlocks(true)\n                        .build())\n                    .build())\n                .build())\n            .proxy(TeamsAccountProxyArgs.builder()\n                .tcp(true)\n                .udp(true)\n                .build())\n            .tlsDecryptEnabled(true)\n            .urlBrowserIsolationEnabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: cloudflare:TeamsAccount\n    properties:\n      accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      antivirus:\n        enabledDownloadPhase: true\n        enabledUploadPhase: false\n        failClosed: true\n      blockPage:\n        backgroundColor: '#000000'\n        footerText: hello\n        headerText: hello\n        logoPath: https://google.com\n      fips:\n        tls: true\n      logging:\n        redactPii: true\n        settingsByRuleType:\n          dns:\n            logAll: false\n            logBlocks: true\n          http:\n            logAll: true\n            logBlocks: true\n          l4:\n            logAll: false\n            logBlocks: true\n      proxy:\n        tcp: true\n        udp: true\n      tlsDecryptEnabled: true\n      urlBrowserIsolationEnabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nSince a Teams account does not have a unique resource ID, configuration can be imported using the account ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsAccount:TeamsAccount example cb029e245cfdd66dc8d2e570d5dd3322\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                    "description": "Configuration block for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "fips": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountFips:TeamsAccountFips",
                    "description": "Configure compliance with Federal Information Processing Standards.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLogging:TeamsAccountLogging"
                },
                "proxy": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountProxy:TeamsAccountProxy",
                    "description": "Configuration block for specifying which protocols are proxied.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                },
                "urlBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Safely browse websites in Browser Isolation through a URL.\n"
                }
            },
            "required": [
                "accountId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "activityLogEnabled": {
                    "type": "boolean"
                },
                "antivirus": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                    "description": "Configuration block for antivirus traffic scanning.\n"
                },
                "blockPage": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                    "description": "Configuration for a custom block page.\n"
                },
                "fips": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountFips:TeamsAccountFips",
                    "description": "Configure compliance with Federal Information Processing Standards.\n"
                },
                "logging": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountLogging:TeamsAccountLogging"
                },
                "proxy": {
                    "$ref": "#/types/cloudflare:index/TeamsAccountProxy:TeamsAccountProxy",
                    "description": "Configuration block for specifying which protocols are proxied.\n"
                },
                "tlsDecryptEnabled": {
                    "type": "boolean",
                    "description": "Indicator that decryption of TLS traffic is enabled.\n"
                },
                "urlBrowserIsolationEnabled": {
                    "type": "boolean",
                    "description": "Safely browse websites in Browser Isolation through a URL.\n"
                }
            },
            "requiredInputs": [
                "accountId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsAccount resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams location should be added.\n"
                    },
                    "activityLogEnabled": {
                        "type": "boolean"
                    },
                    "antivirus": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountAntivirus:TeamsAccountAntivirus",
                        "description": "Configuration block for antivirus traffic scanning.\n"
                    },
                    "blockPage": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountBlockPage:TeamsAccountBlockPage",
                        "description": "Configuration for a custom block page.\n"
                    },
                    "fips": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountFips:TeamsAccountFips",
                        "description": "Configure compliance with Federal Information Processing Standards.\n"
                    },
                    "logging": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountLogging:TeamsAccountLogging"
                    },
                    "proxy": {
                        "$ref": "#/types/cloudflare:index/TeamsAccountProxy:TeamsAccountProxy",
                        "description": "Configuration block for specifying which protocols are proxied.\n"
                    },
                    "tlsDecryptEnabled": {
                        "type": "boolean",
                        "description": "Indicator that decryption of TLS traffic is enabled.\n"
                    },
                    "urlBrowserIsolationEnabled": {
                        "type": "boolean",
                        "description": "Safely browse websites in Browser Isolation through a URL.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsList:TeamsList": {
            "description": "Provides a Cloudflare Teams List resource. Teams lists are referenced when creating secure web gateway policies or device posture rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst corporateDevices = new cloudflare.TeamsList(\"corporateDevices\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    description: \"Serial numbers for all corporate devices.\",\n    items: [\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ],\n    name: \"Corporate devices\",\n    type: \"SERIAL\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ncorporate_devices = cloudflare.TeamsList(\"corporateDevices\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    description=\"Serial numbers for all corporate devices.\",\n    items=[\n        \"8GE8721REF\",\n        \"5RE8543EGG\",\n        \"1YE2880LNP\",\n    ],\n    name=\"Corporate devices\",\n    type=\"SERIAL\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var corporateDevices = new Cloudflare.TeamsList(\"corporateDevices\", new()\n    {\n        AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        Description = \"Serial numbers for all corporate devices.\",\n        Items = new[]\n        {\n            \"8GE8721REF\",\n            \"5RE8543EGG\",\n            \"1YE2880LNP\",\n        },\n        Name = \"Corporate devices\",\n        Type = \"SERIAL\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsList(ctx, \"corporateDevices\", \u0026cloudflare.TeamsListArgs{\n\t\t\tAccountId:   pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tDescription: pulumi.String(\"Serial numbers for all corporate devices.\"),\n\t\t\tItems: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"8GE8721REF\"),\n\t\t\t\tpulumi.String(\"5RE8543EGG\"),\n\t\t\t\tpulumi.String(\"1YE2880LNP\"),\n\t\t\t},\n\t\t\tName: pulumi.String(\"Corporate devices\"),\n\t\t\tType: pulumi.String(\"SERIAL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsList;\nimport com.pulumi.cloudflare.TeamsListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var corporateDevices = new TeamsList(\"corporateDevices\", TeamsListArgs.builder()        \n            .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .description(\"Serial numbers for all corporate devices.\")\n            .items(            \n                \"8GE8721REF\",\n                \"5RE8543EGG\",\n                \"1YE2880LNP\")\n            .name(\"Corporate devices\")\n            .type(\"SERIAL\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  corporateDevices:\n    type: cloudflare:TeamsList\n    properties:\n      accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      description: Serial numbers for all corporate devices.\n      items:\n        - 8GE8721REF\n        - 5RE8543EGG\n        - 1YE2880LNP\n      name: Corporate devices\n      type: SERIAL\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams lists can be imported using a composite ID formed of account ID and teams list ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsList:TeamsList corporate_devices cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams list should be added.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Valid values are `IP`, `SERIAL`, `URL`, `DOMAIN`, and `EMAIL`.\n"
                }
            },
            "required": [
                "accountId",
                "name",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams list should be added.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams list.\n"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The items of the teams list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The teams list type. Valid values are `IP`, `SERIAL`, `URL`, `DOMAIN`, and `EMAIL`.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsList resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams list should be added.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams list.\n"
                    },
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The items of the teams list.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams list.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The teams list type. Valid values are `IP`, `SERIAL`, `URL`, `DOMAIN`, and `EMAIL`.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsLocation:TeamsLocation": {
            "description": "Provides a Cloudflare Teams Location resource. Teams Locations are referenced\nwhen creating secure web gateway policies.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst corporateOffice = new cloudflare.TeamsLocation(\"corporateOffice\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    clientDefault: true,\n    name: \"office\",\n    networks: [\n        {\n            network: \"203.0.113.1/32\",\n        },\n        {\n            network: \"203.0.113.2/32\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ncorporate_office = cloudflare.TeamsLocation(\"corporateOffice\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    client_default=True,\n    name=\"office\",\n    networks=[\n        cloudflare.TeamsLocationNetworkArgs(\n            network=\"203.0.113.1/32\",\n        ),\n        cloudflare.TeamsLocationNetworkArgs(\n            network=\"203.0.113.2/32\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var corporateOffice = new Cloudflare.TeamsLocation(\"corporateOffice\", new()\n    {\n        AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        ClientDefault = true,\n        Name = \"office\",\n        Networks = new[]\n        {\n            new Cloudflare.Inputs.TeamsLocationNetworkArgs\n            {\n                Network = \"203.0.113.1/32\",\n            },\n            new Cloudflare.Inputs.TeamsLocationNetworkArgs\n            {\n                Network = \"203.0.113.2/32\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsLocation(ctx, \"corporateOffice\", \u0026cloudflare.TeamsLocationArgs{\n\t\t\tAccountId:     pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tClientDefault: pulumi.Bool(true),\n\t\t\tName:          pulumi.String(\"office\"),\n\t\t\tNetworks: cloudflare.TeamsLocationNetworkArray{\n\t\t\t\t\u0026cloudflare.TeamsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.1/32\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.TeamsLocationNetworkArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"203.0.113.2/32\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsLocation;\nimport com.pulumi.cloudflare.TeamsLocationArgs;\nimport com.pulumi.cloudflare.inputs.TeamsLocationNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var corporateOffice = new TeamsLocation(\"corporateOffice\", TeamsLocationArgs.builder()        \n            .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .clientDefault(true)\n            .name(\"office\")\n            .networks(            \n                TeamsLocationNetworkArgs.builder()\n                    .network(\"203.0.113.1/32\")\n                    .build(),\n                TeamsLocationNetworkArgs.builder()\n                    .network(\"203.0.113.2/32\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  corporateOffice:\n    type: cloudflare:TeamsLocation\n    properties:\n      accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      clientDefault: true\n      name: office\n      networks:\n        - network: 203.0.113.1/32\n        - network: 203.0.113.2/32\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams locations can be imported using a composite ID formed of account ID and teams location ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsLocation:TeamsLocation corporate_office cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "anonymizedLogsEnabled": {
                    "type": "boolean",
                    "description": "Indicator that anonymized logs are enabled.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "dohSubdomain": {
                    "type": "string",
                    "description": "The FQDN that DoH clients should be pointed at.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Client IP address\n"
                },
                "ipv4Destination": {
                    "type": "string",
                    "description": "IP to direct all IPv4 DNS queries too.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                },
                "policyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "accountId",
                "anonymizedLogsEnabled",
                "dohSubdomain",
                "ip",
                "ipv4Destination",
                "name",
                "policyIds"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams location should be added.\n"
                },
                "clientDefault": {
                    "type": "boolean",
                    "description": "Indicator that this is the default location.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams location.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                    },
                    "description": "The networks CIDRs that comprise the location.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsLocation resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams location should be added.\n"
                    },
                    "anonymizedLogsEnabled": {
                        "type": "boolean",
                        "description": "Indicator that anonymized logs are enabled.\n"
                    },
                    "clientDefault": {
                        "type": "boolean",
                        "description": "Indicator that this is the default location.\n"
                    },
                    "dohSubdomain": {
                        "type": "string",
                        "description": "The FQDN that DoH clients should be pointed at.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "Client IP address\n"
                    },
                    "ipv4Destination": {
                        "type": "string",
                        "description": "IP to direct all IPv4 DNS queries too.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams location.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/TeamsLocationNetwork:TeamsLocationNetwork"
                        },
                        "description": "The networks CIDRs that comprise the location.\n"
                    },
                    "policyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint": {
            "description": "Provides a Cloudflare Teams Proxy Endpoint resource. Teams Proxy Endpoints are used for pointing proxy clients at\nCloudflare Secure Gateway.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst corporateOffice = new cloudflare.TeamsProxyEndpoint(\"corporateOffice\", {\n    accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    ips: [\"192.0.2.0/24\"],\n    name: \"office\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ncorporate_office = cloudflare.TeamsProxyEndpoint(\"corporateOffice\",\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    ips=[\"192.0.2.0/24\"],\n    name=\"office\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var corporateOffice = new Cloudflare.TeamsProxyEndpoint(\"corporateOffice\", new()\n    {\n        AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        Ips = new[]\n        {\n            \"192.0.2.0/24\",\n        },\n        Name = \"office\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsProxyEndpoint(ctx, \"corporateOffice\", \u0026cloudflare.TeamsProxyEndpointArgs{\n\t\t\tAccountId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.0.2.0/24\"),\n\t\t\t},\n\t\t\tName: pulumi.String(\"office\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsProxyEndpoint;\nimport com.pulumi.cloudflare.TeamsProxyEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var corporateOffice = new TeamsProxyEndpoint(\"corporateOffice\", TeamsProxyEndpointArgs.builder()        \n            .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .ips(\"192.0.2.0/24\")\n            .name(\"office\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  corporateOffice:\n    type: cloudflare:TeamsProxyEndpoint\n    properties:\n      accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      ips:\n        - 192.0.2.0/24\n      name: office\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams Proxy Endpoints can be imported using a composite ID formed of account ID and teams proxy_endpoint ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint corporate_office cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams proxy endpoint should be added.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams proxy endpoint.\n"
                },
                "subdomain": {
                    "type": "string",
                    "description": "The FQDN that proxy clients should be pointed at.\n"
                }
            },
            "required": [
                "accountId",
                "ips",
                "name",
                "subdomain"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams proxy endpoint should be added.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the teams proxy endpoint.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "ips",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsProxyEndpoint resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams proxy endpoint should be added.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The networks CIDRs that will be allowed to initiate proxy connections.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the teams proxy endpoint.\n"
                    },
                    "subdomain": {
                        "type": "string",
                        "description": "The FQDN that proxy clients should be pointed at.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/teamsRule:TeamsRule": {
            "description": "Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst rule1 = new cloudflare.TeamsRule(\"rule1\", {\n    accountId: \"d57c3de47a013c03ca7e237dd3e61d7d\",\n    action: \"block\",\n    description: \"desc\",\n    filters: [\"http\"],\n    name: \"office\",\n    precedence: 1,\n    ruleSettings: {\n        blockPageEnabled: true,\n        blockPageReason: \"access not permitted\",\n    },\n    traffic: \"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nrule1 = cloudflare.TeamsRule(\"rule1\",\n    account_id=\"d57c3de47a013c03ca7e237dd3e61d7d\",\n    action=\"block\",\n    description=\"desc\",\n    filters=[\"http\"],\n    name=\"office\",\n    precedence=1,\n    rule_settings=cloudflare.TeamsRuleRuleSettingsArgs(\n        block_page_enabled=True,\n        block_page_reason=\"access not permitted\",\n    ),\n    traffic=\"http.request.uri == \\\"https://www.example.com/malicious\\\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rule1 = new Cloudflare.TeamsRule(\"rule1\", new()\n    {\n        AccountId = \"d57c3de47a013c03ca7e237dd3e61d7d\",\n        Action = \"block\",\n        Description = \"desc\",\n        Filters = new[]\n        {\n            \"http\",\n        },\n        Name = \"office\",\n        Precedence = 1,\n        RuleSettings = new Cloudflare.Inputs.TeamsRuleRuleSettingsArgs\n        {\n            BlockPageEnabled = true,\n            BlockPageReason = \"access not permitted\",\n        },\n        Traffic = \"http.request.uri == \\\"https://www.example.com/malicious\\\"\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTeamsRule(ctx, \"rule1\", \u0026cloudflare.TeamsRuleArgs{\n\t\t\tAccountId:   pulumi.String(\"d57c3de47a013c03ca7e237dd3e61d7d\"),\n\t\t\tAction:      pulumi.String(\"block\"),\n\t\t\tDescription: pulumi.String(\"desc\"),\n\t\t\tFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http\"),\n\t\t\t},\n\t\t\tName:       pulumi.String(\"office\"),\n\t\t\tPrecedence: pulumi.Int(1),\n\t\t\tRuleSettings: \u0026cloudflare.TeamsRuleRuleSettingsArgs{\n\t\t\t\tBlockPageEnabled: pulumi.Bool(true),\n\t\t\t\tBlockPageReason:  pulumi.String(\"access not permitted\"),\n\t\t\t},\n\t\t\tTraffic: pulumi.String(\"http.request.uri == \\\"https://www.example.com/malicious\\\"\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TeamsRule;\nimport com.pulumi.cloudflare.TeamsRuleArgs;\nimport com.pulumi.cloudflare.inputs.TeamsRuleRuleSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rule1 = new TeamsRule(\"rule1\", TeamsRuleArgs.builder()        \n            .accountId(\"d57c3de47a013c03ca7e237dd3e61d7d\")\n            .action(\"block\")\n            .description(\"desc\")\n            .filters(\"http\")\n            .name(\"office\")\n            .precedence(1)\n            .ruleSettings(TeamsRuleRuleSettingsArgs.builder()\n                .blockPageEnabled(true)\n                .blockPageReason(\"access not permitted\")\n                .build())\n            .traffic(\"http.request.uri == \\\"https://www.example.com/malicious\\\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule1:\n    type: cloudflare:TeamsRule\n    properties:\n      accountId: d57c3de47a013c03ca7e237dd3e61d7d\n      action: block\n      description: desc\n      filters:\n        - http\n      name: office\n      precedence: 1\n      ruleSettings:\n        blockPageEnabled: true\n        blockPageReason: access not permitted\n      traffic: http.request.uri == \"https://www.example.com/malicious\"\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTeams Rules can be imported using a composite ID formed of account ID and teams rule ID.\n\n```sh\n $ pulumi import cloudflare:index/teamsRule:TeamsRule rule1 cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams rule should be added.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                    "description": "Additional rule settings (refer to the nested schema).\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                },
                "version": {
                    "type": "integer"
                }
            },
            "required": [
                "accountId",
                "action",
                "description",
                "name",
                "precedence",
                "version"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account to which the teams rule should be added.\n"
                },
                "action": {
                    "type": "string",
                    "description": "The action executed by matched teams rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the teams rule.\n"
                },
                "devicePosture": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for device_posture check matching.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicator of rule enablement.\n"
                },
                "filters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                },
                "identity": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for identity matching.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the teams rule.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The evaluation precedence of the teams rule.\n"
                },
                "ruleSettings": {
                    "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                    "description": "Additional rule settings (refer to the nested schema).\n"
                },
                "traffic": {
                    "type": "string",
                    "description": "The wirefilter expression to be used for traffic matching.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "action",
                "description",
                "name",
                "precedence"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TeamsRule resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account to which the teams rule should be added.\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "The action executed by matched teams rule.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the teams rule.\n"
                    },
                    "devicePosture": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for device_posture check matching.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicator of rule enablement.\n"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The protocol or layer to evaluate the traffic and identity expressions.\n"
                    },
                    "identity": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for identity matching.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the teams rule.\n"
                    },
                    "precedence": {
                        "type": "integer",
                        "description": "The evaluation precedence of the teams rule.\n"
                    },
                    "ruleSettings": {
                        "$ref": "#/types/cloudflare:index/TeamsRuleRuleSettings:TeamsRuleRuleSettings",
                        "description": "Additional rule settings (refer to the nested schema).\n"
                    },
                    "traffic": {
                        "type": "string",
                        "description": "The wirefilter expression to be used for traffic matching.\n"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tieredCache:TieredCache": {
            "description": "Provides a resource, that manages Cloudflare Tiered Cache settings.\nThis allows you to adjust topologies for your zone.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TieredCache(\"example\", {\n    cacheType: \"smart\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TieredCache(\"example\",\n    cache_type=\"smart\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TieredCache(\"example\", new()\n    {\n        CacheType = \"smart\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTieredCache(ctx, \"example\", \u0026cloudflare.TieredCacheArgs{\n\t\t\tCacheType: pulumi.String(\"smart\"),\n\t\t\tZoneId:    pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TieredCache;\nimport com.pulumi.cloudflare.TieredCacheArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TieredCache(\"example\", TieredCacheArgs.builder()        \n            .cacheType(\"smart\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TieredCache\n    properties:\n      cacheType: smart\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "cacheType": {
                    "type": "string",
                    "description": "The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "cacheType",
                "zoneId"
            ],
            "inputProperties": {
                "cacheType": {
                    "type": "string",
                    "description": "The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "cacheType",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TieredCache resources.\n",
                "properties": {
                    "cacheType": {
                        "type": "string",
                        "description": "The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/totalTls:TotalTls": {
            "description": "Provides a resource which manages Total TLS for a zone.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TotalTls(\"example\", {\n    certificateAuthority: \"lets_encrypt\",\n    enabled: true,\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TotalTls(\"example\",\n    certificate_authority=\"lets_encrypt\",\n    enabled=True,\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TotalTls(\"example\", new()\n    {\n        CertificateAuthority = \"lets_encrypt\",\n        Enabled = true,\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTotalTls(ctx, \"example\", \u0026cloudflare.TotalTlsArgs{\n\t\t\tCertificateAuthority: pulumi.String(\"lets_encrypt\"),\n\t\t\tEnabled:              pulumi.Bool(true),\n\t\t\tZoneId:               pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TotalTls;\nimport com.pulumi.cloudflare.TotalTlsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TotalTls(\"example\", TotalTlsArgs.builder()        \n            .certificateAuthority(\"lets_encrypt\")\n            .enabled(true)\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TotalTls\n    properties:\n      certificateAuthority: lets_encrypt\n      enabled: true\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable Total TLS for the zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "enabled",
                "zoneId"
            ],
            "inputProperties": {
                "certificateAuthority": {
                    "type": "string",
                    "description": "The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable Total TLS for the zone.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TotalTls resources.\n",
                "properties": {
                    "certificateAuthority": {
                        "type": "string",
                        "description": "The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable Total TLS for the zone.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnelConfig:TunnelConfig": {
            "description": "Provides a Cloudflare Tunnel configuration resource.\n\n!\u003e When you delete a tunnel configuration, the tunnel will be deleted. You need to make sure that the tunnel is not in use before deleting the configuration.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleTunnel = new cloudflare.ArgoTunnel(\"exampleTunnel\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example_tunnel\",\n    secret: \"\u003c32 character secret\u003e\",\n});\nconst exampleConfig = new cloudflare.TunnelConfig(\"exampleConfig\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tunnelId: exampleTunnel.id,\n    config: {\n        warpRouting: {\n            enabled: true,\n        },\n        originRequest: {\n            connectTimeout: \"1m0s\",\n            tlsTimeout: \"1m0s\",\n            tcpKeepAlive: \"1m0s\",\n            noHappyEyeballs: false,\n            keepAliveConnections: 1024,\n            keepAliveTimeout: \"1m0s\",\n            httpHostHeader: \"baz\",\n            originServerName: \"foobar\",\n            caPool: \"/path/to/unsigned/ca/pool\",\n            noTlsVerify: false,\n            disableChunkedEncoding: false,\n            bastionMode: false,\n            proxyAddress: \"10.0.0.1\",\n            proxyPort: 8123,\n            proxyType: \"socks\",\n            ipRules: [{\n                prefix: \"/web\",\n                ports: [\n                    80,\n                    443,\n                ],\n                allow: false,\n            }],\n        },\n        ingressRules: [\n            {\n                hostname: \"foo\",\n                path: \"/bar\",\n                service: \"http://10.0.0.2:8080\",\n            },\n            {\n                service: \"https://10.0.0.3:8081\",\n            },\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_tunnel = cloudflare.ArgoTunnel(\"exampleTunnel\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example_tunnel\",\n    secret=\"\u003c32 character secret\u003e\")\nexample_config = cloudflare.TunnelConfig(\"exampleConfig\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tunnel_id=example_tunnel.id,\n    config=cloudflare.TunnelConfigConfigArgs(\n        warp_routing=cloudflare.TunnelConfigConfigWarpRoutingArgs(\n            enabled=True,\n        ),\n        origin_request=cloudflare.TunnelConfigConfigOriginRequestArgs(\n            connect_timeout=\"1m0s\",\n            tls_timeout=\"1m0s\",\n            tcp_keep_alive=\"1m0s\",\n            no_happy_eyeballs=False,\n            keep_alive_connections=1024,\n            keep_alive_timeout=\"1m0s\",\n            http_host_header=\"baz\",\n            origin_server_name=\"foobar\",\n            ca_pool=\"/path/to/unsigned/ca/pool\",\n            no_tls_verify=False,\n            disable_chunked_encoding=False,\n            bastion_mode=False,\n            proxy_address=\"10.0.0.1\",\n            proxy_port=8123,\n            proxy_type=\"socks\",\n            ip_rules=[cloudflare.TunnelConfigConfigOriginRequestIpRuleArgs(\n                prefix=\"/web\",\n                ports=[\n                    80,\n                    443,\n                ],\n                allow=False,\n            )],\n        ),\n        ingress_rules=[\n            cloudflare.TunnelConfigConfigIngressRuleArgs(\n                hostname=\"foo\",\n                path=\"/bar\",\n                service=\"http://10.0.0.2:8080\",\n            ),\n            cloudflare.TunnelConfigConfigIngressRuleArgs(\n                service=\"https://10.0.0.3:8081\",\n            ),\n        ],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleTunnel = new Cloudflare.ArgoTunnel(\"exampleTunnel\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example_tunnel\",\n        Secret = \"\u003c32 character secret\u003e\",\n    });\n\n    var exampleConfig = new Cloudflare.TunnelConfig(\"exampleConfig\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TunnelId = exampleTunnel.Id,\n        Config = new Cloudflare.Inputs.TunnelConfigConfigArgs\n        {\n            WarpRouting = new Cloudflare.Inputs.TunnelConfigConfigWarpRoutingArgs\n            {\n                Enabled = true,\n            },\n            OriginRequest = new Cloudflare.Inputs.TunnelConfigConfigOriginRequestArgs\n            {\n                ConnectTimeout = \"1m0s\",\n                TlsTimeout = \"1m0s\",\n                TcpKeepAlive = \"1m0s\",\n                NoHappyEyeballs = false,\n                KeepAliveConnections = 1024,\n                KeepAliveTimeout = \"1m0s\",\n                HttpHostHeader = \"baz\",\n                OriginServerName = \"foobar\",\n                CaPool = \"/path/to/unsigned/ca/pool\",\n                NoTlsVerify = false,\n                DisableChunkedEncoding = false,\n                BastionMode = false,\n                ProxyAddress = \"10.0.0.1\",\n                ProxyPort = 8123,\n                ProxyType = \"socks\",\n                IpRules = new[]\n                {\n                    new Cloudflare.Inputs.TunnelConfigConfigOriginRequestIpRuleArgs\n                    {\n                        Prefix = \"/web\",\n                        Ports = new[]\n                        {\n                            80,\n                            443,\n                        },\n                        Allow = false,\n                    },\n                },\n            },\n            IngressRules = new[]\n            {\n                new Cloudflare.Inputs.TunnelConfigConfigIngressRuleArgs\n                {\n                    Hostname = \"foo\",\n                    Path = \"/bar\",\n                    Service = \"http://10.0.0.2:8080\",\n                },\n                new Cloudflare.Inputs.TunnelConfigConfigIngressRuleArgs\n                {\n                    Service = \"https://10.0.0.3:8081\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleTunnel, err := cloudflare.NewArgoTunnel(ctx, \"exampleTunnel\", \u0026cloudflare.ArgoTunnelArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example_tunnel\"),\n\t\t\tSecret:    pulumi.String(\"\u003c32 character secret\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewTunnelConfig(ctx, \"exampleConfig\", \u0026cloudflare.TunnelConfigArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTunnelId:  exampleTunnel.ID(),\n\t\t\tConfig: \u0026cloudflare.TunnelConfigConfigArgs{\n\t\t\t\tWarpRouting: \u0026cloudflare.TunnelConfigConfigWarpRoutingArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\tOriginRequest: \u0026cloudflare.TunnelConfigConfigOriginRequestArgs{\n\t\t\t\t\tConnectTimeout:         pulumi.String(\"1m0s\"),\n\t\t\t\t\tTlsTimeout:             pulumi.String(\"1m0s\"),\n\t\t\t\t\tTcpKeepAlive:           pulumi.String(\"1m0s\"),\n\t\t\t\t\tNoHappyEyeballs:        pulumi.Bool(false),\n\t\t\t\t\tKeepAliveConnections:   pulumi.Int(1024),\n\t\t\t\t\tKeepAliveTimeout:       pulumi.String(\"1m0s\"),\n\t\t\t\t\tHttpHostHeader:         pulumi.String(\"baz\"),\n\t\t\t\t\tOriginServerName:       pulumi.String(\"foobar\"),\n\t\t\t\t\tCaPool:                 pulumi.String(\"/path/to/unsigned/ca/pool\"),\n\t\t\t\t\tNoTlsVerify:            pulumi.Bool(false),\n\t\t\t\t\tDisableChunkedEncoding: pulumi.Bool(false),\n\t\t\t\t\tBastionMode:            pulumi.Bool(false),\n\t\t\t\t\tProxyAddress:           pulumi.String(\"10.0.0.1\"),\n\t\t\t\t\tProxyPort:              pulumi.Int(8123),\n\t\t\t\t\tProxyType:              pulumi.String(\"socks\"),\n\t\t\t\t\tIpRules: cloudflare.TunnelConfigConfigOriginRequestIpRuleArray{\n\t\t\t\t\t\t\u0026cloudflare.TunnelConfigConfigOriginRequestIpRuleArgs{\n\t\t\t\t\t\t\tPrefix: pulumi.String(\"/web\"),\n\t\t\t\t\t\t\tPorts: pulumi.IntArray{\n\t\t\t\t\t\t\t\tpulumi.Int(80),\n\t\t\t\t\t\t\t\tpulumi.Int(443),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAllow: pulumi.Bool(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tIngressRules: cloudflare.TunnelConfigConfigIngressRuleArray{\n\t\t\t\t\t\u0026cloudflare.TunnelConfigConfigIngressRuleArgs{\n\t\t\t\t\t\tHostname: pulumi.String(\"foo\"),\n\t\t\t\t\t\tPath:     pulumi.String(\"/bar\"),\n\t\t\t\t\t\tService:  pulumi.String(\"http://10.0.0.2:8080\"),\n\t\t\t\t\t},\n\t\t\t\t\t\u0026cloudflare.TunnelConfigConfigIngressRuleArgs{\n\t\t\t\t\t\tService: pulumi.String(\"https://10.0.0.3:8081\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ArgoTunnel;\nimport com.pulumi.cloudflare.ArgoTunnelArgs;\nimport com.pulumi.cloudflare.TunnelConfig;\nimport com.pulumi.cloudflare.TunnelConfigArgs;\nimport com.pulumi.cloudflare.inputs.TunnelConfigConfigArgs;\nimport com.pulumi.cloudflare.inputs.TunnelConfigConfigWarpRoutingArgs;\nimport com.pulumi.cloudflare.inputs.TunnelConfigConfigOriginRequestArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleTunnel = new ArgoTunnel(\"exampleTunnel\", ArgoTunnelArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example_tunnel\")\n            .secret(\"\u003c32 character secret\u003e\")\n            .build());\n\n        var exampleConfig = new TunnelConfig(\"exampleConfig\", TunnelConfigArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tunnelId(exampleTunnel.id())\n            .config(TunnelConfigConfigArgs.builder()\n                .warpRouting(TunnelConfigConfigWarpRoutingArgs.builder()\n                    .enabled(true)\n                    .build())\n                .originRequest(TunnelConfigConfigOriginRequestArgs.builder()\n                    .connectTimeout(\"1m0s\")\n                    .tlsTimeout(\"1m0s\")\n                    .tcpKeepAlive(\"1m0s\")\n                    .noHappyEyeballs(false)\n                    .keepAliveConnections(1024)\n                    .keepAliveTimeout(\"1m0s\")\n                    .httpHostHeader(\"baz\")\n                    .originServerName(\"foobar\")\n                    .caPool(\"/path/to/unsigned/ca/pool\")\n                    .noTlsVerify(false)\n                    .disableChunkedEncoding(false)\n                    .bastionMode(false)\n                    .proxyAddress(\"10.0.0.1\")\n                    .proxyPort(\"8123\")\n                    .proxyType(\"socks\")\n                    .ipRules(TunnelConfigConfigOriginRequestIpRuleArgs.builder()\n                        .prefix(\"/web\")\n                        .ports(                        \n                            80,\n                            443)\n                        .allow(false)\n                        .build())\n                    .build())\n                .ingressRules(                \n                    TunnelConfigConfigIngressRuleArgs.builder()\n                        .hostname(\"foo\")\n                        .path(\"/bar\")\n                        .service(\"http://10.0.0.2:8080\")\n                        .build(),\n                    TunnelConfigConfigIngressRuleArgs.builder()\n                        .service(\"https://10.0.0.3:8081\")\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleTunnel:\n    type: cloudflare:ArgoTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example_tunnel\n      secret: \u003c32 character secret\u003e\n  exampleConfig:\n    type: cloudflare:TunnelConfig\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tunnelId: ${exampleTunnel.id}\n      config:\n        warpRouting:\n          enabled: true\n        originRequest:\n          connectTimeout: 1m0s\n          tlsTimeout: 1m0s\n          tcpKeepAlive: 1m0s\n          noHappyEyeballs: false\n          keepAliveConnections: 1024\n          keepAliveTimeout: 1m0s\n          httpHostHeader: baz\n          originServerName: foobar\n          caPool: /path/to/unsigned/ca/pool\n          noTlsVerify: false\n          disableChunkedEncoding: false\n          bastionMode: false\n          proxyAddress: 10.0.0.1\n          proxyPort: '8123'\n          proxyType: socks\n          ipRules:\n            - prefix: /web\n              ports:\n                - 80\n                - 443\n              allow: false\n        ingressRules:\n          - hostname: foo\n            path: /bar\n            service: http://10.0.0.2:8080\n          - service: https://10.0.0.3:8081\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfig:TunnelConfigConfig",
                    "description": "Configuration block for Tunnel Configuration.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "Identifier of the Tunnel to target for this configuration.\n"
                }
            },
            "required": [
                "accountId",
                "config",
                "tunnelId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "config": {
                    "$ref": "#/types/cloudflare:index/TunnelConfigConfig:TunnelConfigConfig",
                    "description": "Configuration block for Tunnel Configuration.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "Identifier of the Tunnel to target for this configuration.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "config",
                "tunnelId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TunnelConfig resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "config": {
                        "$ref": "#/types/cloudflare:index/TunnelConfigConfig:TunnelConfigConfig",
                        "description": "Configuration block for Tunnel Configuration.\n"
                    },
                    "tunnelId": {
                        "type": "string",
                        "description": "Identifier of the Tunnel to target for this configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnelRoute:TunnelRoute": {
            "description": "Provides a resource, that manages Cloudflare tunnel routes for Zero\nTrust. Tunnel routes are used to direct IP traffic through\nCloudflare Tunnels.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Tunnel route\nconst exampleTunnelRoute = new cloudflare.TunnelRoute(\"exampleTunnelRoute\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tunnelId: \"f70ff985-a4ef-4643-bbbc-4a0ed4fc8415\",\n    network: \"192.0.2.24/32\",\n    comment: \"New tunnel route for documentation\",\n    virtualNetworkId: \"bdc39a3c-3104-4c23-8ac0-9f455dda691a\",\n});\n// Tunnel with tunnel route\nconst tunnel = new cloudflare.ArgoTunnel(\"tunnel\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"my_tunnel\",\n    secret: \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n});\nconst exampleIndex_tunnelRouteTunnelRoute = new cloudflare.TunnelRoute(\"exampleIndex/tunnelRouteTunnelRoute\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    tunnelId: tunnel.id,\n    network: \"192.0.2.24/32\",\n    comment: \"New tunnel route for documentation\",\n    virtualNetworkId: \"bdc39a3c-3104-4c23-8ac0-9f455dda691a\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Tunnel route\nexample_tunnel_route = cloudflare.TunnelRoute(\"exampleTunnelRoute\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tunnel_id=\"f70ff985-a4ef-4643-bbbc-4a0ed4fc8415\",\n    network=\"192.0.2.24/32\",\n    comment=\"New tunnel route for documentation\",\n    virtual_network_id=\"bdc39a3c-3104-4c23-8ac0-9f455dda691a\")\n# Tunnel with tunnel route\ntunnel = cloudflare.ArgoTunnel(\"tunnel\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"my_tunnel\",\n    secret=\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\nexample_index_tunnel_route_tunnel_route = cloudflare.TunnelRoute(\"exampleIndex/tunnelRouteTunnelRoute\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    tunnel_id=tunnel.id,\n    network=\"192.0.2.24/32\",\n    comment=\"New tunnel route for documentation\",\n    virtual_network_id=\"bdc39a3c-3104-4c23-8ac0-9f455dda691a\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Tunnel route\n    var exampleTunnelRoute = new Cloudflare.TunnelRoute(\"exampleTunnelRoute\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TunnelId = \"f70ff985-a4ef-4643-bbbc-4a0ed4fc8415\",\n        Network = \"192.0.2.24/32\",\n        Comment = \"New tunnel route for documentation\",\n        VirtualNetworkId = \"bdc39a3c-3104-4c23-8ac0-9f455dda691a\",\n    });\n\n    // Tunnel with tunnel route\n    var tunnel = new Cloudflare.ArgoTunnel(\"tunnel\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"my_tunnel\",\n        Secret = \"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\",\n    });\n\n    var exampleIndex_tunnelRouteTunnelRoute = new Cloudflare.TunnelRoute(\"exampleIndex/tunnelRouteTunnelRoute\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        TunnelId = tunnel.Id,\n        Network = \"192.0.2.24/32\",\n        Comment = \"New tunnel route for documentation\",\n        VirtualNetworkId = \"bdc39a3c-3104-4c23-8ac0-9f455dda691a\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTunnelRoute(ctx, \"exampleTunnelRoute\", \u0026cloudflare.TunnelRouteArgs{\n\t\t\tAccountId:        pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTunnelId:         pulumi.String(\"f70ff985-a4ef-4643-bbbc-4a0ed4fc8415\"),\n\t\t\tNetwork:          pulumi.String(\"192.0.2.24/32\"),\n\t\t\tComment:          pulumi.String(\"New tunnel route for documentation\"),\n\t\t\tVirtualNetworkId: pulumi.String(\"bdc39a3c-3104-4c23-8ac0-9f455dda691a\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttunnel, err := cloudflare.NewArgoTunnel(ctx, \"tunnel\", \u0026cloudflare.ArgoTunnelArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"my_tunnel\"),\n\t\t\tSecret:    pulumi.String(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewTunnelRoute(ctx, \"exampleIndex/tunnelRouteTunnelRoute\", \u0026cloudflare.TunnelRouteArgs{\n\t\t\tAccountId:        pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTunnelId:         tunnel.ID(),\n\t\t\tNetwork:          pulumi.String(\"192.0.2.24/32\"),\n\t\t\tComment:          pulumi.String(\"New tunnel route for documentation\"),\n\t\t\tVirtualNetworkId: pulumi.String(\"bdc39a3c-3104-4c23-8ac0-9f455dda691a\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TunnelRoute;\nimport com.pulumi.cloudflare.TunnelRouteArgs;\nimport com.pulumi.cloudflare.ArgoTunnel;\nimport com.pulumi.cloudflare.ArgoTunnelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleTunnelRoute = new TunnelRoute(\"exampleTunnelRoute\", TunnelRouteArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tunnelId(\"f70ff985-a4ef-4643-bbbc-4a0ed4fc8415\")\n            .network(\"192.0.2.24/32\")\n            .comment(\"New tunnel route for documentation\")\n            .virtualNetworkId(\"bdc39a3c-3104-4c23-8ac0-9f455dda691a\")\n            .build());\n\n        var tunnel = new ArgoTunnel(\"tunnel\", ArgoTunnelArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"my_tunnel\")\n            .secret(\"AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\")\n            .build());\n\n        var exampleIndex_tunnelRouteTunnelRoute = new TunnelRoute(\"exampleIndex/tunnelRouteTunnelRoute\", TunnelRouteArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .tunnelId(tunnel.id())\n            .network(\"192.0.2.24/32\")\n            .comment(\"New tunnel route for documentation\")\n            .virtualNetworkId(\"bdc39a3c-3104-4c23-8ac0-9f455dda691a\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Tunnel route\n  exampleTunnelRoute:\n    type: cloudflare:TunnelRoute\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tunnelId: f70ff985-a4ef-4643-bbbc-4a0ed4fc8415\n      network: 192.0.2.24/32\n      comment: New tunnel route for documentation\n      virtualNetworkId: bdc39a3c-3104-4c23-8ac0-9f455dda691a\n  # Tunnel with tunnel route\n  tunnel:\n    type: cloudflare:ArgoTunnel\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: my_tunnel\n      secret: AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\n  exampleIndex/tunnelRouteTunnelRoute:\n    type: cloudflare:TunnelRoute\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      tunnelId: ${tunnel.id}\n      network: 192.0.2.24/32\n      comment: New tunnel route for documentation\n      virtualNetworkId: bdc39a3c-3104-4c23-8ac0-9f455dda691a\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/tunnelRoute:TunnelRoute example \u003caccount_id\u003e/\u003cnetwork_cidr\u003e/\u003cvirtual_network_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "The ID of the tunnel that will service the tunnel route.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "accountId",
                "network",
                "tunnelId"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                },
                "tunnelId": {
                    "type": "string",
                    "description": "The ID of the tunnel that will service the tunnel route.\n"
                },
                "virtualNetworkId": {
                    "type": "string",
                    "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accountId",
                "network",
                "tunnelId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TunnelRoute resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Description of the tunnel route.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.\n"
                    },
                    "tunnelId": {
                        "type": "string",
                        "description": "The ID of the tunnel that will service the tunnel route.\n"
                    },
                    "virtualNetworkId": {
                        "type": "string",
                        "description": "The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork": {
            "description": "Provides a resource, that manages Cloudflare tunnel virtual networks\nfor Zero Trust. Tunnel virtual networks are used for segregation of\nTunnel IP Routes via Virtualized Networks to handle overlapping\nprivate IPs in your origins.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.TunnelVirtualNetwork(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    comment: \"New tunnel virtual network for documentation\",\n    name: \"vnet-for-documentation\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.TunnelVirtualNetwork(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    comment=\"New tunnel virtual network for documentation\",\n    name=\"vnet-for-documentation\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.TunnelVirtualNetwork(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Comment = \"New tunnel virtual network for documentation\",\n        Name = \"vnet-for-documentation\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewTunnelVirtualNetwork(ctx, \"example\", \u0026cloudflare.TunnelVirtualNetworkArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tComment:   pulumi.String(\"New tunnel virtual network for documentation\"),\n\t\t\tName:      pulumi.String(\"vnet-for-documentation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.TunnelVirtualNetwork;\nimport com.pulumi.cloudflare.TunnelVirtualNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TunnelVirtualNetwork(\"example\", TunnelVirtualNetworkArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .comment(\"New tunnel virtual network for documentation\")\n            .name(\"vnet-for-documentation\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:TunnelVirtualNetwork\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      comment: New tunnel virtual network for documentation\n      name: vnet-for-documentation\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork example \u003caccount_id\u003e/\u003cvnet_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel virtual network.\n"
                },
                "isDefaultNetwork": {
                    "type": "boolean",
                    "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the virtual network is created.\n"
                }
            },
            "required": [
                "accountId",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Description of the tunnel virtual network.\n"
                },
                "isDefaultNetwork": {
                    "type": "boolean",
                    "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A user-friendly name chosen when the virtual network is created.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TunnelVirtualNetwork resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Description of the tunnel virtual network.\n"
                    },
                    "isDefaultNetwork": {
                        "type": "boolean",
                        "description": "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A user-friendly name chosen when the virtual network is created.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/urlNormalizationSettings:UrlNormalizationSettings": {
            "description": "Provides a resource to manage URL Normalization Settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.UrlNormalizationSettings(\"example\", {\n    scope: \"incoming\",\n    type: \"cloudflare\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.UrlNormalizationSettings(\"example\",\n    scope=\"incoming\",\n    type=\"cloudflare\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.UrlNormalizationSettings(\"example\", new()\n    {\n        Scope = \"incoming\",\n        Type = \"cloudflare\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewUrlNormalizationSettings(ctx, \"example\", \u0026cloudflare.UrlNormalizationSettingsArgs{\n\t\t\tScope:  pulumi.String(\"incoming\"),\n\t\t\tType:   pulumi.String(\"cloudflare\"),\n\t\t\tZoneId: pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.UrlNormalizationSettings;\nimport com.pulumi.cloudflare.UrlNormalizationSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new UrlNormalizationSettings(\"example\", UrlNormalizationSettingsArgs.builder()        \n            .scope(\"incoming\")\n            .type(\"cloudflare\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:UrlNormalizationSettings\n    properties:\n      scope: incoming\n      type: cloudflare\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "scope": {
                    "type": "string",
                    "description": "The scope of the URL normalization.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of URL normalization performed by Cloudflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "scope",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "scope": {
                    "type": "string",
                    "description": "The scope of the URL normalization.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of URL normalization performed by Cloudflare.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "scope",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UrlNormalizationSettings resources.\n",
                "properties": {
                    "scope": {
                        "type": "string",
                        "description": "The scope of the URL normalization.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of URL normalization performed by Cloudflare.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/userAgentBlockingRule:UserAgentBlockingRule": {
            "description": "Provides a resource to manage User Agent Blocking Rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example1 = new cloudflare.UserAgentBlockingRule(\"example1\", {\n    configuration: {\n        target: \"ua\",\n        value: \"Chrome\",\n    },\n    description: \"My description 1\",\n    mode: \"js_challenge\",\n    paused: false,\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\nconst example2 = new cloudflare.UserAgentBlockingRule(\"example2\", {\n    configuration: {\n        target: \"ua\",\n        value: \"Mozilla\",\n    },\n    description: \"My description 22\",\n    mode: \"challenge\",\n    paused: true,\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample1 = cloudflare.UserAgentBlockingRule(\"example1\",\n    configuration=cloudflare.UserAgentBlockingRuleConfigurationArgs(\n        target=\"ua\",\n        value=\"Chrome\",\n    ),\n    description=\"My description 1\",\n    mode=\"js_challenge\",\n    paused=False,\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\nexample2 = cloudflare.UserAgentBlockingRule(\"example2\",\n    configuration=cloudflare.UserAgentBlockingRuleConfigurationArgs(\n        target=\"ua\",\n        value=\"Mozilla\",\n    ),\n    description=\"My description 22\",\n    mode=\"challenge\",\n    paused=True,\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example1 = new Cloudflare.UserAgentBlockingRule(\"example1\", new()\n    {\n        Configuration = new Cloudflare.Inputs.UserAgentBlockingRuleConfigurationArgs\n        {\n            Target = \"ua\",\n            Value = \"Chrome\",\n        },\n        Description = \"My description 1\",\n        Mode = \"js_challenge\",\n        Paused = false,\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n    var example2 = new Cloudflare.UserAgentBlockingRule(\"example2\", new()\n    {\n        Configuration = new Cloudflare.Inputs.UserAgentBlockingRuleConfigurationArgs\n        {\n            Target = \"ua\",\n            Value = \"Mozilla\",\n        },\n        Description = \"My description 22\",\n        Mode = \"challenge\",\n        Paused = true,\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewUserAgentBlockingRule(ctx, \"example1\", \u0026cloudflare.UserAgentBlockingRuleArgs{\n\t\t\tConfiguration: \u0026cloudflare.UserAgentBlockingRuleConfigurationArgs{\n\t\t\t\tTarget: pulumi.String(\"ua\"),\n\t\t\t\tValue:  pulumi.String(\"Chrome\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"My description 1\"),\n\t\t\tMode:        pulumi.String(\"js_challenge\"),\n\t\t\tPaused:      pulumi.Bool(false),\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewUserAgentBlockingRule(ctx, \"example2\", \u0026cloudflare.UserAgentBlockingRuleArgs{\n\t\t\tConfiguration: \u0026cloudflare.UserAgentBlockingRuleConfigurationArgs{\n\t\t\t\tTarget: pulumi.String(\"ua\"),\n\t\t\t\tValue:  pulumi.String(\"Mozilla\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"My description 22\"),\n\t\t\tMode:        pulumi.String(\"challenge\"),\n\t\t\tPaused:      pulumi.Bool(true),\n\t\t\tZoneId:      pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.UserAgentBlockingRule;\nimport com.pulumi.cloudflare.UserAgentBlockingRuleArgs;\nimport com.pulumi.cloudflare.inputs.UserAgentBlockingRuleConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example1 = new UserAgentBlockingRule(\"example1\", UserAgentBlockingRuleArgs.builder()        \n            .configuration(UserAgentBlockingRuleConfigurationArgs.builder()\n                .target(\"ua\")\n                .value(\"Chrome\")\n                .build())\n            .description(\"My description 1\")\n            .mode(\"js_challenge\")\n            .paused(false)\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n        var example2 = new UserAgentBlockingRule(\"example2\", UserAgentBlockingRuleArgs.builder()        \n            .configuration(UserAgentBlockingRuleConfigurationArgs.builder()\n                .target(\"ua\")\n                .value(\"Mozilla\")\n                .build())\n            .description(\"My description 22\")\n            .mode(\"challenge\")\n            .paused(true)\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example1:\n    type: cloudflare:UserAgentBlockingRule\n    properties:\n      configuration:\n        target: ua\n        value: Chrome\n      description: My description 1\n      mode: js_challenge\n      paused: false\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n  example2:\n    type: cloudflare:UserAgentBlockingRule\n    properties:\n      configuration:\n        target: ua\n        value: Mozilla\n      description: My description 22\n      mode: challenge\n      paused: true\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration",
                    "description": "The configuration object for the current rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An informative summary of the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "When true, indicates that the rule is currently paused.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "configuration",
                "description",
                "mode",
                "paused",
                "zoneId"
            ],
            "inputProperties": {
                "configuration": {
                    "$ref": "#/types/cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration",
                    "description": "The configuration object for the current rule.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An informative summary of the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "When true, indicates that the rule is currently paused.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configuration",
                "description",
                "mode",
                "paused",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAgentBlockingRule resources.\n",
                "properties": {
                    "configuration": {
                        "$ref": "#/types/cloudflare:index/UserAgentBlockingRuleConfiguration:UserAgentBlockingRuleConfiguration",
                        "description": "The configuration object for the current rule.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An informative summary of the rule.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "When true, indicates that the rule is currently paused.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafGroup:WafGroup": {
            "description": "Provides a Cloudflare WAF rule group resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall groups.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst honeyPot = new cloudflare.WafGroup(\"honeyPot\", {\n    groupId: \"de677e5818985db1285d0e80225f06e5\",\n    mode: \"on\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nhoney_pot = cloudflare.WafGroup(\"honeyPot\",\n    group_id=\"de677e5818985db1285d0e80225f06e5\",\n    mode=\"on\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var honeyPot = new Cloudflare.WafGroup(\"honeyPot\", new()\n    {\n        GroupId = \"de677e5818985db1285d0e80225f06e5\",\n        Mode = \"on\",\n        ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafGroup(ctx, \"honeyPot\", \u0026cloudflare.WafGroupArgs{\n\t\t\tGroupId: pulumi.String(\"de677e5818985db1285d0e80225f06e5\"),\n\t\t\tMode:    pulumi.String(\"on\"),\n\t\t\tZoneId:  pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WafGroup;\nimport com.pulumi.cloudflare.WafGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var honeyPot = new WafGroup(\"honeyPot\", WafGroupArgs.builder()        \n            .groupId(\"de677e5818985db1285d0e80225f06e5\")\n            .mode(\"on\")\n            .zoneId(\"ae36f999674d196762efcc5abb06b345\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  honeyPot:\n    type: cloudflare:WafGroup\n    properties:\n      groupId: de677e5818985db1285d0e80225f06e5\n      mode: on\n      zoneId: ae36f999674d196762efcc5abb06b345\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWAF Rule Groups can be imported using a composite ID formed of zone ID and the WAF Rule Group ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/wafGroup:WafGroup honey_pot ae36f999674d196762efcc5abb06b345/de677e5818985db1285d0e80225f06e5\n```\n\n ",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The WAF Rule Group ID.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the group.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "groupId",
                "packageId",
                "zoneId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "description": "The WAF Rule Group ID.\n",
                    "willReplaceOnChanges": true
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the group.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafGroup resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The WAF Rule Group ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the group, can be one of [\"on\", \"off\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the group.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafOverride:WafOverride": {
            "description": "Provides a Cloudflare WAF override resource. This enables the ability to toggle\nWAF rules and groups on or off based on URIs.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst shopEcxample = new cloudflare.WafOverride(\"shopEcxample\", {\n    zoneId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    urls: [\n        \"example.com/no-waf-here\",\n        \"example.com/another/path/*\",\n    ],\n    rules: {\n        \"100015\": \"disable\",\n    },\n    groups: {\n        ea8687e59929c1fd05ba97574ad43f77: \"default\",\n    },\n    rewriteAction: {\n        \"default\": \"block\",\n        challenge: \"block\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nshop_ecxample = cloudflare.WafOverride(\"shopEcxample\",\n    zone_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    urls=[\n        \"example.com/no-waf-here\",\n        \"example.com/another/path/*\",\n    ],\n    rules={\n        \"100015\": \"disable\",\n    },\n    groups={\n        \"ea8687e59929c1fd05ba97574ad43f77\": \"default\",\n    },\n    rewrite_action={\n        \"default\": \"block\",\n        \"challenge\": \"block\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var shopEcxample = new Cloudflare.WafOverride(\"shopEcxample\", new()\n    {\n        ZoneId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        Urls = new[]\n        {\n            \"example.com/no-waf-here\",\n            \"example.com/another/path/*\",\n        },\n        Rules = \n        {\n            { \"100015\", \"disable\" },\n        },\n        Groups = \n        {\n            { \"ea8687e59929c1fd05ba97574ad43f77\", \"default\" },\n        },\n        RewriteAction = \n        {\n            { \"default\", \"block\" },\n            { \"challenge\", \"block\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafOverride(ctx, \"shopEcxample\", \u0026cloudflare.WafOverrideArgs{\n\t\t\tZoneId: pulumi.String(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\tUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com/no-waf-here\"),\n\t\t\t\tpulumi.String(\"example.com/another/path/*\"),\n\t\t\t},\n\t\t\tRules: pulumi.StringMap{\n\t\t\t\t\"100015\": pulumi.String(\"disable\"),\n\t\t\t},\n\t\t\tGroups: pulumi.StringMap{\n\t\t\t\t\"ea8687e59929c1fd05ba97574ad43f77\": pulumi.String(\"default\"),\n\t\t\t},\n\t\t\tRewriteAction: pulumi.StringMap{\n\t\t\t\t\"default\":   pulumi.String(\"block\"),\n\t\t\t\t\"challenge\": pulumi.String(\"block\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WafOverride;\nimport com.pulumi.cloudflare.WafOverrideArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var shopEcxample = new WafOverride(\"shopEcxample\", WafOverrideArgs.builder()        \n            .zoneId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n            .urls(            \n                \"example.com/no-waf-here\",\n                \"example.com/another/path/*\")\n            .rules(Map.of(\"100015\", \"disable\"))\n            .groups(Map.of(\"ea8687e59929c1fd05ba97574ad43f77\", \"default\"))\n            .rewriteAction(Map.ofEntries(\n                Map.entry(\"default\", \"block\"),\n                Map.entry(\"challenge\", \"block\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  shopEcxample:\n    type: cloudflare:WafOverride\n    properties:\n      zoneId: 1d5fdc9e88c8a8c4518b068cd94331fe\n      urls:\n        - example.com/no-waf-here\n        - example.com/another/path/*\n      # Disable rule ID 100015.\n      rules:\n        '100015': disable\n      # Set to Cloudflare default action for group ID ea8687e59929c1fd05ba97574ad43f77.\n      groups:\n        ea8687e59929c1fd05ba97574ad43f77: default\n      # Update the actions for when a matching rule is encountered.\n      rewriteAction:\n        default: block\n        challenge: block\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWAF Overrides can be imported using a composite ID formed of zone ID and override ID.\n\n```sh\n $ pulumi import cloudflare:index/wafOverride:WafOverride my_example_waf_override 3abe5b950053dbddf1516d89f9ef1e8a/9d4e66d7649c178663bf62e06dbacb23\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of what the WAF override does.\n"
                },
                "groups": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Similar to `rules`; which WAF groups you want to alter.\n"
                },
                "overrideId": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this package is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Relative priority of this configuration when multiple configurations match a single URL.\n"
                },
                "rewriteAction": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "When a WAF rule matches, substitute its configured action for a different action specified by this definition.\n"
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of WAF rule ID to rule action you intend to apply.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of URLs to apply the WAF override to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the WAF override condition should be added.\n"
                }
            },
            "required": [
                "overrideId",
                "urls",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of what the WAF override does.\n"
                },
                "groups": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Similar to `rules`; which WAF groups you want to alter.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this package is currently paused.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Relative priority of this configuration when multiple configurations match a single URL.\n"
                },
                "rewriteAction": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "When a WAF rule matches, substitute its configured action for a different action specified by this definition.\n"
                },
                "rules": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of WAF rule ID to rule action you intend to apply.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of URLs to apply the WAF override to.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone to which the WAF override condition should be added.\n"
                }
            },
            "requiredInputs": [
                "urls",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafOverride resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of what the WAF override does.\n"
                    },
                    "groups": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Similar to `rules`; which WAF groups you want to alter.\n"
                    },
                    "overrideId": {
                        "type": "string"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this package is currently paused.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Relative priority of this configuration when multiple configurations match a single URL.\n"
                    },
                    "rewriteAction": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "When a WAF rule matches, substitute its configured action for a different action specified by this definition.\n"
                    },
                    "rules": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of WAF rule ID to rule action you intend to apply.\n"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of URLs to apply the WAF override to.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone to which the WAF override condition should be added.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafPackage:WafPackage": {
            "description": "Provides a Cloudflare WAF rule package resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall packages.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst owasp = new cloudflare.WafPackage(\"owasp\", {\n    actionMode: \"simulate\",\n    packageId: \"a25a9a7e9c00afc1fb2e0245519d725b\",\n    sensitivity: \"medium\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nowasp = cloudflare.WafPackage(\"owasp\",\n    action_mode=\"simulate\",\n    package_id=\"a25a9a7e9c00afc1fb2e0245519d725b\",\n    sensitivity=\"medium\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var owasp = new Cloudflare.WafPackage(\"owasp\", new()\n    {\n        ActionMode = \"simulate\",\n        PackageId = \"a25a9a7e9c00afc1fb2e0245519d725b\",\n        Sensitivity = \"medium\",\n        ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafPackage(ctx, \"owasp\", \u0026cloudflare.WafPackageArgs{\n\t\t\tActionMode:  pulumi.String(\"simulate\"),\n\t\t\tPackageId:   pulumi.String(\"a25a9a7e9c00afc1fb2e0245519d725b\"),\n\t\t\tSensitivity: pulumi.String(\"medium\"),\n\t\t\tZoneId:      pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WafPackage;\nimport com.pulumi.cloudflare.WafPackageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var owasp = new WafPackage(\"owasp\", WafPackageArgs.builder()        \n            .actionMode(\"simulate\")\n            .packageId(\"a25a9a7e9c00afc1fb2e0245519d725b\")\n            .sensitivity(\"medium\")\n            .zoneId(\"ae36f999674d196762efcc5abb06b345\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  owasp:\n    type: cloudflare:WafPackage\n    properties:\n      actionMode: simulate\n      packageId: a25a9a7e9c00afc1fb2e0245519d725b\n      sensitivity: medium\n      zoneId: ae36f999674d196762efcc5abb06b345\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPackages can be imported using a composite ID formed of zone ID and the WAF Package ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/wafPackage:WafPackage owasp ae36f999674d196762efcc5abb06b345/a25a9a7e9c00afc1fb2e0245519d725b\n```\n\n ",
            "properties": {
                "actionMode": {
                    "type": "string",
                    "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The WAF Package ID.\n"
                },
                "sensitivity": {
                    "type": "string",
                    "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "packageId",
                "zoneId"
            ],
            "inputProperties": {
                "actionMode": {
                    "type": "string",
                    "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The WAF Package ID.\n",
                    "willReplaceOnChanges": true
                },
                "sensitivity": {
                    "type": "string",
                    "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "packageId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafPackage resources.\n",
                "properties": {
                    "actionMode": {
                        "type": "string",
                        "description": "The action mode of the package, can be one of [\"block\", \"challenge\", \"simulate\"].\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The WAF Package ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "sensitivity": {
                        "type": "string",
                        "description": "The sensitivity of the package, can be one of [\"high\", \"medium\", \"low\", \"off\"].\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/wafRule:WafRule": {
            "description": "Provides a Cloudflare WAF rule resource for a particular zone. This can be used to configure firewall behaviour for pre-defined firewall rules.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst rule100000 = new cloudflare.WafRule(\"rule100000\", {\n    mode: \"simulate\",\n    ruleId: \"100000\",\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nrule100000 = cloudflare.WafRule(\"rule100000\",\n    mode=\"simulate\",\n    rule_id=\"100000\",\n    zone_id=\"ae36f999674d196762efcc5abb06b345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rule100000 = new Cloudflare.WafRule(\"rule100000\", new()\n    {\n        Mode = \"simulate\",\n        RuleId = \"100000\",\n        ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWafRule(ctx, \"rule100000\", \u0026cloudflare.WafRuleArgs{\n\t\t\tMode:   pulumi.String(\"simulate\"),\n\t\t\tRuleId: pulumi.String(\"100000\"),\n\t\t\tZoneId: pulumi.String(\"ae36f999674d196762efcc5abb06b345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WafRule;\nimport com.pulumi.cloudflare.WafRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rule100000 = new WafRule(\"rule100000\", WafRuleArgs.builder()        \n            .mode(\"simulate\")\n            .ruleId(\"100000\")\n            .zoneId(\"ae36f999674d196762efcc5abb06b345\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule100000:\n    type: cloudflare:WafRule\n    properties:\n      mode: simulate\n      ruleId: '100000'\n      zoneId: ae36f999674d196762efcc5abb06b345\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRules can be imported using a composite ID formed of zone ID and the WAF Rule ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/wafRule:WafRule 100000 ae36f999674d196762efcc5abb06b345/100000\n```\n\n ",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Group that contains the rule.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the rule.\n"
                },
                "ruleId": {
                    "type": "string",
                    "description": "The WAF Rule ID.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "required": [
                "groupId",
                "mode",
                "packageId",
                "ruleId",
                "zoneId"
            ],
            "inputProperties": {
                "mode": {
                    "type": "string",
                    "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n"
                },
                "packageId": {
                    "type": "string",
                    "description": "The ID of the WAF Rule Package that contains the rule.\n"
                },
                "ruleId": {
                    "type": "string",
                    "description": "The WAF Rule ID.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to apply to.\n"
                }
            },
            "requiredInputs": [
                "mode",
                "ruleId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WafRule resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Group that contains the rule.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "The mode of the rule, can be one of [\"block\", \"challenge\", \"default\", \"disable\", \"simulate\"] or [\"on\", \"off\"] depending on the WAF Rule type.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the rule.\n"
                    },
                    "ruleId": {
                        "type": "string",
                        "description": "The WAF Rule ID.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoom:WaitingRoom": {
            "description": "Provides a Cloudflare Waiting Room resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Waiting Room\nconst example = new cloudflare.WaitingRoom(\"example\", {\n    host: \"foo.example.com\",\n    name: \"foo\",\n    newUsersPerMinute: 200,\n    path: \"/\",\n    totalActiveUsers: 200,\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Waiting Room\nexample = cloudflare.WaitingRoom(\"example\",\n    host=\"foo.example.com\",\n    name=\"foo\",\n    new_users_per_minute=200,\n    path=\"/\",\n    total_active_users=200,\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Waiting Room\n    var example = new Cloudflare.WaitingRoom(\"example\", new()\n    {\n        Host = \"foo.example.com\",\n        Name = \"foo\",\n        NewUsersPerMinute = 200,\n        Path = \"/\",\n        TotalActiveUsers = 200,\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWaitingRoom(ctx, \"example\", \u0026cloudflare.WaitingRoomArgs{\n\t\t\tHost:              pulumi.String(\"foo.example.com\"),\n\t\t\tName:              pulumi.String(\"foo\"),\n\t\t\tNewUsersPerMinute: pulumi.Int(200),\n\t\t\tPath:              pulumi.String(\"/\"),\n\t\t\tTotalActiveUsers:  pulumi.Int(200),\n\t\t\tZoneId:            pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoom;\nimport com.pulumi.cloudflare.WaitingRoomArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WaitingRoom(\"example\", WaitingRoomArgs.builder()        \n            .host(\"foo.example.com\")\n            .name(\"foo\")\n            .newUsersPerMinute(200)\n            .path(\"/\")\n            .totalActiveUsers(200)\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Waiting Room\n  example:\n    type: cloudflare:WaitingRoom\n    properties:\n      host: foo.example.com\n      name: foo\n      newUsersPerMinute: 200\n      path: /\n      totalActiveUsers: 200\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nUse the Zone ID and Waiting Room ID to import.\n\n```sh\n $ pulumi import cloudflare:index/waitingRoom:WaitingRoom default \u003czone_id\u003e/\u003cwaiting_room_id\u003e\n```\n\n ",
            "properties": {
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "defaultTemplateLanguage": {
                    "type": "string",
                    "description": "The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`. Defaults to `en-US`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to add more details about the waiting room.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                },
                "jsonResponseEnabled": {
                    "type": "boolean",
                    "description": "If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the host to enable the waiting room on. Defaults to `/`.\n"
                },
                "queueAll": {
                    "type": "boolean",
                    "description": "If queue_all is true, then all traffic will be sent to the waiting room.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "Suspends the waiting room.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "host",
                "name",
                "newUsersPerMinute",
                "totalActiveUsers",
                "zoneId"
            ],
            "inputProperties": {
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "defaultTemplateLanguage": {
                    "type": "string",
                    "description": "The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`. Defaults to `en-US`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to add more details about the waiting room.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                },
                "jsonResponseEnabled": {
                    "type": "boolean",
                    "description": "If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path within the host to enable the waiting room on. Defaults to `/`.\n"
                },
                "queueAll": {
                    "type": "boolean",
                    "description": "If queue_all is true, then all traffic will be sent to the waiting room.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "Suspends the waiting room.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "host",
                "name",
                "newUsersPerMinute",
                "totalActiveUsers",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoom resources.\n",
                "properties": {
                    "customPageHtml": {
                        "type": "string",
                        "description": "This is a templated html file that will be rendered at the edge.\n"
                    },
                    "defaultTemplateLanguage": {
                        "type": "string",
                        "description": "The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`. Defaults to `en-US`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description to add more details about the waiting room.\n"
                    },
                    "disableSessionRenewal": {
                        "type": "boolean",
                        "description": "Disables automatic renewal of session cookies.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "Host name for which the waiting room will be applied (no wildcards).\n"
                    },
                    "jsonResponseEnabled": {
                        "type": "boolean",
                        "description": "If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "newUsersPerMinute": {
                        "type": "integer",
                        "description": "The number of new users that will be let into the route every minute.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path within the host to enable the waiting room on. Defaults to `/`.\n"
                    },
                    "queueAll": {
                        "type": "boolean",
                        "description": "If queue_all is true, then all traffic will be sent to the waiting room.\n"
                    },
                    "queueingMethod": {
                        "type": "string",
                        "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.\n"
                    },
                    "sessionDuration": {
                        "type": "integer",
                        "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "Suspends the waiting room.\n"
                    },
                    "totalActiveUsers": {
                        "type": "integer",
                        "description": "The total number of active user sessions on the route at a point in time.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoomEvent:WaitingRoomEvent": {
            "description": "Provides a Cloudflare Waiting Room Event resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Waiting Room Event\nconst example = new cloudflare.WaitingRoomEvent(\"example\", {\n    eventEndTime: \"2006-01-02T20:04:05Z\",\n    eventStartTime: \"2006-01-02T15:04:05Z\",\n    name: \"foo\",\n    waitingRoomId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Waiting Room Event\nexample = cloudflare.WaitingRoomEvent(\"example\",\n    event_end_time=\"2006-01-02T20:04:05Z\",\n    event_start_time=\"2006-01-02T15:04:05Z\",\n    name=\"foo\",\n    waiting_room_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Waiting Room Event\n    var example = new Cloudflare.WaitingRoomEvent(\"example\", new()\n    {\n        EventEndTime = \"2006-01-02T20:04:05Z\",\n        EventStartTime = \"2006-01-02T15:04:05Z\",\n        Name = \"foo\",\n        WaitingRoomId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWaitingRoomEvent(ctx, \"example\", \u0026cloudflare.WaitingRoomEventArgs{\n\t\t\tEventEndTime:   pulumi.String(\"2006-01-02T20:04:05Z\"),\n\t\t\tEventStartTime: pulumi.String(\"2006-01-02T15:04:05Z\"),\n\t\t\tName:           pulumi.String(\"foo\"),\n\t\t\tWaitingRoomId:  pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tZoneId:         pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoomEvent;\nimport com.pulumi.cloudflare.WaitingRoomEventArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WaitingRoomEvent(\"example\", WaitingRoomEventArgs.builder()        \n            .eventEndTime(\"2006-01-02T20:04:05Z\")\n            .eventStartTime(\"2006-01-02T15:04:05Z\")\n            .name(\"foo\")\n            .waitingRoomId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Waiting Room Event\n  example:\n    type: cloudflare:WaitingRoomEvent\n    properties:\n      eventEndTime: 2006-01-02T20:04:05Z\n      eventStartTime: 2006-01-02T15:04:05Z\n      name: foo\n      waitingRoomId: d41d8cd98f00b204e9800998ecf8427e\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nUse the Zone ID, Waiting Room ID, and Event ID to import.\n\n```sh\n $ pulumi import cloudflare:index/waitingRoomEvent:WaitingRoomEvent default \u003czone_id\u003e/\u003cwaiting_room_id\u003e/\u003cwaiting_room_event_id\u003e\n```\n\n ",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to let users add more details about the event.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "eventEndTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "eventStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Last modified time.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "prequeueStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.\n"
                },
                "shuffleAtEventStart": {
                    "type": "boolean",
                    "description": "Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "createdOn",
                "eventEndTime",
                "eventStartTime",
                "modifiedOn",
                "name",
                "waitingRoomId",
                "zoneId"
            ],
            "inputProperties": {
                "customPageHtml": {
                    "type": "string",
                    "description": "This is a templated html file that will be rendered at the edge.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description to let users add more details about the event.\n"
                },
                "disableSessionRenewal": {
                    "type": "boolean",
                    "description": "Disables automatic renewal of session cookies.\n"
                },
                "eventEndTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "eventStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "newUsersPerMinute": {
                    "type": "integer",
                    "description": "The number of new users that will be let into the route every minute.\n"
                },
                "prequeueStartTime": {
                    "type": "string",
                    "description": "ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.\n"
                },
                "queueingMethod": {
                    "type": "string",
                    "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.\n"
                },
                "sessionDuration": {
                    "type": "integer",
                    "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.\n"
                },
                "shuffleAtEventStart": {
                    "type": "boolean",
                    "description": "Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.\n"
                },
                "suspended": {
                    "type": "boolean",
                    "description": "If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.\n"
                },
                "totalActiveUsers": {
                    "type": "integer",
                    "description": "The total number of active user sessions on the route at a point in time.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "eventEndTime",
                "eventStartTime",
                "name",
                "waitingRoomId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoomEvent resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "customPageHtml": {
                        "type": "string",
                        "description": "This is a templated html file that will be rendered at the edge.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description to let users add more details about the event.\n"
                    },
                    "disableSessionRenewal": {
                        "type": "boolean",
                        "description": "Disables automatic renewal of session cookies.\n"
                    },
                    "eventEndTime": {
                        "type": "string",
                        "description": "ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "eventStartTime": {
                        "type": "string",
                        "description": "ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Last modified time.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "newUsersPerMinute": {
                        "type": "integer",
                        "description": "The number of new users that will be let into the route every minute.\n"
                    },
                    "prequeueStartTime": {
                        "type": "string",
                        "description": "ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.\n"
                    },
                    "queueingMethod": {
                        "type": "string",
                        "description": "The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.\n"
                    },
                    "sessionDuration": {
                        "type": "integer",
                        "description": "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.\n"
                    },
                    "shuffleAtEventStart": {
                        "type": "boolean",
                        "description": "Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.\n"
                    },
                    "suspended": {
                        "type": "boolean",
                        "description": "If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.\n"
                    },
                    "totalActiveUsers": {
                        "type": "integer",
                        "description": "The total number of active user sessions on the route at a point in time.\n"
                    },
                    "waitingRoomId": {
                        "type": "string",
                        "description": "The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/waitingRoomRules:WaitingRoomRules": {
            "description": "Provides a Cloudflare Waiting Room Rules resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WaitingRoomRules(\"example\", {\n    rules: [\n        {\n            action: \"bypass_waiting_room\",\n            description: \"bypass ip list\",\n            expression: \"src.ip in {192.0.2.0 192.0.2.1}\",\n            status: \"enabled\",\n        },\n        {\n            action: \"bypass_waiting_room\",\n            description: \"bypass query string\",\n            expression: \"http.request.uri.query contains \\\"bypass=true\\\"\",\n            status: \"enabled\",\n        },\n    ],\n    waitingRoomId: \"d41d8cd98f00b204e9800998ecf8427e\",\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WaitingRoomRules(\"example\",\n    rules=[\n        cloudflare.WaitingRoomRulesRuleArgs(\n            action=\"bypass_waiting_room\",\n            description=\"bypass ip list\",\n            expression=\"src.ip in {192.0.2.0 192.0.2.1}\",\n            status=\"enabled\",\n        ),\n        cloudflare.WaitingRoomRulesRuleArgs(\n            action=\"bypass_waiting_room\",\n            description=\"bypass query string\",\n            expression=\"http.request.uri.query contains \\\"bypass=true\\\"\",\n            status=\"enabled\",\n        ),\n    ],\n    waiting_room_id=\"d41d8cd98f00b204e9800998ecf8427e\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WaitingRoomRules(\"example\", new()\n    {\n        Rules = new[]\n        {\n            new Cloudflare.Inputs.WaitingRoomRulesRuleArgs\n            {\n                Action = \"bypass_waiting_room\",\n                Description = \"bypass ip list\",\n                Expression = \"src.ip in {192.0.2.0 192.0.2.1}\",\n                Status = \"enabled\",\n            },\n            new Cloudflare.Inputs.WaitingRoomRulesRuleArgs\n            {\n                Action = \"bypass_waiting_room\",\n                Description = \"bypass query string\",\n                Expression = \"http.request.uri.query contains \\\"bypass=true\\\"\",\n                Status = \"enabled\",\n            },\n        },\n        WaitingRoomId = \"d41d8cd98f00b204e9800998ecf8427e\",\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWaitingRoomRules(ctx, \"example\", \u0026cloudflare.WaitingRoomRulesArgs{\n\t\t\tRules: cloudflare.WaitingRoomRulesRuleArray{\n\t\t\t\t\u0026cloudflare.WaitingRoomRulesRuleArgs{\n\t\t\t\t\tAction:      pulumi.String(\"bypass_waiting_room\"),\n\t\t\t\t\tDescription: pulumi.String(\"bypass ip list\"),\n\t\t\t\t\tExpression:  pulumi.String(\"src.ip in {192.0.2.0 192.0.2.1}\"),\n\t\t\t\t\tStatus:      pulumi.String(\"enabled\"),\n\t\t\t\t},\n\t\t\t\t\u0026cloudflare.WaitingRoomRulesRuleArgs{\n\t\t\t\t\tAction:      pulumi.String(\"bypass_waiting_room\"),\n\t\t\t\t\tDescription: pulumi.String(\"bypass query string\"),\n\t\t\t\t\tExpression:  pulumi.String(\"http.request.uri.query contains \\\"bypass=true\\\"\"),\n\t\t\t\t\tStatus:      pulumi.String(\"enabled\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWaitingRoomId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t\tZoneId:        pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WaitingRoomRules;\nimport com.pulumi.cloudflare.WaitingRoomRulesArgs;\nimport com.pulumi.cloudflare.inputs.WaitingRoomRulesRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WaitingRoomRules(\"example\", WaitingRoomRulesArgs.builder()        \n            .rules(            \n                WaitingRoomRulesRuleArgs.builder()\n                    .action(\"bypass_waiting_room\")\n                    .description(\"bypass ip list\")\n                    .expression(\"src.ip in {192.0.2.0 192.0.2.1}\")\n                    .status(\"enabled\")\n                    .build(),\n                WaitingRoomRulesRuleArgs.builder()\n                    .action(\"bypass_waiting_room\")\n                    .description(\"bypass query string\")\n                    .expression(\"http.request.uri.query contains \\\"bypass=true\\\"\")\n                    .status(\"enabled\")\n                    .build())\n            .waitingRoomId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WaitingRoomRules\n    properties:\n      rules:\n        - action: bypass_waiting_room\n          description: bypass ip list\n          expression: src.ip in {192.0.2.0 192.0.2.1}\n          status: enabled\n        - action: bypass_waiting_room\n          description: bypass query string\n          expression: http.request.uri.query contains \"bypass=true\"\n          status: enabled\n      waitingRoomId: d41d8cd98f00b204e9800998ecf8427e\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/waitingRoomRules:WaitingRoomRules default \u003czone_id\u003e/\u003cwaiting_room_id\u003e\n```\n\n ",
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "waitingRoomId",
                "zoneId"
            ],
            "inputProperties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule"
                    },
                    "description": "List of rules to apply to the ruleset.\n"
                },
                "waitingRoomId": {
                    "type": "string",
                    "description": "The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "waitingRoomId",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WaitingRoomRules resources.\n",
                "properties": {
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WaitingRoomRulesRule:WaitingRoomRulesRule"
                        },
                        "description": "List of rules to apply to the ruleset.\n"
                    },
                    "waitingRoomId": {
                        "type": "string",
                        "description": "The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/web3Hostname:Web3Hostname": {
            "description": "Manages Web3 hostnames for IPFS and Ethereum gateways.\n",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the hostname.\n"
                },
                "dnslink": {
                    "type": "string",
                    "description": "DNSLink value used if the target is ipfs.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Last modification time.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The hostname that will point to the target gateway via CNAME.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the hostname's activation.\n"
                },
                "target": {
                    "type": "string",
                    "description": "Target gateway of the hostname.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "required": [
                "createdOn",
                "modifiedOn",
                "name",
                "status",
                "target",
                "zoneId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the hostname.\n"
                },
                "dnslink": {
                    "type": "string",
                    "description": "DNSLink value used if the target is ipfs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The hostname that will point to the target gateway via CNAME.\n"
                },
                "target": {
                    "type": "string",
                    "description": "Target gateway of the hostname.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource.\n"
                }
            },
            "requiredInputs": [
                "name",
                "target",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Web3Hostname resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description of the hostname.\n"
                    },
                    "dnslink": {
                        "type": "string",
                        "description": "DNSLink value used if the target is ipfs.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Last modification time.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The hostname that will point to the target gateway via CNAME.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the hostname's activation.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "Target gateway of the hostname.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerCronTrigger:WorkerCronTrigger": {
            "description": "Worker Cron Triggers allow users to map a cron expression to a Worker script\nusing a `ScheduledEvent` listener that enables Workers to be executed on a\nschedule. Worker Cron Triggers are ideal for running periodic jobs for\nmaintenance or calling third-party APIs to collect up-to-date data.\n\n\u003e This resource uses the Cloudflare account APIs. This requires setting the\n`CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument\nif you do not explicitly set the resource level `account_id` value.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as fs from \"fs\";\n\nconst exampleScript = new cloudflare.WorkerScript(\"exampleScript\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"example-script\",\n    content: fs.readFileSync(\"path/to/my.js\"),\n});\nconst exampleTrigger = new cloudflare.WorkerCronTrigger(\"exampleTrigger\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    scriptName: exampleScript.name,\n    schedules: [\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_script = cloudflare.WorkerScript(\"exampleScript\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"example-script\",\n    content=(lambda path: open(path).read())(\"path/to/my.js\"))\nexample_trigger = cloudflare.WorkerCronTrigger(\"exampleTrigger\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    script_name=example_script.name,\n    schedules=[\n        \"*/5 * * * *\",\n        \"10 7 * * mon-fri\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleScript = new Cloudflare.WorkerScript(\"exampleScript\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"example-script\",\n        Content = File.ReadAllText(\"path/to/my.js\"),\n    });\n\n    var exampleTrigger = new Cloudflare.WorkerCronTrigger(\"exampleTrigger\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ScriptName = exampleScript.Name,\n        Schedules = new[]\n        {\n            \"*/5 * * * *\",\n            \"10 7 * * mon-fri\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleScript, err := cloudflare.NewWorkerScript(ctx, \"exampleScript\", \u0026cloudflare.WorkerScriptArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"example-script\"),\n\t\t\tContent:   readFileOrPanic(\"path/to/my.js\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerCronTrigger(ctx, \"exampleTrigger\", \u0026cloudflare.WorkerCronTriggerArgs{\n\t\t\tAccountId:  pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tScriptName: exampleScript.Name,\n\t\t\tSchedules: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*/5 * * * *\"),\n\t\t\t\tpulumi.String(\"10 7 * * mon-fri\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkerScript;\nimport com.pulumi.cloudflare.WorkerScriptArgs;\nimport com.pulumi.cloudflare.WorkerCronTrigger;\nimport com.pulumi.cloudflare.WorkerCronTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleScript = new WorkerScript(\"exampleScript\", WorkerScriptArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"example-script\")\n            .content(Files.readString(Paths.get(\"path/to/my.js\")))\n            .build());\n\n        var exampleTrigger = new WorkerCronTrigger(\"exampleTrigger\", WorkerCronTriggerArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .scriptName(exampleScript.name())\n            .schedules(            \n                \"*/5 * * * *\",\n                \"10 7 * * mon-fri\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleScript:\n    type: cloudflare:WorkerScript\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      name: example-script\n      content:\n        fn::readFile: path/to/my.js\n  exampleTrigger:\n    type: cloudflare:WorkerCronTrigger\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      scriptName: ${exampleScript.name}\n      schedules:\n        - '*/5 * * * *'\n        - 10 7 * * mon-fri\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/workerCronTrigger:WorkerCronTrigger example \u003caccount_id\u003e/\u003cscript_name\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cron expressions to execute the Worker script.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules.\n"
                }
            },
            "required": [
                "accountId",
                "schedules",
                "scriptName"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cron expressions to execute the Worker script.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script to target for the schedules.\n"
                }
            },
            "requiredInputs": [
                "accountId",
                "schedules",
                "scriptName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerCronTrigger resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "schedules": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cron expressions to execute the Worker script.\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script to target for the schedules.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerRoute:WorkerRoute": {
            "description": "Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`.\n\n\u003e This resource uses the Cloudflare account APIs. This requires setting the\n`CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument\nif you do not explicitly set the resource level `account_id` value.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst myScript = new cloudflare.WorkerScript(\"myScript\", {});\n// see \"cloudflare_worker_script\" documentation ...\n// Runs the specified worker script for all URLs that match `example.com/*`\nconst myRoute = new cloudflare.WorkerRoute(\"myRoute\", {\n    zoneId: \"0da42c8d2132a9ddaf714f9e7c920711\",\n    pattern: \"example.com/*\",\n    scriptName: myScript.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmy_script = cloudflare.WorkerScript(\"myScript\")\n# see \"cloudflare_worker_script\" documentation ...\n# Runs the specified worker script for all URLs that match `example.com/*`\nmy_route = cloudflare.WorkerRoute(\"myRoute\",\n    zone_id=\"0da42c8d2132a9ddaf714f9e7c920711\",\n    pattern=\"example.com/*\",\n    script_name=my_script.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myScript = new Cloudflare.WorkerScript(\"myScript\");\n\n    // see \"cloudflare_worker_script\" documentation ...\n    // Runs the specified worker script for all URLs that match `example.com/*`\n    var myRoute = new Cloudflare.WorkerRoute(\"myRoute\", new()\n    {\n        ZoneId = \"0da42c8d2132a9ddaf714f9e7c920711\",\n        Pattern = \"example.com/*\",\n        ScriptName = myScript.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyScript, err := cloudflare.NewWorkerScript(ctx, \"myScript\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerRoute(ctx, \"myRoute\", \u0026cloudflare.WorkerRouteArgs{\n\t\t\tZoneId:     pulumi.String(\"0da42c8d2132a9ddaf714f9e7c920711\"),\n\t\t\tPattern:    pulumi.String(\"example.com/*\"),\n\t\t\tScriptName: myScript.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkerScript;\nimport com.pulumi.cloudflare.WorkerRoute;\nimport com.pulumi.cloudflare.WorkerRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myScript = new WorkerScript(\"myScript\");\n\n        var myRoute = new WorkerRoute(\"myRoute\", WorkerRouteArgs.builder()        \n            .zoneId(\"0da42c8d2132a9ddaf714f9e7c920711\")\n            .pattern(\"example.com/*\")\n            .scriptName(myScript.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Runs the specified worker script for all URLs that match `example.com/*`\n  myRoute:\n    type: cloudflare:WorkerRoute\n    properties:\n      zoneId: 0da42c8d2132a9ddaf714f9e7c920711\n      pattern: example.com/*\n      scriptName: ${myScript.name}\n  myScript:\n    type: cloudflare:WorkerScript\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/workerRoute:WorkerRoute example \u003czone_id\u003e/\u003croute_id\u003e\n```\n\n ",
            "properties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script name to invoke for requests that match the route pattern.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "pattern",
                "zoneId"
            ],
            "inputProperties": {
                "pattern": {
                    "type": "string",
                    "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                },
                "scriptName": {
                    "type": "string",
                    "description": "Worker script name to invoke for requests that match the route pattern.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "pattern",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerRoute resources.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.\n"
                    },
                    "scriptName": {
                        "type": "string",
                        "description": "Worker script name to invoke for requests that match the route pattern.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workerScript:WorkerScript": {
            "description": "Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`.\n\n\u003e This resource uses the Cloudflare account APIs. This requires setting the\n  `CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as fs from \"fs\";\n\nconst myNamespace = new cloudflare.WorkersKvNamespace(\"myNamespace\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"example\",\n});\n// Sets the script with the name \"script_1\"\nconst myScript = new cloudflare.WorkerScript(\"myScript\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    name: \"script_1\",\n    content: fs.readFileSync(\"script.js\"),\n    kvNamespaceBindings: [{\n        name: \"MY_EXAMPLE_KV_NAMESPACE\",\n        namespaceId: myNamespace.id,\n    }],\n    plainTextBindings: [{\n        name: \"MY_EXAMPLE_PLAIN_TEXT\",\n        text: \"foobar\",\n    }],\n    secretTextBindings: [{\n        name: \"MY_EXAMPLE_SECRET_TEXT\",\n        text: _var.secret_foo_value,\n    }],\n    webassemblyBindings: [{\n        name: \"MY_EXAMPLE_WASM\",\n        module: Buffer.from(fs.readFileSync(\"example.wasm\"), 'binary').toString('base64'),\n    }],\n    serviceBindings: [{\n        name: \"MY_SERVICE_BINDING\",\n        service: \"MY_SERVICE\",\n        environment: \"production\",\n    }],\n    r2BucketBindings: [{\n        name: \"MY_BUCKET\",\n        bucketName: \"MY_BUCKET_NAME\",\n    }],\n    analyticsEngineBindings: [{\n        name: \"MY_DATASET\",\n        dataset: \"dataset1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport base64\nimport pulumi_cloudflare as cloudflare\n\nmy_namespace = cloudflare.WorkersKvNamespace(\"myNamespace\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"example\")\n# Sets the script with the name \"script_1\"\nmy_script = cloudflare.WorkerScript(\"myScript\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    name=\"script_1\",\n    content=(lambda path: open(path).read())(\"script.js\"),\n    kv_namespace_bindings=[cloudflare.WorkerScriptKvNamespaceBindingArgs(\n        name=\"MY_EXAMPLE_KV_NAMESPACE\",\n        namespace_id=my_namespace.id,\n    )],\n    plain_text_bindings=[cloudflare.WorkerScriptPlainTextBindingArgs(\n        name=\"MY_EXAMPLE_PLAIN_TEXT\",\n        text=\"foobar\",\n    )],\n    secret_text_bindings=[cloudflare.WorkerScriptSecretTextBindingArgs(\n        name=\"MY_EXAMPLE_SECRET_TEXT\",\n        text=var[\"secret_foo_value\"],\n    )],\n    webassembly_bindings=[cloudflare.WorkerScriptWebassemblyBindingArgs(\n        name=\"MY_EXAMPLE_WASM\",\n        module=(lambda path: base64.b64encode(open(path).read().encode()).decode())(\"example.wasm\"),\n    )],\n    service_bindings=[cloudflare.WorkerScriptServiceBindingArgs(\n        name=\"MY_SERVICE_BINDING\",\n        service=\"MY_SERVICE\",\n        environment=\"production\",\n    )],\n    r2_bucket_bindings=[cloudflare.WorkerScriptR2BucketBindingArgs(\n        name=\"MY_BUCKET\",\n        bucket_name=\"MY_BUCKET_NAME\",\n    )],\n    analytics_engine_bindings=[cloudflare.WorkerScriptAnalyticsEngineBindingArgs(\n        name=\"MY_DATASET\",\n        dataset=\"dataset1\",\n    )])\n```\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\n\tprivate static string ReadFileBase64(string path) {\n\t\treturn Convert.ToBase64String(Encoding.UTF8.GetBytes(File.ReadAllText(path)))\n\t}\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myNamespace = new Cloudflare.WorkersKvNamespace(\"myNamespace\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"example\",\n    });\n\n    // Sets the script with the name \"script_1\"\n    var myScript = new Cloudflare.WorkerScript(\"myScript\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Name = \"script_1\",\n        Content = File.ReadAllText(\"script.js\"),\n        KvNamespaceBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptKvNamespaceBindingArgs\n            {\n                Name = \"MY_EXAMPLE_KV_NAMESPACE\",\n                NamespaceId = myNamespace.Id,\n            },\n        },\n        PlainTextBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptPlainTextBindingArgs\n            {\n                Name = \"MY_EXAMPLE_PLAIN_TEXT\",\n                Text = \"foobar\",\n            },\n        },\n        SecretTextBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptSecretTextBindingArgs\n            {\n                Name = \"MY_EXAMPLE_SECRET_TEXT\",\n                Text = @var.Secret_foo_value,\n            },\n        },\n        WebassemblyBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptWebassemblyBindingArgs\n            {\n                Name = \"MY_EXAMPLE_WASM\",\n                Module = ReadFileBase64(\"example.wasm\"),\n            },\n        },\n        ServiceBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptServiceBindingArgs\n            {\n                Name = \"MY_SERVICE_BINDING\",\n                Service = \"MY_SERVICE\",\n                Environment = \"production\",\n            },\n        },\n        R2BucketBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptR2BucketBindingArgs\n            {\n                Name = \"MY_BUCKET\",\n                BucketName = \"MY_BUCKET_NAME\",\n            },\n        },\n        AnalyticsEngineBindings = new[]\n        {\n            new Cloudflare.Inputs.WorkerScriptAnalyticsEngineBindingArgs\n            {\n                Name = \"MY_DATASET\",\n                Dataset = \"dataset1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc filebase64OrPanic(path string) pulumi.StringPtrInput {\n\tif fileData, err := ioutil.ReadFile(path); err == nil {\n\t\treturn pulumi.String(base64.StdEncoding.EncodeToString(fileData[:]))\n\t} else {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyNamespace, err := cloudflare.NewWorkersKvNamespace(ctx, \"myNamespace\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkerScript(ctx, \"myScript\", \u0026cloudflare.WorkerScriptArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tName:      pulumi.String(\"script_1\"),\n\t\t\tContent:   readFileOrPanic(\"script.js\"),\n\t\t\tKvNamespaceBindings: cloudflare.WorkerScriptKvNamespaceBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptKvNamespaceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_EXAMPLE_KV_NAMESPACE\"),\n\t\t\t\t\tNamespaceId: myNamespace.ID(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPlainTextBindings: cloudflare.WorkerScriptPlainTextBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptPlainTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_PLAIN_TEXT\"),\n\t\t\t\t\tText: pulumi.String(\"foobar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tSecretTextBindings: cloudflare.WorkerScriptSecretTextBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptSecretTextBindingArgs{\n\t\t\t\t\tName: pulumi.String(\"MY_EXAMPLE_SECRET_TEXT\"),\n\t\t\t\t\tText: pulumi.Any(_var.Secret_foo_value),\n\t\t\t\t},\n\t\t\t},\n\t\t\tWebassemblyBindings: cloudflare.WorkerScriptWebassemblyBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptWebassemblyBindingArgs{\n\t\t\t\t\tName:   pulumi.String(\"MY_EXAMPLE_WASM\"),\n\t\t\t\t\tModule: filebase64OrPanic(\"example.wasm\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tServiceBindings: cloudflare.WorkerScriptServiceBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptServiceBindingArgs{\n\t\t\t\t\tName:        pulumi.String(\"MY_SERVICE_BINDING\"),\n\t\t\t\t\tService:     pulumi.String(\"MY_SERVICE\"),\n\t\t\t\t\tEnvironment: pulumi.String(\"production\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tR2BucketBindings: cloudflare.WorkerScriptR2BucketBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptR2BucketBindingArgs{\n\t\t\t\t\tName:       pulumi.String(\"MY_BUCKET\"),\n\t\t\t\t\tBucketName: pulumi.String(\"MY_BUCKET_NAME\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tAnalyticsEngineBindings: cloudflare.WorkerScriptAnalyticsEngineBindingArray{\n\t\t\t\t\u0026cloudflare.WorkerScriptAnalyticsEngineBindingArgs{\n\t\t\t\t\tName:    pulumi.String(\"MY_DATASET\"),\n\t\t\t\t\tDataset: pulumi.String(\"dataset1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport com.pulumi.cloudflare.WorkerScript;\nimport com.pulumi.cloudflare.WorkerScriptArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptKvNamespaceBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptPlainTextBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptSecretTextBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptWebassemblyBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptServiceBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptR2BucketBindingArgs;\nimport com.pulumi.cloudflare.inputs.WorkerScriptAnalyticsEngineBindingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myNamespace = new WorkersKvNamespace(\"myNamespace\", WorkersKvNamespaceArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"example\")\n            .build());\n\n        var myScript = new WorkerScript(\"myScript\", WorkerScriptArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .name(\"script_1\")\n            .content(Files.readString(Paths.get(\"script.js\")))\n            .kvNamespaceBindings(WorkerScriptKvNamespaceBindingArgs.builder()\n                .name(\"MY_EXAMPLE_KV_NAMESPACE\")\n                .namespaceId(myNamespace.id())\n                .build())\n            .plainTextBindings(WorkerScriptPlainTextBindingArgs.builder()\n                .name(\"MY_EXAMPLE_PLAIN_TEXT\")\n                .text(\"foobar\")\n                .build())\n            .secretTextBindings(WorkerScriptSecretTextBindingArgs.builder()\n                .name(\"MY_EXAMPLE_SECRET_TEXT\")\n                .text(var_.secret_foo_value())\n                .build())\n            .webassemblyBindings(WorkerScriptWebassemblyBindingArgs.builder()\n                .name(\"MY_EXAMPLE_WASM\")\n                .module(Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(\"example.wasm\"))))\n                .build())\n            .serviceBindings(WorkerScriptServiceBindingArgs.builder()\n                .name(\"MY_SERVICE_BINDING\")\n                .service(\"MY_SERVICE\")\n                .environment(\"production\")\n                .build())\n            .r2BucketBindings(WorkerScriptR2BucketBindingArgs.builder()\n                .name(\"MY_BUCKET\")\n                .bucketName(\"MY_BUCKET_NAME\")\n                .build())\n            .analyticsEngineBindings(WorkerScriptAnalyticsEngineBindingArgs.builder()\n                .name(\"MY_DATASET\")\n                .dataset(\"dataset1\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/workerScript:WorkerScript example \u003caccount_id\u003e/\u003cscript_name\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "analyticsEngineBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding"
                    }
                },
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "module": {
                    "type": "boolean",
                    "description": "Whether to upload Worker as a module.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                    }
                },
                "r2BucketBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                    }
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                    }
                }
            },
            "required": [
                "content",
                "name"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "analyticsEngineBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding"
                    }
                },
                "content": {
                    "type": "string",
                    "description": "The script content.\n"
                },
                "kvNamespaceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                    }
                },
                "module": {
                    "type": "boolean",
                    "description": "Whether to upload Worker as a module.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "plainTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                    }
                },
                "r2BucketBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding"
                    }
                },
                "secretTextBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                    }
                },
                "serviceBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding"
                    }
                },
                "webassemblyBindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                    }
                }
            },
            "requiredInputs": [
                "content",
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkerScript resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "analyticsEngineBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptAnalyticsEngineBinding:WorkerScriptAnalyticsEngineBinding"
                        }
                    },
                    "content": {
                        "type": "string",
                        "description": "The script content.\n"
                    },
                    "kvNamespaceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptKvNamespaceBinding:WorkerScriptKvNamespaceBinding"
                        }
                    },
                    "module": {
                        "type": "boolean",
                        "description": "Whether to upload Worker as a module.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for the script. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "plainTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptPlainTextBinding:WorkerScriptPlainTextBinding"
                        }
                    },
                    "r2BucketBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptR2BucketBinding:WorkerScriptR2BucketBinding"
                        }
                    },
                    "secretTextBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptSecretTextBinding:WorkerScriptSecretTextBinding"
                        }
                    },
                    "serviceBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptServiceBinding:WorkerScriptServiceBinding"
                        }
                    },
                    "webassemblyBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/WorkerScriptWebassemblyBinding:WorkerScriptWebassemblyBinding"
                        }
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKv:WorkersKv": {
            "description": "Provides a resource to manage a Cloudflare Workers KV Pair.\n\n\u003e This resource uses the Cloudflare account APIs. This requires setting the\n`CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument\nif you do not explicitly set the resource level `account_id` value.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleNs = new cloudflare.WorkersKvNamespace(\"exampleNs\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"test-namespace\",\n});\nconst example = new cloudflare.WorkersKv(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    namespaceId: exampleNs.id,\n    key: \"test-key\",\n    value: \"test value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_ns = cloudflare.WorkersKvNamespace(\"exampleNs\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"test-namespace\")\nexample = cloudflare.WorkersKv(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    namespace_id=example_ns.id,\n    key=\"test-key\",\n    value=\"test value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleNs = new Cloudflare.WorkersKvNamespace(\"exampleNs\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"test-namespace\",\n    });\n\n    var example = new Cloudflare.WorkersKv(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        NamespaceId = exampleNs.Id,\n        Key = \"test-key\",\n        Value = \"test value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleNs, err := cloudflare.NewWorkersKvNamespace(ctx, \"exampleNs\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"test-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewWorkersKv(ctx, \"example\", \u0026cloudflare.WorkersKvArgs{\n\t\t\tAccountId:   pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tNamespaceId: exampleNs.ID(),\n\t\t\tKey:         pulumi.String(\"test-key\"),\n\t\t\tValue:       pulumi.String(\"test value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport com.pulumi.cloudflare.WorkersKv;\nimport com.pulumi.cloudflare.WorkersKvArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleNs = new WorkersKvNamespace(\"exampleNs\", WorkersKvNamespaceArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"test-namespace\")\n            .build());\n\n        var example = new WorkersKv(\"example\", WorkersKvArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .namespaceId(exampleNs.id())\n            .key(\"test-key\")\n            .value(\"test value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleNs:\n    type: cloudflare:WorkersKvNamespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      title: test-namespace\n  example:\n    type: cloudflare:WorkersKv\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      namespaceId: ${exampleNs.id}\n      key: test-key\n      value: test value\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/workersKv:WorkersKv example \u003caccount_id\u003e/\u003cnamespace_id\u003e/\u003ckey_name\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Name of the KV pair. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the KV pair.\n"
                }
            },
            "required": [
                "accountId",
                "key",
                "namespaceId",
                "value"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Name of the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "namespaceId": {
                    "type": "string",
                    "description": "The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the KV pair.\n"
                }
            },
            "requiredInputs": [
                "key",
                "namespaceId",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKv resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Name of the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of the KV pair.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/workersKvNamespace:WorkersKvNamespace": {
            "description": "Provides the ability to manage Cloudflare Workers KV Namespace features.\n\n\u003e This resource uses the Cloudflare account APIs. This requires setting the\n`CLOUDFLARE_ACCOUNT_ID` environment variable or `account_id` provider argument.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.WorkersKvNamespace(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    title: \"test-namespace\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.WorkersKvNamespace(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    title=\"test-namespace\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.WorkersKvNamespace(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Title = \"test-namespace\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewWorkersKvNamespace(ctx, \"example\", \u0026cloudflare.WorkersKvNamespaceArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tTitle:     pulumi.String(\"test-namespace\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.WorkersKvNamespace;\nimport com.pulumi.cloudflare.WorkersKvNamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WorkersKvNamespace(\"example\", WorkersKvNamespaceArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .title(\"test-namespace\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:WorkersKvNamespace\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      title: test-namespace\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/workersKvNamespace:WorkersKvNamespace example \u003caccount_id\u003e/\u003cnamespace_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title value of the Worker KV Namespace.\n"
                }
            },
            "required": [
                "accountId",
                "title"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "The account identifier to target for the resource.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title value of the Worker KV Namespace.\n"
                }
            },
            "requiredInputs": [
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WorkersKvNamespace resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the resource.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title value of the Worker KV Namespace.\n"
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zone:Zone": {
            "description": "Provides a Cloudflare Zone resource. Zone is the basic resource for\nworking with Cloudflare and is roughly equivalent to a domain name\nthat the user purchases.\n\n\u003e If you are attempting to sign up a subdomain of a zone you must first have Subdomain Support entitlement for your account.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.Zone(\"example\", {\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    zone: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.Zone(\"example\",\n    account_id=\"f037e56e89293a057740de681ac9abbe\",\n    zone=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.Zone(\"example\", new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        ZoneName = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZone(ctx, \"example\", \u0026cloudflare.ZoneArgs{\n\t\t\tAccountId: pulumi.String(\"f037e56e89293a057740de681ac9abbe\"),\n\t\t\tZone:      pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Zone;\nimport com.pulumi.cloudflare.ZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Zone(\"example\", ZoneArgs.builder()        \n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .zone(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:Zone\n    properties:\n      accountId: f037e56e89293a057740de681ac9abbe\n      zone: example.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/zone:Zone example \u003czone_id\u003e\n```\n\n ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to manage the zone resource in.\n"
                },
                "jumpStart": {
                    "type": "boolean",
                    "description": "Whether to scan for DNS records on creation. Ignored after zone is created.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    }
                },
                "nameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the zone. Available values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`. Defaults to `full`.\n"
                },
                "vanityNameServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Vanity Nameservers (if set).\n"
                },
                "verificationKey": {
                    "type": "string",
                    "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    }
                }
            },
            "required": [
                "meta",
                "nameServers",
                "plan",
                "status",
                "vanityNameServers",
                "verificationKey",
                "zone"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "Account ID to manage the zone resource in.\n"
                },
                "jumpStart": {
                    "type": "boolean",
                    "description": "Whether to scan for DNS records on creation. Ignored after zone is created.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`. Defaults to `full`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**\n",
                    "language": {
                        "csharp": {
                            "name": "ZoneName"
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Zone resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "Account ID to manage the zone resource in.\n"
                    },
                    "jumpStart": {
                        "type": "boolean",
                        "description": "Whether to scan for DNS records on creation. Ignored after zone is created.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "boolean"
                        }
                    },
                    "nameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the zone. Available values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`. Defaults to `full`.\n"
                    },
                    "vanityNameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vanity Nameservers (if set).\n"
                    },
                    "verificationKey": {
                        "type": "string",
                        "description": "Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**\n",
                        "language": {
                            "csharp": {
                                "name": "ZoneName"
                            }
                        },
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneCacheVariants:ZoneCacheVariants": {
            "description": "Provides a resource which customizes Cloudflare zone cache variants.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = new cloudflare.ZoneCacheVariants(\"example\", {\n    avifs: [\n        \"image/avif\",\n        \"image/webp\",\n    ],\n    bmps: [\n        \"image/bmp\",\n        \"image/webp\",\n    ],\n    gifs: [\n        \"image/gif\",\n        \"image/webp\",\n    ],\n    jp2s: [\n        \"image/jp2\",\n        \"image/webp\",\n    ],\n    jpegs: [\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n    jpgs: [\n        \"image/jpg\",\n        \"image/webp\",\n    ],\n    jpg2s: [\n        \"image/jpg2\",\n        \"image/webp\",\n    ],\n    pngs: [\n        \"image/png\",\n        \"image/webp\",\n    ],\n    tifs: [\n        \"image/tif\",\n        \"image/webp\",\n    ],\n    tiffs: [\n        \"image/tiff\",\n        \"image/webp\",\n    ],\n    webps: [\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n    zoneId: \"7df50664b7f90274f4d77cdfee701380\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.ZoneCacheVariants(\"example\",\n    avifs=[\n        \"image/avif\",\n        \"image/webp\",\n    ],\n    bmps=[\n        \"image/bmp\",\n        \"image/webp\",\n    ],\n    gifs=[\n        \"image/gif\",\n        \"image/webp\",\n    ],\n    jp2s=[\n        \"image/jp2\",\n        \"image/webp\",\n    ],\n    jpegs=[\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n    jpgs=[\n        \"image/jpg\",\n        \"image/webp\",\n    ],\n    jpg2s=[\n        \"image/jpg2\",\n        \"image/webp\",\n    ],\n    pngs=[\n        \"image/png\",\n        \"image/webp\",\n    ],\n    tifs=[\n        \"image/tif\",\n        \"image/webp\",\n    ],\n    tiffs=[\n        \"image/tiff\",\n        \"image/webp\",\n    ],\n    webps=[\n        \"image/jpeg\",\n        \"image/webp\",\n    ],\n    zone_id=\"7df50664b7f90274f4d77cdfee701380\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Cloudflare.ZoneCacheVariants(\"example\", new()\n    {\n        Avifs = new[]\n        {\n            \"image/avif\",\n            \"image/webp\",\n        },\n        Bmps = new[]\n        {\n            \"image/bmp\",\n            \"image/webp\",\n        },\n        Gifs = new[]\n        {\n            \"image/gif\",\n            \"image/webp\",\n        },\n        Jp2s = new[]\n        {\n            \"image/jp2\",\n            \"image/webp\",\n        },\n        Jpegs = new[]\n        {\n            \"image/jpeg\",\n            \"image/webp\",\n        },\n        Jpgs = new[]\n        {\n            \"image/jpg\",\n            \"image/webp\",\n        },\n        Jpg2s = new[]\n        {\n            \"image/jpg2\",\n            \"image/webp\",\n        },\n        Pngs = new[]\n        {\n            \"image/png\",\n            \"image/webp\",\n        },\n        Tifs = new[]\n        {\n            \"image/tif\",\n            \"image/webp\",\n        },\n        Tiffs = new[]\n        {\n            \"image/tiff\",\n            \"image/webp\",\n        },\n        Webps = new[]\n        {\n            \"image/jpeg\",\n            \"image/webp\",\n        },\n        ZoneId = \"7df50664b7f90274f4d77cdfee701380\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneCacheVariants(ctx, \"example\", \u0026cloudflare.ZoneCacheVariantsArgs{\n\t\t\tAvifs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/avif\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tBmps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/bmp\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tGifs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/gif\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJp2s: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jp2\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJpegs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpeg\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJpgs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpg\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tJpg2s: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpg2\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tPngs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/png\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tTifs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/tif\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tTiffs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/tiff\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tWebps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"image/jpeg\"),\n\t\t\t\tpulumi.String(\"image/webp\"),\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"7df50664b7f90274f4d77cdfee701380\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneCacheVariants;\nimport com.pulumi.cloudflare.ZoneCacheVariantsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ZoneCacheVariants(\"example\", ZoneCacheVariantsArgs.builder()        \n            .avifs(            \n                \"image/avif\",\n                \"image/webp\")\n            .bmps(            \n                \"image/bmp\",\n                \"image/webp\")\n            .gifs(            \n                \"image/gif\",\n                \"image/webp\")\n            .jp2s(            \n                \"image/jp2\",\n                \"image/webp\")\n            .jpegs(            \n                \"image/jpeg\",\n                \"image/webp\")\n            .jpgs(            \n                \"image/jpg\",\n                \"image/webp\")\n            .jpg2s(            \n                \"image/jpg2\",\n                \"image/webp\")\n            .pngs(            \n                \"image/png\",\n                \"image/webp\")\n            .tifs(            \n                \"image/tif\",\n                \"image/webp\")\n            .tiffs(            \n                \"image/tiff\",\n                \"image/webp\")\n            .webps(            \n                \"image/jpeg\",\n                \"image/webp\")\n            .zoneId(\"7df50664b7f90274f4d77cdfee701380\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: cloudflare:ZoneCacheVariants\n    properties:\n      avifs:\n        - image/avif\n        - image/webp\n      bmps:\n        - image/bmp\n        - image/webp\n      gifs:\n        - image/gif\n        - image/webp\n      jp2s:\n        - image/jp2\n        - image/webp\n      jpegs:\n        - image/jpeg\n        - image/webp\n      jpgs:\n        - image/jpg\n        - image/webp\n      jpg2s:\n        - image/jpg2\n        - image/webp\n      pngs:\n        - image/png\n        - image/webp\n      tifs:\n        - image/tif\n        - image/webp\n      tiffs:\n        - image/tiff\n        - image/webp\n      webps:\n        - image/jpeg\n        - image/webp\n      zoneId: 7df50664b7f90274f4d77cdfee701380\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "avifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for avif\n"
                },
                "bmps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for bmp\n"
                },
                "gifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for gif\n"
                },
                "jp2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jp2\n"
                },
                "jpegs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpeg\n"
                },
                "jpg2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg2\n"
                },
                "jpgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg\n"
                },
                "pngs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for png\n"
                },
                "tiffs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tiff\n"
                },
                "tifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tif\n"
                },
                "webps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for webp\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the DNS zone in which to apply the cache variants setting\n"
                }
            },
            "required": [
                "zoneId"
            ],
            "inputProperties": {
                "avifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for avif\n"
                },
                "bmps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for bmp\n"
                },
                "gifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for gif\n"
                },
                "jp2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jp2\n"
                },
                "jpegs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpeg\n"
                },
                "jpg2s": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg2\n"
                },
                "jpgs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for jpg\n"
                },
                "pngs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for png\n"
                },
                "tiffs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tiff\n"
                },
                "tifs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for tif\n"
                },
                "webps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings with the MIME types of all the variants that should be served for webp\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The ID of the DNS zone in which to apply the cache variants setting\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneCacheVariants resources.\n",
                "properties": {
                    "avifs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for avif\n"
                    },
                    "bmps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for bmp\n"
                    },
                    "gifs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for gif\n"
                    },
                    "jp2s": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jp2\n"
                    },
                    "jpegs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jpeg\n"
                    },
                    "jpg2s": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jpg2\n"
                    },
                    "jpgs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for jpg\n"
                    },
                    "pngs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for png\n"
                    },
                    "tiffs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for tiff\n"
                    },
                    "tifs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for tif\n"
                    },
                    "webps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings with the MIME types of all the variants that should be served for webp\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to apply the cache variants setting\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneDnssec:ZoneDnssec": {
            "description": "Provides a Cloudflare resource to create and modify zone DNSSEC settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleZone = new cloudflare.Zone(\"exampleZone\", {zone: \"example.com\"});\nconst exampleZoneDnssec = new cloudflare.ZoneDnssec(\"exampleZoneDnssec\", {zoneId: exampleZone.id});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_zone = cloudflare.Zone(\"exampleZone\", zone=\"example.com\")\nexample_zone_dnssec = cloudflare.ZoneDnssec(\"exampleZoneDnssec\", zone_id=example_zone.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleZone = new Cloudflare.Zone(\"exampleZone\", new()\n    {\n        ZoneName = \"example.com\",\n    });\n\n    var exampleZoneDnssec = new Cloudflare.ZoneDnssec(\"exampleZoneDnssec\", new()\n    {\n        ZoneId = exampleZone.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleZone, err := cloudflare.NewZone(ctx, \"exampleZone\", \u0026cloudflare.ZoneArgs{\n\t\t\tZone: pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewZoneDnssec(ctx, \"exampleZoneDnssec\", \u0026cloudflare.ZoneDnssecArgs{\n\t\t\tZoneId: exampleZone.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.Zone;\nimport com.pulumi.cloudflare.ZoneArgs;\nimport com.pulumi.cloudflare.ZoneDnssec;\nimport com.pulumi.cloudflare.ZoneDnssecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleZone = new Zone(\"exampleZone\", ZoneArgs.builder()        \n            .zone(\"example.com\")\n            .build());\n\n        var exampleZoneDnssec = new ZoneDnssec(\"exampleZoneDnssec\", ZoneDnssecArgs.builder()        \n            .zoneId(exampleZone.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleZone:\n    type: cloudflare:Zone\n    properties:\n      zone: example.com\n  exampleZoneDnssec:\n    type: cloudflare:ZoneDnssec\n    properties:\n      zoneId: ${exampleZone.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import cloudflare:index/zoneDnssec:ZoneDnssec example \u003czone_id\u003e\n```\n\n ",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Zone DNSSEC algorithm.\n"
                },
                "digest": {
                    "type": "string",
                    "description": "Zone DNSSEC digest.\n"
                },
                "digestAlgorithm": {
                    "type": "string",
                    "description": "Digest algorithm use for Zone DNSSEC.\n"
                },
                "digestType": {
                    "type": "string",
                    "description": "Digest Type for Zone DNSSEC.\n"
                },
                "ds": {
                    "type": "string",
                    "description": "DS for the Zone DNSSEC.\n"
                },
                "flags": {
                    "type": "integer",
                    "description": "Zone DNSSEC flags.\n"
                },
                "keyTag": {
                    "type": "integer",
                    "description": "Key Tag for the Zone DNSSEC.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Key type used for Zone DNSSEC.\n"
                },
                "modifiedOn": {
                    "type": "string",
                    "description": "Zone DNSSEC updated time.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "Public Key for the Zone DNSSEC.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the Zone DNSSEC.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n"
                }
            },
            "required": [
                "algorithm",
                "digest",
                "digestAlgorithm",
                "digestType",
                "ds",
                "flags",
                "keyTag",
                "keyType",
                "modifiedOn",
                "publicKey",
                "status",
                "zoneId"
            ],
            "inputProperties": {
                "modifiedOn": {
                    "type": "string",
                    "description": "Zone DNSSEC updated time.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneDnssec resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Zone DNSSEC algorithm.\n"
                    },
                    "digest": {
                        "type": "string",
                        "description": "Zone DNSSEC digest.\n"
                    },
                    "digestAlgorithm": {
                        "type": "string",
                        "description": "Digest algorithm use for Zone DNSSEC.\n"
                    },
                    "digestType": {
                        "type": "string",
                        "description": "Digest Type for Zone DNSSEC.\n"
                    },
                    "ds": {
                        "type": "string",
                        "description": "DS for the Zone DNSSEC.\n"
                    },
                    "flags": {
                        "type": "integer",
                        "description": "Zone DNSSEC flags.\n"
                    },
                    "keyTag": {
                        "type": "integer",
                        "description": "Key Tag for the Zone DNSSEC.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Key type used for Zone DNSSEC.\n"
                    },
                    "modifiedOn": {
                        "type": "string",
                        "description": "Zone DNSSEC updated time.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public Key for the Zone DNSSEC.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the Zone DNSSEC.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneLockdown:ZoneLockdown": {
            "description": "Provides a Cloudflare Zone Lockdown resource. Zone Lockdown allows you to define one or more URLs (with wildcard matching on the domain or path) that will only permit access if the request originates from an IP address that matches a safelist of one or more IP addresses and/or IP ranges.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\n// Restrict access to these endpoints to requests from a known IP address range.\nconst endpointLockdown = new cloudflare.ZoneLockdown(\"endpointLockdown\", {\n    configurations: [{\n        target: \"ip_range\",\n        value: \"198.51.100.0/16\",\n    }],\n    description: \"Restrict access to these endpoints to requests from a known IP address range\",\n    paused: false,\n    urls: [\"api.mysite.com/some/endpoint*\"],\n    zoneId: \"d41d8cd98f00b204e9800998ecf8427e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\n# Restrict access to these endpoints to requests from a known IP address range.\nendpoint_lockdown = cloudflare.ZoneLockdown(\"endpointLockdown\",\n    configurations=[cloudflare.ZoneLockdownConfigurationArgs(\n        target=\"ip_range\",\n        value=\"198.51.100.0/16\",\n    )],\n    description=\"Restrict access to these endpoints to requests from a known IP address range\",\n    paused=False,\n    urls=[\"api.mysite.com/some/endpoint*\"],\n    zone_id=\"d41d8cd98f00b204e9800998ecf8427e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Restrict access to these endpoints to requests from a known IP address range.\n    var endpointLockdown = new Cloudflare.ZoneLockdown(\"endpointLockdown\", new()\n    {\n        Configurations = new[]\n        {\n            new Cloudflare.Inputs.ZoneLockdownConfigurationArgs\n            {\n                Target = \"ip_range\",\n                Value = \"198.51.100.0/16\",\n            },\n        },\n        Description = \"Restrict access to these endpoints to requests from a known IP address range\",\n        Paused = false,\n        Urls = new[]\n        {\n            \"api.mysite.com/some/endpoint*\",\n        },\n        ZoneId = \"d41d8cd98f00b204e9800998ecf8427e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneLockdown(ctx, \"endpointLockdown\", \u0026cloudflare.ZoneLockdownArgs{\n\t\t\tConfigurations: cloudflare.ZoneLockdownConfigurationArray{\n\t\t\t\t\u0026cloudflare.ZoneLockdownConfigurationArgs{\n\t\t\t\t\tTarget: pulumi.String(\"ip_range\"),\n\t\t\t\t\tValue:  pulumi.String(\"198.51.100.0/16\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"Restrict access to these endpoints to requests from a known IP address range\"),\n\t\t\tPaused:      pulumi.Bool(false),\n\t\t\tUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api.mysite.com/some/endpoint*\"),\n\t\t\t},\n\t\t\tZoneId: pulumi.String(\"d41d8cd98f00b204e9800998ecf8427e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneLockdown;\nimport com.pulumi.cloudflare.ZoneLockdownArgs;\nimport com.pulumi.cloudflare.inputs.ZoneLockdownConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var endpointLockdown = new ZoneLockdown(\"endpointLockdown\", ZoneLockdownArgs.builder()        \n            .configurations(ZoneLockdownConfigurationArgs.builder()\n                .target(\"ip_range\")\n                .value(\"198.51.100.0/16\")\n                .build())\n            .description(\"Restrict access to these endpoints to requests from a known IP address range\")\n            .paused(\"false\")\n            .urls(\"api.mysite.com/some/endpoint*\")\n            .zoneId(\"d41d8cd98f00b204e9800998ecf8427e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Restrict access to these endpoints to requests from a known IP address range.\n  endpointLockdown:\n    type: cloudflare:ZoneLockdown\n    properties:\n      configurations:\n        - target: ip_range\n          value: 198.51.100.0/16\n      description: Restrict access to these endpoints to requests from a known IP address range\n      paused: 'false'\n      urls:\n        - api.mysite.com/some/endpoint*\n      zoneId: d41d8cd98f00b204e9800998ecf8427e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRecords can be imported using a composite ID formed of zone name and record ID, e.g.\n\n```sh\n $ pulumi import cloudflare:index/zoneLockdown:ZoneLockdown cloudflare_zone_lockdown d41d8cd98f00b204e9800998ecf8427e/37cb64fe4a90adb5ca3afc04f2c82a2f\n```\n\n where- `d41d8cd98f00b204e9800998ecf8427e` - zone ID - `37cb64fe4a90adb5ca3afc04f2c82a2f` - zone lockdown ID as returned by [API](https://api.cloudflare.com/#zone-lockdown-list-lockdown-rules) ",
            "properties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs. It's a complex value. See description below. The order of the configuration entries is unimportant.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the access rule should be added.\n"
                }
            },
            "required": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "inputProperties": {
                "configurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                    },
                    "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs. It's a complex value. See description below. The order of the configuration entries is unimportant.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                },
                "priority": {
                    "type": "integer"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which the access rule should be added.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configurations",
                "urls",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneLockdown resources.\n",
                "properties": {
                    "configurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZoneLockdownConfiguration:ZoneLockdownConfiguration"
                        },
                        "description": "A list of IP addresses or IP ranges to match the request against specified in target, value pairs. It's a complex value. See description below. The order of the configuration entries is unimportant.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Boolean of whether this zone lockdown is currently paused. Default: false.\n"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which the access rule should be added.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "cloudflare:index/zoneSettingsOverride:ZoneSettingsOverride": {
            "description": "Provides a resource which customizes Cloudflare zone settings. Note that after destroying this resource Zone Settings will be reset to their initial values.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = new cloudflare.ZoneSettingsOverride(\"test\", {\n    zoneId: _var.cloudflare_zone_id,\n    settings: {\n        brotli: \"on\",\n        challengeTtl: 2700,\n        securityLevel: \"high\",\n        opportunisticEncryption: \"on\",\n        automaticHttpsRewrites: \"on\",\n        mirage: \"on\",\n        waf: \"on\",\n        minify: {\n            css: \"on\",\n            js: \"off\",\n            html: \"off\",\n        },\n        securityHeader: {\n            enabled: true,\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.ZoneSettingsOverride(\"test\",\n    zone_id=var[\"cloudflare_zone_id\"],\n    settings=cloudflare.ZoneSettingsOverrideSettingsArgs(\n        brotli=\"on\",\n        challenge_ttl=2700,\n        security_level=\"high\",\n        opportunistic_encryption=\"on\",\n        automatic_https_rewrites=\"on\",\n        mirage=\"on\",\n        waf=\"on\",\n        minify=cloudflare.ZoneSettingsOverrideSettingsMinifyArgs(\n            css=\"on\",\n            js=\"off\",\n            html=\"off\",\n        ),\n        security_header=cloudflare.ZoneSettingsOverrideSettingsSecurityHeaderArgs(\n            enabled=True,\n        ),\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Cloudflare.ZoneSettingsOverride(\"test\", new()\n    {\n        ZoneId = @var.Cloudflare_zone_id,\n        Settings = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsArgs\n        {\n            Brotli = \"on\",\n            ChallengeTtl = 2700,\n            SecurityLevel = \"high\",\n            OpportunisticEncryption = \"on\",\n            AutomaticHttpsRewrites = \"on\",\n            Mirage = \"on\",\n            Waf = \"on\",\n            Minify = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsMinifyArgs\n            {\n                Css = \"on\",\n                Js = \"off\",\n                Html = \"off\",\n            },\n            SecurityHeader = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs\n            {\n                Enabled = true,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cloudflare.NewZoneSettingsOverride(ctx, \"test\", \u0026cloudflare.ZoneSettingsOverrideArgs{\n\t\t\tZoneId: pulumi.Any(_var.Cloudflare_zone_id),\n\t\t\tSettings: \u0026cloudflare.ZoneSettingsOverrideSettingsArgs{\n\t\t\t\tBrotli:                  pulumi.String(\"on\"),\n\t\t\t\tChallengeTtl:            pulumi.Int(2700),\n\t\t\t\tSecurityLevel:           pulumi.String(\"high\"),\n\t\t\t\tOpportunisticEncryption: pulumi.String(\"on\"),\n\t\t\t\tAutomaticHttpsRewrites:  pulumi.String(\"on\"),\n\t\t\t\tMirage:                  pulumi.String(\"on\"),\n\t\t\t\tWaf:                     pulumi.String(\"on\"),\n\t\t\t\tMinify: \u0026cloudflare.ZoneSettingsOverrideSettingsMinifyArgs{\n\t\t\t\t\tCss:  pulumi.String(\"on\"),\n\t\t\t\t\tJs:   pulumi.String(\"off\"),\n\t\t\t\t\tHtml: pulumi.String(\"off\"),\n\t\t\t\t},\n\t\t\t\tSecurityHeader: \u0026cloudflare.ZoneSettingsOverrideSettingsSecurityHeaderArgs{\n\t\t\t\t\tEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.ZoneSettingsOverride;\nimport com.pulumi.cloudflare.ZoneSettingsOverrideArgs;\nimport com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsArgs;\nimport com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsMinifyArgs;\nimport com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ZoneSettingsOverride(\"test\", ZoneSettingsOverrideArgs.builder()        \n            .zoneId(var_.cloudflare_zone_id())\n            .settings(ZoneSettingsOverrideSettingsArgs.builder()\n                .brotli(\"on\")\n                .challengeTtl(2700)\n                .securityLevel(\"high\")\n                .opportunisticEncryption(\"on\")\n                .automaticHttpsRewrites(\"on\")\n                .mirage(\"on\")\n                .waf(\"on\")\n                .minify(ZoneSettingsOverrideSettingsMinifyArgs.builder()\n                    .css(\"on\")\n                    .js(\"off\")\n                    .html(\"off\")\n                    .build())\n                .securityHeader(ZoneSettingsOverrideSettingsSecurityHeaderArgs.builder()\n                    .enabled(true)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: cloudflare:ZoneSettingsOverride\n    properties:\n      zoneId: ${var.cloudflare_zone_id}\n      settings:\n        brotli: on\n        challengeTtl: 2700\n        securityLevel: high\n        opportunisticEncryption: on\n        automaticHttpsRewrites: on\n        mirage: on\n        waf: on\n        minify:\n          css: on\n          js: off\n          html: off\n        securityHeader:\n          enabled: true\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "initialSettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting"
                    },
                    "description": "Settings present in the zone at the time the resource is created. This will be used to restore the original settings when this resource is destroyed. Shares the same schema as the `settings` attribute (Above).\n"
                },
                "initialSettingsReadAt": {
                    "type": "string",
                    "description": "Time when this resource was created and the `initial_settings` were set.\n"
                },
                "readonlySettings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Which of the current `settings` are not able to be set by the user. Which settings these are is determined by plan level and user permissions.\n- `zone_status`. A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup.\n- `zone_type`. Status of the zone. Valid values: active, pending, initializing, moved, deleted, deactivated.\n"
                },
                "settings": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                    "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n"
                },
                "zoneStatus": {
                    "type": "string"
                },
                "zoneType": {
                    "type": "string"
                }
            },
            "required": [
                "initialSettings",
                "initialSettingsReadAt",
                "readonlySettings",
                "settings",
                "zoneId",
                "zoneStatus",
                "zoneType"
            ],
            "inputProperties": {
                "settings": {
                    "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                    "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "The DNS zone ID to which apply settings.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ZoneSettingsOverride resources.\n",
                "properties": {
                    "initialSettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideInitialSetting:ZoneSettingsOverrideInitialSetting"
                        },
                        "description": "Settings present in the zone at the time the resource is created. This will be used to restore the original settings when this resource is destroyed. Shares the same schema as the `settings` attribute (Above).\n"
                    },
                    "initialSettingsReadAt": {
                        "type": "string",
                        "description": "Time when this resource was created and the `initial_settings` were set.\n"
                    },
                    "readonlySettings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Which of the current `settings` are not able to be set by the user. Which settings these are is determined by plan level and user permissions.\n- `zone_status`. A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup.\n- `zone_type`. Status of the zone. Valid values: active, pending, initializing, moved, deleted, deactivated.\n"
                    },
                    "settings": {
                        "$ref": "#/types/cloudflare:index/ZoneSettingsOverrideSettings:ZoneSettingsOverrideSettings",
                        "description": "Settings overrides that will be applied to the zone. If a setting is not specified the existing setting will be used. For a full list of available settings see below.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The DNS zone ID to which apply settings.\n",
                        "willReplaceOnChanges": true
                    },
                    "zoneStatus": {
                        "type": "string"
                    },
                    "zoneType": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "cloudflare:index/getAccessIdentityProvider:getAccessIdentityProvider": {
            "description": "Use this data source to lookup a single [Access Identity Provider][access_identity_provider_guide] by name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst mainAccessIdentityProvider = cloudflare.getAccessIdentityProvider({\n    name: \"Google SSO\",\n    accountId: \"example-account-id\",\n});\nconst mainAccessApplication = new cloudflare.AccessApplication(\"mainAccessApplication\", {\n    zoneId: \"example.com\",\n    name: \"name\",\n    domain: \"name.example.com\",\n    type: \"self_hosted\",\n    sessionDuration: \"24h\",\n    allowedIdps: [mainAccessIdentityProvider.then(mainAccessIdentityProvider =\u003e mainAccessIdentityProvider.id)],\n    autoRedirectToIdentity: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nmain_access_identity_provider = cloudflare.get_access_identity_provider(name=\"Google SSO\",\n    account_id=\"example-account-id\")\nmain_access_application = cloudflare.AccessApplication(\"mainAccessApplication\",\n    zone_id=\"example.com\",\n    name=\"name\",\n    domain=\"name.example.com\",\n    type=\"self_hosted\",\n    session_duration=\"24h\",\n    allowed_idps=[main_access_identity_provider.id],\n    auto_redirect_to_identity=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mainAccessIdentityProvider = Cloudflare.GetAccessIdentityProvider.Invoke(new()\n    {\n        Name = \"Google SSO\",\n        AccountId = \"example-account-id\",\n    });\n\n    var mainAccessApplication = new Cloudflare.AccessApplication(\"mainAccessApplication\", new()\n    {\n        ZoneId = \"example.com\",\n        Name = \"name\",\n        Domain = \"name.example.com\",\n        Type = \"self_hosted\",\n        SessionDuration = \"24h\",\n        AllowedIdps = new[]\n        {\n            mainAccessIdentityProvider.Apply(getAccessIdentityProviderResult =\u003e getAccessIdentityProviderResult.Id),\n        },\n        AutoRedirectToIdentity = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmainAccessIdentityProvider, err := cloudflare.LookupAccessIdentityProvider(ctx, \u0026cloudflare.LookupAccessIdentityProviderArgs{\n\t\t\tName:      \"Google SSO\",\n\t\t\tAccountId: pulumi.StringRef(\"example-account-id\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewAccessApplication(ctx, \"mainAccessApplication\", \u0026cloudflare.AccessApplicationArgs{\n\t\t\tZoneId:          pulumi.String(\"example.com\"),\n\t\t\tName:            pulumi.String(\"name\"),\n\t\t\tDomain:          pulumi.String(\"name.example.com\"),\n\t\t\tType:            pulumi.String(\"self_hosted\"),\n\t\t\tSessionDuration: pulumi.String(\"24h\"),\n\t\t\tAllowedIdps: pulumi.StringArray{\n\t\t\t\tpulumi.String(mainAccessIdentityProvider.Id),\n\t\t\t},\n\t\t\tAutoRedirectToIdentity: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetAccessIdentityProviderArgs;\nimport com.pulumi.cloudflare.AccessApplication;\nimport com.pulumi.cloudflare.AccessApplicationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var mainAccessIdentityProvider = CloudflareFunctions.getAccessIdentityProvider(GetAccessIdentityProviderArgs.builder()\n            .name(\"Google SSO\")\n            .accountId(\"example-account-id\")\n            .build());\n\n        var mainAccessApplication = new AccessApplication(\"mainAccessApplication\", AccessApplicationArgs.builder()        \n            .zoneId(\"example.com\")\n            .name(\"name\")\n            .domain(\"name.example.com\")\n            .type(\"self_hosted\")\n            .sessionDuration(\"24h\")\n            .allowedIdps(mainAccessIdentityProvider.applyValue(getAccessIdentityProviderResult -\u003e getAccessIdentityProviderResult.id()))\n            .autoRedirectToIdentity(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mainAccessApplication:\n    type: cloudflare:AccessApplication\n    properties:\n      zoneId: example.com\n      name: name\n      domain: name.example.com\n      type: self_hosted\n      sessionDuration: 24h\n      allowedIdps:\n        - ${mainAccessIdentityProvider.id}\n      autoRedirectToIdentity: true\nvariables:\n  mainAccessIdentityProvider:\n    fn::invoke:\n      Function: cloudflare:getAccessIdentityProvider\n      Arguments:\n        name: Google SSO\n        accountId: example-account-id\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account for which to look for an Access Identity Provider. Conflicts with `zone_id`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Access Identity Provider name to search for.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The Zone's ID. Conflicts with `account_id`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessIdentityProvider.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Access Identity Provider Name\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Access Identity Provider Type\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "cloudflare:index/getAccountRoles:getAccountRoles": {
            "description": "Use this data source to lookup [Account Roles](https://api.cloudflare.com/#account-roles-properties).\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccountRoles.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account for which to list the roles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccountRoles.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getAccountRolesRole:getAccountRolesRole"
                        },
                        "description": "A list of roles object. See below for nested attributes.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "roles",
                    "id"
                ]
            }
        },
        "cloudflare:index/getAccounts:getAccounts": {
            "description": "Data source for looking up Cloudflare Accounts.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getAccounts({\n    name: \"example account\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_accounts(name=\"example account\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetAccounts.Invoke(new()\n    {\n        Name = \"example account\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetAccounts(ctx, \u0026cloudflare.GetAccountsArgs{\n\t\t\tName: pulumi.StringRef(\"example account\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetAccountsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getAccounts(GetAccountsArgs.builder()\n            .name(\"example account\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getAccounts\n      Arguments:\n        name: example account\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAccounts.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The account name to target for the resource.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAccounts.\n",
                "properties": {
                    "accounts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getAccountsAccount:getAccountsAccount"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The account name to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accounts",
                    "id"
                ]
            }
        },
        "cloudflare:index/getApiTokenPermissionGroups:getApiTokenPermissionGroups": {
            "description": "Use this data source to look up [API Token Permission Groups](https://developers.cloudflare.com/api/tokens/create/permissions).\nCommonly used as references within [`cloudflare_token`](https://www.terraform.io/docs/providers/cloudflare/r/api_token.html) resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst all = cloudflare.getApiTokenPermissionGroups({});\nexport const dnsReadPermissionId = all.then(all =\u003e all.zone?.[\"DNS Read\"]);\nexport const accountLbMonitorsAndReadId = all.then(all =\u003e all.account?.[\"Load Balancing: Monitors and Pools Read\"]);\nexport const userMembershipsReadId = all.then(all =\u003e all.user?.[\"Memberships Read\"]);\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = Cloudflare.GetApiTokenPermissionGroups.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dnsReadPermissionId\"] = all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.Zone?.DNS_Read),\n        [\"accountLbMonitorsAndReadId\"] = all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.Account?.Load_Balancing__Monitors_and_Pools_Read),\n        [\"userMembershipsReadId\"] = all.Apply(getApiTokenPermissionGroupsResult =\u003e getApiTokenPermissionGroupsResult.User?.Memberships_Read),\n    };\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = CloudflareFunctions.getApiTokenPermissionGroups();\n\n        ctx.export(\"dnsReadPermissionId\", all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.zone().DNS Read()));\n        ctx.export(\"accountLbMonitorsAndReadId\", all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.account().Load Balancing: Monitors and Pools Read()));\n        ctx.export(\"userMembershipsReadId\", all.applyValue(getApiTokenPermissionGroupsResult -\u003e getApiTokenPermissionGroupsResult.user().Memberships Read()));\n    }\n}\n```\n```yaml\nvariables:\n  all:\n    fn::invoke:\n      Function: cloudflare:getApiTokenPermissionGroups\n      Arguments: {}\noutputs:\n  # Get zone level DNS read permission ID.\n  dnsReadPermissionId: ${all.zone\"DNS Read\"[%!s(MISSING)]}\n  # Get account level \"Load Balancing: Monitors and Pools Read\" permission ID.\n  accountLbMonitorsAndReadId: '${all.account\"Load Balancing: Monitors and Pools Read\"[%!s(MISSING)]}'\n  # Get user level \"Memberships Read\" permission ID.\n  userMembershipsReadId: ${all.user\"Memberships Read\"[%!s(MISSING)]}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getApiTokenPermissionGroups.\n",
                "properties": {
                    "account": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Map of permissions for account level resources.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "permissions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Map of all permissions available. Should not be used as some permissions will overlap resource scope. Instead, use resource level specific attributes.\n",
                        "deprecationMessage": "Use specific account, zone or user attributes instead."
                    },
                    "user": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Map of permissions for user level resources.\n"
                    },
                    "zone": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Map of permissions for zone level resources.\n"
                    }
                },
                "type": "object",
                "required": [
                    "account",
                    "permissions",
                    "user",
                    "zone",
                    "id"
                ]
            }
        },
        "cloudflare:index/getDevices:getDevices": {
            "description": "Use this data source to lookup [Devices](https://api.cloudflare.com/#devices-list-devices).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst devices = cloudflare.getDevices({\n    accountId: \"c68973221045fe805dfb9aa520153148\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ndevices = cloudflare.get_devices(account_id=\"c68973221045fe805dfb9aa520153148\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var devices = Cloudflare.GetDevices.Invoke(new()\n    {\n        AccountId = \"c68973221045fe805dfb9aa520153148\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetDevices(ctx, \u0026cloudflare.GetDevicesArgs{\n\t\t\tAccountId: \"c68973221045fe805dfb9aa520153148\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetDevicesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var devices = CloudflareFunctions.getDevices(GetDevicesArgs.builder()\n            .accountId(\"c68973221045fe805dfb9aa520153148\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  devices:\n    fn::invoke:\n      Function: cloudflare:getDevices\n      Arguments:\n        accountId: c68973221045fe805dfb9aa520153148\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDevices.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account for which to list the devices.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDevices.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "devices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getDevicesDevice:getDevicesDevice"
                        },
                        "description": "A list of device object. See below for nested attributes.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "devices",
                    "id"
                ]
            }
        },
        "cloudflare:index/getIpRanges:getIpRanges": {
            "description": "Use this data source to get the [IP ranges](https://www.cloudflare.com/ips/) of Cloudflare edge nodes.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst cloudflare = cloudflare.getIpRanges({});\nconst allowCloudflareIngress = new gcp.compute.Firewall(\"allowCloudflareIngress\", {\n    network: \"default\",\n    sourceRanges: cloudflare.then(cloudflare =\u003e cloudflare.ipv4CidrBlocks),\n    allows: [{\n        ports: \"443\",\n        protocol: \"tcp\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\nimport pulumi_gcp as gcp\n\ncloudflare = cloudflare.get_ip_ranges()\nallow_cloudflare_ingress = gcp.compute.Firewall(\"allowCloudflareIngress\",\n    network=\"default\",\n    source_ranges=cloudflare.ipv4_cidr_blocks,\n    allows=[gcp.compute.FirewallAllowArgs(\n        ports=\"443\",\n        protocol=\"tcp\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cloudflare = Cloudflare.GetIpRanges.Invoke();\n\n    var allowCloudflareIngress = new Gcp.Compute.Firewall(\"allowCloudflareIngress\", new()\n    {\n        Network = \"default\",\n        SourceRanges = cloudflare.Apply(getIpRangesResult =\u003e getIpRangesResult.Ipv4CidrBlocks),\n        Allows = new[]\n        {\n            new Gcp.Compute.Inputs.FirewallAllowArgs\n            {\n                Ports = \"443\",\n                Protocol = \"tcp\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcloudflare, err := cloudflare.GetIpRanges(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewFirewall(ctx, \"allowCloudflareIngress\", \u0026compute.FirewallArgs{\n\t\t\tNetwork:      pulumi.String(\"default\"),\n\t\t\tSourceRanges: interface{}(cloudflare.Ipv4CidrBlocks),\n\t\t\tAllows: compute.FirewallAllowArray{\n\t\t\t\t\u0026compute.FirewallAllowArgs{\n\t\t\t\t\tPorts:    pulumi.StringArray(\"443\"),\n\t\t\t\t\tProtocol: pulumi.String(\"tcp\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.gcp.compute.Firewall;\nimport com.pulumi.gcp.compute.FirewallArgs;\nimport com.pulumi.gcp.compute.inputs.FirewallAllowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var cloudflare = CloudflareFunctions.getIpRanges();\n\n        var allowCloudflareIngress = new Firewall(\"allowCloudflareIngress\", FirewallArgs.builder()        \n            .network(\"default\")\n            .sourceRanges(cloudflare.applyValue(getIpRangesResult -\u003e getIpRangesResult.ipv4CidrBlocks()))\n            .allows(FirewallAllowArgs.builder()\n                .ports(\"443\")\n                .protocol(\"tcp\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  allowCloudflareIngress:\n    type: gcp:compute:Firewall\n    properties:\n      network: default\n      sourceRanges: ${cloudflare.ipv4CidrBlocks}\n      allows:\n        - ports: '443'\n          protocol: tcp\nvariables:\n  cloudflare:\n    fn::invoke:\n      Function: cloudflare:getIpRanges\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getIpRanges.\n",
                "properties": {
                    "chinaIpv4CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv4 China CIDR blocks.\n"
                    },
                    "chinaIpv6CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv6 China CIDR blocks.\n"
                    },
                    "cidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of all non-China CIDR blocks.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipv4CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv4 CIDR blocks.\n"
                    },
                    "ipv6CidrBlocks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The lexically ordered list of only the IPv6 CIDR blocks.\n"
                    }
                },
                "type": "object",
                "required": [
                    "chinaIpv4CidrBlocks",
                    "chinaIpv6CidrBlocks",
                    "cidrBlocks",
                    "ipv4CidrBlocks",
                    "ipv6CidrBlocks",
                    "id"
                ]
            }
        },
        "cloudflare:index/getLoadBalancerPools:getLoadBalancerPools": {
            "description": "A datasource to find Load Balancer Pools.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getLoadBalancerPools({\n    accountId: \"f037e56e89293a057740de681ac9abbe\",\n    filter: {\n        name: \"example-lb-pool\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_load_balancer_pools(account_id=\"f037e56e89293a057740de681ac9abbe\",\n    filter=cloudflare.GetLoadBalancerPoolsFilterArgs(\n        name=\"example-lb-pool\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetLoadBalancerPools.Invoke(new()\n    {\n        AccountId = \"f037e56e89293a057740de681ac9abbe\",\n        Filter = new Cloudflare.Inputs.GetLoadBalancerPoolsFilterInputArgs\n        {\n            Name = \"example-lb-pool\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetLoadBalancerPools(ctx, \u0026cloudflare.GetLoadBalancerPoolsArgs{\n\t\t\tAccountId: \"f037e56e89293a057740de681ac9abbe\",\n\t\t\tFilter: cloudflare.GetLoadBalancerPoolsFilter{\n\t\t\t\tName: pulumi.StringRef(\"example-lb-pool\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetLoadBalancerPoolsArgs;\nimport com.pulumi.cloudflare.inputs.GetLoadBalancerPoolsFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getLoadBalancerPools(GetLoadBalancerPoolsArgs.builder()\n            .accountId(\"f037e56e89293a057740de681ac9abbe\")\n            .filter(GetLoadBalancerPoolsFilterArgs.builder()\n                .name(\"example-lb-pool\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getLoadBalancerPools\n      Arguments:\n        accountId: f037e56e89293a057740de681ac9abbe\n        filter:\n          name: example-lb-pool\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getLoadBalancerPools.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the datasource lookups.\n"
                    },
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsFilter:getLoadBalancerPoolsFilter",
                        "description": "One or more values used to look up Load Balancer pools. If more than one value is given all values must match in order to be included.\n"
                    },
                    "pools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPool:getLoadBalancerPoolsPool"
                        },
                        "description": "A list of Load Balancer Pools details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLoadBalancerPools.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account identifier to target for the datasource lookups.\n"
                    },
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsFilter:getLoadBalancerPoolsFilter",
                        "description": "One or more values used to look up Load Balancer pools. If more than one value is given all values must match in order to be included.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getLoadBalancerPoolsPool:getLoadBalancerPoolsPool"
                        },
                        "description": "A list of Load Balancer Pools details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "pools",
                    "id"
                ]
            }
        },
        "cloudflare:index/getOriginCaRootCertificate:getOriginCaRootCertificate": {
            "description": "Use this data source to get the [Origin CA root certificate](https://developers.cloudflare.com/ssl/origin-configuration/origin-ca#4-required-for-some-add-cloudflare-origin-ca-root-certificates) for a given algorithm.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst originCa = cloudflare.getOriginCaRootCertificate({\n    algorithm: \"\u003calgorithm\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\norigin_ca = cloudflare.get_origin_ca_root_certificate(algorithm=\"\u003calgorithm\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var originCa = Cloudflare.GetOriginCaRootCertificate.Invoke(new()\n    {\n        Algorithm = \"\u003calgorithm\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetOriginCaRootCertificate(ctx, \u0026cloudflare.GetOriginCaRootCertificateArgs{\n\t\t\tAlgorithm: \"\u003calgorithm\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetOriginCaRootCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var originCa = CloudflareFunctions.getOriginCaRootCertificate(GetOriginCaRootCertificateArgs.builder()\n            .algorithm(\"\u003calgorithm\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  originCa:\n    fn::invoke:\n      Function: cloudflare:getOriginCaRootCertificate\n      Arguments:\n        algorithm: \u003calgorithm\u003e\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getOriginCaRootCertificate.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "The name of the algorithm used when creating an Origin CA certificate. Currently-supported values are \"rsa\" and \"ecc\" (case-insensitive).\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOriginCaRootCertificate.\n",
                "properties": {
                    "algorithm": {
                        "type": "string"
                    },
                    "certPem": {
                        "type": "string",
                        "description": "The Origin CA root certificate in PEM format.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "certPem",
                    "id"
                ]
            }
        },
        "cloudflare:index/getRecord:getRecord": {
            "description": "Use this data source to lookup a single [DNS Record](https://api.cloudflare.com/#dns-records-for-a-zone-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getRecord({\n    zoneId: _var.zone_id,\n    hostname: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_record(zone_id=var[\"zone_id\"],\n    hostname=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetRecord.Invoke(new()\n    {\n        ZoneId = @var.Zone_id,\n        Hostname = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.LookupRecord(ctx, \u0026cloudflare.LookupRecordArgs{\n\t\t\tZoneId:   _var.Zone_id,\n\t\t\tHostname: \"example.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getRecord(GetRecordArgs.builder()\n            .zoneId(var_.zone_id())\n            .hostname(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getRecord\n      Arguments:\n        zoneId: ${var.zone_id}\n        hostname: example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRecord.\n",
                "properties": {
                    "hostname": {
                        "type": "string",
                        "description": "Hostname to filter DNS record results on.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "DNS priority to filter record results on.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "DNS record type to filter record results on. Defaults to `A`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostname",
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRecord.\n",
                "properties": {
                    "hostname": {
                        "type": "string",
                        "description": "Hostname to filter DNS record results on.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "locked": {
                        "type": "boolean",
                        "description": "Locked status of the found DNS record.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "DNS priority to filter record results on.\n"
                    },
                    "proxiable": {
                        "type": "boolean",
                        "description": "Proxiable status of the found DNS record.\n"
                    },
                    "proxied": {
                        "type": "boolean",
                        "description": "Proxied status of the found DNS record.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "TTL of the found DNS record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "DNS record type to filter record results on. Defaults to `A`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of the found DNS record.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone identifier to target for the resource.\n"
                    },
                    "zoneName": {
                        "type": "string",
                        "description": "Zone name of the found DNS record.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostname",
                    "locked",
                    "proxiable",
                    "proxied",
                    "ttl",
                    "value",
                    "zoneId",
                    "zoneName",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafGroups:getWafGroups": {
            "description": "Use this data source to look up [WAF Rule Groups](https://api.cloudflare.com/#waf-rule-groups-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all WAF Rule Groups that contain the word `example` and are currently `on`. The matched WAF Rule Groups are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafGroups({\n    filter: {\n        name: \".*example.*\",\n        mode: \"on\",\n    },\n});\nexport const wafGroups = test.then(test =\u003e test.groups);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_groups(filter=cloudflare.GetWafGroupsFilterArgs(\n    name=\".*example.*\",\n    mode=\"on\",\n))\npulumi.export(\"wafGroups\", test.groups)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Cloudflare.GetWafGroups.Invoke(new()\n    {\n        Filter = new Cloudflare.Inputs.GetWafGroupsFilterInputArgs\n        {\n            Name = \".*example.*\",\n            Mode = \"on\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"wafGroups\"] = test.Apply(getWafGroupsResult =\u003e getWafGroupsResult.Groups),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := cloudflare.GetWafGroups(ctx, \u0026cloudflare.GetWafGroupsArgs{\n\t\t\tFilter: cloudflare.GetWafGroupsFilter{\n\t\t\t\tName: pulumi.StringRef(\".*example.*\"),\n\t\t\t\tMode: pulumi.StringRef(\"on\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafGroups\", test.Groups)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetWafGroupsArgs;\nimport com.pulumi.cloudflare.inputs.GetWafGroupsFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = CloudflareFunctions.getWafGroups(GetWafGroupsArgs.builder()\n            .filter(GetWafGroupsFilterArgs.builder()\n                .name(\".*example.*\")\n                .mode(\"on\")\n                .build())\n            .build());\n\n        ctx.export(\"wafGroups\", test.applyValue(getWafGroupsResult -\u003e getWafGroupsResult.groups()));\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: cloudflare:getWafGroups\n      Arguments:\n        filter:\n          name: .*example.*\n          mode: on\noutputs:\n  wafGroups: ${test.groups}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getWafGroups.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafGroupsFilter:getWafGroupsFilter",
                        "description": "One or more values used to look up WAF Rule Groups. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package in which to search for the WAF Rule Groups.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to search for the WAF Rule Groups.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafGroups.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafGroupsFilter:getWafGroupsFilter"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getWafGroupsGroup:getWafGroupsGroup"
                        },
                        "description": "A map of WAF Rule Groups details. Full list below:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the WAF Rule Group\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "groups",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafPackages:getWafPackages": {
            "description": "Use this data source to look up [WAF Rule Packages](https://api.cloudflare.com/#waf-rule-packages-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all `high` sensitivity WAF Rule Packages, with a `challenge` action mode and an `anomaly` detection mode, that contain the word `example`. The matched WAF Rule Packages are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafPackages({\n    filter: {\n        name: \".*example.*\",\n        detectionMode: \"anomaly\",\n        sensitivity: \"high\",\n        actionMode: \"challenge\",\n    },\n});\nexport const wafPackages = test.then(test =\u003e test.packages);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_packages(filter=cloudflare.GetWafPackagesFilterArgs(\n    name=\".*example.*\",\n    detection_mode=\"anomaly\",\n    sensitivity=\"high\",\n    action_mode=\"challenge\",\n))\npulumi.export(\"wafPackages\", test.packages)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Cloudflare.GetWafPackages.Invoke(new()\n    {\n        Filter = new Cloudflare.Inputs.GetWafPackagesFilterInputArgs\n        {\n            Name = \".*example.*\",\n            DetectionMode = \"anomaly\",\n            Sensitivity = \"high\",\n            ActionMode = \"challenge\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"wafPackages\"] = test.Apply(getWafPackagesResult =\u003e getWafPackagesResult.Packages),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := cloudflare.GetWafPackages(ctx, \u0026cloudflare.GetWafPackagesArgs{\n\t\t\tFilter: cloudflare.GetWafPackagesFilter{\n\t\t\t\tName:          pulumi.StringRef(\".*example.*\"),\n\t\t\t\tDetectionMode: pulumi.StringRef(\"anomaly\"),\n\t\t\t\tSensitivity:   pulumi.StringRef(\"high\"),\n\t\t\t\tActionMode:    pulumi.StringRef(\"challenge\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafPackages\", test.Packages)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetWafPackagesArgs;\nimport com.pulumi.cloudflare.inputs.GetWafPackagesFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = CloudflareFunctions.getWafPackages(GetWafPackagesArgs.builder()\n            .filter(GetWafPackagesFilterArgs.builder()\n                .name(\".*example.*\")\n                .detectionMode(\"anomaly\")\n                .sensitivity(\"high\")\n                .actionMode(\"challenge\")\n                .build())\n            .build());\n\n        ctx.export(\"wafPackages\", test.applyValue(getWafPackagesResult -\u003e getWafPackagesResult.packages()));\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: cloudflare:getWafPackages\n      Arguments:\n        filter:\n          name: .*example.*\n          detectionMode: anomaly\n          sensitivity: high\n          actionMode: challenge\noutputs:\n  wafPackages: ${test.packages}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getWafPackages.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafPackagesFilter:getWafPackagesFilter",
                        "description": "One or more values used to look up WAF Rule Packages. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to search for the WAF Rule Packages.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafPackages.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafPackagesFilter:getWafPackagesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getWafPackagesPackage:getWafPackagesPackage"
                        },
                        "description": "A map of WAF Rule Packages details. Full list below:\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "packages",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getWafRules:getWafRules": {
            "description": "Use this data source to look up [WAF Rules](https://api.cloudflare.com/#waf-rule-groups-properties).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below matches all WAF Rules that are in the group of ID `de677e5818985db1285d0e80225f06e5`, contain `example` in their description, and are currently `on`. The matched WAF Rules are then returned as output.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst test = cloudflare.getWafRules({\n    zoneId: \"ae36f999674d196762efcc5abb06b345\",\n    packageId: \"a25a9a7e9c00afc1fb2e0245519d725b\",\n    filter: {\n        description: \".*example.*\",\n        mode: \"on\",\n        groupId: \"de677e5818985db1285d0e80225f06e5\",\n    },\n});\nexport const wafRules = test.then(test =\u003e test.rules);\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\ntest = cloudflare.get_waf_rules(zone_id=\"ae36f999674d196762efcc5abb06b345\",\n    package_id=\"a25a9a7e9c00afc1fb2e0245519d725b\",\n    filter=cloudflare.GetWafRulesFilterArgs(\n        description=\".*example.*\",\n        mode=\"on\",\n        group_id=\"de677e5818985db1285d0e80225f06e5\",\n    ))\npulumi.export(\"wafRules\", test.rules)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Cloudflare.GetWafRules.Invoke(new()\n    {\n        ZoneId = \"ae36f999674d196762efcc5abb06b345\",\n        PackageId = \"a25a9a7e9c00afc1fb2e0245519d725b\",\n        Filter = new Cloudflare.Inputs.GetWafRulesFilterInputArgs\n        {\n            Description = \".*example.*\",\n            Mode = \"on\",\n            GroupId = \"de677e5818985db1285d0e80225f06e5\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"wafRules\"] = test.Apply(getWafRulesResult =\u003e getWafRulesResult.Rules),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := cloudflare.GetWafRules(ctx, \u0026cloudflare.GetWafRulesArgs{\n\t\t\tZoneId:    \"ae36f999674d196762efcc5abb06b345\",\n\t\t\tPackageId: pulumi.StringRef(\"a25a9a7e9c00afc1fb2e0245519d725b\"),\n\t\t\tFilter: cloudflare.GetWafRulesFilter{\n\t\t\t\tDescription: pulumi.StringRef(\".*example.*\"),\n\t\t\t\tMode:        pulumi.StringRef(\"on\"),\n\t\t\t\tGroupId:     pulumi.StringRef(\"de677e5818985db1285d0e80225f06e5\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafRules\", test.Rules)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetWafRulesArgs;\nimport com.pulumi.cloudflare.inputs.GetWafRulesFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = CloudflareFunctions.getWafRules(GetWafRulesArgs.builder()\n            .zoneId(\"ae36f999674d196762efcc5abb06b345\")\n            .packageId(\"a25a9a7e9c00afc1fb2e0245519d725b\")\n            .filter(GetWafRulesFilterArgs.builder()\n                .description(\".*example.*\")\n                .mode(\"on\")\n                .groupId(\"de677e5818985db1285d0e80225f06e5\")\n                .build())\n            .build());\n\n        ctx.export(\"wafRules\", test.applyValue(getWafRulesResult -\u003e getWafRulesResult.rules()));\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: cloudflare:getWafRules\n      Arguments:\n        zoneId: ae36f999674d196762efcc5abb06b345\n        packageId: a25a9a7e9c00afc1fb2e0245519d725b\n        filter:\n          description: .*example.*\n          mode: on\n          groupId: de677e5818985db1285d0e80225f06e5\noutputs:\n  wafRules: ${test.rules}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getWafRules.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafRulesFilter:getWafRulesFilter",
                        "description": "One or more values used to look up WAF Rules. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package in which to search for the WAF Rules.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The ID of the DNS zone in which to search for the WAF Rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWafRules.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getWafRulesFilter:getWafRulesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "packageId": {
                        "type": "string",
                        "description": "The ID of the WAF Rule Package that contains the WAF Rule\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getWafRulesRule:getWafRulesRule"
                        },
                        "description": "A map of WAF Rules details. Full list below:\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "rules",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZone:getZone": {
            "description": "Use this data source to look up [zone] info. This is the singular alternative\nto `cloudflare.getZones`.\n\n\u003e **Note** Cloudflare zone names **are not unique**. It is possible for multiple\naccounts to have the same zone created but in different states. If you are\nusing this setup, it is advised to use the `account_id` attribute on this\nresource or swap to `cloudflare.getZones` to further filter the results.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZone({\n    zoneId: \"0b6d347b01d437a092be84c2edfce72c\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone(zone_id=\"0b6d347b01d437a092be84c2edfce72c\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZone.Invoke(new()\n    {\n        ZoneId = \"0b6d347b01d437a092be84c2edfce72c\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.LookupZone(ctx, \u0026cloudflare.LookupZoneArgs{\n\t\t\tZoneId: pulumi.StringRef(\"0b6d347b01d437a092be84c2edfce72c\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZone(GetZoneArgs.builder()\n            .zoneId(\"0b6d347b01d437a092be84c2edfce72c\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZone\n      Arguments:\n        zoneId: 0b6d347b01d437a092be84c2edfce72c\n```\n{{% /example %}}\n{{% example %}}\n### Example usage with other resources\n\nThe example below fetches the zone information for example.com and then is\nreferenced in the `cloudflare.Record` section.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst exampleZone = cloudflare.getZone({\n    name: \"example.com\",\n});\nconst exampleRecord = new cloudflare.Record(\"exampleRecord\", {\n    zoneId: exampleZone.then(exampleZone =\u003e exampleZone.id),\n    name: \"www\",\n    value: \"203.0.113.1\",\n    type: \"A\",\n    proxied: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample_zone = cloudflare.get_zone(name=\"example.com\")\nexample_record = cloudflare.Record(\"exampleRecord\",\n    zone_id=example_zone.id,\n    name=\"www\",\n    value=\"203.0.113.1\",\n    type=\"A\",\n    proxied=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleZone = Cloudflare.GetZone.Invoke(new()\n    {\n        Name = \"example.com\",\n    });\n\n    var exampleRecord = new Cloudflare.Record(\"exampleRecord\", new()\n    {\n        ZoneId = exampleZone.Apply(getZoneResult =\u003e getZoneResult.Id),\n        Name = \"www\",\n        Value = \"203.0.113.1\",\n        Type = \"A\",\n        Proxied = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleZone, err := cloudflare.LookupZone(ctx, \u0026cloudflare.LookupZoneArgs{\n\t\t\tName: pulumi.StringRef(\"example.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudflare.NewRecord(ctx, \"exampleRecord\", \u0026cloudflare.RecordArgs{\n\t\t\tZoneId:  pulumi.String(exampleZone.Id),\n\t\t\tName:    pulumi.String(\"www\"),\n\t\t\tValue:   pulumi.String(\"203.0.113.1\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t\tProxied: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZoneArgs;\nimport com.pulumi.cloudflare.Record;\nimport com.pulumi.cloudflare.RecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleZone = CloudflareFunctions.getZone(GetZoneArgs.builder()\n            .name(\"example.com\")\n            .build());\n\n        var exampleRecord = new Record(\"exampleRecord\", RecordArgs.builder()        \n            .zoneId(exampleZone.applyValue(getZoneResult -\u003e getZoneResult.id()))\n            .name(\"www\")\n            .value(\"203.0.113.1\")\n            .type(\"A\")\n            .proxied(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleRecord:\n    type: cloudflare:Record\n    properties:\n      zoneId: ${exampleZone.id}\n      name: www\n      value: 203.0.113.1\n      type: A\n      proxied: true\nvariables:\n  exampleZone:\n    fn::invoke:\n      Function: cloudflare:getZone\n      Arguments:\n        name: example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getZone.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID associated with the zone.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the zone. Conflicts with `\"zone_id\"`.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "The zone ID. Conflicts with `\"name\"`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZone.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "The account ID associated with the zone.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the zone.\n"
                    },
                    "nameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Cloudflare assigned name servers. This is only populated for zones that use Cloudflare DNS.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "`true` if cloudflare is enabled on the zone, otherwise `false`.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The name of the plan associated with the zone.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the zone. Values can be: `\"active\"`, `\"pending\"`, `\"initializing\"`, `\"moved\"`, `\"deleted\"`,\nor `\"deactivated\"`.\n"
                    },
                    "vanityNameServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Vanity Nameservers (if set).\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "name",
                    "nameServers",
                    "paused",
                    "plan",
                    "status",
                    "vanityNameServers",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZoneDnssec:getZoneDnssec": {
            "description": "Use this data source to look up [Zone][1] DNSSEC settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZoneDnssec({\n    zoneId: \"\u003czone_id\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zone_dnssec(zone_id=\"\u003czone_id\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZoneDnssec.Invoke(new()\n    {\n        ZoneId = \"\u003czone_id\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.LookupZoneDnssec(ctx, \u0026cloudflare.LookupZoneDnssecArgs{\n\t\t\tZoneId: \"\u003czone_id\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZoneDnssecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZoneDnssec(GetZoneDnssecArgs.builder()\n            .zoneId(\"\u003czone_id\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZoneDnssec\n      Arguments:\n        zoneId: \u003czone_id\u003e\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getZoneDnssec.\n",
                "properties": {
                    "zoneId": {
                        "type": "string",
                        "description": "The zone id for the zone.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZoneDnssec.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Zone DNSSEC algorithm.\n"
                    },
                    "digest": {
                        "type": "string",
                        "description": "Zone DNSSEC digest.\n"
                    },
                    "digestAlgorithm": {
                        "type": "string",
                        "description": "Digest algorithm use for Zone DNSSEC.\n"
                    },
                    "digestType": {
                        "type": "string",
                        "description": "Digest Type for Zone DNSSEC.\n"
                    },
                    "ds": {
                        "type": "string",
                        "description": "DS for the Zone DNSSEC.\n"
                    },
                    "flags": {
                        "type": "integer",
                        "description": "Zone DNSSEC flags.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keyTag": {
                        "type": "integer",
                        "description": "Key Tag for the Zone DNSSEC.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Key type used for Zone DNSSEC.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public Key for the Zone DNSSEC.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the Zone DNSSEC.\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "digest",
                    "digestAlgorithm",
                    "digestType",
                    "ds",
                    "flags",
                    "keyTag",
                    "keyType",
                    "publicKey",
                    "status",
                    "zoneId",
                    "id"
                ]
            }
        },
        "cloudflare:index/getZones:getZones": {
            "description": "Use this data source to look up [Zone](https://api.cloudflare.com/#zone-properties) records.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nGiven you have the following zones in Cloudflare.\n\n- example.com\n- example.net\n- not-example.com\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZones({\n    filter: {\n        name: \"example.com\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    name=\"example.com\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZones.Invoke(new()\n    {\n        Filter = new Cloudflare.Inputs.GetZonesFilterInputArgs\n        {\n            Name = \"example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetZones(ctx, \u0026cloudflare.GetZonesArgs{\n\t\t\tFilter: cloudflare.GetZonesFilter{\n\t\t\t\tName: pulumi.StringRef(\"example.com\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZonesArgs;\nimport com.pulumi.cloudflare.inputs.GetZonesFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZones(GetZonesArgs.builder()\n            .filter(GetZonesFilterArgs.builder()\n                .name(\"example.com\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZones\n      Arguments:\n        filter:\n          name: example.com\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZones({\n    filter: {\n        lookupType: \"contains\",\n        name: \"example\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    lookup_type=\"contains\",\n    name=\"example\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZones.Invoke(new()\n    {\n        Filter = new Cloudflare.Inputs.GetZonesFilterInputArgs\n        {\n            LookupType = \"contains\",\n            Name = \"example\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetZones(ctx, \u0026cloudflare.GetZonesArgs{\n\t\t\tFilter: cloudflare.GetZonesFilter{\n\t\t\t\tLookupType: pulumi.StringRef(\"contains\"),\n\t\t\t\tName:       pulumi.StringRef(\"example\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZonesArgs;\nimport com.pulumi.cloudflare.inputs.GetZonesFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZones(GetZonesArgs.builder()\n            .filter(GetZonesFilterArgs.builder()\n                .lookupType(\"contains\")\n                .name(\"example\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZones\n      Arguments:\n        filter:\n          lookupType: contains\n          name: example\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZones({\n    filter: {\n        lookupType: \"contains\",\n        match: \"^not-\",\n        name: \"example\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    lookup_type=\"contains\",\n    match=\"^not-\",\n    name=\"example\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZones.Invoke(new()\n    {\n        Filter = new Cloudflare.Inputs.GetZonesFilterInputArgs\n        {\n            LookupType = \"contains\",\n            Match = \"^not-\",\n            Name = \"example\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetZones(ctx, \u0026cloudflare.GetZonesArgs{\n\t\t\tFilter: cloudflare.GetZonesFilter{\n\t\t\t\tLookupType: pulumi.StringRef(\"contains\"),\n\t\t\t\tMatch:      pulumi.StringRef(\"^not-\"),\n\t\t\t\tName:       pulumi.StringRef(\"example\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZonesArgs;\nimport com.pulumi.cloudflare.inputs.GetZonesFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZones(GetZonesArgs.builder()\n            .filter(GetZonesFilterArgs.builder()\n                .lookupType(\"contains\")\n                .match(\"^not-\")\n                .name(\"example\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZones\n      Arguments:\n        filter:\n          lookupType: contains\n          match: ^not-\n          name: example\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as cloudflare from \"@pulumi/cloudflare\";\n\nconst example = cloudflare.getZones({\n    filter: {\n        accountId: \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n        status: \"active\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_cloudflare as cloudflare\n\nexample = cloudflare.get_zones(filter=cloudflare.GetZonesFilterArgs(\n    account_id=\"1d5fdc9e88c8a8c4518b068cd94331fe\",\n    status=\"active\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Cloudflare.GetZones.Invoke(new()\n    {\n        Filter = new Cloudflare.Inputs.GetZonesFilterInputArgs\n        {\n            AccountId = \"1d5fdc9e88c8a8c4518b068cd94331fe\",\n            Status = \"active\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-cloudflare/sdk/v4/go/cloudflare\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err = cloudflare.GetZones(ctx, \u0026cloudflare.GetZonesArgs{\n\t\t\tFilter: cloudflare.GetZonesFilter{\n\t\t\t\tAccountId: pulumi.StringRef(\"1d5fdc9e88c8a8c4518b068cd94331fe\"),\n\t\t\t\tStatus:    pulumi.StringRef(\"active\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.cloudflare.CloudflareFunctions;\nimport com.pulumi.cloudflare.inputs.GetZonesArgs;\nimport com.pulumi.cloudflare.inputs.GetZonesFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CloudflareFunctions.getZones(GetZonesArgs.builder()\n            .filter(GetZonesFilterArgs.builder()\n                .accountId(\"1d5fdc9e88c8a8c4518b068cd94331fe\")\n                .status(\"active\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: cloudflare:getZones\n      Arguments:\n        filter:\n          accountId: 1d5fdc9e88c8a8c4518b068cd94331fe\n          status: active\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getZonesFilter:getZonesFilter",
                        "description": "One or more values used to look up zone records. If more than one value is given all\nvalues must match in order to be included, see below for full list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "filter"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getZones.\n",
                "properties": {
                    "filter": {
                        "$ref": "#/types/cloudflare:index/getZonesFilter:getZonesFilter"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "zones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/cloudflare:index/getZonesZone:getZonesZone"
                        },
                        "description": "A list of zone objects. Object format:\n"
                    }
                },
                "type": "object",
                "required": [
                    "filter",
                    "zones",
                    "id"
                ]
            }
        }
    }
}